var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// <define:AnParams>
var define_AnParams_default;
var init_define_AnParams = __esm({
  "<define:AnParams>"() {
    define_AnParams_default = { maxLogHistory_Desc: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E \u0437\u0430\u043F\u043E\u043C\u0438\u043D\u0430\u0435\u043C\u044B\u0445 \u0441\u043E\u043E\u0431\u0449\u0435\u043D\u0438\u0439 \u043B\u043E\u0433\u0430", maxLogHistory: 1e3, baseWidth_Desc: "\u0411\u0430\u0437\u043E\u0432\u0430\u044F \u0448\u0438\u0440\u0438\u043D\u0430 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u0438\u044F \u0432 \u043F\u0438\u043A\u0441\u0435\u043B\u044F\u0445 \u043E\u0442 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u043E\u0442\u0442\u0430\u043B\u043A\u0438\u0432\u0430\u044E\u0442\u0441\u044F \u0432\u0441\u0435 2\u0434 \u0430\u0441\u0441\u0435\u0442\u044B", baseWidth: 1920, baseHeight_Desc: "\u0411\u0430\u0437\u043E\u0432\u0430\u044F \u0432\u044B\u0441\u043E\u0442\u0430 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043D\u0438\u044F \u0432 \u043F\u0438\u043A\u0441\u0435\u043B\u044F\u0445 \u043E\u0442 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u043E\u0442\u0442\u0430\u043B\u043A\u0438\u0432\u0430\u044E\u0442\u0441\u044F \u0432\u0441\u0435 2\u0434 \u0430\u0441\u0441\u0435\u0442\u044B", baseHeight: 1080, minFPS_Desc: "\u041C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u044B\u0439 FPS (\u043A\u0430\u0434\u0440\u043E\u0432 \u0432 \u0441\u0435\u043A\u0443\u043D\u0434\u0443)", minFPS: 30, maxFPS_Desc: "\u041C\u0430\u043A\u0441\u0438\u043C\u0430\u043B\u044C\u043D\u044B\u0439 \u0446\u0435\u043B\u0435\u0432\u043E\u0439 FPS (\u043A\u0430\u0434\u0440\u043E\u0432 \u0432 \u0441\u0435\u043A\u0443\u043D\u0434\u0443)", maxFPS: 60, baseFPS_Desc: "\u0411\u0430\u0437\u043E\u0432\u044B\u0439 FPS \u0434\u043B\u044F \u043D\u043E\u0440\u043C\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u0438", baseFPS: 60 };
  }
});

// node_modules/pixi.js/lib/extensions/Extensions.mjs
var ExtensionType, normalizeExtension, normalizeExtensionPriority, extensions;
var init_Extensions = __esm({
  "node_modules/pixi.js/lib/extensions/Extensions.mjs"() {
    "use strict";
    init_define_AnParams();
    ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
      ExtensionType2["Application"] = "application";
      ExtensionType2["WebGLPipes"] = "webgl-pipes";
      ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
      ExtensionType2["WebGLSystem"] = "webgl-system";
      ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
      ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
      ExtensionType2["WebGPUSystem"] = "webgpu-system";
      ExtensionType2["CanvasSystem"] = "canvas-system";
      ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
      ExtensionType2["CanvasPipes"] = "canvas-pipes";
      ExtensionType2["Asset"] = "asset";
      ExtensionType2["LoadParser"] = "load-parser";
      ExtensionType2["ResolveParser"] = "resolve-parser";
      ExtensionType2["CacheParser"] = "cache-parser";
      ExtensionType2["DetectionParser"] = "detection-parser";
      ExtensionType2["MaskEffect"] = "mask-effect";
      ExtensionType2["BlendMode"] = "blend-mode";
      ExtensionType2["TextureSource"] = "texture-source";
      ExtensionType2["Environment"] = "environment";
      ExtensionType2["ShapeBuilder"] = "shape-builder";
      ExtensionType2["Batcher"] = "batcher";
      return ExtensionType2;
    })(ExtensionType || {});
    normalizeExtension = (ext) => {
      if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
        if (!ext.extension) {
          throw new Error("Extension class must have an extension object");
        }
        const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
        ext = { ...metadata, ref: ext };
      }
      if (typeof ext === "object") {
        ext = { ...ext };
      } else {
        throw new Error("Invalid extension type");
      }
      if (typeof ext.type === "string") {
        ext.type = [ext.type];
      }
      return ext;
    };
    normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
    extensions = {
      /** @ignore */
      _addHandlers: {},
      /** @ignore */
      _removeHandlers: {},
      /** @ignore */
      _queue: {},
      /**
       * Remove extensions from PixiJS.
       * @param extensions - Extensions to be removed.
       * @returns {extensions} For chaining.
       */
      remove(...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext) => {
          ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
        });
        return this;
      },
      /**
       * Register new extensions with PixiJS.
       * @param extensions - The spread of extensions to add to PixiJS.
       * @returns {extensions} For chaining.
       */
      add(...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext) => {
          ext.type.forEach((type) => {
            const handlers = this._addHandlers;
            const queue = this._queue;
            if (!handlers[type]) {
              queue[type] = queue[type] || [];
              queue[type]?.push(ext);
            } else {
              handlers[type]?.(ext);
            }
          });
        });
        return this;
      },
      /**
       * Internal method to handle extensions by name.
       * @param type - The extension type.
       * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
       * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
       * @returns {extensions} For chaining.
       */
      handle(type, onAdd, onRemove) {
        const addHandlers = this._addHandlers;
        const removeHandlers = this._removeHandlers;
        if (addHandlers[type] || removeHandlers[type]) {
          throw new Error(`Extension type ${type} already has a handler`);
        }
        addHandlers[type] = onAdd;
        removeHandlers[type] = onRemove;
        const queue = this._queue;
        if (queue[type]) {
          queue[type]?.forEach((ext) => onAdd(ext));
          delete queue[type];
        }
        return this;
      },
      /**
       * Handle a type, but using a map by `name` property.
       * @param type - Type of extension to handle.
       * @param map - The object map of named extensions.
       * @returns {extensions} For chaining.
       */
      handleByMap(type, map) {
        return this.handle(
          type,
          (extension) => {
            if (extension.name) {
              map[extension.name] = extension.ref;
            }
          },
          (extension) => {
            if (extension.name) {
              delete map[extension.name];
            }
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions with a `name` property.
       * @param type - Type of extension to handle.
       * @param map - The array of named extensions.
       * @param defaultPriority - Fallback priority if none is defined.
       * @returns {extensions} For chaining.
       */
      handleByNamedList(type, map, defaultPriority = -1) {
        return this.handle(
          type,
          (extension) => {
            const index = map.findIndex((item) => item.name === extension.name);
            if (index >= 0)
              return;
            map.push({ name: extension.name, value: extension.ref });
            map.sort((a2, b3) => normalizeExtensionPriority(b3.value, defaultPriority) - normalizeExtensionPriority(a2.value, defaultPriority));
          },
          (extension) => {
            const index = map.findIndex((item) => item.name === extension.name);
            if (index !== -1) {
              map.splice(index, 1);
            }
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions.
       * @param type - Type of extension to handle.
       * @param list - The list of extensions.
       * @param defaultPriority - The default priority to use if none is specified.
       * @returns {extensions} For chaining.
       */
      handleByList(type, list, defaultPriority = -1) {
        return this.handle(
          type,
          (extension) => {
            if (list.includes(extension.ref)) {
              return;
            }
            list.push(extension.ref);
            list.sort((a2, b3) => normalizeExtensionPriority(b3, defaultPriority) - normalizeExtensionPriority(a2, defaultPriority));
          },
          (extension) => {
            const index = list.indexOf(extension.ref);
            if (index !== -1) {
              list.splice(index, 1);
            }
          }
        );
      },
      /**
       * Mixin the source object into the target object.
       * @param Target - The target object to mix into.
       * @param sources - The source(s) object to mix from
       */
      mixin(Target, ...sources2) {
        for (const source9 of sources2) {
          Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source9));
        }
      }
    };
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    init_define_AnParams();
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context2, once) {
      this.fn = fn;
      this.context = context2;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context2, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i3 = 0, l2 = handlers.length, ee = new Array(l2); i3 < l2; i3++) {
        ee[i3] = handlers[i3].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i3;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i3 = 1, args = new Array(len - 1); i3 < len; i3++) {
          args[i3 - 1] = arguments[i3];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i3 = 0; i3 < length; i3++) {
          if (listeners[i3].once) this.removeListener(event, listeners[i3].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i3].fn.call(listeners[i3].context);
              break;
            case 2:
              listeners[i3].fn.call(listeners[i3].context, a1);
              break;
            case 3:
              listeners[i3].fn.call(listeners[i3].context, a1, a2);
              break;
            case 4:
              listeners[i3].fn.call(listeners[i3].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners[i3].fn.apply(listeners[i3].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context2) {
      return addListener(this, event, fn, context2, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context2) {
      return addListener(this, event, fn, context2, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i3 = 0, events = [], length = listeners.length; i3 < length; i3++) {
          if (listeners[i3].fn !== fn || once && !listeners[i3].once || context2 && listeners[i3].context !== context2) {
            events.push(listeners[i3]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/eventemitter3/index.mjs
var import_index, eventemitter3_default;
var init_eventemitter3 = __esm({
  "node_modules/eventemitter3/index.mjs"() {
    init_define_AnParams();
    import_index = __toESM(require_eventemitter3(), 1);
    eventemitter3_default = import_index.default;
  }
});

// node_modules/@pixi/colord/index.mjs
var r, t, n, e, u, a, o, i, s, h, b, g, d, f, c, l, p, v, m, y, N, x, M, H, $, j, w, S, k;
var init_colord = __esm({
  "node_modules/@pixi/colord/index.mjs"() {
    init_define_AnParams();
    r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
    t = function(r2) {
      return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
    };
    n = function(r2, t2, n2) {
      return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
    };
    e = function(r2, t2, n2) {
      return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
    };
    u = function(r2) {
      return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
    };
    a = function(r2) {
      return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
    };
    o = function(r2) {
      return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
    };
    i = /^#([0-9a-f]{3,8})$/i;
    s = function(r2) {
      var t2 = r2.toString(16);
      return t2.length < 2 ? "0" + t2 : t2;
    };
    h = function(r2) {
      var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i3 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
      return { h: 60 * (i3 < 0 ? i3 + 6 : i3), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
    };
    b = function(r2) {
      var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
      t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
      var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i3 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
      return { r: 255 * [e2, i3, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i3, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i3][h2], a: u2 };
    };
    g = function(r2) {
      return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
    };
    d = function(r2) {
      return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
    };
    f = function(r2) {
      return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
      var t2, n2, e2;
    };
    c = function(r2) {
      return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
      var t2, n2, e2, u2;
    };
    l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    y = { string: [[function(r2) {
      var t2 = i.exec(r2);
      return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
    }, "hex"], [function(r2) {
      var t2 = v.exec(r2) || m.exec(r2);
      return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
    }, "rgb"], [function(t2) {
      var n2 = l.exec(t2) || p.exec(t2);
      if (!n2) return null;
      var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
      return f(a2);
    }, "hsl"]], object: [[function(r2) {
      var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i3 = void 0 === o2 ? 1 : o2;
      return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i3) }) : null;
    }, "rgb"], [function(r2) {
      var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
      if (!t(n2) || !t(e2) || !t(u2)) return null;
      var i3 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
      return f(i3);
    }, "hsl"], [function(r2) {
      var n2 = r2.h, a2 = r2.s, o2 = r2.v, i3 = r2.a, s2 = void 0 === i3 ? 1 : i3;
      if (!t(n2) || !t(a2) || !t(o2)) return null;
      var h2 = function(r3) {
        return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
      }({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
      return b(h2);
    }, "hsv"]] };
    N = function(r2, t2) {
      for (var n2 = 0; n2 < t2.length; n2++) {
        var e2 = t2[n2][0](r2);
        if (e2) return [e2, t2[n2][1]];
      }
      return [null, void 0];
    };
    x = function(r2) {
      return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
    };
    M = function(r2, t2) {
      var n2 = c(r2);
      return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
    };
    H = function(r2) {
      return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
    };
    $ = function(r2, t2) {
      var n2 = c(r2);
      return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
    };
    j = function() {
      function r2(r3) {
        this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
      }
      return r2.prototype.isValid = function() {
        return null !== this.parsed;
      }, r2.prototype.brightness = function() {
        return n(H(this.rgba), 2);
      }, r2.prototype.isDark = function() {
        return H(this.rgba) < 0.5;
      }, r2.prototype.isLight = function() {
        return H(this.rgba) >= 0.5;
      }, r2.prototype.toHex = function() {
        return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i3 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i3;
        var r3, t2, e2, u2, a2, i3;
      }, r2.prototype.toRgb = function() {
        return o(this.rgba);
      }, r2.prototype.toRgbString = function() {
        return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
        var r3, t2, n2, e2, u2;
      }, r2.prototype.toHsl = function() {
        return d(c(this.rgba));
      }, r2.prototype.toHslString = function() {
        return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
        var r3, t2, n2, e2, u2;
      }, r2.prototype.toHsv = function() {
        return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
        var r3;
      }, r2.prototype.invert = function() {
        return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
        var r3;
      }, r2.prototype.saturate = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
      }, r2.prototype.desaturate = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
      }, r2.prototype.grayscale = function() {
        return w(M(this.rgba, -1));
      }, r2.prototype.lighten = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
      }, r2.prototype.darken = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
      }, r2.prototype.rotate = function(r3) {
        return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
      }, r2.prototype.alpha = function(r3) {
        return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
        var t2;
      }, r2.prototype.hue = function(r3) {
        var t2 = c(this.rgba);
        return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
      }, r2.prototype.isEqual = function(r3) {
        return this.toHex() === w(r3).toHex();
      }, r2;
    }();
    w = function(r2) {
      return r2 instanceof j ? r2 : new j(r2);
    };
    S = [];
    k = function(r2) {
      r2.forEach(function(r3) {
        S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
      });
    };
  }
});

// node_modules/@pixi/colord/plugins/names.mjs
function names_default(e2, f2) {
  var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d2 in a2) r2[a2[d2]] = d2;
  var l2 = {};
  e2.prototype.toName = function(f3) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var d3, i3, n2 = r2[this.toHex()];
    if (n2) return n2;
    if (null == f3 ? void 0 : f3.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b3 = "black";
      if (!l2.length) for (var c2 in a2) l2[c2] = new e2(a2[c2]).toRgb();
      for (var g2 in a2) {
        var u2 = (d3 = o2, i3 = l2[g2], Math.pow(d3.r - i3.r, 2) + Math.pow(d3.g - i3.g, 2) + Math.pow(d3.b - i3.b, 2));
        u2 < t2 && (t2 = u2, b3 = g2);
      }
      return b3;
    }
  };
  f2.string.push([function(f3) {
    var r3 = f3.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a2[r3];
    return d3 ? new e2(d3).toRgb() : null;
  }, "name"]);
}
var init_names = __esm({
  "node_modules/@pixi/colord/plugins/names.mjs"() {
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/color/Color.mjs
var _Color, Color;
var init_Color = __esm({
  "node_modules/pixi.js/lib/color/Color.mjs"() {
    init_define_AnParams();
    init_colord();
    init_names();
    k([names_default]);
    _Color = class _Color2 {
      /**
       * @param {ColorSource} value - Optional value to use, if not provided, white is used.
       */
      constructor(value = 16777215) {
        this._value = null;
        this._components = new Float32Array(4);
        this._components.fill(1);
        this._int = 16777215;
        this.value = value;
      }
      /** Get red component (0 - 1) */
      get red() {
        return this._components[0];
      }
      /** Get green component (0 - 1) */
      get green() {
        return this._components[1];
      }
      /** Get blue component (0 - 1) */
      get blue() {
        return this._components[2];
      }
      /** Get alpha component (0 - 1) */
      get alpha() {
        return this._components[3];
      }
      /**
       * Set the value, suitable for chaining
       * @param value
       * @see Color.value
       */
      setValue(value) {
        this.value = value;
        return this;
      }
      /**
       * The current color source.
       *
       * When setting:
       * - Setting to an instance of `Color` will copy its color source and components.
       * - Otherwise, `Color` will try to normalize the color source and set the components.
       *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
       *
       * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
       * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
       *
       * When getting:
       * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},
       *   {@link Color.premultiply premultiply} or {@link Color.round round}).
       * - Otherwise, the color source used when setting is returned.
       */
      set value(value) {
        if (value instanceof _Color2) {
          this._value = this._cloneSource(value._value);
          this._int = value._int;
          this._components.set(value._components);
        } else if (value === null) {
          throw new Error("Cannot set Color#value to null");
        } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
          this._value = this._cloneSource(value);
          this._normalize(this._value);
        }
      }
      get value() {
        return this._value;
      }
      /**
       * Copy a color source internally.
       * @param value - Color source
       */
      _cloneSource(value) {
        if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
          return value;
        } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
          return value.slice(0);
        } else if (typeof value === "object" && value !== null) {
          return { ...value };
        }
        return value;
      }
      /**
       * Equality check for color sources.
       * @param value1 - First color source
       * @param value2 - Second color source
       * @returns `true` if the color sources are equal, `false` otherwise.
       */
      _isSourceEqual(value1, value2) {
        const type1 = typeof value1;
        const type2 = typeof value2;
        if (type1 !== type2) {
          return false;
        } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
          return value1 === value2;
        } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
          if (value1.length !== value2.length) {
            return false;
          }
          return value1.every((v2, i3) => v2 === value2[i3]);
        } else if (value1 !== null && value2 !== null) {
          const keys1 = Object.keys(value1);
          const keys2 = Object.keys(value2);
          if (keys1.length !== keys2.length) {
            return false;
          }
          return keys1.every((key) => value1[key] === value2[key]);
        }
        return value1 === value2;
      }
      /**
       * Convert to a RGBA color object.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
       */
      toRgba() {
        const [r2, g2, b3, a2] = this._components;
        return { r: r2, g: g2, b: b3, a: a2 };
      }
      /**
       * Convert to a RGB color object.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
       */
      toRgb() {
        const [r2, g2, b3] = this._components;
        return { r: r2, g: g2, b: b3 };
      }
      /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
      toRgbaString() {
        const [r2, g2, b3] = this.toUint8RgbArray();
        return `rgba(${r2},${g2},${b3},${this.alpha})`;
      }
      toUint8RgbArray(out2) {
        const [r2, g2, b3] = this._components;
        if (!this._arrayRgb) {
          this._arrayRgb = [];
        }
        out2 || (out2 = this._arrayRgb);
        out2[0] = Math.round(r2 * 255);
        out2[1] = Math.round(g2 * 255);
        out2[2] = Math.round(b3 * 255);
        return out2;
      }
      toArray(out2) {
        if (!this._arrayRgba) {
          this._arrayRgba = [];
        }
        out2 || (out2 = this._arrayRgba);
        const [r2, g2, b3, a2] = this._components;
        out2[0] = r2;
        out2[1] = g2;
        out2[2] = b3;
        out2[3] = a2;
        return out2;
      }
      toRgbArray(out2) {
        if (!this._arrayRgb) {
          this._arrayRgb = [];
        }
        out2 || (out2 = this._arrayRgb);
        const [r2, g2, b3] = this._components;
        out2[0] = r2;
        out2[1] = g2;
        out2[2] = b3;
        return out2;
      }
      /**
       * Convert to a hexadecimal number.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toNumber(); // returns 16777215
       */
      toNumber() {
        return this._int;
      }
      /**
       * Convert to a BGR number
       * @example
       * import { Color } from 'pixi.js';
       * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
       */
      toBgrNumber() {
        const [r2, g2, b3] = this.toUint8RgbArray();
        return (b3 << 16) + (g2 << 8) + r2;
      }
      /**
       * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
       * @example
       * import { Color } from 'pixi.js';
       * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
       * @returns {number} - The color as a number in little endian format.
       */
      toLittleEndianNumber() {
        const value = this._int;
        return (value >> 16) + (value & 65280) + ((value & 255) << 16);
      }
      /**
       * Multiply with another color. This action is destructive, and will
       * override the previous `value` property to be `null`.
       * @param {ColorSource} value - The color to multiply by.
       */
      multiply(value) {
        const [r2, g2, b3, a2] = _Color2._temp.setValue(value)._components;
        this._components[0] *= r2;
        this._components[1] *= g2;
        this._components[2] *= b3;
        this._components[3] *= a2;
        this._refreshInt();
        this._value = null;
        return this;
      }
      /**
       * Converts color to a premultiplied alpha format. This action is destructive, and will
       * override the previous `value` property to be `null`.
       * @param alpha - The alpha to multiply by.
       * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
       * @returns {Color} - Itself.
       */
      premultiply(alpha, applyToRGB = true) {
        if (applyToRGB) {
          this._components[0] *= alpha;
          this._components[1] *= alpha;
          this._components[2] *= alpha;
        }
        this._components[3] = alpha;
        this._refreshInt();
        this._value = null;
        return this;
      }
      /**
       * Premultiplies alpha with current color.
       * @param {number} alpha - The alpha to multiply by.
       * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
       * @returns {number} tint multiplied by alpha
       */
      toPremultiplied(alpha, applyToRGB = true) {
        if (alpha === 1) {
          return (255 << 24) + this._int;
        }
        if (alpha === 0) {
          return applyToRGB ? 0 : this._int;
        }
        let r2 = this._int >> 16 & 255;
        let g2 = this._int >> 8 & 255;
        let b3 = this._int & 255;
        if (applyToRGB) {
          r2 = r2 * alpha + 0.5 | 0;
          g2 = g2 * alpha + 0.5 | 0;
          b3 = b3 * alpha + 0.5 | 0;
        }
        return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b3;
      }
      /**
       * Convert to a hexadecimal string.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toHex(); // returns "#ffffff"
       */
      toHex() {
        const hexString = this._int.toString(16);
        return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
      }
      /**
       * Convert to a hexadecimal string with alpha.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toHexa(); // returns "#ffffffff"
       */
      toHexa() {
        const alphaValue = Math.round(this._components[3] * 255);
        const alphaString = alphaValue.toString(16);
        return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
      }
      /**
       * Set alpha, suitable for chaining.
       * @param alpha
       */
      setAlpha(alpha) {
        this._components[3] = this._clamp(alpha);
        return this;
      }
      /**
       * Normalize the input value into rgba
       * @param value - Input value
       */
      _normalize(value) {
        let r2;
        let g2;
        let b3;
        let a2;
        if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
          const int = value;
          r2 = (int >> 16 & 255) / 255;
          g2 = (int >> 8 & 255) / 255;
          b3 = (int & 255) / 255;
          a2 = 1;
        } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
          value = this._clamp(value);
          [r2, g2, b3, a2 = 1] = value;
        } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
          value = this._clamp(value, 0, 255);
          [r2, g2, b3, a2 = 255] = value;
          r2 /= 255;
          g2 /= 255;
          b3 /= 255;
          a2 /= 255;
        } else if (typeof value === "string" || typeof value === "object") {
          if (typeof value === "string") {
            const match = _Color2.HEX_PATTERN.exec(value);
            if (match) {
              value = `#${match[2]}`;
            }
          }
          const color = w(value);
          if (color.isValid()) {
            ({ r: r2, g: g2, b: b3, a: a2 } = color.rgba);
            r2 /= 255;
            g2 /= 255;
            b3 /= 255;
          }
        }
        if (r2 !== void 0) {
          this._components[0] = r2;
          this._components[1] = g2;
          this._components[2] = b3;
          this._components[3] = a2;
          this._refreshInt();
        } else {
          throw new Error(`Unable to convert color ${value}`);
        }
      }
      /** Refresh the internal color rgb number */
      _refreshInt() {
        this._clamp(this._components);
        const [r2, g2, b3] = this._components;
        this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b3 * 255 | 0);
      }
      /**
       * Clamps values to a range. Will override original values
       * @param value - Value(s) to clamp
       * @param min - Minimum value
       * @param max - Maximum value
       */
      _clamp(value, min = 0, max2 = 1) {
        if (typeof value === "number") {
          return Math.min(Math.max(value, min), max2);
        }
        value.forEach((v2, i3) => {
          value[i3] = Math.min(Math.max(v2, min), max2);
        });
        return value;
      }
      /**
       * Check if the value is a color-like object
       * @param value - Value to check
       * @returns True if the value is a color-like object
       * @static
       * @example
       * import { Color } from 'pixi.js';
       * Color.isColorLike('white'); // returns true
       * Color.isColorLike(0xffffff); // returns true
       * Color.isColorLike([1, 1, 1]); // returns true
       */
      static isColorLike(value) {
        return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color2 || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
      }
    };
    _Color.shared = new _Color();
    _Color._temp = new _Color();
    _Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
    Color = _Color;
  }
});

// node_modules/pixi.js/lib/culling/cullingMixin.mjs
var cullingMixin;
var init_cullingMixin = __esm({
  "node_modules/pixi.js/lib/culling/cullingMixin.mjs"() {
    "use strict";
    init_define_AnParams();
    cullingMixin = {
      cullArea: null,
      cullable: false,
      cullableChildren: true
    };
  }
});

// node_modules/pixi.js/lib/maths/misc/const.mjs
var PI_2, RAD_TO_DEG, DEG_TO_RAD;
var init_const = __esm({
  "node_modules/pixi.js/lib/maths/misc/const.mjs"() {
    "use strict";
    init_define_AnParams();
    PI_2 = Math.PI * 2;
    RAD_TO_DEG = 180 / Math.PI;
    DEG_TO_RAD = Math.PI / 180;
  }
});

// node_modules/pixi.js/lib/maths/point/Point.mjs
var Point, tempPoint;
var init_Point = __esm({
  "node_modules/pixi.js/lib/maths/point/Point.mjs"() {
    "use strict";
    init_define_AnParams();
    Point = class _Point {
      /**
       * Creates a new `Point`
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(x2 = 0, y2 = 0) {
        this.x = 0;
        this.y = 0;
        this.x = x2;
        this.y = y2;
      }
      /**
       * Creates a clone of this point
       * @returns A clone of this point
       */
      clone() {
        return new _Point(this.x, this.y);
      }
      /**
       * Copies `x` and `y` from the given point into this point
       * @param p - The point to copy from
       * @returns The point instance itself
       */
      copyFrom(p2) {
        this.set(p2.x, p2.y);
        return this;
      }
      /**
       * Copies this point's x and y into the given point (`p`).
       * @param p - The point to copy to. Can be any of type that is or extends `PointData`
       * @returns The point (`p`) with values updated
       */
      copyTo(p2) {
        p2.set(this.x, this.y);
        return p2;
      }
      /**
       * Accepts another point (`p`) and returns `true` if the given point is equal to this point
       * @param p - The point to check
       * @returns Returns `true` if both `x` and `y` are equal
       */
      equals(p2) {
        return p2.x === this.x && p2.y === this.y;
      }
      /**
       * Sets the point to a new `x` and `y` position.
       * If `y` is omitted, both `x` and `y` will be set to `x`.
       * @param {number} [x=0] - position of the point on the `x` axis
       * @param {number} [y=x] - position of the point on the `y` axis
       * @returns The point instance itself
       */
      set(x2 = 0, y2 = x2) {
        this.x = x2;
        this.y = y2;
        return this;
      }
      toString() {
        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
      }
      /**
       * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.
       * @readonly
       */
      static get shared() {
        tempPoint.x = 0;
        tempPoint.y = 0;
        return tempPoint;
      }
    };
    tempPoint = new Point();
  }
});

// node_modules/pixi.js/lib/maths/matrix/Matrix.mjs
var Matrix, tempMatrix, identityMatrix;
var init_Matrix = __esm({
  "node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"() {
    init_define_AnParams();
    init_const();
    init_Point();
    Matrix = class _Matrix {
      /**
       * @param a - x scale
       * @param b - y skew
       * @param c - x skew
       * @param d - y scale
       * @param tx - x translation
       * @param ty - y translation
       */
      constructor(a2 = 1, b3 = 0, c2 = 0, d2 = 1, tx = 0, ty = 0) {
        this.array = null;
        this.a = a2;
        this.b = b3;
        this.c = c2;
        this.d = d2;
        this.tx = tx;
        this.ty = ty;
      }
      /**
       * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
       *
       * a = array[0]
       * b = array[1]
       * c = array[3]
       * d = array[4]
       * tx = array[2]
       * ty = array[5]
       * @param array - The array that the matrix will be populated from.
       */
      fromArray(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
      }
      /**
       * Sets the matrix properties.
       * @param a - Matrix component
       * @param b - Matrix component
       * @param c - Matrix component
       * @param d - Matrix component
       * @param tx - Matrix component
       * @param ty - Matrix component
       * @returns This matrix. Good for chaining method calls.
       */
      set(a2, b3, c2, d2, tx, ty) {
        this.a = a2;
        this.b = b3;
        this.c = c2;
        this.d = d2;
        this.tx = tx;
        this.ty = ty;
        return this;
      }
      /**
       * Creates an array from the current Matrix object.
       * @param transpose - Whether we need to transpose the matrix or not
       * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
       * @returns The newly created array which contains the matrix
       */
      toArray(transpose, out2) {
        if (!this.array) {
          this.array = new Float32Array(9);
        }
        const array = out2 || this.array;
        if (transpose) {
          array[0] = this.a;
          array[1] = this.b;
          array[2] = 0;
          array[3] = this.c;
          array[4] = this.d;
          array[5] = 0;
          array[6] = this.tx;
          array[7] = this.ty;
          array[8] = 1;
        } else {
          array[0] = this.a;
          array[1] = this.c;
          array[2] = this.tx;
          array[3] = this.b;
          array[4] = this.d;
          array[5] = this.ty;
          array[6] = 0;
          array[7] = 0;
          array[8] = 1;
        }
        return array;
      }
      /**
       * Get a new position with the current transformation applied.
       * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
       * @param pos - The origin
       * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
       * @returns {Point} The new point, transformed through this matrix
       */
      apply(pos, newPos) {
        newPos = newPos || new Point();
        const x2 = pos.x;
        const y2 = pos.y;
        newPos.x = this.a * x2 + this.c * y2 + this.tx;
        newPos.y = this.b * x2 + this.d * y2 + this.ty;
        return newPos;
      }
      /**
       * Get a new position with the inverse of the current transformation applied.
       * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
       * @param pos - The origin
       * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
       * @returns {Point} The new point, inverse-transformed through this matrix
       */
      applyInverse(pos, newPos) {
        newPos = newPos || new Point();
        const a2 = this.a;
        const b3 = this.b;
        const c2 = this.c;
        const d2 = this.d;
        const tx = this.tx;
        const ty = this.ty;
        const id = 1 / (a2 * d2 + c2 * -b3);
        const x2 = pos.x;
        const y2 = pos.y;
        newPos.x = d2 * id * x2 + -c2 * id * y2 + (ty * c2 - tx * d2) * id;
        newPos.y = a2 * id * y2 + -b3 * id * x2 + (-ty * a2 + tx * b3) * id;
        return newPos;
      }
      /**
       * Translates the matrix on the x and y.
       * @param x - How much to translate x by
       * @param y - How much to translate y by
       * @returns This matrix. Good for chaining method calls.
       */
      translate(x2, y2) {
        this.tx += x2;
        this.ty += y2;
        return this;
      }
      /**
       * Applies a scale transformation to the matrix.
       * @param x - The amount to scale horizontally
       * @param y - The amount to scale vertically
       * @returns This matrix. Good for chaining method calls.
       */
      scale(x2, y2) {
        this.a *= x2;
        this.d *= y2;
        this.c *= x2;
        this.b *= y2;
        this.tx *= x2;
        this.ty *= y2;
        return this;
      }
      /**
       * Applies a rotation transformation to the matrix.
       * @param angle - The angle in radians.
       * @returns This matrix. Good for chaining method calls.
       */
      rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const a1 = this.a;
        const c1 = this.c;
        const tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
      }
      /**
       * Appends the given Matrix to this Matrix.
       * @param matrix - The matrix to append.
       * @returns This matrix. Good for chaining method calls.
       */
      append(matrix) {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
      }
      /**
       * Appends two matrix's and sets the result to this matrix. AB = A * B
       * @param a - The matrix to append.
       * @param b - The matrix to append.
       * @returns This matrix. Good for chaining method calls.
       */
      appendFrom(a2, b3) {
        const a1 = a2.a;
        const b1 = a2.b;
        const c1 = a2.c;
        const d1 = a2.d;
        const tx = a2.tx;
        const ty = a2.ty;
        const a22 = b3.a;
        const b22 = b3.b;
        const c2 = b3.c;
        const d2 = b3.d;
        this.a = a1 * a22 + b1 * c2;
        this.b = a1 * b22 + b1 * d2;
        this.c = c1 * a22 + d1 * c2;
        this.d = c1 * b22 + d1 * d2;
        this.tx = tx * a22 + ty * c2 + b3.tx;
        this.ty = tx * b22 + ty * d2 + b3.ty;
        return this;
      }
      /**
       * Sets the matrix based on all the available properties
       * @param x - Position on the x axis
       * @param y - Position on the y axis
       * @param pivotX - Pivot on the x axis
       * @param pivotY - Pivot on the y axis
       * @param scaleX - Scale on the x axis
       * @param scaleY - Scale on the y axis
       * @param rotation - Rotation in radians
       * @param skewX - Skew on the x axis
       * @param skewY - Skew on the y axis
       * @returns This matrix. Good for chaining method calls.
       */
      setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x2 - (pivotX * this.a + pivotY * this.c);
        this.ty = y2 - (pivotX * this.b + pivotY * this.d);
        return this;
      }
      /**
       * Prepends the given Matrix to this Matrix.
       * @param matrix - The matrix to prepend
       * @returns This matrix. Good for chaining method calls.
       */
      prepend(matrix) {
        const tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
          const a1 = this.a;
          const c1 = this.c;
          this.a = a1 * matrix.a + this.b * matrix.c;
          this.b = a1 * matrix.b + this.b * matrix.d;
          this.c = c1 * matrix.a + this.d * matrix.c;
          this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
      }
      /**
       * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
       * @param transform - The transform to apply the properties to.
       * @returns The transform with the newly applied properties
       */
      decompose(transform2) {
        const a2 = this.a;
        const b3 = this.b;
        const c2 = this.c;
        const d2 = this.d;
        const pivot = transform2.pivot;
        const skewX = -Math.atan2(-c2, d2);
        const skewY = Math.atan2(b3, a2);
        const delta = Math.abs(skewX + skewY);
        if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
          transform2.rotation = skewY;
          transform2.skew.x = transform2.skew.y = 0;
        } else {
          transform2.rotation = 0;
          transform2.skew.x = skewX;
          transform2.skew.y = skewY;
        }
        transform2.scale.x = Math.sqrt(a2 * a2 + b3 * b3);
        transform2.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
        transform2.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
        transform2.position.y = this.ty + (pivot.x * b3 + pivot.y * d2);
        return transform2;
      }
      /**
       * Inverts this matrix
       * @returns This matrix. Good for chaining method calls.
       */
      invert() {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        const tx1 = this.tx;
        const n2 = a1 * d1 - b1 * c1;
        this.a = d1 / n2;
        this.b = -b1 / n2;
        this.c = -c1 / n2;
        this.d = a1 / n2;
        this.tx = (c1 * this.ty - d1 * tx1) / n2;
        this.ty = -(a1 * this.ty - b1 * tx1) / n2;
        return this;
      }
      /** Checks if this matrix is an identity matrix */
      isIdentity() {
        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
      }
      /**
       * Resets this Matrix to an identity (default) matrix.
       * @returns This matrix. Good for chaining method calls.
       */
      identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
      }
      /**
       * Creates a new Matrix object with the same values as this one.
       * @returns A copy of this matrix. Good for chaining method calls.
       */
      clone() {
        const matrix = new _Matrix();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Changes the values of the given matrix to be the same as the ones in this matrix
       * @param matrix - The matrix to copy to.
       * @returns The matrix given in parameter with its values updated.
       */
      copyTo(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Changes the values of the matrix to be the same as the ones in given matrix
       * @param matrix - The matrix to copy from.
       * @returns this
       */
      copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
      }
      /**
       * check to see if two matrices are the same
       * @param matrix - The matrix to compare to.
       */
      equals(matrix) {
        return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
      }
      toString() {
        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
      }
      /**
       * A default (identity) matrix.
       *
       * This is a shared object, if you want to modify it consider creating a new `Matrix`
       * @readonly
       */
      static get IDENTITY() {
        return identityMatrix.identity();
      }
      /**
       * A static Matrix that can be used to avoid creating new objects.
       * Will always ensure the matrix is reset to identity when requested.
       * Use this object for fast but temporary calculations, as it may be mutated later on.
       * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.
       * @readonly
       */
      static get shared() {
        return tempMatrix.identity();
      }
    };
    tempMatrix = new Matrix();
    identityMatrix = new Matrix();
  }
});

// node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs
var ObservablePoint;
var init_ObservablePoint = __esm({
  "node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs"() {
    "use strict";
    init_define_AnParams();
    ObservablePoint = class _ObservablePoint {
      /**
       * Creates a new `ObservablePoint`
       * @param observer - Observer to pass to listen for change events.
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(observer, x2, y2) {
        this._x = x2 || 0;
        this._y = y2 || 0;
        this._observer = observer;
      }
      /**
       * Creates a clone of this point.
       * @param observer - Optional observer to pass to the new observable point.
       * @returns a copy of this observable point
       */
      clone(observer) {
        return new _ObservablePoint(observer ?? this._observer, this._x, this._y);
      }
      /**
       * Sets the point to a new `x` and `y` position.
       * If `y` is omitted, both `x` and `y` will be set to `x`.
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=x] - position of the point on the y axis
       * @returns The observable point instance itself
       */
      set(x2 = 0, y2 = x2) {
        if (this._x !== x2 || this._y !== y2) {
          this._x = x2;
          this._y = y2;
          this._observer._onUpdate(this);
        }
        return this;
      }
      /**
       * Copies x and y from the given point (`p`)
       * @param p - The point to copy from. Can be any of type that is or extends `PointData`
       * @returns The observable point instance itself
       */
      copyFrom(p2) {
        if (this._x !== p2.x || this._y !== p2.y) {
          this._x = p2.x;
          this._y = p2.y;
          this._observer._onUpdate(this);
        }
        return this;
      }
      /**
       * Copies this point's x and y into that of the given point (`p`)
       * @param p - The point to copy to. Can be any of type that is or extends `PointData`
       * @returns The point (`p`) with values updated
       */
      copyTo(p2) {
        p2.set(this._x, this._y);
        return p2;
      }
      /**
       * Accepts another point (`p`) and returns `true` if the given point is equal to this point
       * @param p - The point to check
       * @returns Returns `true` if both `x` and `y` are equal
       */
      equals(p2) {
        return p2.x === this._x && p2.y === this._y;
      }
      toString() {
        return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;
      }
      /** Position of the observable point on the x axis. */
      get x() {
        return this._x;
      }
      set x(value) {
        if (this._x !== value) {
          this._x = value;
          this._observer._onUpdate(this);
        }
      }
      /** Position of the observable point on the y axis. */
      get y() {
        return this._y;
      }
      set y(value) {
        if (this._y !== value) {
          this._y = value;
          this._observer._onUpdate(this);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/data/uid.mjs
function uid(name = "default") {
  if (uidCache[name] === void 0) {
    uidCache[name] = -1;
  }
  return ++uidCache[name];
}
function resetUids() {
  for (const key in uidCache) {
    delete uidCache[key];
  }
}
var uidCache;
var init_uid = __esm({
  "node_modules/pixi.js/lib/utils/data/uid.mjs"() {
    "use strict";
    init_define_AnParams();
    uidCache = {
      default: -1
    };
  }
});

// node_modules/pixi.js/lib/utils/logging/deprecation.mjs
function deprecation(version, message, ignoreDepth = 3) {
  if (warnings[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed(
        "%cPixiJS Deprecation Warning: %c%s",
        "color:#614108;background:#fffbe6",
        "font-weight:normal;color:#614108;background:#fffbe6",
        `${message}
Deprecated since v${version}`
      );
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}
var warnings, v8_0_0, v8_3_4;
var init_deprecation = __esm({
  "node_modules/pixi.js/lib/utils/logging/deprecation.mjs"() {
    "use strict";
    init_define_AnParams();
    warnings = {};
    v8_0_0 = "8.0.0";
    v8_3_4 = "8.3.4";
  }
});

// node_modules/pixi.js/lib/utils/pool/Pool.mjs
var Pool;
var init_Pool = __esm({
  "node_modules/pixi.js/lib/utils/pool/Pool.mjs"() {
    "use strict";
    init_define_AnParams();
    Pool = class {
      /**
       * Constructs a new Pool.
       * @param ClassType - The constructor of the items in the pool.
       * @param {number} [initialSize] - The initial size of the pool.
       */
      constructor(ClassType, initialSize) {
        this._pool = [];
        this._count = 0;
        this._index = 0;
        this._classType = ClassType;
        if (initialSize) {
          this.prepopulate(initialSize);
        }
      }
      /**
       * Prepopulates the pool with a given number of items.
       * @param total - The number of items to add to the pool.
       */
      prepopulate(total) {
        for (let i3 = 0; i3 < total; i3++) {
          this._pool[this._index++] = new this._classType();
        }
        this._count += total;
      }
      /**
       * Gets an item from the pool. Calls the item's `init` method if it exists.
       * If there are no items left in the pool, a new one will be created.
       * @param {unknown} [data] - Optional data to pass to the item's constructor.
       * @returns {T} The item from the pool.
       */
      get(data) {
        let item;
        if (this._index > 0) {
          item = this._pool[--this._index];
        } else {
          item = new this._classType();
        }
        item.init?.(data);
        return item;
      }
      /**
       * Returns an item to the pool. Calls the item's `reset` method if it exists.
       * @param {T} item - The item to return to the pool.
       */
      return(item) {
        item.reset?.();
        this._pool[this._index++] = item;
      }
      /**
       * Gets the number of items in the pool.
       * @readonly
       * @member {number}
       */
      get totalSize() {
        return this._count;
      }
      /**
       * Gets the number of items in the pool that are free to use without needing to create more.
       * @readonly
       * @member {number}
       */
      get totalFree() {
        return this._index;
      }
      /**
       * Gets the number of items in the pool that are currently in use.
       * @readonly
       * @member {number}
       */
      get totalUsed() {
        return this._count - this._index;
      }
      /** clears the pool - mainly used for debugging! */
      clear() {
        this._pool.length = 0;
        this._index = 0;
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs
var PoolGroupClass, BigPool;
var init_PoolGroup = __esm({
  "node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"() {
    init_define_AnParams();
    init_Pool();
    PoolGroupClass = class {
      constructor() {
        this._poolsByClass = /* @__PURE__ */ new Map();
      }
      /**
       * Prepopulates a specific pool with a given number of items.
       * @template T The type of items in the pool. Must extend PoolItem.
       * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
       * @param {number} total - The number of items to add to the pool.
       */
      prepopulate(Class, total) {
        const classPool = this.getPool(Class);
        classPool.prepopulate(total);
      }
      /**
       * Gets an item from a specific pool.
       * @template T The type of items in the pool. Must extend PoolItem.
       * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
       * @param {unknown} [data] - Optional data to pass to the item's constructor.
       * @returns {T} The item from the pool.
       */
      get(Class, data) {
        const pool = this.getPool(Class);
        return pool.get(data);
      }
      /**
       * Returns an item to its respective pool.
       * @param {PoolItem} item - The item to return to the pool.
       */
      return(item) {
        const pool = this.getPool(item.constructor);
        pool.return(item);
      }
      /**
       * Gets a specific pool based on the class type.
       * @template T The type of items in the pool. Must extend PoolItem.
       * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
       * @returns {Pool<T>} The pool of the given class type.
       */
      getPool(ClassType) {
        if (!this._poolsByClass.has(ClassType)) {
          this._poolsByClass.set(ClassType, new Pool(ClassType));
        }
        return this._poolsByClass.get(ClassType);
      }
      /** gets the usage stats of each pool in the system */
      stats() {
        const stats = {};
        this._poolsByClass.forEach((pool) => {
          const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
          stats[name] = {
            free: pool.totalFree,
            used: pool.totalUsed,
            size: pool.totalSize
          };
        });
        return stats;
      }
    };
    BigPool = new PoolGroupClass();
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs
var cacheAsTextureMixin;
var init_cacheAsTextureMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs"() {
    init_define_AnParams();
    init_deprecation();
    cacheAsTextureMixin = {
      /**
       * Is this container cached as a texture?
       * @readonly
       * @type {boolean}
       * @memberof scene.Container#
       */
      get isCachedAsTexture() {
        return !!this.renderGroup?.isCachedAsTexture;
      },
      cacheAsTexture(val) {
        if (typeof val === "boolean" && val === false) {
          this.disableRenderGroup();
        } else {
          this.enableRenderGroup();
          this.renderGroup.enableCacheAsTexture(val === true ? {} : val);
        }
      },
      /**
       * Updates the cached texture. Will flag that this container's cached texture needs to be redrawn.
       * This will happen on the next render.
       * @memberof scene.Container#
       */
      updateCacheTexture() {
        this.renderGroup?.updateCacheTexture();
      },
      /**
       * Allows backwards compatibility with pixi.js below version v8. Use `cacheAsTexture` instead.
       * @deprecated
       */
      get cacheAsBitmap() {
        return this.isCachedAsTexture;
      },
      /**
       * @deprecated
       */
      set cacheAsBitmap(val) {
        deprecation("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead.");
        this.cacheAsTexture(val);
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/data/removeItems.mjs
function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i3;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i3 = startIdx; i3 < len; ++i3) {
    arr[i3] = arr[i3 + removeCount];
  }
  arr.length = len;
}
var init_removeItems = __esm({
  "node_modules/pixi.js/lib/utils/data/removeItems.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs
var childrenHelperMixin;
var init_childrenHelperMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs"() {
    init_define_AnParams();
    init_removeItems();
    init_deprecation();
    childrenHelperMixin = {
      allowChildren: true,
      /**
       * Removes all children from this container that are within the begin and end indexes.
       * @param beginIndex - The beginning position.
       * @param endIndex - The ending position. Default value is size of the container.
       * @returns - List of removed children
       * @memberof scene.Container#
       */
      removeChildren(beginIndex = 0, endIndex) {
        const end = endIndex ?? this.children.length;
        const range = end - beginIndex;
        const removed = [];
        if (range > 0 && range <= end) {
          for (let i3 = end - 1; i3 >= beginIndex; i3--) {
            const child = this.children[i3];
            if (!child)
              continue;
            removed.push(child);
            child.parent = null;
          }
          removeItems(this.children, beginIndex, end);
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.removeChildren(removed);
          }
          for (let i3 = 0; i3 < removed.length; ++i3) {
            this.emit("childRemoved", removed[i3], this, i3);
            removed[i3].emit("removed", this);
          }
          if (removed.length > 0) {
            this._didViewChangeTick++;
          }
          return removed;
        } else if (range === 0 && this.children.length === 0) {
          return removed;
        }
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
      },
      /**
       * Removes a child from the specified index position.
       * @param index - The index to get the child from
       * @returns The child that was removed.
       * @memberof scene.Container#
       */
      removeChildAt(index) {
        const child = this.getChildAt(index);
        return this.removeChild(child);
      },
      /**
       * Returns the child at the specified index
       * @param index - The index to get the child at
       * @returns - The child at the given index, if any.
       * @memberof scene.Container#
       */
      getChildAt(index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error(`getChildAt: Index (${index}) does not exist.`);
        }
        return this.children[index];
      },
      /**
       * Changes the position of an existing child in the container
       * @param child - The child Container instance for which you want to change the index number
       * @param index - The resulting index number for the child container
       * @memberof scene.Container#
       */
      setChildIndex(child, index) {
        if (index < 0 || index >= this.children.length) {
          throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
        }
        this.getChildIndex(child);
        this.addChildAt(child, index);
      },
      /**
       * Returns the index position of a child Container instance
       * @param child - The Container instance to identify
       * @returns - The index position of the child container to identify
       * @memberof scene.Container#
       */
      getChildIndex(child) {
        const index = this.children.indexOf(child);
        if (index === -1) {
          throw new Error("The supplied Container must be a child of the caller");
        }
        return index;
      },
      /**
       * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
       * If the child is already in this container, it will be moved to the specified index.
       * @param {Container} child - The child to add.
       * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
       * @returns {Container} The child that was added.
       * @memberof scene.Container#
       */
      addChildAt(child, index) {
        if (!this.allowChildren) {
          deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
        }
        const { children } = this;
        if (index < 0 || index > children.length) {
          throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
        }
        if (child.parent) {
          const currentIndex = child.parent.children.indexOf(child);
          if (child.parent === this && currentIndex === index) {
            return child;
          }
          if (currentIndex !== -1) {
            child.parent.children.splice(currentIndex, 1);
          }
        }
        if (index === children.length) {
          children.push(child);
        } else {
          children.splice(index, 0, child);
        }
        child.parent = this;
        child.didChange = true;
        child._updateFlags = 15;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.addChild(child);
        }
        if (this.sortableChildren)
          this.sortDirty = true;
        this.emit("childAdded", child, this, index);
        child.emit("added", this);
        return child;
      },
      /**
       * Swaps the position of 2 Containers within this container.
       * @param child - First container to swap
       * @param child2 - Second container to swap
       * @memberof scene.Container#
       */
      swapChildren(child, child2) {
        if (child === child2) {
          return;
        }
        const index1 = this.getChildIndex(child);
        const index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.structureDidChange = true;
        }
        this._didContainerChangeTick++;
      },
      /**
       * Remove the Container from its parent Container. If the Container has no parent, do nothing.
       * @memberof scene.Container#
       */
      removeFromParent() {
        this.parent?.removeChild(this);
      },
      /**
       * Reparent the child to this container, keeping the same worldTransform.
       * @param child - The child to reparent
       * @returns The first child that was reparented.
       * @memberof scene.Container#
       */
      reparentChild(...child) {
        if (child.length === 1) {
          return this.reparentChildAt(child[0], this.children.length);
        }
        child.forEach((c2) => this.reparentChildAt(c2, this.children.length));
        return child[0];
      },
      /**
       * Reparent the child to this container at the specified index, keeping the same worldTransform.
       * @param child - The child to reparent
       * @param index - The index to reparent the child to
       * @memberof scene.Container#
       */
      reparentChildAt(child, index) {
        if (child.parent === this) {
          this.setChildIndex(child, index);
          return child;
        }
        const childMat = child.worldTransform.clone();
        child.removeFromParent();
        this.addChildAt(child, index);
        const newMatrix = this.worldTransform.clone();
        newMatrix.invert();
        childMat.prepend(newMatrix);
        child.setFromMatrix(childMat);
        return child;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs
var collectRenderablesMixin;
var init_collectRenderablesMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/collectRenderablesMixin.mjs"() {
    "use strict";
    init_define_AnParams();
    collectRenderablesMixin = {
      /**
       * Main method to collect renderables from the container and its children.
       * It checks the container's properties to decide whether to use a simple or advanced collection method.
       * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.
       * @param {Renderer} renderer - The renderer responsible for rendering the scene.
       * @param {IRenderLayer} currentLayer - The current render layer being processed.
       * @memberof scene.Container#
       */
      collectRenderables(instructionSet, renderer, currentLayer) {
        if (this.parentRenderLayer && this.parentRenderLayer !== currentLayer || this.globalDisplayStatus < 7 || !this.includeInBuild)
          return;
        if (this.sortableChildren) {
          this.sortChildren();
        }
        if (this.isSimple) {
          this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
        } else if (this.renderGroup) {
          renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);
        } else {
          this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);
        }
      },
      /**
       * Simple method for collecting renderables from the container's children.
       * This method is efficient and used when the container is marked as simple.
       * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.
       * @param {Renderer} renderer - The renderer responsible for rendering the scene.
       * @param {IRenderLayer} currentLayer - The current render layer being processed.
       * @memberof scene.Container#
       */
      collectRenderablesSimple(instructionSet, renderer, currentLayer) {
        const children = this.children;
        const length = children.length;
        for (let i3 = 0; i3 < length; i3++) {
          children[i3].collectRenderables(instructionSet, renderer, currentLayer);
        }
      },
      /**
       * Advanced method for collecting renderables, which handles additional effects.
       * This method is used when the container has complex processing needs.
       * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.
       * @param {Renderer} renderer - The renderer responsible for rendering the scene.
       * @param {IRenderLayer} currentLayer - The current render layer being processed.
       * @memberof scene.Container#
       */
      collectRenderablesWithEffects(instructionSet, renderer, currentLayer) {
        const { renderPipes: renderPipes3 } = renderer;
        for (let i3 = 0; i3 < this.effects.length; i3++) {
          const effect = this.effects[i3];
          const pipe = renderPipes3[effect.pipe];
          pipe.push(effect, this, instructionSet);
        }
        this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
        for (let i3 = this.effects.length - 1; i3 >= 0; i3--) {
          const effect = this.effects[i3];
          const pipe = renderPipes3[effect.pipe];
          pipe.pop(effect, this, instructionSet);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/filters/FilterEffect.mjs
var FilterEffect;
var init_FilterEffect = __esm({
  "node_modules/pixi.js/lib/filters/FilterEffect.mjs"() {
    "use strict";
    init_define_AnParams();
    FilterEffect = class {
      constructor() {
        this.pipe = "filter";
        this.priority = 1;
      }
      destroy() {
        for (let i3 = 0; i3 < this.filters.length; i3++) {
          this.filters[i3].destroy();
        }
        this.filters = null;
        this.filterArea = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs
var MaskEffectManagerClass, MaskEffectManager;
var init_MaskEffectManager = __esm({
  "node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_PoolGroup();
    MaskEffectManagerClass = class {
      constructor() {
        this._effectClasses = [];
        this._tests = [];
        this._initialized = false;
      }
      init() {
        if (this._initialized)
          return;
        this._initialized = true;
        this._effectClasses.forEach((test) => {
          this.add({
            test: test.test,
            maskClass: test
          });
        });
      }
      add(test) {
        this._tests.push(test);
      }
      getMaskEffect(item) {
        if (!this._initialized)
          this.init();
        for (let i3 = 0; i3 < this._tests.length; i3++) {
          const test = this._tests[i3];
          if (test.test(item)) {
            return BigPool.get(test.maskClass, item);
          }
        }
        return item;
      }
      returnMaskEffect(effect) {
        BigPool.return(effect);
      }
    };
    MaskEffectManager = new MaskEffectManagerClass();
    extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs
var effectsMixin;
var init_effectsMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs"() {
    init_define_AnParams();
    init_FilterEffect();
    init_MaskEffectManager();
    effectsMixin = {
      _maskEffect: null,
      _maskOptions: {
        inverse: false
      },
      _filterEffect: null,
      /**
       * @todo Needs docs.
       * @memberof scene.Container#
       * @type {Array<Effect>}
       */
      effects: [],
      _markStructureAsChanged() {
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.structureDidChange = true;
        }
      },
      /**
       * @todo Needs docs.
       * @param effect - The effect to add.
       * @memberof scene.Container#
       * @ignore
       */
      addEffect(effect) {
        const index = this.effects.indexOf(effect);
        if (index !== -1)
          return;
        this.effects.push(effect);
        this.effects.sort((a2, b3) => a2.priority - b3.priority);
        this._markStructureAsChanged();
        this._updateIsSimple();
      },
      /**
       * @todo Needs docs.
       * @param effect - The effect to remove.
       * @memberof scene.Container#
       * @ignore
       */
      removeEffect(effect) {
        const index = this.effects.indexOf(effect);
        if (index === -1)
          return;
        this.effects.splice(index, 1);
        this._markStructureAsChanged();
        this._updateIsSimple();
      },
      set mask(value) {
        const effect = this._maskEffect;
        if (effect?.mask === value)
          return;
        if (effect) {
          this.removeEffect(effect);
          MaskEffectManager.returnMaskEffect(effect);
          this._maskEffect = null;
        }
        if (value === null || value === void 0)
          return;
        this._maskEffect = MaskEffectManager.getMaskEffect(value);
        this.addEffect(this._maskEffect);
      },
      /**
       * Used to set mask and control mask options.
       * @param options
       * @example
       * import { Graphics, Sprite } from 'pixi.js';
       *
       * const graphics = new Graphics();
       * graphics.beginFill(0xFF3300);
       * graphics.drawRect(50, 250, 100, 100);
       * graphics.endFill();
       *
       * const sprite = new Sprite(texture);
       * sprite.setMask({
       *     mask: graphics,
       *     inverse: true,
       * });
       * @memberof scene.Container#
       */
      setMask(options) {
        this._maskOptions = {
          ...this._maskOptions,
          ...options
        };
        if (options.mask) {
          this.mask = options.mask;
        }
        this._markStructureAsChanged();
      },
      /**
       * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
       * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
       * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it
       * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
       * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
       * To remove a mask, set this property to `null`.
       *
       * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
       * @example
       * import { Graphics, Sprite } from 'pixi.js';
       *
       * const graphics = new Graphics();
       * graphics.beginFill(0xFF3300);
       * graphics.drawRect(50, 250, 100, 100);
       * graphics.endFill();
       *
       * const sprite = new Sprite(texture);
       * sprite.mask = graphics;
       * @memberof scene.Container#
       */
      get mask() {
        return this._maskEffect?.mask;
      },
      set filters(value) {
        if (!Array.isArray(value) && value)
          value = [value];
        const effect = this._filterEffect || (this._filterEffect = new FilterEffect());
        value = value;
        const hasFilters = value?.length > 0;
        const hadFilters = effect.filters?.length > 0;
        const didChange = hasFilters !== hadFilters;
        value = Array.isArray(value) ? value.slice(0) : value;
        effect.filters = Object.freeze(value);
        if (didChange) {
          if (hasFilters) {
            this.addEffect(effect);
          } else {
            this.removeEffect(effect);
            effect.filters = value ?? null;
          }
        }
      },
      /**
       * Sets the filters for the displayObject.
       * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
       * To remove filters simply set this property to `'null'`.
       * @memberof scene.Container#
       */
      get filters() {
        return this._filterEffect?.filters;
      },
      set filterArea(value) {
        this._filterEffect || (this._filterEffect = new FilterEffect());
        this._filterEffect.filterArea = value;
      },
      /**
       * The area the filter is applied to. This is used as more of an optimization
       * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
       *
       * Also works as an interaction mask.
       * @memberof scene.Container#
       */
      get filterArea() {
        return this._filterEffect?.filterArea;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs
var findMixin;
var init_findMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs"() {
    init_define_AnParams();
    init_deprecation();
    findMixin = {
      /**
       * The instance label of the object.
       * @memberof scene.Container#
       * @member {string} label
       */
      label: null,
      /**
       * The instance name of the object.
       * @deprecated since 8.0.0
       * @see scene.Container#label
       * @member {string} name
       * @memberof scene.Container#
       */
      get name() {
        deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
        return this.label;
      },
      set name(value) {
        deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
        this.label = value;
      },
      /**
       * @method getChildByName
       * @deprecated since 8.0.0
       * @param {string} name - Instance name.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @returns {Container} The child with the specified name.
       * @see scene.Container#getChildByLabel
       * @memberof scene.Container#
       */
      getChildByName(name, deep = false) {
        return this.getChildByLabel(name, deep);
      },
      /**
       * Returns the first child in the container with the specified label.
       *
       * Recursive searches are done in a pre-order traversal.
       * @memberof scene.Container#
       * @param {string|RegExp} label - Instance label.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @returns {Container} The child with the specified label.
       */
      getChildByLabel(label, deep = false) {
        const children = this.children;
        for (let i3 = 0; i3 < children.length; i3++) {
          const child = children[i3];
          if (child.label === label || label instanceof RegExp && label.test(child.label))
            return child;
        }
        if (deep) {
          for (let i3 = 0; i3 < children.length; i3++) {
            const child = children[i3];
            const found = child.getChildByLabel(label, true);
            if (found) {
              return found;
            }
          }
        }
        return null;
      },
      /**
       * Returns all children in the container with the specified label.
       * @memberof scene.Container#
       * @param {string|RegExp} label - Instance label.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @param {Container[]} [out=[]] - The array to store matching children in.
       * @returns {Container[]} An array of children with the specified label.
       */
      getChildrenByLabel(label, deep = false, out2 = []) {
        const children = this.children;
        for (let i3 = 0; i3 < children.length; i3++) {
          const child = children[i3];
          if (child.label === label || label instanceof RegExp && label.test(child.label)) {
            out2.push(child);
          }
        }
        if (deep) {
          for (let i3 = 0; i3 < children.length; i3++) {
            children[i3].getChildrenByLabel(label, true, out2);
          }
        }
        return out2;
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs
var tempPoints, Rectangle;
var init_Rectangle = __esm({
  "node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"() {
    init_define_AnParams();
    init_Point();
    tempPoints = [new Point(), new Point(), new Point(), new Point()];
    Rectangle = class _Rectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rectangle
       * @param y - The Y coordinate of the upper-left corner of the rectangle
       * @param width - The overall width of the rectangle
       * @param height - The overall height of the rectangle
       */
      constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
        this.type = "rectangle";
        this.x = Number(x2);
        this.y = Number(y2);
        this.width = Number(width);
        this.height = Number(height);
      }
      /** Returns the left edge of the rectangle. */
      get left() {
        return this.x;
      }
      /** Returns the right edge of the rectangle. */
      get right() {
        return this.x + this.width;
      }
      /** Returns the top edge of the rectangle. */
      get top() {
        return this.y;
      }
      /** Returns the bottom edge of the rectangle. */
      get bottom() {
        return this.y + this.height;
      }
      /** Determines whether the Rectangle is empty. */
      isEmpty() {
        return this.left === this.right || this.top === this.bottom;
      }
      /** A constant empty rectangle. This is a new object every time the property is accessed */
      static get EMPTY() {
        return new _Rectangle(0, 0, 0, 0);
      }
      /**
       * Creates a clone of this Rectangle
       * @returns a copy of the rectangle
       */
      clone() {
        return new _Rectangle(this.x, this.y, this.width, this.height);
      }
      /**
       * Converts a Bounds object to a Rectangle object.
       * @param bounds - The bounds to copy and convert to a rectangle.
       * @returns Returns itself.
       */
      copyFromBounds(bounds) {
        this.x = bounds.minX;
        this.y = bounds.minY;
        this.width = bounds.maxX - bounds.minX;
        this.height = bounds.maxY - bounds.minY;
        return this;
      }
      /**
       * Copies another rectangle to this one.
       * @param rectangle - The rectangle to copy from.
       * @returns Returns itself.
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @param rectangle - The rectangle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rectangle
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Rectangle
       */
      contains(x2, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x2 >= this.x && x2 < this.x + this.width) {
          if (y2 >= this.y && y2 < this.y + this.height) {
            return true;
          }
        }
        return false;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @param strokeWidth - The width of the line to check
       * @param alignment - The alignment of the stroke, 0.5 by default
       * @returns Whether the x/y coordinates are within this rectangle
       */
      strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
        const { width, height } = this;
        if (width <= 0 || height <= 0)
          return false;
        const _x = this.x;
        const _y = this.y;
        const strokeWidthOuter = strokeWidth * (1 - alignment);
        const strokeWidthInner = strokeWidth - strokeWidthOuter;
        const outerLeft = _x - strokeWidthOuter;
        const outerRight = _x + width + strokeWidthOuter;
        const outerTop = _y - strokeWidthOuter;
        const outerBottom = _y + height + strokeWidthOuter;
        const innerLeft = _x + strokeWidthInner;
        const innerRight = _x + width - strokeWidthInner;
        const innerTop = _y + strokeWidthInner;
        const innerBottom = _y + height - strokeWidthInner;
        return x2 >= outerLeft && x2 <= outerRight && y2 >= outerTop && y2 <= outerBottom && !(x2 > innerLeft && x2 < innerRight && y2 > innerTop && y2 < innerBottom);
      }
      /**
       * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
       * Returns true only if the area of the intersection is >0, this means that Rectangles
       * sharing a side are not overlapping. Another side effect is that an arealess rectangle
       * (width or height equal to zero) can't intersect any other rectangle.
       * @param {Rectangle} other - The Rectangle to intersect with `this`.
       * @param {Matrix} transform - The transformation matrix of `other`.
       * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
       */
      intersects(other, transform2) {
        if (!transform2) {
          const x02 = this.x < other.x ? other.x : this.x;
          const x12 = this.right > other.right ? other.right : this.right;
          if (x12 <= x02) {
            return false;
          }
          const y02 = this.y < other.y ? other.y : this.y;
          const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
          return y12 > y02;
        }
        const x0 = this.left;
        const x1 = this.right;
        const y0 = this.top;
        const y1 = this.bottom;
        if (x1 <= x0 || y1 <= y0) {
          return false;
        }
        const lt = tempPoints[0].set(other.left, other.top);
        const lb = tempPoints[1].set(other.left, other.bottom);
        const rt = tempPoints[2].set(other.right, other.top);
        const rb = tempPoints[3].set(other.right, other.bottom);
        if (rt.x <= lt.x || lb.y <= lt.y) {
          return false;
        }
        const s2 = Math.sign(transform2.a * transform2.d - transform2.b * transform2.c);
        if (s2 === 0) {
          return false;
        }
        transform2.apply(lt, lt);
        transform2.apply(lb, lb);
        transform2.apply(rt, rt);
        transform2.apply(rb, rb);
        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
          return false;
        }
        const nx = s2 * (lb.y - lt.y);
        const ny = s2 * (lt.x - lb.x);
        const n00 = nx * x0 + ny * y0;
        const n10 = nx * x1 + ny * y0;
        const n01 = nx * x0 + ny * y1;
        const n11 = nx * x1 + ny * y1;
        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
          return false;
        }
        const mx = s2 * (lt.y - rt.y);
        const my = s2 * (rt.x - lt.x);
        const m00 = mx * x0 + my * y0;
        const m10 = mx * x1 + my * y0;
        const m01 = mx * x0 + my * y1;
        const m11 = mx * x1 + my * y1;
        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
          return false;
        }
        return true;
      }
      /**
       * Pads the rectangle making it grow in all directions.
       * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
       * @param paddingX - The horizontal padding amount.
       * @param paddingY - The vertical padding amount.
       * @returns Returns itself.
       */
      pad(paddingX = 0, paddingY = paddingX) {
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
        return this;
      }
      /**
       * Fits this rectangle around the passed one.
       * @param rectangle - The rectangle to fit.
       * @returns Returns itself.
       */
      fit(rectangle) {
        const x1 = Math.max(this.x, rectangle.x);
        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.max(this.y, rectangle.y);
        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x2 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
        return this;
      }
      /**
       * Enlarges rectangle that way its corners lie on grid
       * @param resolution - resolution
       * @param eps - precision
       * @returns Returns itself.
       */
      ceil(resolution = 1, eps = 1e-3) {
        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x2 - this.x;
        this.height = y2 - this.y;
        return this;
      }
      /**
       * Enlarges this rectangle to include the passed rectangle.
       * @param rectangle - The rectangle to include.
       * @returns Returns itself.
       */
      enlarge(rectangle) {
        const x1 = Math.min(this.x, rectangle.x);
        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.min(this.y, rectangle.y);
        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x2 - x1;
        this.y = y1;
        this.height = y2 - y1;
        return this;
      }
      /**
       * Returns the framing rectangle of the rectangle as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 || (out2 = new _Rectangle());
        out2.copyFrom(this);
        return out2;
      }
      /**
       * Checks if this rectangle fully contains another rectangle.
       *
       * A rectangle contains another rectangle if all four corners of the other rectangle
       * lie within the bounds of this rectangle.
       *
       * ```ts
       * const container = new Rectangle(0, 0, 100, 100);
       * const inside = new Rectangle(25, 25, 50, 50);
       * const partial = new Rectangle(75, 75, 50, 50);
       *
       * container.containsRect(inside); // Returns true
       * container.containsRect(partial); // Returns false - partial overlap
       * ```
       *
       * Note: If either rectangle has a width or height of 0, this method returns false
       * since a zero-area rectangle cannot meaningfully contain another rectangle.
       * @param other - The rectangle to check if it is contained within this one
       * @returns True if the other rectangle is fully contained within this one
       */
      containsRect(other) {
        if (this.width <= 0 || this.height <= 0)
          return false;
        const x1 = other.x;
        const y1 = other.y;
        const x2 = other.x + other.width;
        const y2 = other.y + other.height;
        return x1 >= this.x && x1 < this.x + this.width && y1 >= this.y && y1 < this.y + this.height && x2 >= this.x && x2 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;
      }
      toString() {
        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs
var defaultMatrix, Bounds;
var init_Bounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_Rectangle();
    defaultMatrix = new Matrix();
    Bounds = class _Bounds {
      constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.matrix = defaultMatrix;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      /**
       * Checks if bounds are empty.
       * @returns - True if empty.
       */
      isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY;
      }
      /** The bounding rectangle of the bounds. */
      get rectangle() {
        if (!this._rectangle) {
          this._rectangle = new Rectangle();
        }
        const rectangle = this._rectangle;
        if (this.minX > this.maxX || this.minY > this.maxY) {
          rectangle.x = 0;
          rectangle.y = 0;
          rectangle.width = 0;
          rectangle.height = 0;
        } else {
          rectangle.copyFromBounds(this);
        }
        return rectangle;
      }
      /** Clears the bounds and resets. */
      clear() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.matrix = defaultMatrix;
        return this;
      }
      /**
       * Sets the bounds.
       * @param x0 - left X of frame
       * @param y0 - top Y of frame
       * @param x1 - right X of frame
       * @param y1 - bottom Y of frame
       */
      set(x0, y0, x1, y1) {
        this.minX = x0;
        this.minY = y0;
        this.maxX = x1;
        this.maxY = y1;
      }
      /**
       * Adds sprite frame
       * @param x0 - left X of frame
       * @param y0 - top Y of frame
       * @param x1 - right X of frame
       * @param y1 - bottom Y of frame
       * @param matrix
       */
      addFrame(x0, y0, x1, y1, matrix) {
        matrix || (matrix = this.matrix);
        const a2 = matrix.a;
        const b3 = matrix.b;
        const c2 = matrix.c;
        const d2 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        let x2 = a2 * x0 + c2 * y0 + tx;
        let y2 = b3 * x0 + d2 * y0 + ty;
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
        x2 = a2 * x1 + c2 * y0 + tx;
        y2 = b3 * x1 + d2 * y0 + ty;
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
        x2 = a2 * x0 + c2 * y1 + tx;
        y2 = b3 * x0 + d2 * y1 + ty;
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
        x2 = a2 * x1 + c2 * y1 + tx;
        y2 = b3 * x1 + d2 * y1 + ty;
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      /**
       * Adds a rectangle to the bounds.
       * @param rect - The rectangle to be added.
       * @param matrix - The matrix to apply to the bounds.
       */
      addRect(rect, matrix) {
        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
      }
      /**
       * Adds other {@link Bounds}.
       * @param bounds - The Bounds to be added
       * @param matrix
       */
      addBounds(bounds, matrix) {
        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
      }
      /**
       * Adds other Bounds, masked with Bounds.
       * @param mask - The Bounds to be added.
       */
      addBoundsMask(mask) {
        this.minX = this.minX > mask.minX ? this.minX : mask.minX;
        this.minY = this.minY > mask.minY ? this.minY : mask.minY;
        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
      }
      /**
       * Adds other Bounds, multiplied with matrix.
       * @param matrix - The matrix to apply to the bounds.
       */
      applyMatrix(matrix) {
        const minX = this.minX;
        const minY = this.minY;
        const maxX = this.maxX;
        const maxY = this.maxY;
        const { a: a2, b: b3, c: c2, d: d2, tx, ty } = matrix;
        let x2 = a2 * minX + c2 * minY + tx;
        let y2 = b3 * minX + d2 * minY + ty;
        this.minX = x2;
        this.minY = y2;
        this.maxX = x2;
        this.maxY = y2;
        x2 = a2 * maxX + c2 * minY + tx;
        y2 = b3 * maxX + d2 * minY + ty;
        this.minX = x2 < this.minX ? x2 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x2 > this.maxX ? x2 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
        x2 = a2 * minX + c2 * maxY + tx;
        y2 = b3 * minX + d2 * maxY + ty;
        this.minX = x2 < this.minX ? x2 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x2 > this.maxX ? x2 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
        x2 = a2 * maxX + c2 * maxY + tx;
        y2 = b3 * maxX + d2 * maxY + ty;
        this.minX = x2 < this.minX ? x2 : this.minX;
        this.minY = y2 < this.minY ? y2 : this.minY;
        this.maxX = x2 > this.maxX ? x2 : this.maxX;
        this.maxY = y2 > this.maxY ? y2 : this.maxY;
      }
      /**
       * Resizes the bounds object to include the given rectangle.
       * @param rect - The rectangle to be included.
       */
      fit(rect) {
        if (this.minX < rect.left)
          this.minX = rect.left;
        if (this.maxX > rect.right)
          this.maxX = rect.right;
        if (this.minY < rect.top)
          this.minY = rect.top;
        if (this.maxY > rect.bottom)
          this.maxY = rect.bottom;
        return this;
      }
      /**
       * Resizes the bounds object to include the given bounds.
       * @param left - The left value of the bounds.
       * @param right - The right value of the bounds.
       * @param top - The top value of the bounds.
       * @param bottom - The bottom value of the bounds.
       */
      fitBounds(left, right, top, bottom) {
        if (this.minX < left)
          this.minX = left;
        if (this.maxX > right)
          this.maxX = right;
        if (this.minY < top)
          this.minY = top;
        if (this.maxY > bottom)
          this.maxY = bottom;
        return this;
      }
      /**
       * Pads bounds object, making it grow in all directions.
       * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
       * @param paddingX - The horizontal padding amount.
       * @param paddingY - The vertical padding amount.
       */
      pad(paddingX, paddingY = paddingX) {
        this.minX -= paddingX;
        this.maxX += paddingX;
        this.minY -= paddingY;
        this.maxY += paddingY;
        return this;
      }
      /** Ceils the bounds. */
      ceil() {
        this.minX = Math.floor(this.minX);
        this.minY = Math.floor(this.minY);
        this.maxX = Math.ceil(this.maxX);
        this.maxY = Math.ceil(this.maxY);
        return this;
      }
      /** Clones the bounds. */
      clone() {
        return new _Bounds(this.minX, this.minY, this.maxX, this.maxY);
      }
      /**
       * Scales the bounds by the given values
       * @param x - The X value to scale by.
       * @param y - The Y value to scale by.
       */
      scale(x2, y2 = x2) {
        this.minX *= x2;
        this.minY *= y2;
        this.maxX *= x2;
        this.maxY *= y2;
        return this;
      }
      /** the x value of the bounds. */
      get x() {
        return this.minX;
      }
      set x(value) {
        const width = this.maxX - this.minX;
        this.minX = value;
        this.maxX = value + width;
      }
      /** the y value of the bounds. */
      get y() {
        return this.minY;
      }
      set y(value) {
        const height = this.maxY - this.minY;
        this.minY = value;
        this.maxY = value + height;
      }
      /** the width value of the bounds. */
      get width() {
        return this.maxX - this.minX;
      }
      set width(value) {
        this.maxX = this.minX + value;
      }
      /** the height value of the bounds. */
      get height() {
        return this.maxY - this.minY;
      }
      set height(value) {
        this.maxY = this.minY + value;
      }
      /** the left value of the bounds. */
      get left() {
        return this.minX;
      }
      /** the right value of the bounds. */
      get right() {
        return this.maxX;
      }
      /** the top value of the bounds. */
      get top() {
        return this.minY;
      }
      /** the bottom value of the bounds. */
      get bottom() {
        return this.maxY;
      }
      /** Is the bounds positive. */
      get isPositive() {
        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
      }
      get isValid() {
        return this.minX + this.minY !== Infinity;
      }
      /**
       * Adds screen vertices from array
       * @param vertexData - calculated vertices
       * @param beginOffset - begin offset
       * @param endOffset - end offset, excluded
       * @param matrix
       */
      addVertexData(vertexData, beginOffset, endOffset, matrix) {
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        matrix || (matrix = this.matrix);
        const a2 = matrix.a;
        const b3 = matrix.b;
        const c2 = matrix.c;
        const d2 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        for (let i3 = beginOffset; i3 < endOffset; i3 += 2) {
          const localX = vertexData[i3];
          const localY = vertexData[i3 + 1];
          const x2 = a2 * localX + c2 * localY + tx;
          const y2 = b3 * localX + d2 * localY + ty;
          minX = x2 < minX ? x2 : minX;
          minY = y2 < minY ? y2 : minY;
          maxX = x2 > maxX ? x2 : maxX;
          maxY = y2 > maxY ? y2 : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      /**
       * Checks if the point is contained within the bounds.
       * @param x - x coordinate
       * @param y - y coordinate
       */
      containsPoint(x2, y2) {
        if (this.minX <= x2 && this.minY <= y2 && this.maxX >= x2 && this.maxY >= y2) {
          return true;
        }
        return false;
      }
      toString() {
        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
      }
      /**
       * Copies the bounds from another bounds object.
       * @param bounds - The bounds to copy from.
       * @returns - This bounds object.
       */
      copyFrom(bounds) {
        this.minX = bounds.minX;
        this.minY = bounds.minY;
        this.maxX = bounds.maxX;
        this.maxY = bounds.maxY;
        return this;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs
var matrixPool, boundsPool;
var init_matrixAndBoundsPool = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_Pool();
    init_Bounds();
    matrixPool = new Pool(Matrix);
    boundsPool = new Pool(Bounds);
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs
var tempMatrix2, getFastGlobalBoundsMixin;
var init_getFastGlobalBoundsMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/getFastGlobalBoundsMixin.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_Bounds();
    init_matrixAndBoundsPool();
    tempMatrix2 = new Matrix();
    getFastGlobalBoundsMixin = {
      /**
       * Computes the global bounds for the container, considering its children and optionally
       * factoring in render layers. It starts by clearing the provided bounds object, then
       * recursively calculates the bounds, and finally applies the world transformation.
       * @param {boolean} [factorRenderLayers] - Whether to consider render layers in the calculation.
       * @param {Bounds} [bounds] - The bounds object to store the result. If not provided, a new one is created.
       * @returns {Bounds} The computed bounds.
       * @memberof scene.Container#
       */
      getFastGlobalBounds(factorRenderLayers, bounds) {
        bounds || (bounds = new Bounds());
        bounds.clear();
        this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);
        if (!bounds.isValid) {
          bounds.set(0, 0, 0, 0);
        }
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        bounds.applyMatrix(renderGroup.worldTransform);
        return bounds;
      },
      /**
       * Recursively calculates the global bounds for the container and its children.
       * It considers visibility, measurability, and effects, and applies transformations
       * as necessary to compute the bounds accurately.
       * @param {boolean} factorRenderLayers - Whether to consider render layers in the calculation.
       * @param {Bounds} bounds - The bounds object to update with the calculated values.
       * @param {IRenderLayer} currentLayer - The current render layer being processed.
       * @memberof scene.Container#
       */
      _getGlobalBoundsRecursive(factorRenderLayers, bounds, currentLayer) {
        let localBounds = bounds;
        if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer)
          return;
        if (this.localDisplayStatus !== 7 || !this.measurable) {
          return;
        }
        const manageEffects = !!this.effects.length;
        if (this.renderGroup || manageEffects) {
          localBounds = boundsPool.get().clear();
        }
        if (this.boundsArea) {
          bounds.addRect(this.boundsArea, this.worldTransform);
        } else {
          if (this.renderPipeId) {
            const viewBounds = this.bounds;
            localBounds.addFrame(
              viewBounds.minX,
              viewBounds.minY,
              viewBounds.maxX,
              viewBounds.maxY,
              this.groupTransform
            );
          }
          const children = this.children;
          for (let i3 = 0; i3 < children.length; i3++) {
            children[i3]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);
          }
        }
        if (manageEffects) {
          let advanced = false;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          for (let i3 = 0; i3 < this.effects.length; i3++) {
            if (this.effects[i3].addBounds) {
              if (!advanced) {
                advanced = true;
                localBounds.applyMatrix(renderGroup.worldTransform);
              }
              this.effects[i3].addBounds(localBounds, true);
            }
          }
          if (advanced) {
            localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix2).invert());
            bounds.addBounds(localBounds, this.relativeGroupTransform);
          }
          bounds.addBounds(localBounds);
          boundsPool.return(localBounds);
        } else if (this.renderGroup) {
          bounds.addBounds(localBounds, this.relativeGroupTransform);
          boundsPool.return(localBounds);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs
function getGlobalBounds(target, skipUpdateTransform, bounds) {
  bounds.clear();
  let parentTransform;
  let pooledMatrix;
  if (target.parent) {
    if (!skipUpdateTransform) {
      pooledMatrix = matrixPool.get().identity();
      parentTransform = updateTransformBackwards(target, pooledMatrix);
    } else {
      parentTransform = target.parent.worldTransform;
    }
  } else {
    parentTransform = Matrix.IDENTITY;
  }
  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
  if (pooledMatrix) {
    matrixPool.return(pooledMatrix);
  }
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
  if (!target.visible || !target.measurable)
    return;
  let worldTransform;
  if (!skipUpdateTransform) {
    target.updateLocalTransform();
    worldTransform = matrixPool.get();
    worldTransform.appendFrom(target.localTransform, parentTransform);
  } else {
    worldTransform = target.worldTransform;
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, worldTransform);
  } else {
    if (target.bounds) {
      bounds.matrix = worldTransform;
      bounds.addBounds(target.bounds);
    }
    for (let i3 = 0; i3 < target.children.length; i3++) {
      _getGlobalBounds(target.children[i3], bounds, worldTransform, skipUpdateTransform);
    }
  }
  if (preserveBounds) {
    for (let i3 = 0; i3 < target.effects.length; i3++) {
      target.effects[i3].addBounds?.(bounds);
    }
    parentBounds.addBounds(bounds, Matrix.IDENTITY);
    boundsPool.return(bounds);
  }
  if (!skipUpdateTransform) {
    matrixPool.return(worldTransform);
  }
}
function updateTransformBackwards(target, parentTransform) {
  const parent2 = target.parent;
  if (parent2) {
    updateTransformBackwards(parent2, parentTransform);
    parent2.updateLocalTransform();
    parentTransform.append(parent2.localTransform);
  }
  return parentTransform;
}
var init_getGlobalBounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_matrixAndBoundsPool();
  }
});

// node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs
function multiplyHexColors(color1, color2) {
  if (color1 === 16777215 || !color2)
    return color2;
  if (color2 === 16777215 || !color1)
    return color1;
  const r1 = color1 >> 16 & 255;
  const g1 = color1 >> 8 & 255;
  const b1 = color1 & 255;
  const r2 = color2 >> 16 & 255;
  const g2 = color2 >> 8 & 255;
  const b22 = color2 & 255;
  const r3 = r1 * r2 / 255 | 0;
  const g3 = g1 * g2 / 255 | 0;
  const b3 = b1 * b22 / 255 | 0;
  return (r3 << 16) + (g3 << 8) + b3;
}
var init_multiplyHexColors = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs
function multiplyColors(localBGRColor, parentBGRColor) {
  if (localBGRColor === WHITE_BGR) {
    return parentBGRColor;
  }
  if (parentBGRColor === WHITE_BGR) {
    return localBGRColor;
  }
  return multiplyHexColors(localBGRColor, parentBGRColor);
}
var WHITE_BGR;
var init_multiplyColors = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs"() {
    init_define_AnParams();
    init_multiplyHexColors();
    WHITE_BGR = 16777215;
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs
function bgr2rgb(color) {
  return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);
}
var getGlobalMixin;
var init_getGlobalMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs"() {
    init_define_AnParams();
    init_getGlobalBounds();
    init_matrixAndBoundsPool();
    init_multiplyColors();
    getGlobalMixin = {
      /**
       * Returns the global (compound) alpha of the container within the scene.
       * @param skipUpdate - Performance optimization flag:
       *   - If false (default): Recalculates the entire alpha chain through parents for accuracy
       *   - If true: Uses cached worldAlpha from the last render pass for better performance
       * @returns The resulting alpha value (between 0 and 1)
       * @example
       * // Accurate but slower - recalculates entire alpha chain
       * const preciseAlpha = container.getGlobalAlpha();
       *
       * // Faster but may be outdated - uses cached alpha
       * const cachedAlpha = container.getGlobalAlpha(true);
       */
      getGlobalAlpha(skipUpdate) {
        if (skipUpdate) {
          if (this.renderGroup) {
            return this.renderGroup.worldAlpha;
          }
          if (this.parentRenderGroup) {
            return this.parentRenderGroup.worldAlpha * this.alpha;
          }
          return this.alpha;
        }
        let alpha = this.alpha;
        let current = this.parent;
        while (current) {
          alpha *= current.alpha;
          current = current.parent;
        }
        return alpha;
      },
      /**
       * Returns the global transform matrix of the container within the scene.
       * @param matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.
       * @param skipUpdate - Performance optimization flag:
       *   - If false (default): Recalculates the entire transform chain for accuracy
       *   - If true: Uses cached worldTransform from the last render pass for better performance
       * @returns The resulting transformation matrix (either the input matrix or a new one)
       * @example
       * // Accurate but slower - recalculates entire transform chain
       * const preciseTransform = container.getGlobalTransform();
       *
       * // Faster but may be outdated - uses cached transform
       * const cachedTransform = container.getGlobalTransform(undefined, true);
       *
       * // Reuse existing matrix
       * const existingMatrix = new Matrix();
       * container.getGlobalTransform(existingMatrix);
       */
      getGlobalTransform(matrix, skipUpdate) {
        if (skipUpdate) {
          return matrix.copyFrom(this.worldTransform);
        }
        this.updateLocalTransform();
        const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());
        matrix.appendFrom(this.localTransform, parentTransform);
        matrixPool.return(parentTransform);
        return matrix;
      },
      /**
       * Returns the global (compound) tint color of the container within the scene.
       * @param skipUpdate - Performance optimization flag:
       *   - If false (default): Recalculates the entire tint chain through parents for accuracy
       *   - If true: Uses cached worldColor from the last render pass for better performance
       * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)
       * @example
       * // Accurate but slower - recalculates entire tint chain
       * const preciseTint = container.getGlobalTint();
       *
       * // Faster but may be outdated - uses cached tint
       * const cachedTint = container.getGlobalTint(true);
       */
      getGlobalTint(skipUpdate) {
        if (skipUpdate) {
          if (this.renderGroup) {
            return bgr2rgb(this.renderGroup.worldColor);
          }
          if (this.parentRenderGroup) {
            return bgr2rgb(
              multiplyColors(this.localColor, this.parentRenderGroup.worldColor)
            );
          }
          return this.tint;
        }
        let color = this.localColor;
        let parent2 = this.parent;
        while (parent2) {
          color = multiplyColors(color, parent2.localColor);
          parent2 = parent2.parent;
        }
        return bgr2rgb(color);
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/logging/warn.mjs
function warn(...args) {
  if (warnCount === maxWarnings)
    return;
  warnCount++;
  if (warnCount === maxWarnings) {
    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
  } else {
    console.warn("PixiJS Warning: ", ...args);
  }
}
var warnCount, maxWarnings;
var init_warn = __esm({
  "node_modules/pixi.js/lib/utils/logging/warn.mjs"() {
    "use strict";
    init_define_AnParams();
    warnCount = 0;
    maxWarnings = 500;
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs
function getLocalBounds(target, bounds, relativeMatrix) {
  bounds.clear();
  relativeMatrix || (relativeMatrix = Matrix.IDENTITY);
  _getLocalBounds(target, bounds, relativeMatrix, target, true);
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
  let relativeTransform;
  if (!isRoot) {
    if (!target.visible || !target.measurable)
      return;
    target.updateLocalTransform();
    const localTransform = target.localTransform;
    relativeTransform = matrixPool.get();
    relativeTransform.appendFrom(localTransform, parentTransform);
  } else {
    relativeTransform = matrixPool.get();
    relativeTransform = parentTransform.copyTo(relativeTransform);
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, relativeTransform);
  } else {
    if (target.renderPipeId) {
      bounds.matrix = relativeTransform;
      bounds.addBounds(target.bounds);
    }
    const children = target.children;
    for (let i3 = 0; i3 < children.length; i3++) {
      _getLocalBounds(children[i3], bounds, relativeTransform, rootContainer, false);
    }
  }
  if (preserveBounds) {
    for (let i3 = 0; i3 < target.effects.length; i3++) {
      target.effects[i3].addLocalBounds?.(bounds, rootContainer);
    }
    parentBounds.addBounds(bounds, Matrix.IDENTITY);
    boundsPool.return(bounds);
  }
  matrixPool.return(relativeTransform);
}
function getParent(target, root, matrix) {
  const parent2 = target.parent;
  if (!parent2) {
    warn("Item is not inside the root container");
    return;
  }
  if (parent2 !== root) {
    getParent(parent2, root, matrix);
    parent2.updateLocalTransform();
    matrix.append(parent2.localTransform);
  }
}
var init_getLocalBounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_warn();
    init_matrixAndBoundsPool();
  }
});

// node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs
function checkChildrenDidChange(container, previousData) {
  const children = container.children;
  for (let i3 = 0; i3 < children.length; i3++) {
    const child = children[i3];
    const uid3 = child.uid;
    const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
    const index = previousData.index;
    if (previousData.data[index] !== uid3 || previousData.data[index + 1] !== didChange) {
      previousData.data[previousData.index] = uid3;
      previousData.data[previousData.index + 1] = didChange;
      previousData.didChange = true;
    }
    previousData.index = index + 2;
    if (child.children.length) {
      checkChildrenDidChange(child, previousData);
    }
  }
  return previousData.didChange;
}
var init_checkChildrenDidChange = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs
var tempMatrix3, measureMixin;
var init_measureMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_Bounds();
    init_getGlobalBounds();
    init_getLocalBounds();
    init_checkChildrenDidChange();
    tempMatrix3 = new Matrix();
    measureMixin = {
      _localBoundsCacheId: -1,
      _localBoundsCacheData: null,
      _setWidth(value, localWidth) {
        const sign = Math.sign(this.scale.x) || 1;
        if (localWidth !== 0) {
          this.scale.x = value / localWidth * sign;
        } else {
          this.scale.x = sign;
        }
      },
      _setHeight(value, localHeight) {
        const sign = Math.sign(this.scale.y) || 1;
        if (localHeight !== 0) {
          this.scale.y = value / localHeight * sign;
        } else {
          this.scale.y = sign;
        }
      },
      /**
       * Retrieves the local bounds of the container as a Bounds object.
       * @returns - The bounding area.
       * @memberof scene.Container#
       */
      getLocalBounds() {
        if (!this._localBoundsCacheData) {
          this._localBoundsCacheData = {
            data: [],
            index: 1,
            didChange: false,
            localBounds: new Bounds()
          };
        }
        const localBoundsCacheData = this._localBoundsCacheData;
        localBoundsCacheData.index = 1;
        localBoundsCacheData.didChange = false;
        if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
          localBoundsCacheData.didChange = true;
          localBoundsCacheData.data[0] = this._didViewChangeTick;
        }
        checkChildrenDidChange(this, localBoundsCacheData);
        if (localBoundsCacheData.didChange) {
          getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix3);
        }
        return localBoundsCacheData.localBounds;
      },
      /**
       * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.
       * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
       *  being updated. This means the calculation returned MAY be out of date BUT will give you a
       *  nice performance boost.
       * @param bounds - Optional bounds to store the result of the bounds calculation.
       * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
       * @memberof scene.Container#
       */
      getBounds(skipUpdate, bounds) {
        return getGlobalBounds(this, skipUpdate, bounds || new Bounds());
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs
var onRenderMixin;
var init_onRenderMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs"() {
    "use strict";
    init_define_AnParams();
    onRenderMixin = {
      _onRender: null,
      set onRender(func) {
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (!func) {
          if (this._onRender) {
            renderGroup?.removeOnRender(this);
          }
          this._onRender = null;
          return;
        }
        if (!this._onRender) {
          renderGroup?.addOnRender(this);
        }
        this._onRender = func;
      },
      /**
       * This callback is used when the container is rendered. This is where you should add your custom
       * logic that is needed to be run every frame.
       *
       * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different
       * and "updateTransform" is no longer called every frame
       * @example
       * const container = new Container();
       * container.onRender = () => {
       *    container.rotation += 0.01;
       * };
       * @memberof scene.Container#
       */
      get onRender() {
        return this._onRender;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs
function sortChildren(a2, b3) {
  return a2._zIndex - b3._zIndex;
}
var sortMixin;
var init_sortMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs"() {
    "use strict";
    init_define_AnParams();
    sortMixin = {
      _zIndex: 0,
      /**
       * Should children be sorted by zIndex at the next render call.
       *
       * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
       * @type {boolean}
       * @memberof scene.Container#
       */
      sortDirty: false,
      /**
       * If set to true, the container will sort its children by `zIndex` value
       * when the next render is called, or manually if `sortChildren()` is called.
       *
       * This actually changes the order of elements in the array, so should be treated
       * as a basic solution that is not performant compared to other solutions,
       * such as {@link https://github.com/pixijs/layers PixiJS Layers}
       *
       * Also be aware of that this may not work nicely with the `addChildAt()` function,
       * as the `zIndex` sorting may cause the child to automatically sorted to another position.
       * @type {boolean}
       * @memberof scene.Container#
       */
      sortableChildren: false,
      /**
       * The zIndex of the container.
       *
       * Setting this value, will automatically set the parent to be sortable. Children will be automatically
       * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
       * and thus rendered on top of other display objects within the same container.
       * @see scene.Container#sortableChildren
       * @memberof scene.Container#
       */
      get zIndex() {
        return this._zIndex;
      },
      set zIndex(value) {
        if (this._zIndex === value)
          return;
        this._zIndex = value;
        this.depthOfChildModified();
      },
      depthOfChildModified() {
        if (this.parent) {
          this.parent.sortableChildren = true;
          this.parent.sortDirty = true;
        }
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
      },
      /**
       * Sorts children by zIndex.
       * @memberof scene.Container#
       */
      sortChildren() {
        if (!this.sortDirty)
          return;
        this.sortDirty = false;
        this.children.sort(sortChildren);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
var toLocalGlobalMixin;
var init_toLocalGlobalMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs"() {
    init_define_AnParams();
    init_Point();
    init_matrixAndBoundsPool();
    toLocalGlobalMixin = {
      /**
       * Returns the global position of the container.
       * @param point - The optional point to write the global value to.
       * @param skipUpdate - Should we skip the update transform.
       * @returns - The updated point.
       * @memberof scene.Container#
       */
      getGlobalPosition(point = new Point(), skipUpdate = false) {
        if (this.parent) {
          this.parent.toGlobal(this._position, point, skipUpdate);
        } else {
          point.x = this._position.x;
          point.y = this._position.y;
        }
        return point;
      },
      /**
       * Calculates the global position of the container.
       * @param position - The world origin to calculate from.
       * @param point - A Point object in which to store the value, optional
       *  (otherwise will create a new Point).
       * @param skipUpdate - Should we skip the update transform.
       * @returns - A point object representing the position of this object.
       * @memberof scene.Container#
       */
      toGlobal(position, point, skipUpdate = false) {
        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
        point = globalMatrix.apply(position, point);
        matrixPool.return(globalMatrix);
        return point;
      },
      /**
       * Calculates the local position of the container relative to another point.
       * @param position - The world origin to calculate from.
       * @param from - The Container to calculate the global position from.
       * @param point - A Point object in which to store the value, optional
       *  (otherwise will create a new Point).
       * @param skipUpdate - Should we skip the update transform
       * @returns - A point object representing the position of this object
       * @memberof scene.Container#
       */
      toLocal(position, from, point, skipUpdate) {
        if (from) {
          position = from.toGlobal(position, point, skipUpdate);
        }
        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
        point = globalMatrix.applyInverse(position, point);
        matrixPool.return(globalMatrix);
        return point;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
var InstructionSet;
var init_InstructionSet = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs"() {
    init_define_AnParams();
    init_uid();
    InstructionSet = class {
      constructor() {
        this.uid = uid("instructionSet");
        this.instructions = [];
        this.instructionSize = 0;
        this.renderables = [];
        this.gcTick = 0;
      }
      /** reset the instruction set so it can be reused set size back to 0 */
      reset() {
        this.instructionSize = 0;
      }
      /**
       * Add an instruction to the set
       * @param instruction - add an instruction to the set
       */
      add(instruction) {
        this.instructions[this.instructionSize++] = instruction;
      }
      /**
       * Log the instructions to the console (for debugging)
       * @internal
       * @ignore
       */
      log() {
        this.instructions.length = this.instructionSize;
        console.table(this.instructions, ["type", "action"]);
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/misc/pow2.mjs
function nextPow2(v2) {
  v2 += v2 === 0 ? 1 : 0;
  --v2;
  v2 |= v2 >>> 1;
  v2 |= v2 >>> 2;
  v2 |= v2 >>> 4;
  v2 |= v2 >>> 8;
  v2 |= v2 >>> 16;
  return v2 + 1;
}
function isPow2(v2) {
  return !(v2 & v2 - 1) && !!v2;
}
function log2(v2) {
  let r2 = (v2 > 65535 ? 1 : 0) << 4;
  v2 >>>= r2;
  let shift = (v2 > 255 ? 1 : 0) << 3;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 15 ? 1 : 0) << 2;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 3 ? 1 : 0) << 1;
  v2 >>>= shift;
  r2 |= shift;
  return r2 | v2 >> 1;
}
var init_pow2 = __esm({
  "node_modules/pixi.js/lib/maths/misc/pow2.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs
function definedProps(obj) {
  const result = {};
  for (const key in obj) {
    if (obj[key] !== void 0) {
      result[key] = obj[key];
    }
  }
  return result;
}
var init_definedProps = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs
function createResourceIdFromString(value) {
  const id = idHash[value];
  if (id === void 0) {
    idHash[value] = uid("resource");
  }
  return id;
}
var idHash, _TextureStyle, TextureStyle;
var init_TextureStyle = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"() {
    init_define_AnParams();
    init_eventemitter3();
    init_uid();
    init_deprecation();
    idHash = /* @__PURE__ */ Object.create(null);
    _TextureStyle = class _TextureStyle2 extends eventemitter3_default {
      /**
       * @param options - options for the style
       */
      constructor(options = {}) {
        super();
        this._resourceType = "textureSampler";
        this._touched = 0;
        this._maxAnisotropy = 1;
        this.destroyed = false;
        options = { ..._TextureStyle2.defaultOptions, ...options };
        this.addressMode = options.addressMode;
        this.addressModeU = options.addressModeU ?? this.addressModeU;
        this.addressModeV = options.addressModeV ?? this.addressModeV;
        this.addressModeW = options.addressModeW ?? this.addressModeW;
        this.scaleMode = options.scaleMode;
        this.magFilter = options.magFilter ?? this.magFilter;
        this.minFilter = options.minFilter ?? this.minFilter;
        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
        this.lodMinClamp = options.lodMinClamp;
        this.lodMaxClamp = options.lodMaxClamp;
        this.compare = options.compare;
        this.maxAnisotropy = options.maxAnisotropy ?? 1;
      }
      set addressMode(value) {
        this.addressModeU = value;
        this.addressModeV = value;
        this.addressModeW = value;
      }
      /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
      get addressMode() {
        return this.addressModeU;
      }
      set wrapMode(value) {
        deprecation(v8_0_0, "TextureStyle.wrapMode is now TextureStyle.addressMode");
        this.addressMode = value;
      }
      get wrapMode() {
        return this.addressMode;
      }
      set scaleMode(value) {
        this.magFilter = value;
        this.minFilter = value;
        this.mipmapFilter = value;
      }
      /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
      get scaleMode() {
        return this.magFilter;
      }
      /** Specifies the maximum anisotropy value clamp used by the sampler. */
      set maxAnisotropy(value) {
        this._maxAnisotropy = Math.min(value, 16);
        if (this._maxAnisotropy > 1) {
          this.scaleMode = "linear";
        }
      }
      get maxAnisotropy() {
        return this._maxAnisotropy;
      }
      // TODO - move this to WebGL?
      get _resourceId() {
        return this._sharedResourceId || this._generateResourceId();
      }
      update() {
        this.emit("change", this);
        this._sharedResourceId = null;
      }
      _generateResourceId() {
        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
        this._sharedResourceId = createResourceIdFromString(bigKey);
        return this._resourceId;
      }
      /** Destroys the style */
      destroy() {
        this.destroyed = true;
        this.emit("destroy", this);
        this.emit("change", this);
        this.removeAllListeners();
      }
    };
    _TextureStyle.defaultOptions = {
      addressMode: "clamp-to-edge",
      scaleMode: "linear"
    };
    TextureStyle = _TextureStyle;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
var _TextureSource, TextureSource;
var init_TextureSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"() {
    init_define_AnParams();
    init_eventemitter3();
    init_pow2();
    init_definedProps();
    init_uid();
    init_TextureStyle();
    _TextureSource = class _TextureSource2 extends eventemitter3_default {
      /**
       * @param options - options for creating a new TextureSource
       */
      constructor(options = {}) {
        super();
        this.options = options;
        this.uid = uid("textureSource");
        this._resourceType = "textureSource";
        this._resourceId = uid("resource");
        this.uploadMethodId = "unknown";
        this._resolution = 1;
        this.pixelWidth = 1;
        this.pixelHeight = 1;
        this.width = 1;
        this.height = 1;
        this.sampleCount = 1;
        this.mipLevelCount = 1;
        this.autoGenerateMipmaps = false;
        this.format = "rgba8unorm";
        this.dimension = "2d";
        this.antialias = false;
        this._touched = 0;
        this._batchTick = -1;
        this._textureBindLocation = -1;
        options = { ..._TextureSource2.defaultOptions, ...options };
        this.label = options.label ?? "";
        this.resource = options.resource;
        this.autoGarbageCollect = options.autoGarbageCollect;
        this._resolution = options.resolution;
        if (options.width) {
          this.pixelWidth = options.width * this._resolution;
        } else {
          this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;
        }
        if (options.height) {
          this.pixelHeight = options.height * this._resolution;
        } else {
          this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;
        }
        this.width = this.pixelWidth / this._resolution;
        this.height = this.pixelHeight / this._resolution;
        this.format = options.format;
        this.dimension = options.dimensions;
        this.mipLevelCount = options.mipLevelCount;
        this.autoGenerateMipmaps = options.autoGenerateMipmaps;
        this.sampleCount = options.sampleCount;
        this.antialias = options.antialias;
        this.alphaMode = options.alphaMode;
        this.style = new TextureStyle(definedProps(options));
        this.destroyed = false;
        this._refreshPOT();
      }
      /** returns itself */
      get source() {
        return this;
      }
      /** the style of the texture */
      get style() {
        return this._style;
      }
      set style(value) {
        if (this.style === value)
          return;
        this._style?.off("change", this._onStyleChange, this);
        this._style = value;
        this._style?.on("change", this._onStyleChange, this);
        this._onStyleChange();
      }
      /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
      get addressMode() {
        return this._style.addressMode;
      }
      set addressMode(value) {
        this._style.addressMode = value;
      }
      /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
      get repeatMode() {
        return this._style.addressMode;
      }
      set repeatMode(value) {
        this._style.addressMode = value;
      }
      /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
      get magFilter() {
        return this._style.magFilter;
      }
      set magFilter(value) {
        this._style.magFilter = value;
      }
      /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
      get minFilter() {
        return this._style.minFilter;
      }
      set minFilter(value) {
        this._style.minFilter = value;
      }
      /** Specifies behavior for sampling between mipmap levels. */
      get mipmapFilter() {
        return this._style.mipmapFilter;
      }
      set mipmapFilter(value) {
        this._style.mipmapFilter = value;
      }
      /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
      get lodMinClamp() {
        return this._style.lodMinClamp;
      }
      set lodMinClamp(value) {
        this._style.lodMinClamp = value;
      }
      /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
      get lodMaxClamp() {
        return this._style.lodMaxClamp;
      }
      set lodMaxClamp(value) {
        this._style.lodMaxClamp = value;
      }
      _onStyleChange() {
        this.emit("styleChange", this);
      }
      /** call this if you have modified the texture outside of the constructor */
      update() {
        if (this.resource) {
          const resolution = this._resolution;
          const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);
          if (didResize)
            return;
        }
        this.emit("update", this);
      }
      /** Destroys this texture source */
      destroy() {
        this.destroyed = true;
        this.emit("destroy", this);
        this.emit("change", this);
        if (this._style) {
          this._style.destroy();
          this._style = null;
        }
        this.uploadMethodId = null;
        this.resource = null;
        this.removeAllListeners();
      }
      /**
       * This will unload the Texture source from the GPU. This will free up the GPU memory
       * As soon as it is required fore rendering, it will be re-uploaded.
       */
      unload() {
        this._resourceId = uid("resource");
        this.emit("change", this);
        this.emit("unload", this);
      }
      /** the width of the resource. This is the REAL pure number, not accounting resolution   */
      get resourceWidth() {
        const { resource } = this;
        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
      }
      /** the height of the resource. This is the REAL pure number, not accounting resolution */
      get resourceHeight() {
        const { resource } = this;
        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
      }
      /**
       * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
       * but will the size of the texture when rendered.
       *
       * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
       * density will have increased)
       */
      get resolution() {
        return this._resolution;
      }
      set resolution(resolution) {
        if (this._resolution === resolution)
          return;
        this._resolution = resolution;
        this.width = this.pixelWidth / resolution;
        this.height = this.pixelHeight / resolution;
      }
      /**
       * Resize the texture, this is handy if you want to use the texture as a render texture
       * @param width - the new width of the texture
       * @param height - the new height of the texture
       * @param resolution - the new resolution of the texture
       * @returns - if the texture was resized
       */
      resize(width, height, resolution) {
        resolution || (resolution = this._resolution);
        width || (width = this.width);
        height || (height = this.height);
        const newPixelWidth = Math.round(width * resolution);
        const newPixelHeight = Math.round(height * resolution);
        this.width = newPixelWidth / resolution;
        this.height = newPixelHeight / resolution;
        this._resolution = resolution;
        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
          return false;
        }
        this._refreshPOT();
        this.pixelWidth = newPixelWidth;
        this.pixelHeight = newPixelHeight;
        this.emit("resize", this);
        this._resourceId = uid("resource");
        this.emit("change", this);
        return true;
      }
      /**
       * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
       * This is only important for RenderTexture instances, as standard Texture instances will have their
       * mipmaps generated on upload. You should call this method after you make any change to the texture
       *
       * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
       * We want you, the developer to specify when this action should happen.
       *
       * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
       */
      updateMipmaps() {
        if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
          this.emit("updateMipmaps", this);
        }
      }
      set wrapMode(value) {
        this._style.wrapMode = value;
      }
      get wrapMode() {
        return this._style.wrapMode;
      }
      set scaleMode(value) {
        this._style.scaleMode = value;
      }
      /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
      get scaleMode() {
        return this._style.scaleMode;
      }
      /**
       * Refresh check for isPowerOfTwo texture based on size
       * @private
       */
      _refreshPOT() {
        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);
      }
      static test(_resource) {
        throw new Error("Unimplemented");
      }
    };
    _TextureSource.defaultOptions = {
      resolution: 1,
      format: "bgra8unorm",
      alphaMode: "premultiply-alpha-on-upload",
      dimensions: "2d",
      mipLevelCount: 1,
      autoGenerateMipmaps: false,
      sampleCount: 1,
      antialias: false,
      autoGarbageCollect: false
    };
    TextureSource = _TextureSource;
  }
});

// node_modules/pixi.js/lib/maths/matrix/groupD8.mjs
function init() {
  for (let i3 = 0; i3 < 16; i3++) {
    const row = [];
    rotationCayley.push(row);
    for (let j2 = 0; j2 < 16; j2++) {
      const _ux = signum(ux[i3] * ux[j2] + vx[i3] * uy[j2]);
      const _uy = signum(uy[i3] * ux[j2] + vy[i3] * uy[j2]);
      const _vx = signum(ux[i3] * vx[j2] + vx[i3] * vy[j2]);
      const _vy = signum(uy[i3] * vx[j2] + vy[i3] * vy[j2]);
      for (let k2 = 0; k2 < 16; k2++) {
        if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
          row.push(k2);
          break;
        }
      }
    }
  }
  for (let i3 = 0; i3 < 16; i3++) {
    const mat = new Matrix();
    mat.set(ux[i3], uy[i3], vx[i3], vy[i3], 0, 0);
    rotationMatrices.push(mat);
  }
}
var ux, uy, vx, vy, rotationCayley, rotationMatrices, signum, groupD8;
var init_groupD8 = __esm({
  "node_modules/pixi.js/lib/maths/matrix/groupD8.mjs"() {
    init_define_AnParams();
    init_Matrix();
    ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
    uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
    vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
    vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
    rotationCayley = [];
    rotationMatrices = [];
    signum = Math.sign;
    init();
    groupD8 = {
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 0       | East      |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      E: 0,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 45     | Southeast |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      SE: 1,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 90     | South     |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      S: 2,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 135    | Southwest |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      SW: 3,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 180     | West      |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      W: 4,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -135/225 | Northwest    |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      NW: 5,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -90/270  | North        |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      N: 6,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -45/315  | Northeast    |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      NE: 7,
      /**
       * Reflection about Y-axis.
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      MIRROR_VERTICAL: 8,
      /**
       * Reflection about the main diagonal.
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      MAIN_DIAGONAL: 10,
      /**
       * Reflection about X-axis.
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      MIRROR_HORIZONTAL: 12,
      /**
       * Reflection about reverse diagonal.
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      REVERSE_DIAGONAL: 14,
      /**
       * @memberof maths.groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The X-component of the U-axis
       *    after rotating the axes.
       */
      uX: (ind) => ux[ind],
      /**
       * @memberof maths.groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The Y-component of the U-axis
       *    after rotating the axes.
       */
      uY: (ind) => uy[ind],
      /**
       * @memberof maths.groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The X-component of the V-axis
       *    after rotating the axes.
       */
      vX: (ind) => vx[ind],
      /**
       * @memberof maths.groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The Y-component of the V-axis
       *    after rotating the axes.
       */
      vY: (ind) => vy[ind],
      /**
       * @memberof maths.groupD8
       * @param {GD8Symmetry} rotation - symmetry whose opposite
       *   is needed. Only rotations have opposite symmetries while
       *   reflections don't.
       * @returns {GD8Symmetry} The opposite symmetry of `rotation`
       */
      inv: (rotation) => {
        if (rotation & 8) {
          return rotation & 15;
        }
        return -rotation & 7;
      },
      /**
       * Composes the two D8 operations.
       *
       * Taking `^` as reflection:
       *
       * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
       * |-------|-----|-----|-----|-----|------|-------|-------|-------|
       * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
       * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
       * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
       * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
       * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
       * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
       * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
       * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
       *
       * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
       * @memberof maths.groupD8
       * @param {GD8Symmetry} rotationSecond - Second operation, which
       *   is the row in the above cayley table.
       * @param {GD8Symmetry} rotationFirst - First operation, which
       *   is the column in the above cayley table.
       * @returns {GD8Symmetry} Composed operation
       */
      add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
      /**
       * Reverse of `add`.
       * @memberof maths.groupD8
       * @param {GD8Symmetry} rotationSecond - Second operation
       * @param {GD8Symmetry} rotationFirst - First operation
       * @returns {GD8Symmetry} Result
       */
      sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
      /**
       * Adds 180 degrees to rotation, which is a commutative
       * operation.
       * @memberof maths.groupD8
       * @param {number} rotation - The number to rotate.
       * @returns {number} Rotated number
       */
      rotate180: (rotation) => rotation ^ 4,
      /**
       * Checks if the rotation angle is vertical, i.e. south
       * or north. It doesn't work for reflections.
       * @memberof maths.groupD8
       * @param {GD8Symmetry} rotation - The number to check.
       * @returns {boolean} Whether or not the direction is vertical
       */
      isVertical: (rotation) => (rotation & 3) === 2,
      // rotation % 4 === 2
      /**
       * Approximates the vector `V(dx,dy)` into one of the
       * eight directions provided by `groupD8`.
       * @memberof maths.groupD8
       * @param {number} dx - X-component of the vector
       * @param {number} dy - Y-component of the vector
       * @returns {GD8Symmetry} Approximation of the vector into
       *  one of the eight symmetries.
       */
      byDirection: (dx, dy) => {
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
          if (dy >= 0) {
            return groupD8.S;
          }
          return groupD8.N;
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
          if (dx > 0) {
            return groupD8.E;
          }
          return groupD8.W;
        } else if (dy > 0) {
          if (dx > 0) {
            return groupD8.SE;
          }
          return groupD8.SW;
        } else if (dx > 0) {
          return groupD8.NE;
        }
        return groupD8.NW;
      },
      /**
       * Helps sprite to compensate texture packer rotation.
       * @memberof maths.groupD8
       * @param {Matrix} matrix - sprite world matrix
       * @param {GD8Symmetry} rotation - The rotation factor to use.
       * @param {number} tx - sprite anchoring
       * @param {number} ty - sprite anchoring
       */
      matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
        const mat = rotationMatrices[groupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/misc/NOOP.mjs
var NOOP;
var init_NOOP = __esm({
  "node_modules/pixi.js/lib/utils/misc/NOOP.mjs"() {
    "use strict";
    init_define_AnParams();
    NOOP = () => {
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs
var BufferImageSource;
var init_BufferImageSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_TextureSource();
    BufferImageSource = class extends TextureSource {
      constructor(options) {
        const buffer = options.resource || new Float32Array(options.width * options.height * 4);
        let format = options.format;
        if (!format) {
          if (buffer instanceof Float32Array) {
            format = "rgba32float";
          } else if (buffer instanceof Int32Array) {
            format = "rgba32uint";
          } else if (buffer instanceof Uint32Array) {
            format = "rgba32uint";
          } else if (buffer instanceof Int16Array) {
            format = "rgba16uint";
          } else if (buffer instanceof Uint16Array) {
            format = "rgba16uint";
          } else if (buffer instanceof Int8Array) {
            format = "bgra8unorm";
          } else {
            format = "bgra8unorm";
          }
        }
        super({
          ...options,
          resource: buffer,
          format
        });
        this.uploadMethodId = "buffer";
      }
      static test(resource) {
        return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
      }
    };
    BufferImageSource.extension = ExtensionType.TextureSource;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
var tempMat, TextureMatrix;
var init_TextureMatrix = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"() {
    init_define_AnParams();
    init_Matrix();
    tempMat = new Matrix();
    TextureMatrix = class {
      /**
       * @param texture - observed texture
       * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
       */
      constructor(texture, clampMargin) {
        this.mapCoord = new Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        this._textureID = -1;
        this._updateID = 0;
        this.clampOffset = 0;
        if (typeof clampMargin === "undefined") {
          this.clampMargin = texture.width < 10 ? 0 : 0.5;
        } else {
          this.clampMargin = clampMargin;
        }
        this.isSimple = false;
        this.texture = texture;
      }
      /** Texture property. */
      get texture() {
        return this._texture;
      }
      set texture(value) {
        if (this.texture === value)
          return;
        this._texture?.removeListener("update", this.update, this);
        this._texture = value;
        this._texture.addListener("update", this.update, this);
        this.update();
      }
      /**
       * Multiplies uvs array to transform
       * @param uvs - mesh uvs
       * @param [out=uvs] - output
       * @returns - output
       */
      multiplyUvs(uvs, out2) {
        if (out2 === void 0) {
          out2 = uvs;
        }
        const mat = this.mapCoord;
        for (let i3 = 0; i3 < uvs.length; i3 += 2) {
          const x2 = uvs[i3];
          const y2 = uvs[i3 + 1];
          out2[i3] = x2 * mat.a + y2 * mat.c + mat.tx;
          out2[i3 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
        }
        return out2;
      }
      /**
       * Updates matrices if texture was changed
       * @returns - whether or not it was updated
       */
      update() {
        const tex = this._texture;
        this._updateID++;
        const uvs = tex.uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        const orig = tex.orig;
        const trim = tex.trim;
        if (trim) {
          tempMat.set(
            orig.width / trim.width,
            0,
            0,
            orig.height / trim.height,
            -trim.x / trim.width,
            -trim.y / trim.height
          );
          this.mapCoord.append(tempMat);
        }
        const texBase = tex.source;
        const frame = this.uClampFrame;
        const margin = this.clampMargin / texBase._resolution;
        const offset = this.clampOffset / texBase._resolution;
        frame[0] = (tex.frame.x + margin + offset) / texBase.width;
        frame[1] = (tex.frame.y + margin + offset) / texBase.height;
        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;
        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;
        this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;
        this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;
        this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;
        return true;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs
var Texture;
var init_Texture = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"() {
    init_define_AnParams();
    init_eventemitter3();
    init_groupD8();
    init_Rectangle();
    init_uid();
    init_deprecation();
    init_NOOP();
    init_BufferImageSource();
    init_TextureSource();
    init_TextureMatrix();
    Texture = class extends eventemitter3_default {
      /**
       * @param {rendering.TextureOptions} options - Options for the texture
       */
      constructor({
        source: source9,
        label,
        frame,
        orig,
        trim,
        defaultAnchor,
        defaultBorders,
        rotate,
        dynamic
      } = {}) {
        super();
        this.uid = uid("texture");
        this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
        this.frame = new Rectangle();
        this.noFrame = false;
        this.dynamic = false;
        this.isTexture = true;
        this.label = label;
        this.source = source9?.source ?? new TextureSource();
        this.noFrame = !frame;
        if (frame) {
          this.frame.copyFrom(frame);
        } else {
          const { width, height } = this._source;
          this.frame.width = width;
          this.frame.height = height;
        }
        this.orig = orig || this.frame;
        this.trim = trim;
        this.rotate = rotate ?? 0;
        this.defaultAnchor = defaultAnchor;
        this.defaultBorders = defaultBorders;
        this.destroyed = false;
        this.dynamic = dynamic || false;
        this.updateUvs();
      }
      set source(value) {
        if (this._source) {
          this._source.off("resize", this.update, this);
        }
        this._source = value;
        value.on("resize", this.update, this);
        this.emit("update", this);
      }
      /** the underlying source of the texture (equivalent of baseTexture in v7) */
      get source() {
        return this._source;
      }
      /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
      get textureMatrix() {
        if (!this._textureMatrix) {
          this._textureMatrix = new TextureMatrix(this);
        }
        return this._textureMatrix;
      }
      /** The width of the Texture in pixels. */
      get width() {
        return this.orig.width;
      }
      /** The height of the Texture in pixels. */
      get height() {
        return this.orig.height;
      }
      /** Call this function when you have modified the frame of this texture. */
      updateUvs() {
        const { uvs, frame } = this;
        const { width, height } = this._source;
        const nX = frame.x / width;
        const nY = frame.y / height;
        const nW = frame.width / width;
        const nH = frame.height / height;
        let rotate = this.rotate;
        if (rotate) {
          const w2 = nW / 2;
          const h2 = nH / 2;
          const cX = nX + w2;
          const cY = nY + h2;
          rotate = groupD8.add(rotate, groupD8.NW);
          uvs.x0 = cX + w2 * groupD8.uX(rotate);
          uvs.y0 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x1 = cX + w2 * groupD8.uX(rotate);
          uvs.y1 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x2 = cX + w2 * groupD8.uX(rotate);
          uvs.y2 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x3 = cX + w2 * groupD8.uX(rotate);
          uvs.y3 = cY + h2 * groupD8.uY(rotate);
        } else {
          uvs.x0 = nX;
          uvs.y0 = nY;
          uvs.x1 = nX + nW;
          uvs.y1 = nY;
          uvs.x2 = nX + nW;
          uvs.y2 = nY + nH;
          uvs.x3 = nX;
          uvs.y3 = nY + nH;
        }
      }
      /**
       * Destroys this texture
       * @param destroySource - Destroy the source when the texture is destroyed.
       */
      destroy(destroySource = false) {
        if (this._source) {
          if (destroySource) {
            this._source.destroy();
            this._source = null;
          }
        }
        this._textureMatrix = null;
        this.destroyed = true;
        this.emit("destroy", this);
        this.removeAllListeners();
      }
      /**
       * Call this if you have modified the `texture outside` of the constructor.
       *
       * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.
       */
      update() {
        if (this.noFrame) {
          this.frame.width = this._source.width;
          this.frame.height = this._source.height;
        }
        this.updateUvs();
        this.emit("update", this);
      }
      /** @deprecated since 8.0.0 */
      get baseTexture() {
        deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
        return this._source;
      }
    };
    Texture.EMPTY = new Texture({
      label: "EMPTY",
      source: new TextureSource({
        label: "EMPTY"
      })
    });
    Texture.EMPTY.destroy = NOOP;
    Texture.WHITE = new Texture({
      source: new BufferImageSource({
        resource: new Uint8Array([255, 255, 255, 255]),
        width: 1,
        height: 1,
        alphaMode: "premultiply-alpha-on-upload",
        label: "WHITE"
      }),
      label: "WHITE"
    });
    Texture.WHITE.destroy = NOOP;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs
var count, TexturePoolClass, TexturePool;
var init_TexturePool = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"() {
    init_define_AnParams();
    init_pow2();
    init_TextureSource();
    init_Texture();
    count = 0;
    TexturePoolClass = class {
      /**
       * @param textureOptions - options that will be passed to BaseRenderTexture constructor
       * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
       */
      constructor(textureOptions) {
        this._poolKeyHash = /* @__PURE__ */ Object.create(null);
        this._texturePool = {};
        this.textureOptions = textureOptions || {};
        this.enableFullScreen = false;
      }
      /**
       * Creates texture with params that were specified in pool constructor.
       * @param pixelWidth - Width of texture in pixels.
       * @param pixelHeight - Height of texture in pixels.
       * @param antialias
       */
      createTexture(pixelWidth, pixelHeight, antialias) {
        const textureSource = new TextureSource({
          ...this.textureOptions,
          width: pixelWidth,
          height: pixelHeight,
          resolution: 1,
          antialias,
          autoGarbageCollect: false
        });
        return new Texture({
          source: textureSource,
          label: `texturePool_${count++}`
        });
      }
      /**
       * Gets a Power-of-Two render texture or fullScreen texture
       * @param frameWidth - The minimum width of the render texture.
       * @param frameHeight - The minimum height of the render texture.
       * @param resolution - The resolution of the render texture.
       * @param antialias
       * @returns The new render texture.
       */
      getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
        let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
        let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
        po2Width = nextPow2(po2Width);
        po2Height = nextPow2(po2Height);
        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
        if (!this._texturePool[key]) {
          this._texturePool[key] = [];
        }
        let texture = this._texturePool[key].pop();
        if (!texture) {
          texture = this.createTexture(po2Width, po2Height, antialias);
        }
        texture.source._resolution = resolution;
        texture.source.width = po2Width / resolution;
        texture.source.height = po2Height / resolution;
        texture.source.pixelWidth = po2Width;
        texture.source.pixelHeight = po2Height;
        texture.frame.x = 0;
        texture.frame.y = 0;
        texture.frame.width = frameWidth;
        texture.frame.height = frameHeight;
        texture.updateUvs();
        this._poolKeyHash[texture.uid] = key;
        return texture;
      }
      /**
       * Gets extra texture of the same size as input renderTexture
       * @param texture - The texture to check what size it is.
       * @param antialias - Whether to use antialias.
       * @returns A texture that is a power of two
       */
      getSameSizeTexture(texture, antialias = false) {
        const source9 = texture.source;
        return this.getOptimalTexture(texture.width, texture.height, source9._resolution, antialias);
      }
      /**
       * Place a render texture back into the pool.
       * @param renderTexture - The renderTexture to free
       */
      returnTexture(renderTexture) {
        const key = this._poolKeyHash[renderTexture.uid];
        this._texturePool[key].push(renderTexture);
      }
      /**
       * Clears the pool.
       * @param destroyTextures - Destroy all stored textures.
       */
      clear(destroyTextures) {
        destroyTextures = destroyTextures !== false;
        if (destroyTextures) {
          for (const i3 in this._texturePool) {
            const textures = this._texturePool[i3];
            if (textures) {
              for (let j2 = 0; j2 < textures.length; j2++) {
                textures[j2].destroy(true);
              }
            }
          }
        }
        this._texturePool = {};
      }
    };
    TexturePool = new TexturePoolClass();
  }
});

// node_modules/pixi.js/lib/scene/container/RenderGroup.mjs
var RenderGroup;
var init_RenderGroup = __esm({
  "node_modules/pixi.js/lib/scene/container/RenderGroup.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_InstructionSet();
    init_TexturePool();
    RenderGroup = class {
      constructor() {
        this.renderPipeId = "renderGroup";
        this.root = null;
        this.canBundle = false;
        this.renderGroupParent = null;
        this.renderGroupChildren = [];
        this.worldTransform = new Matrix();
        this.worldColorAlpha = 4294967295;
        this.worldColor = 16777215;
        this.worldAlpha = 1;
        this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
        this.updateTick = 0;
        this.gcTick = 0;
        this.childrenRenderablesToUpdate = { list: [], index: 0 };
        this.structureDidChange = true;
        this.instructionSet = new InstructionSet();
        this._onRenderContainers = [];
        this.textureNeedsUpdate = true;
        this.isCachedAsTexture = false;
        this._matrixDirty = 7;
      }
      init(root) {
        this.root = root;
        if (root._onRender)
          this.addOnRender(root);
        root.didChange = true;
        const children = root.children;
        for (let i3 = 0; i3 < children.length; i3++) {
          const child = children[i3];
          child._updateFlags = 15;
          this.addChild(child);
        }
      }
      enableCacheAsTexture(options = {}) {
        this.textureOptions = options;
        this.isCachedAsTexture = true;
        this.textureNeedsUpdate = true;
      }
      disableCacheAsTexture() {
        this.isCachedAsTexture = false;
        if (this.texture) {
          TexturePool.returnTexture(this.texture);
          this.texture = null;
        }
      }
      updateCacheTexture() {
        this.textureNeedsUpdate = true;
      }
      reset() {
        this.renderGroupChildren.length = 0;
        for (const i3 in this.childrenToUpdate) {
          const childrenAtDepth = this.childrenToUpdate[i3];
          childrenAtDepth.list.fill(null);
          childrenAtDepth.index = 0;
        }
        this.childrenRenderablesToUpdate.index = 0;
        this.childrenRenderablesToUpdate.list.fill(null);
        this.root = null;
        this.updateTick = 0;
        this.structureDidChange = true;
        this._onRenderContainers.length = 0;
        this.renderGroupParent = null;
        this.disableCacheAsTexture();
      }
      get localTransform() {
        return this.root.localTransform;
      }
      addRenderGroupChild(renderGroupChild) {
        if (renderGroupChild.renderGroupParent) {
          renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
        }
        renderGroupChild.renderGroupParent = this;
        this.renderGroupChildren.push(renderGroupChild);
      }
      _removeRenderGroupChild(renderGroupChild) {
        const index = this.renderGroupChildren.indexOf(renderGroupChild);
        if (index > -1) {
          this.renderGroupChildren.splice(index, 1);
        }
        renderGroupChild.renderGroupParent = null;
      }
      addChild(child) {
        this.structureDidChange = true;
        child.parentRenderGroup = this;
        child.updateTick = -1;
        if (child.parent === this.root) {
          child.relativeRenderGroupDepth = 1;
        } else {
          child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
        }
        child.didChange = true;
        this.onChildUpdate(child);
        if (child.renderGroup) {
          this.addRenderGroupChild(child.renderGroup);
          return;
        }
        if (child._onRender)
          this.addOnRender(child);
        const children = child.children;
        for (let i3 = 0; i3 < children.length; i3++) {
          this.addChild(children[i3]);
        }
      }
      removeChild(child) {
        this.structureDidChange = true;
        if (child._onRender) {
          if (!child.renderGroup) {
            this.removeOnRender(child);
          }
        }
        child.parentRenderGroup = null;
        if (child.renderGroup) {
          this._removeRenderGroupChild(child.renderGroup);
          return;
        }
        const children = child.children;
        for (let i3 = 0; i3 < children.length; i3++) {
          this.removeChild(children[i3]);
        }
      }
      removeChildren(children) {
        for (let i3 = 0; i3 < children.length; i3++) {
          this.removeChild(children[i3]);
        }
      }
      onChildUpdate(child) {
        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
        if (!childrenToUpdate) {
          childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
            index: 0,
            list: []
          };
        }
        childrenToUpdate.list[childrenToUpdate.index++] = child;
      }
      updateRenderable(renderable) {
        if (renderable.globalDisplayStatus < 7)
          return;
        this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);
        renderable.didViewUpdate = false;
      }
      onChildViewUpdate(child) {
        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
      }
      get isRenderable() {
        return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
      }
      /**
       * adding a container to the onRender list will make sure the user function
       * passed in to the user defined 'onRender` callBack
       * @param container - the container to add to the onRender list
       */
      addOnRender(container) {
        this._onRenderContainers.push(container);
      }
      removeOnRender(container) {
        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
      }
      runOnRender(renderer) {
        for (let i3 = 0; i3 < this._onRenderContainers.length; i3++) {
          this._onRenderContainers[i3]._onRender(renderer);
        }
      }
      destroy() {
        this.disableCacheAsTexture();
        this.renderGroupParent = null;
        this.root = null;
        this.childrenRenderablesToUpdate = null;
        this.childrenToUpdate = null;
        this.renderGroupChildren = null;
        this._onRenderContainers = null;
        this.instructionSet = null;
      }
      getChildren(out2 = []) {
        const children = this.root.children;
        for (let i3 = 0; i3 < children.length; i3++) {
          this._getChildren(children[i3], out2);
        }
        return out2;
      }
      _getChildren(container, out2 = []) {
        out2.push(container);
        if (container.renderGroup)
          return out2;
        const children = container.children;
        for (let i3 = 0; i3 < children.length; i3++) {
          this._getChildren(children[i3], out2);
        }
        return out2;
      }
      invalidateMatrices() {
        this._matrixDirty = 7;
      }
      /**
       * Returns the inverse of the world transform matrix.
       * @returns {Matrix} The inverse of the world transform matrix.
       */
      get inverseWorldTransform() {
        if ((this._matrixDirty & 1) === 0)
          return this._inverseWorldTransform;
        this._matrixDirty &= ~1;
        this._inverseWorldTransform || (this._inverseWorldTransform = new Matrix());
        return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();
      }
      /**
       * Returns the inverse of the texture offset transform matrix.
       * @returns {Matrix} The inverse of the texture offset transform matrix.
       */
      get textureOffsetInverseTransform() {
        if ((this._matrixDirty & 2) === 0)
          return this._textureOffsetInverseTransform;
        this._matrixDirty &= ~2;
        this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Matrix());
        return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(
          -this._textureBounds.x,
          -this._textureBounds.y
        );
      }
      /**
       * Returns the inverse of the parent texture transform matrix.
       * This is used to properly transform coordinates when rendering into cached textures.
       * @returns {Matrix} The inverse of the parent texture transform matrix.
       */
      get inverseParentTextureTransform() {
        if ((this._matrixDirty & 4) === 0)
          return this._inverseParentTextureTransform;
        this._matrixDirty &= ~4;
        const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;
        if (parentCacheAsTexture) {
          this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Matrix());
          return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(
            -parentCacheAsTexture._textureBounds.x,
            -parentCacheAsTexture._textureBounds.y
          );
        }
        return this.worldTransform;
      }
      /**
       * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.
       * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.
       * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,
       * or null if no parent is cached as texture.
       */
      get cacheToLocalTransform() {
        if (!this._parentCacheAsTextureRenderGroup)
          return null;
        return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs
function assignWithIgnore(target, options, ignore = {}) {
  for (const key in options) {
    if (!ignore[key] && options[key] !== void 0) {
      target[key] = options[key];
    }
  }
}
var init_assignWithIgnore = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/container/Container.mjs
var defaultSkew, defaultPivot, defaultScale, UPDATE_COLOR, UPDATE_BLEND, UPDATE_VISIBLE, UPDATE_TRANSFORM, Container;
var init_Container = __esm({
  "node_modules/pixi.js/lib/scene/container/Container.mjs"() {
    init_define_AnParams();
    init_eventemitter3();
    init_Color();
    init_cullingMixin();
    init_Extensions();
    init_Matrix();
    init_const();
    init_ObservablePoint();
    init_uid();
    init_deprecation();
    init_PoolGroup();
    init_cacheAsTextureMixin();
    init_childrenHelperMixin();
    init_collectRenderablesMixin();
    init_effectsMixin();
    init_findMixin();
    init_getFastGlobalBoundsMixin();
    init_getGlobalMixin();
    init_measureMixin();
    init_onRenderMixin();
    init_sortMixin();
    init_toLocalGlobalMixin();
    init_RenderGroup();
    init_assignWithIgnore();
    defaultSkew = new ObservablePoint(null);
    defaultPivot = new ObservablePoint(null);
    defaultScale = new ObservablePoint(null, 1, 1);
    UPDATE_COLOR = 1;
    UPDATE_BLEND = 2;
    UPDATE_VISIBLE = 4;
    UPDATE_TRANSFORM = 8;
    Container = class _Container extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.uid = uid("renderable");
        this._updateFlags = 15;
        this.renderGroup = null;
        this.parentRenderGroup = null;
        this.parentRenderGroupIndex = 0;
        this.didChange = false;
        this.didViewUpdate = false;
        this.relativeRenderGroupDepth = 0;
        this.children = [];
        this.parent = null;
        this.includeInBuild = true;
        this.measurable = true;
        this.isSimple = true;
        this.updateTick = -1;
        this.localTransform = new Matrix();
        this.relativeGroupTransform = new Matrix();
        this.groupTransform = this.relativeGroupTransform;
        this.destroyed = false;
        this._position = new ObservablePoint(this, 0, 0);
        this._scale = defaultScale;
        this._pivot = defaultPivot;
        this._skew = defaultSkew;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
        this._rotation = 0;
        this.localColor = 16777215;
        this.localAlpha = 1;
        this.groupAlpha = 1;
        this.groupColor = 16777215;
        this.groupColorAlpha = 4294967295;
        this.localBlendMode = "inherit";
        this.groupBlendMode = "normal";
        this.localDisplayStatus = 7;
        this.globalDisplayStatus = 7;
        this._didContainerChangeTick = 0;
        this._didViewChangeTick = 0;
        this._didLocalTransformChangeId = -1;
        this.effects = [];
        assignWithIgnore(this, options, {
          children: true,
          parent: true,
          effects: true
        });
        options.children?.forEach((child) => this.addChild(child));
        options.parent?.addChild(this);
      }
      /**
       * Mixes all enumerable properties and methods from a source object to Container.
       * @param source - The source of properties and methods to mix in.
       * @deprecated since 8.8.0
       */
      static mixin(source9) {
        deprecation("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead.");
        extensions.mixin(_Container, source9);
      }
      // = 'default';
      /**
       * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
       * @deprecated since 8.2.6
       * @ignore
       */
      set _didChangeId(value) {
        this._didViewChangeTick = value >> 12 & 4095;
        this._didContainerChangeTick = value & 4095;
      }
      get _didChangeId() {
        return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
      }
      /**
       * Adds one or more children to the container.
       *
       * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
       * @param {...Container} children - The Container(s) to add to the container
       * @returns {Container} - The first child that was added.
       */
      addChild(...children) {
        if (!this.allowChildren) {
          deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
        }
        if (children.length > 1) {
          for (let i3 = 0; i3 < children.length; i3++) {
            this.addChild(children[i3]);
          }
          return children[0];
        }
        const child = children[0];
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (child.parent === this) {
          this.children.splice(this.children.indexOf(child), 1);
          this.children.push(child);
          if (renderGroup) {
            renderGroup.structureDidChange = true;
          }
          return child;
        }
        if (child.parent) {
          child.parent.removeChild(child);
        }
        this.children.push(child);
        if (this.sortableChildren)
          this.sortDirty = true;
        child.parent = this;
        child.didChange = true;
        child._updateFlags = 15;
        if (renderGroup) {
          renderGroup.addChild(child);
        }
        this.emit("childAdded", child, this, this.children.length - 1);
        child.emit("added", this);
        this._didViewChangeTick++;
        if (child._zIndex !== 0) {
          child.depthOfChildModified();
        }
        return child;
      }
      /**
       * Removes one or more children from the container.
       * @param {...Container} children - The Container(s) to remove
       * @returns {Container} The first child that was removed.
       */
      removeChild(...children) {
        if (children.length > 1) {
          for (let i3 = 0; i3 < children.length; i3++) {
            this.removeChild(children[i3]);
          }
          return children[0];
        }
        const child = children[0];
        const index = this.children.indexOf(child);
        if (index > -1) {
          this._didViewChangeTick++;
          this.children.splice(index, 1);
          if (this.renderGroup) {
            this.renderGroup.removeChild(child);
          } else if (this.parentRenderGroup) {
            this.parentRenderGroup.removeChild(child);
          }
          if (child.parentRenderLayer) {
            child.parentRenderLayer.detach(child);
          }
          child.parent = null;
          this.emit("childRemoved", child, this, index);
          child.emit("removed", this);
        }
        return child;
      }
      /** @ignore */
      _onUpdate(point) {
        if (point) {
          if (point === this._skew) {
            this._updateSkew();
          }
        }
        this._didContainerChangeTick++;
        if (this.didChange)
          return;
        this.didChange = true;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.onChildUpdate(this);
        }
      }
      set isRenderGroup(value) {
        if (!!this.renderGroup === value)
          return;
        if (value) {
          this.enableRenderGroup();
        } else {
          this.disableRenderGroup();
        }
      }
      /**
       * Returns true if this container is a render group.
       * This means that it will be rendered as a separate pass, with its own set of instructions
       */
      get isRenderGroup() {
        return !!this.renderGroup;
      }
      /**
       * Calling this enables a render group for this container.
       * This means it will be rendered as a separate set of instructions.
       * The transform of the container will also be handled on the GPU rather than the CPU.
       */
      enableRenderGroup() {
        if (this.renderGroup)
          return;
        const parentRenderGroup = this.parentRenderGroup;
        parentRenderGroup?.removeChild(this);
        this.renderGroup = BigPool.get(RenderGroup, this);
        this.groupTransform = Matrix.IDENTITY;
        parentRenderGroup?.addChild(this);
        this._updateIsSimple();
      }
      /** This will disable the render group for this container. */
      disableRenderGroup() {
        if (!this.renderGroup)
          return;
        const parentRenderGroup = this.parentRenderGroup;
        parentRenderGroup?.removeChild(this);
        BigPool.return(this.renderGroup);
        this.renderGroup = null;
        this.groupTransform = this.relativeGroupTransform;
        parentRenderGroup?.addChild(this);
        this._updateIsSimple();
      }
      /** @ignore */
      _updateIsSimple() {
        this.isSimple = !this.renderGroup && this.effects.length === 0;
      }
      /**
       * Current transform of the object based on world (parent) factors.
       * @readonly
       */
      get worldTransform() {
        this._worldTransform || (this._worldTransform = new Matrix());
        if (this.renderGroup) {
          this._worldTransform.copyFrom(this.renderGroup.worldTransform);
        } else if (this.parentRenderGroup) {
          this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
        }
        return this._worldTransform;
      }
      /**
       * The position of the container on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get x() {
        return this._position.x;
      }
      set x(value) {
        this._position.x = value;
      }
      /**
       * The position of the container on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get y() {
        return this._position.y;
      }
      set y(value) {
        this._position.y = value;
      }
      /**
       * The coordinate of the object relative to the local coordinates of the parent.
       * @since 4.0.0
       */
      get position() {
        return this._position;
      }
      set position(value) {
        this._position.copyFrom(value);
      }
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get rotation() {
        return this._rotation;
      }
      set rotation(value) {
        if (this._rotation !== value) {
          this._rotation = value;
          this._onUpdate(this._skew);
        }
      }
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get angle() {
        return this.rotation * RAD_TO_DEG;
      }
      set angle(value) {
        this.rotation = value * DEG_TO_RAD;
      }
      /**
       * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
       * is the projection of `pivot` in the parent's local space.
       *
       * By default, the pivot is the origin (0, 0).
       * @since 4.0.0
       */
      get pivot() {
        if (this._pivot === defaultPivot) {
          this._pivot = new ObservablePoint(this, 0, 0);
        }
        return this._pivot;
      }
      set pivot(value) {
        if (this._pivot === defaultPivot) {
          this._pivot = new ObservablePoint(this, 0, 0);
        }
        typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);
      }
      /**
       * The skew factor for the object in radians.
       * @since 4.0.0
       */
      get skew() {
        if (this._skew === defaultSkew) {
          this._skew = new ObservablePoint(this, 0, 0);
        }
        return this._skew;
      }
      set skew(value) {
        if (this._skew === defaultSkew) {
          this._skew = new ObservablePoint(this, 0, 0);
        }
        this._skew.copyFrom(value);
      }
      /**
       * The scale factors of this object along the local coordinate axes.
       *
       * The default scale is (1, 1).
       * @since 4.0.0
       */
      get scale() {
        if (this._scale === defaultScale) {
          this._scale = new ObservablePoint(this, 1, 1);
        }
        return this._scale;
      }
      set scale(value) {
        if (this._scale === defaultScale) {
          this._scale = new ObservablePoint(this, 0, 0);
        }
        typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);
      }
      /**
       * The width of the Container, setting this will actually modify the scale to achieve the value set.
       * @memberof scene.Container#
       */
      get width() {
        return Math.abs(this.scale.x * this.getLocalBounds().width);
      }
      set width(value) {
        const localWidth = this.getLocalBounds().width;
        this._setWidth(value, localWidth);
      }
      /**
       * The height of the Container, setting this will actually modify the scale to achieve the value set.
       * @memberof scene.Container#
       */
      get height() {
        return Math.abs(this.scale.y * this.getLocalBounds().height);
      }
      set height(value) {
        const localHeight = this.getLocalBounds().height;
        this._setHeight(value, localHeight);
      }
      /**
       * Retrieves the size of the container as a [Size]{@link Size} object.
       * This is faster than get the width and height separately.
       * @param out - Optional object to store the size in.
       * @returns - The size of the container.
       * @memberof scene.Container#
       */
      getSize(out2) {
        if (!out2) {
          out2 = {};
        }
        const bounds = this.getLocalBounds();
        out2.width = Math.abs(this.scale.x * bounds.width);
        out2.height = Math.abs(this.scale.y * bounds.height);
        return out2;
      }
      /**
       * Sets the size of the container to the specified width and height.
       * This is faster than setting the width and height separately.
       * @param value - This can be either a number or a [Size]{@link Size} object.
       * @param height - The height to set. Defaults to the value of `width` if not provided.
       * @memberof scene.Container#
       */
      setSize(value, height) {
        const size = this.getLocalBounds();
        if (typeof value === "object") {
          height = value.height ?? value.width;
          value = value.width;
        } else {
          height ?? (height = value);
        }
        value !== void 0 && this._setWidth(value, size.width);
        height !== void 0 && this._setHeight(height, size.height);
      }
      /** Called when the skew or the rotation changes. */
      _updateSkew() {
        const rotation = this._rotation;
        const skew = this._skew;
        this._cx = Math.cos(rotation + skew._y);
        this._sx = Math.sin(rotation + skew._y);
        this._cy = -Math.sin(rotation - skew._x);
        this._sy = Math.cos(rotation - skew._x);
      }
      /**
       * Updates the transform properties of the container (accepts partial values).
       * @param {object} opts - The options for updating the transform.
       * @param {number} opts.x - The x position of the container.
       * @param {number} opts.y - The y position of the container.
       * @param {number} opts.scaleX - The scale factor on the x-axis.
       * @param {number} opts.scaleY - The scale factor on the y-axis.
       * @param {number} opts.rotation - The rotation of the container, in radians.
       * @param {number} opts.skewX - The skew factor on the x-axis.
       * @param {number} opts.skewY - The skew factor on the y-axis.
       * @param {number} opts.pivotX - The x coordinate of the pivot point.
       * @param {number} opts.pivotY - The y coordinate of the pivot point.
       */
      updateTransform(opts) {
        this.position.set(
          typeof opts.x === "number" ? opts.x : this.position.x,
          typeof opts.y === "number" ? opts.y : this.position.y
        );
        this.scale.set(
          typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,
          typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y
        );
        this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
        this.skew.set(
          typeof opts.skewX === "number" ? opts.skewX : this.skew.x,
          typeof opts.skewY === "number" ? opts.skewY : this.skew.y
        );
        this.pivot.set(
          typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,
          typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y
        );
        return this;
      }
      /**
       * Updates the local transform using the given matrix.
       * @param matrix - The matrix to use for updating the transform.
       */
      setFromMatrix(matrix) {
        matrix.decompose(this);
      }
      /** Updates the local transform. */
      updateLocalTransform() {
        const localTransformChangeId = this._didContainerChangeTick;
        if (this._didLocalTransformChangeId === localTransformChangeId)
          return;
        this._didLocalTransformChangeId = localTransformChangeId;
        const lt = this.localTransform;
        const scale = this._scale;
        const pivot = this._pivot;
        const position = this._position;
        const sx = scale._x;
        const sy = scale._y;
        const px = pivot._x;
        const py = pivot._y;
        lt.a = this._cx * sx;
        lt.b = this._sx * sx;
        lt.c = this._cy * sy;
        lt.d = this._sy * sy;
        lt.tx = position._x - (px * lt.a + py * lt.c);
        lt.ty = position._y - (px * lt.b + py * lt.d);
      }
      // / ///// color related stuff
      set alpha(value) {
        if (value === this.localAlpha)
          return;
        this.localAlpha = value;
        this._updateFlags |= UPDATE_COLOR;
        this._onUpdate();
      }
      /** The opacity of the object. */
      get alpha() {
        return this.localAlpha;
      }
      set tint(value) {
        const tempColor = Color.shared.setValue(value ?? 16777215);
        const bgr = tempColor.toBgrNumber();
        if (bgr === this.localColor)
          return;
        this.localColor = bgr;
        this._updateFlags |= UPDATE_COLOR;
        this._onUpdate();
      }
      /**
       * The tint applied to the sprite. This is a hex value.
       *
       * A value of 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get tint() {
        return bgr2rgb(this.localColor);
      }
      // / //////////////// blend related stuff
      set blendMode(value) {
        if (this.localBlendMode === value)
          return;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_BLEND;
        this.localBlendMode = value;
        this._onUpdate();
      }
      /**
       * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.
       * @default 'normal'
       */
      get blendMode() {
        return this.localBlendMode;
      }
      // / ///////// VISIBILITY / RENDERABLE /////////////////
      /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */
      get visible() {
        return !!(this.localDisplayStatus & 2);
      }
      set visible(value) {
        const valueNumber = value ? 2 : 0;
        if ((this.localDisplayStatus & 2) === valueNumber)
          return;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_VISIBLE;
        this.localDisplayStatus ^= 2;
        this._onUpdate();
      }
      /** @ignore */
      get culled() {
        return !(this.localDisplayStatus & 4);
      }
      /** @ignore */
      set culled(value) {
        const valueNumber = value ? 0 : 4;
        if ((this.localDisplayStatus & 4) === valueNumber)
          return;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_VISIBLE;
        this.localDisplayStatus ^= 4;
        this._onUpdate();
      }
      /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */
      get renderable() {
        return !!(this.localDisplayStatus & 1);
      }
      set renderable(value) {
        const valueNumber = value ? 1 : 0;
        if ((this.localDisplayStatus & 1) === valueNumber)
          return;
        this._updateFlags |= UPDATE_VISIBLE;
        this.localDisplayStatus ^= 1;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
        this._onUpdate();
      }
      /** Whether or not the object should be rendered. */
      get isRenderable() {
        return this.localDisplayStatus === 7 && this.groupAlpha > 0;
      }
      /**
       * Removes all internal references and listeners as well as removes children from the display list.
       * Do not use a Container after calling `destroy`.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
       *  method called as well. 'options' will be passed on to those calls.
       * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
       * is set to true it should destroy the texture of the child sprite
       * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
       * If options.children is set to true it should destroy the texture source of the child sprite
       * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
       * If options.children is set to true it should destroy the context of the child graphics
       */
      destroy(options = false) {
        if (this.destroyed)
          return;
        this.destroyed = true;
        let oldChildren;
        if (this.children.length) {
          oldChildren = this.removeChildren(0, this.children.length);
        }
        this.removeFromParent();
        this.parent = null;
        this._maskEffect = null;
        this._filterEffect = null;
        this.effects = null;
        this._position = null;
        this._scale = null;
        this._pivot = null;
        this._skew = null;
        this.emit("destroyed", this);
        this.removeAllListeners();
        const destroyChildren = typeof options === "boolean" ? options : options?.children;
        if (destroyChildren && oldChildren) {
          for (let i3 = 0; i3 < oldChildren.length; ++i3) {
            oldChildren[i3].destroy(options);
          }
        }
        this.renderGroup?.destroy();
        this.renderGroup = null;
      }
    };
    extensions.mixin(
      Container,
      childrenHelperMixin,
      getFastGlobalBoundsMixin,
      toLocalGlobalMixin,
      onRenderMixin,
      measureMixin,
      effectsMixin,
      findMixin,
      sortMixin,
      cullingMixin,
      cacheAsTextureMixin,
      getGlobalMixin,
      collectRenderablesMixin
    );
  }
});

// node_modules/pixi.js/lib/events/FederatedEvent.mjs
var FederatedEvent;
var init_FederatedEvent = __esm({
  "node_modules/pixi.js/lib/events/FederatedEvent.mjs"() {
    init_define_AnParams();
    init_Point();
    FederatedEvent = class _FederatedEvent {
      /**
       * @param manager - The event boundary which manages this event. Propagation can only occur
       *  within the boundary's jurisdiction.
       */
      constructor(manager) {
        this.bubbles = true;
        this.cancelBubble = true;
        this.cancelable = false;
        this.composed = false;
        this.defaultPrevented = false;
        this.eventPhase = _FederatedEvent.prototype.NONE;
        this.propagationStopped = false;
        this.propagationImmediatelyStopped = false;
        this.layer = new Point();
        this.page = new Point();
        this.NONE = 0;
        this.CAPTURING_PHASE = 1;
        this.AT_TARGET = 2;
        this.BUBBLING_PHASE = 3;
        this.manager = manager;
      }
      /** @readonly */
      get layerX() {
        return this.layer.x;
      }
      /** @readonly */
      get layerY() {
        return this.layer.y;
      }
      /** @readonly */
      get pageX() {
        return this.page.x;
      }
      /** @readonly */
      get pageY() {
        return this.page.y;
      }
      /**
       * Fallback for the deprecated @code{InteractionEvent.data}.
       * @deprecated since 7.0.0
       */
      get data() {
        return this;
      }
      /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */
      composedPath() {
        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
          this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
      }
      /**
       * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.
       * @deprecated
       * @param _type
       * @param _bubbles
       * @param _cancelable
       */
      initEvent(_type, _bubbles, _cancelable) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /**
       * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.
       * @deprecated
       * @param _typeArg
       * @param _bubblesArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       */
      initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /** Prevent default behavior of PixiJS and the user agent. */
      preventDefault() {
        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
          this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = true;
      }
      /**
       * Stop this event from propagating to any addition listeners, including on the
       * {@link FederatedEventTarget.currentTarget currentTarget} and also the following
       * event targets on the propagation path.
       */
      stopImmediatePropagation() {
        this.propagationImmediatelyStopped = true;
      }
      /**
       * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners
       * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
  }
});

// node_modules/ismobilejs/esm/isMobile.js
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
var appleIphone, appleIpod, appleTablet, appleUniversal, androidPhone, androidTablet, amazonPhone, amazonTablet, windowsPhone, windowsTablet, otherBlackBerry, otherBlackBerry10, otherOpera, otherChrome, otherFirefox, isAppleTabletOnIos13;
var init_isMobile = __esm({
  "node_modules/ismobilejs/esm/isMobile.js"() {
    init_define_AnParams();
    appleIphone = /iPhone/i;
    appleIpod = /iPod/i;
    appleTablet = /iPad/i;
    appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
    androidPhone = /\bAndroid(?:.+)Mobile\b/i;
    androidTablet = /Android/i;
    amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
    amazonTablet = /Silk/i;
    windowsPhone = /Windows Phone/i;
    windowsTablet = /\bWindows(?:.+)ARM\b/i;
    otherBlackBerry = /BlackBerry/i;
    otherBlackBerry10 = /BB10/i;
    otherOpera = /Opera Mini/i;
    otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
    otherFirefox = /Mobile(?:.+)Firefox\b/i;
    isAppleTabletOnIos13 = function(navigator2) {
      return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
    };
  }
});

// node_modules/ismobilejs/esm/index.js
var init_esm = __esm({
  "node_modules/ismobilejs/esm/index.js"() {
    init_define_AnParams();
    init_isMobile();
    init_isMobile();
  }
});

// node_modules/pixi.js/lib/utils/browser/isMobile.mjs
var isMobileCall, isMobile2;
var init_isMobile2 = __esm({
  "node_modules/pixi.js/lib/utils/browser/isMobile.mjs"() {
    init_define_AnParams();
    init_esm();
    isMobileCall = isMobile.default ?? isMobile;
    isMobile2 = isMobileCall(globalThis.navigator);
  }
});

// node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs
var KEY_CODE_TAB, DIV_TOUCH_SIZE, DIV_TOUCH_POS_X, DIV_TOUCH_POS_Y, DIV_TOUCH_ZINDEX, DIV_HOOK_SIZE, DIV_HOOK_POS_X, DIV_HOOK_POS_Y, DIV_HOOK_ZINDEX, _AccessibilitySystem, AccessibilitySystem;
var init_AccessibilitySystem = __esm({
  "node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs"() {
    init_define_AnParams();
    init_FederatedEvent();
    init_Extensions();
    init_isMobile2();
    init_removeItems();
    KEY_CODE_TAB = 9;
    DIV_TOUCH_SIZE = 100;
    DIV_TOUCH_POS_X = 0;
    DIV_TOUCH_POS_Y = 0;
    DIV_TOUCH_ZINDEX = 2;
    DIV_HOOK_SIZE = 1;
    DIV_HOOK_POS_X = -1e3;
    DIV_HOOK_POS_Y = -1e3;
    DIV_HOOK_ZINDEX = 2;
    _AccessibilitySystem = class _AccessibilitySystem2 {
      // 2fps
      // eslint-disable-next-line jsdoc/require-param
      /**
       * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
       */
      constructor(renderer, _mobileInfo = isMobile2) {
        this._mobileInfo = _mobileInfo;
        this.debug = false;
        this._activateOnTab = true;
        this._deactivateOnMouseMove = true;
        this._isActive = false;
        this._isMobileAccessibility = false;
        this._div = null;
        this._pool = [];
        this._renderId = 0;
        this._children = [];
        this._androidUpdateCount = 0;
        this._androidUpdateFrequency = 500;
        this._hookDiv = null;
        if (_mobileInfo.tablet || _mobileInfo.phone) {
          this._createTouchHook();
        }
        this._renderer = renderer;
      }
      /**
       * Value of `true` if accessibility is currently active and accessibility layers are showing.
       * @member {boolean}
       * @readonly
       */
      get isActive() {
        return this._isActive;
      }
      /**
       * Value of `true` if accessibility is enabled for touch devices.
       * @member {boolean}
       * @readonly
       */
      get isMobileAccessibility() {
        return this._isMobileAccessibility;
      }
      get hookDiv() {
        return this._hookDiv;
      }
      /**
       * Creates the touch hooks.
       * @private
       */
      _createTouchHook() {
        const hookDiv = document.createElement("button");
        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.position = "absolute";
        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = "#FF0000";
        hookDiv.title = "select to enable accessibility for this content";
        hookDiv.addEventListener("focus", () => {
          this._isMobileAccessibility = true;
          this._activate();
          this._destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
      }
      /**
       * Destroys the touch hooks.
       * @private
       */
      _destroyTouchHook() {
        if (!this._hookDiv) {
          return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
      }
      /**
       * Activating will cause the Accessibility layer to be shown.
       * This is called when a user presses the tab key.
       * @private
       */
      _activate() {
        if (this._isActive) {
          return;
        }
        this._isActive = true;
        if (!this._div) {
          this._div = document.createElement("div");
          this._div.style.width = `${DIV_TOUCH_SIZE}px`;
          this._div.style.height = `${DIV_TOUCH_SIZE}px`;
          this._div.style.position = "absolute";
          this._div.style.top = `${DIV_TOUCH_POS_X}px`;
          this._div.style.left = `${DIV_TOUCH_POS_Y}px`;
          this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          this._div.style.pointerEvents = "none";
        }
        if (this._activateOnTab) {
          this._onKeyDown = this._onKeyDown.bind(this);
          globalThis.addEventListener("keydown", this._onKeyDown, false);
        }
        if (this._deactivateOnMouseMove) {
          this._onMouseMove = this._onMouseMove.bind(this);
          globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
        }
        const canvas = this._renderer.view.canvas;
        if (!canvas.parentNode) {
          const observer = new MutationObserver(() => {
            if (canvas.parentNode) {
              canvas.parentNode.appendChild(this._div);
              observer.disconnect();
              this._initAccessibilitySetup();
            }
          });
          observer.observe(document.body, { childList: true, subtree: true });
        } else {
          canvas.parentNode.appendChild(this._div);
          this._initAccessibilitySetup();
        }
      }
      // New method to handle initialization after div is ready
      _initAccessibilitySetup() {
        this._renderer.runners.postrender.add(this);
        if (this._renderer.lastObjectRendered) {
          this._updateAccessibleObjects(this._renderer.lastObjectRendered);
        }
      }
      /**
       * Deactivates the accessibility system. Removes listeners and accessibility elements.
       * @private
       */
      _deactivate() {
        if (!this._isActive || this._isMobileAccessibility) {
          return;
        }
        this._isActive = false;
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
        if (this._activateOnTab) {
          globalThis.addEventListener("keydown", this._onKeyDown, false);
        }
        this._renderer.runners.postrender.remove(this);
        for (const child of this._children) {
          if (child._accessibleDiv && child._accessibleDiv.parentNode) {
            child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
            child._accessibleDiv = null;
          }
          child._accessibleActive = false;
        }
        this._pool.forEach((div) => {
          if (div.parentNode) {
            div.parentNode.removeChild(div);
          }
        });
        if (this._div && this._div.parentNode) {
          this._div.parentNode.removeChild(this._div);
        }
        this._pool = [];
        this._children = [];
      }
      /**
       * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
       * @private
       * @param {Container} container - The Container to check.
       */
      _updateAccessibleObjects(container) {
        if (!container.visible || !container.accessibleChildren) {
          return;
        }
        if (container.accessible) {
          if (!container._accessibleActive) {
            this._addChild(container);
          }
          container._renderId = this._renderId;
        }
        const children = container.children;
        if (children) {
          for (let i3 = 0; i3 < children.length; i3++) {
            this._updateAccessibleObjects(children[i3]);
          }
        }
      }
      /**
       * Runner init called, view is available at this point.
       * @ignore
       */
      init(options) {
        const defaultOpts = _AccessibilitySystem2.defaultOptions;
        const mergedOptions = {
          accessibilityOptions: {
            ...defaultOpts,
            ...options?.accessibilityOptions || {}
          }
        };
        this.debug = mergedOptions.accessibilityOptions.debug;
        this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;
        this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;
        if (mergedOptions.accessibilityOptions.enabledByDefault) {
          this._activate();
        } else if (this._activateOnTab) {
          this._onKeyDown = this._onKeyDown.bind(this);
          globalThis.addEventListener("keydown", this._onKeyDown, false);
        }
        this._renderer.runners.postrender.remove(this);
      }
      /**
       * Updates the accessibility layer during rendering.
       * - Removes divs for containers no longer in the scene
       * - Updates the position and dimensions of the root div
       * - Updates positions of active accessibility divs
       * Only fires while the accessibility system is active.
       * @ignore
       */
      postrender() {
        const now = performance.now();
        if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
          return;
        }
        this._androidUpdateCount = now + this._androidUpdateFrequency;
        if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
          return;
        }
        const activeIds = /* @__PURE__ */ new Set();
        if (this._renderer.lastObjectRendered) {
          this._updateAccessibleObjects(this._renderer.lastObjectRendered);
          for (const child of this._children) {
            if (child._renderId === this._renderId) {
              activeIds.add(this._children.indexOf(child));
            }
          }
        }
        for (let i3 = this._children.length - 1; i3 >= 0; i3--) {
          const child = this._children[i3];
          if (!activeIds.has(i3)) {
            if (child._accessibleDiv && child._accessibleDiv.parentNode) {
              child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
              this._pool.push(child._accessibleDiv);
              child._accessibleDiv = null;
            }
            child._accessibleActive = false;
            removeItems(this._children, i3, 1);
          }
        }
        if (this._renderer.renderingToScreen) {
          const { x: x2, y: y2, width: viewWidth, height: viewHeight } = this._renderer.screen;
          const div = this._div;
          div.style.left = `${x2}px`;
          div.style.top = `${y2}px`;
          div.style.width = `${viewWidth}px`;
          div.style.height = `${viewHeight}px`;
        }
        for (let i3 = 0; i3 < this._children.length; i3++) {
          const child = this._children[i3];
          if (!child._accessibleActive || !child._accessibleDiv) {
            continue;
          }
          const div = child._accessibleDiv;
          const hitArea = child.hitArea || child.getBounds().rectangle;
          if (child.hitArea) {
            const wt = child.worldTransform;
            const sx = this._renderer.resolution;
            const sy = this._renderer.resolution;
            div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
            div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
            div.style.width = `${hitArea.width * wt.a * sx}px`;
            div.style.height = `${hitArea.height * wt.d * sy}px`;
          } else {
            this._capHitArea(hitArea);
            const sx = this._renderer.resolution;
            const sy = this._renderer.resolution;
            div.style.left = `${hitArea.x * sx}px`;
            div.style.top = `${hitArea.y * sy}px`;
            div.style.width = `${hitArea.width * sx}px`;
            div.style.height = `${hitArea.height * sy}px`;
          }
        }
        this._renderId++;
      }
      /**
       * private function that will visually add the information to the
       * accessibility div
       * @param {HTMLElement} div -
       */
      _updateDebugHTML(div) {
        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
      }
      /**
       * Adjust the hit area based on the bounds of a display object
       * @param {Rectangle} hitArea - Bounds of the child
       */
      _capHitArea(hitArea) {
        if (hitArea.x < 0) {
          hitArea.width += hitArea.x;
          hitArea.x = 0;
        }
        if (hitArea.y < 0) {
          hitArea.height += hitArea.y;
          hitArea.y = 0;
        }
        const { width: viewWidth, height: viewHeight } = this._renderer;
        if (hitArea.x + hitArea.width > viewWidth) {
          hitArea.width = viewWidth - hitArea.x;
        }
        if (hitArea.y + hitArea.height > viewHeight) {
          hitArea.height = viewHeight - hitArea.y;
        }
      }
      /**
       * Creates or reuses a div element for a Container and adds it to the accessibility layer.
       * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.
       * @private
       * @param {Container} container - The child to make accessible.
       */
      _addChild(container) {
        let div = this._pool.pop();
        if (!div) {
          if (container.accessibleType === "button") {
            div = document.createElement("button");
          } else {
            div = document.createElement(container.accessibleType);
            div.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `;
            if (container.accessibleText) {
              div.innerText = container.accessibleText;
            }
          }
          div.style.width = `${DIV_TOUCH_SIZE}px`;
          div.style.height = `${DIV_TOUCH_SIZE}px`;
          div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
          div.style.position = "absolute";
          div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          div.style.borderStyle = "none";
          if (navigator.userAgent.toLowerCase().includes("chrome")) {
            div.setAttribute("aria-live", "off");
          } else {
            div.setAttribute("aria-live", "polite");
          }
          if (navigator.userAgent.match(/rv:.*Gecko\//)) {
            div.setAttribute("aria-relevant", "additions");
          } else {
            div.setAttribute("aria-relevant", "text");
          }
          div.addEventListener("click", this._onClick.bind(this));
          div.addEventListener("focus", this._onFocus.bind(this));
          div.addEventListener("focusout", this._onFocusOut.bind(this));
        }
        div.style.pointerEvents = container.accessiblePointerEvents;
        div.type = container.accessibleType;
        if (container.accessibleTitle && container.accessibleTitle !== null) {
          div.title = container.accessibleTitle;
        } else if (!container.accessibleHint || container.accessibleHint === null) {
          div.title = `container ${container.tabIndex}`;
        }
        if (container.accessibleHint && container.accessibleHint !== null) {
          div.setAttribute("aria-label", container.accessibleHint);
        }
        if (this.debug) {
          this._updateDebugHTML(div);
        }
        container._accessibleActive = true;
        container._accessibleDiv = div;
        div.container = container;
        this._children.push(container);
        this._div.appendChild(container._accessibleDiv);
        if (container.interactive) {
          container._accessibleDiv.tabIndex = container.tabIndex;
        }
      }
      /**
       * Dispatch events with the EventSystem.
       * @param e
       * @param type
       * @private
       */
      _dispatchEvent(e2, type) {
        const { container: target } = e2.target;
        const boundary = this._renderer.events.rootBoundary;
        const event = Object.assign(new FederatedEvent(boundary), { target });
        boundary.rootTarget = this._renderer.lastObjectRendered;
        type.forEach((type2) => boundary.dispatchEvent(event, type2));
      }
      /**
       * Maps the div button press to pixi's EventSystem (click)
       * @private
       * @param {MouseEvent} e - The click event.
       */
      _onClick(e2) {
        this._dispatchEvent(e2, ["click", "pointertap", "tap"]);
      }
      /**
       * Maps the div focus events to pixi's EventSystem (mouseover)
       * @private
       * @param {FocusEvent} e - The focus event.
       */
      _onFocus(e2) {
        if (!e2.target.getAttribute("aria-live")) {
          e2.target.setAttribute("aria-live", "assertive");
        }
        this._dispatchEvent(e2, ["mouseover"]);
      }
      /**
       * Maps the div focus events to pixi's EventSystem (mouseout)
       * @private
       * @param {FocusEvent} e - The focusout event.
       */
      _onFocusOut(e2) {
        if (!e2.target.getAttribute("aria-live")) {
          e2.target.setAttribute("aria-live", "polite");
        }
        this._dispatchEvent(e2, ["mouseout"]);
      }
      /**
       * Is called when a key is pressed
       * @private
       * @param {KeyboardEvent} e - The keydown event.
       */
      _onKeyDown(e2) {
        if (e2.keyCode !== KEY_CODE_TAB || !this._activateOnTab) {
          return;
        }
        this._activate();
      }
      /**
       * Is called when the mouse moves across the renderer element
       * @private
       * @param {MouseEvent} e - The mouse event.
       */
      _onMouseMove(e2) {
        if (e2.movementX === 0 && e2.movementY === 0) {
          return;
        }
        this._deactivate();
      }
      /** Destroys the accessibility system. Removes all elements and listeners. */
      destroy() {
        this._deactivate();
        this._destroyTouchHook();
        this._div = null;
        this._pool = null;
        this._children = null;
        this._renderer = null;
        if (this._activateOnTab) {
          globalThis.removeEventListener("keydown", this._onKeyDown);
        }
      }
      /**
       * Enables or disables the accessibility system.
       * @param enabled - Whether to enable or disable accessibility.
       */
      setAccessibilityEnabled(enabled) {
        if (enabled) {
          this._activate();
        } else {
          this._deactivate();
        }
      }
    };
    _AccessibilitySystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "accessibility"
    };
    _AccessibilitySystem.defaultOptions = {
      /**
       * Whether to enable accessibility features on initialization
       * @default false
       */
      enabledByDefault: false,
      /**
       * Whether to visually show the accessibility divs for debugging
       * @default false
       */
      debug: false,
      /**
       * Whether to activate accessibility when tab key is pressed
       * @default true
       */
      activateOnTab: true,
      /**
       * Whether to deactivate accessibility when mouse moves
       * @default true
       */
      deactivateOnMouseMove: true
    };
    AccessibilitySystem = _AccessibilitySystem;
  }
});

// node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs
var accessibilityTarget;
var init_accessibilityTarget = __esm({
  "node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs"() {
    "use strict";
    init_define_AnParams();
    accessibilityTarget = {
      /**
       * Flag for if the object is accessible. If true AccessibilityManager will overlay a
       * shadow div with attributes set
       * @member {boolean}
       * @memberof scene.Container#
       */
      accessible: false,
      /**
       * Sets the title attribute of the shadow div
       * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'
       * @member {string}
       * @memberof scene.Container#
       */
      accessibleTitle: null,
      /**
       * Sets the aria-label attribute of the shadow div
       * @member {string}
       * @memberof scene.Container#
       */
      accessibleHint: null,
      /**
       * @member {number}
       * @memberof scene.Container#
       * @todo Needs docs.
       */
      tabIndex: 0,
      /**
       * @member {boolean}
       * @memberof scene.Container#
       * @private
       */
      _accessibleActive: false,
      /**
       * @memberof scene.Container#
       * @private
       */
      _accessibleDiv: null,
      /**
       * Specify the type of div the accessible layer is. Screen readers treat the element differently
       * depending on this type. Defaults to button.
       * @member {string}
       * @memberof scene.Container#
       * @default 'button'
       */
      accessibleType: "button",
      /**
       * Sets the text content of the shadow div
       * @member {string}
       * @memberof scene.Container#
       */
      accessibleText: null,
      /**
       * Specify the pointer-events the accessible div will use
       * Defaults to auto.
       * @type {PointerEvents}
       * @memberof scene.Container#
       * @default 'auto'
       */
      accessiblePointerEvents: "auto",
      /**
       * Setting to false will prevent any children inside this container to
       * be accessible. Defaults to true.
       * @member {boolean}
       * @memberof scene.Container#
       * @default true
       */
      accessibleChildren: true,
      /**
       * @member {number}
       * @memberof scene.Container#
       * @private
       */
      _renderId: -1
    };
  }
});

// node_modules/pixi.js/lib/accessibility/init.mjs
var init_init = __esm({
  "node_modules/pixi.js/lib/accessibility/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Container();
    init_AccessibilitySystem();
    init_accessibilityTarget();
    extensions.add(AccessibilitySystem);
    extensions.mixin(Container, accessibilityTarget);
  }
});

// node_modules/pixi.js/lib/app/ResizePlugin.mjs
var ResizePlugin;
var init_ResizePlugin = __esm({
  "node_modules/pixi.js/lib/app/ResizePlugin.mjs"() {
    init_define_AnParams();
    init_Extensions();
    ResizePlugin = class {
      /**
       * Initialize the plugin with scope of application instance
       * @static
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        Object.defineProperty(
          this,
          "resizeTo",
          /**
           * The HTML element or window to automatically resize the
           * renderer's view element to match width and height.
           * @member {Window|HTMLElement}
           * @name resizeTo
           * @memberof app.Application#
           */
          {
            set(dom) {
              globalThis.removeEventListener("resize", this.queueResize);
              this._resizeTo = dom;
              if (dom) {
                globalThis.addEventListener("resize", this.queueResize);
                this.resize();
              }
            },
            get() {
              return this._resizeTo;
            }
          }
        );
        this.queueResize = () => {
          if (!this._resizeTo) {
            return;
          }
          this._cancelResize();
          this._resizeId = requestAnimationFrame(() => this.resize());
        };
        this._cancelResize = () => {
          if (this._resizeId) {
            cancelAnimationFrame(this._resizeId);
            this._resizeId = null;
          }
        };
        this.resize = () => {
          if (!this._resizeTo) {
            return;
          }
          this._cancelResize();
          let width;
          let height;
          if (this._resizeTo === globalThis.window) {
            width = globalThis.innerWidth;
            height = globalThis.innerHeight;
          } else {
            const { clientWidth, clientHeight } = this._resizeTo;
            width = clientWidth;
            height = clientHeight;
          }
          this.renderer.resize(width, height);
          this.render();
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
      }
      /**
       * Clean up the ticker, scoped to application
       * @static
       * @private
       */
      static destroy() {
        globalThis.removeEventListener("resize", this.queueResize);
        this._cancelResize();
        this._cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
      }
    };
    ResizePlugin.extension = ExtensionType.Application;
  }
});

// node_modules/pixi.js/lib/ticker/const.mjs
var UPDATE_PRIORITY;
var init_const2 = __esm({
  "node_modules/pixi.js/lib/ticker/const.mjs"() {
    "use strict";
    init_define_AnParams();
    UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
      return UPDATE_PRIORITY2;
    })(UPDATE_PRIORITY || {});
  }
});

// node_modules/pixi.js/lib/ticker/TickerListener.mjs
var TickerListener;
var init_TickerListener = __esm({
  "node_modules/pixi.js/lib/ticker/TickerListener.mjs"() {
    "use strict";
    init_define_AnParams();
    TickerListener = class {
      /**
       * Constructor
       * @private
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param priority - The priority for emitting
       * @param once - If the handler should fire once
       */
      constructor(fn, context2 = null, priority = 0, once = false) {
        this.next = null;
        this.previous = null;
        this._destroyed = false;
        this._fn = fn;
        this._context = context2;
        this.priority = priority;
        this._once = once;
      }
      /**
       * Simple compare function to figure out if a function and context match.
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @returns `true` if the listener match the arguments
       */
      match(fn, context2 = null) {
        return this._fn === fn && this._context === context2;
      }
      /**
       * Emit by calling the current function.
       * @param ticker - The ticker emitting.
       * @returns Next ticker
       */
      emit(ticker) {
        if (this._fn) {
          if (this._context) {
            this._fn.call(this._context, ticker);
          } else {
            this._fn(ticker);
          }
        }
        const redirect = this.next;
        if (this._once) {
          this.destroy(true);
        }
        if (this._destroyed) {
          this.next = null;
        }
        return redirect;
      }
      /**
       * Connect to the list.
       * @param previous - Input node, previous listener
       */
      connect(previous) {
        this.previous = previous;
        if (previous.next) {
          previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
      }
      /**
       * Destroy and don't use after this.
       * @param hard - `true` to remove the `next` reference, this
       *        is considered a hard destroy. Soft destroy maintains the next reference.
       * @returns The listener to redirect while emitting or removing.
       */
      destroy(hard = false) {
        this._destroyed = true;
        this._fn = null;
        this._context = null;
        if (this.previous) {
          this.previous.next = this.next;
        }
        if (this.next) {
          this.next.previous = this.previous;
        }
        const redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
      }
    };
  }
});

// node_modules/pixi.js/lib/ticker/Ticker.mjs
var _Ticker, Ticker;
var init_Ticker = __esm({
  "node_modules/pixi.js/lib/ticker/Ticker.mjs"() {
    init_define_AnParams();
    init_const2();
    init_TickerListener();
    _Ticker = class _Ticker2 {
      constructor() {
        this.autoStart = false;
        this.deltaTime = 1;
        this.lastTime = -1;
        this.speed = 1;
        this.started = false;
        this._requestId = null;
        this._maxElapsedMS = 100;
        this._minElapsedMS = 0;
        this._protected = false;
        this._lastFrame = -1;
        this._head = new TickerListener(null, null, Infinity);
        this.deltaMS = 1 / _Ticker2.targetFPMS;
        this.elapsedMS = 1 / _Ticker2.targetFPMS;
        this._tick = (time) => {
          this._requestId = null;
          if (this.started) {
            this.update(time);
            if (this.started && this._requestId === null && this._head.next) {
              this._requestId = requestAnimationFrame(this._tick);
            }
          }
        };
      }
      /**
       * Conditionally requests a new animation frame.
       * If a frame has not already been requested, and if the internal
       * emitter has listeners, a new frame is requested.
       * @private
       */
      _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
          this.lastTime = performance.now();
          this._lastFrame = this.lastTime;
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
      /**
       * Conditionally cancels a pending animation frame.
       * @private
       */
      _cancelIfNeeded() {
        if (this._requestId !== null) {
          cancelAnimationFrame(this._requestId);
          this._requestId = null;
        }
      }
      /**
       * Conditionally requests a new animation frame.
       * If the ticker has been started it checks if a frame has not already
       * been requested, and if the internal emitter has listeners. If these
       * conditions are met, a new frame is requested. If the ticker has not
       * been started, but autoStart is `true`, then the ticker starts now,
       * and continues with the previous conditions to request a new frame.
       * @private
       */
      _startIfPossible() {
        if (this.started) {
          this._requestIfNeeded();
        } else if (this.autoStart) {
          this.start();
        }
      }
      /**
       * Register a handler for tick events. Calls continuously unless
       * it is removed or the ticker is stopped.
       * @param fn - The listener function to be added for updates
       * @param context - The listener context
       * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
       * @returns This instance of a ticker
       */
      add(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
        return this._addListener(new TickerListener(fn, context2, priority));
      }
      /**
       * Add a handler for the tick event which is only execute once.
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
       * @returns This instance of a ticker
       */
      addOnce(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
        return this._addListener(new TickerListener(fn, context2, priority, true));
      }
      /**
       * Internally adds the event handler so that it can be sorted by priority.
       * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
       * before the rendering.
       * @private
       * @param listener - Current listener being added.
       * @returns This instance of a ticker
       */
      _addListener(listener) {
        let current = this._head.next;
        let previous = this._head;
        if (!current) {
          listener.connect(previous);
        } else {
          while (current) {
            if (listener.priority > current.priority) {
              listener.connect(previous);
              break;
            }
            previous = current;
            current = current.next;
          }
          if (!listener.previous) {
            listener.connect(previous);
          }
        }
        this._startIfPossible();
        return this;
      }
      /**
       * Removes any handlers matching the function and context parameters.
       * If no handlers are left after removing, then it cancels the animation frame.
       * @param fn - The listener function to be removed
       * @param context - The listener context to be removed
       * @returns This instance of a ticker
       */
      remove(fn, context2) {
        let listener = this._head.next;
        while (listener) {
          if (listener.match(fn, context2)) {
            listener = listener.destroy();
          } else {
            listener = listener.next;
          }
        }
        if (!this._head.next) {
          this._cancelIfNeeded();
        }
        return this;
      }
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get count() {
        if (!this._head) {
          return 0;
        }
        let count2 = 0;
        let current = this._head;
        while (current = current.next) {
          count2++;
        }
        return count2;
      }
      /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
      start() {
        if (!this.started) {
          this.started = true;
          this._requestIfNeeded();
        }
      }
      /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
      stop() {
        if (this.started) {
          this.started = false;
          this._cancelIfNeeded();
        }
      }
      /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
      destroy() {
        if (!this._protected) {
          this.stop();
          let listener = this._head.next;
          while (listener) {
            listener = listener.destroy(true);
          }
          this._head.destroy();
          this._head = null;
        }
      }
      /**
       * Triggers an update. An update entails setting the
       * current {@link ticker.Ticker#elapsedMS|elapsedMS},
       * the current {@link ticker.Ticker#deltaTime|deltaTime},
       * invoking all listeners with current deltaTime,
       * and then finally setting {@link ticker.Ticker#lastTime|lastTime}
       * with the value of currentTime that was provided.
       * This method will be called automatically by animation
       * frame callbacks if the ticker instance has been started
       * and listeners are added.
       * @param {number} [currentTime=performance.now()] - the current time of execution
       */
      update(currentTime = performance.now()) {
        let elapsedMS;
        if (currentTime > this.lastTime) {
          elapsedMS = this.elapsedMS = currentTime - this.lastTime;
          if (elapsedMS > this._maxElapsedMS) {
            elapsedMS = this._maxElapsedMS;
          }
          elapsedMS *= this.speed;
          if (this._minElapsedMS) {
            const delta = currentTime - this._lastFrame | 0;
            if (delta < this._minElapsedMS) {
              return;
            }
            this._lastFrame = currentTime - delta % this._minElapsedMS;
          }
          this.deltaMS = elapsedMS;
          this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;
          const head = this._head;
          let listener = head.next;
          while (listener) {
            listener = listener.emit(this);
          }
          if (!head.next) {
            this._cancelIfNeeded();
          }
        } else {
          this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
      }
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link ticker.Ticker#speed|speed}, which is specific
       * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.
       * @member {number}
       * @readonly
       */
      get FPS() {
        return 1e3 / this.elapsedMS;
      }
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link ticker.Ticker#update|update}.
       * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},
       * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `Ticker.targetFPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get minFPS() {
        return 1e3 / this._maxElapsedMS;
      }
      set minFPS(fps) {
        const minFPS = Math.min(this.maxFPS, fps);
        const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);
        this._maxElapsedMS = 1 / minFPMS;
      }
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link ticker.Ticker#update|update}.
       * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get maxFPS() {
        if (this._minElapsedMS) {
          return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
      }
      set maxFPS(fps) {
        if (fps === 0) {
          this._minElapsedMS = 0;
        } else {
          const maxFPS = Math.max(this.minFPS, fps);
          this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
      }
      /**
       * The shared ticker instance used by {@link AnimatedSprite} and by
       * {@link VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * import { Ticker } from 'pixi.js';
       *
       * const ticker = Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the Ticker.shared instance.
       * ticker.autoStart = false;
       *
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       *
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * import { autoDetectRenderer, Container } from 'pixi.js';
       *
       * // You may use the shared ticker to render...
       * const renderer = autoDetectRenderer();
       * const stage = new Container();
       * document.body.appendChild(renderer.view);
       * ticker.add((time) => renderer.render(stage));
       *
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * const animate = (time) => {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * };
       * animate(performance.now());
       * @member {ticker.Ticker}
       * @readonly
       * @static
       */
      static get shared() {
        if (!_Ticker2._shared) {
          const shared = _Ticker2._shared = new _Ticker2();
          shared.autoStart = true;
          shared._protected = true;
        }
        return _Ticker2._shared;
      }
      /**
       * The system ticker instance used by {@link BasePrepare} for core timing
       * functionality that shouldn't usually need to be paused, unlike the `shared`
       * ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
       * @member {ticker.Ticker}
       * @readonly
       * @static
       */
      static get system() {
        if (!_Ticker2._system) {
          const system = _Ticker2._system = new _Ticker2();
          system.autoStart = true;
          system._protected = true;
        }
        return _Ticker2._system;
      }
    };
    _Ticker.targetFPMS = 0.06;
    Ticker = _Ticker;
  }
});

// node_modules/pixi.js/lib/app/TickerPlugin.mjs
var TickerPlugin;
var init_TickerPlugin = __esm({
  "node_modules/pixi.js/lib/app/TickerPlugin.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_const2();
    init_Ticker();
    TickerPlugin = class {
      /**
       * Initialize the plugin with scope of application instance
       * @static
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        options = Object.assign({
          autoStart: true,
          sharedTicker: false
        }, options);
        Object.defineProperty(
          this,
          "ticker",
          {
            set(ticker) {
              if (this._ticker) {
                this._ticker.remove(this.render, this);
              }
              this._ticker = ticker;
              if (ticker) {
                ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
              }
            },
            get() {
              return this._ticker;
            }
          }
        );
        this.stop = () => {
          this._ticker.stop();
        };
        this.start = () => {
          this._ticker.start();
        };
        this._ticker = null;
        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
        if (options.autoStart) {
          this.start();
        }
      }
      /**
       * Clean up the ticker, scoped to application.
       * @static
       * @private
       */
      static destroy() {
        if (this._ticker) {
          const oldTicker = this._ticker;
          this.ticker = null;
          oldTicker.destroy();
        }
      }
    };
    TickerPlugin.extension = ExtensionType.Application;
  }
});

// node_modules/pixi.js/lib/app/init.mjs
var init_init2 = __esm({
  "node_modules/pixi.js/lib/app/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_ResizePlugin();
    init_TickerPlugin();
    extensions.add(ResizePlugin);
    extensions.add(TickerPlugin);
  }
});

// node_modules/pixi.js/lib/events/EventTicker.mjs
var EventsTickerClass, EventsTicker;
var init_EventTicker = __esm({
  "node_modules/pixi.js/lib/events/EventTicker.mjs"() {
    init_define_AnParams();
    init_const2();
    init_Ticker();
    EventsTickerClass = class {
      constructor() {
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
      }
      /**
       * Initializes the event ticker.
       * @param events - The event system.
       */
      init(events) {
        this.removeTickerListener();
        this.events = events;
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
      }
      /** Whether to pause the update checks or not. */
      get pauseUpdate() {
        return this._pauseUpdate;
      }
      set pauseUpdate(paused) {
        this._pauseUpdate = paused;
      }
      /** Adds the ticker listener. */
      addTickerListener() {
        if (this._tickerAdded || !this.domElement) {
          return;
        }
        Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
        this._tickerAdded = true;
      }
      /** Removes the ticker listener. */
      removeTickerListener() {
        if (!this._tickerAdded) {
          return;
        }
        Ticker.system.remove(this._tickerUpdate, this);
        this._tickerAdded = false;
      }
      /** Sets flag to not fire extra events when the user has already moved there mouse */
      pointerMoved() {
        this._didMove = true;
      }
      /** Updates the state of interactive objects. */
      _update() {
        if (!this.domElement || this._pauseUpdate) {
          return;
        }
        if (this._didMove) {
          this._didMove = false;
          return;
        }
        const rootPointerEvent = this.events["_rootPointerEvent"];
        if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
          return;
        }
        globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
          clientX: rootPointerEvent.clientX,
          clientY: rootPointerEvent.clientY,
          pointerType: rootPointerEvent.pointerType,
          pointerId: rootPointerEvent.pointerId
        }));
      }
      /**
       * Updates the state of interactive objects if at least {@link interactionFrequency}
       * milliseconds have passed since the last invocation.
       *
       * Invoked by a throttled ticker update from {@link Ticker.system}.
       * @param ticker - The throttled ticker.
       */
      _tickerUpdate(ticker) {
        this._deltaTime += ticker.deltaTime;
        if (this._deltaTime < this.interactionFrequency) {
          return;
        }
        this._deltaTime = 0;
        this._update();
      }
    };
    EventsTicker = new EventsTickerClass();
  }
});

// node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs
var FederatedMouseEvent;
var init_FederatedMouseEvent = __esm({
  "node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs"() {
    init_define_AnParams();
    init_Point();
    init_FederatedEvent();
    FederatedMouseEvent = class extends FederatedEvent {
      constructor() {
        super(...arguments);
        this.client = new Point();
        this.movement = new Point();
        this.offset = new Point();
        this.global = new Point();
        this.screen = new Point();
      }
      /** @readonly */
      get clientX() {
        return this.client.x;
      }
      /** @readonly */
      get clientY() {
        return this.client.y;
      }
      /**
       * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
       * @readonly
       */
      get x() {
        return this.clientX;
      }
      /**
       * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
       * @readonly
       */
      get y() {
        return this.clientY;
      }
      /** @readonly */
      get movementX() {
        return this.movement.x;
      }
      /** @readonly */
      get movementY() {
        return this.movement.y;
      }
      /** @readonly */
      get offsetX() {
        return this.offset.x;
      }
      /** @readonly */
      get offsetY() {
        return this.offset.y;
      }
      /** @readonly */
      get globalX() {
        return this.global.x;
      }
      /** @readonly */
      get globalY() {
        return this.global.y;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
       * @readonly
       */
      get screenX() {
        return this.screen.x;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
       * @readonly
       */
      get screenY() {
        return this.screen.y;
      }
      /**
       * This will return the local coordinates of the specified container for this InteractionData
       * @param {Container} container - The Container that you would like the local
       *  coords off
       * @param {PointData} point - A Point object in which to store the value, optional (otherwise
       *  will create a new point)
       * @param {PointData} globalPos - A Point object containing your custom global coords, optional
       *  (otherwise will use the current global coords)
       * @returns - A point containing the coordinates of the InteractionData position relative
       *  to the Container
       */
      getLocalPosition(container, point, globalPos) {
        return container.worldTransform.applyInverse(globalPos || this.global, point);
      }
      /**
       * Whether the modifier key was pressed when this event natively occurred.
       * @param key - The modifier key.
       */
      getModifierState(key) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
      }
      /**
       * Not supported.
       * @param _typeArg
       * @param _canBubbleArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       * @param _screenXArg
       * @param _screenYArg
       * @param _clientXArg
       * @param _clientYArg
       * @param _ctrlKeyArg
       * @param _altKeyArg
       * @param _shiftKeyArg
       * @param _metaKeyArg
       * @param _buttonArg
       * @param _relatedTargetArg
       * @deprecated since 7.0.0
       */
      // eslint-disable-next-line max-params
      initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
        throw new Error("Method not implemented.");
      }
    };
  }
});

// node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs
var FederatedPointerEvent;
var init_FederatedPointerEvent = __esm({
  "node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs"() {
    init_define_AnParams();
    init_FederatedMouseEvent();
    FederatedPointerEvent = class extends FederatedMouseEvent {
      constructor() {
        super(...arguments);
        this.width = 0;
        this.height = 0;
        this.isPrimary = false;
      }
      // Only included for completeness for now
      getCoalescedEvents() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
          return [this];
        }
        return [];
      }
      // Only included for completeness for now
      getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
      }
    };
  }
});

// node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs
var FederatedWheelEvent;
var init_FederatedWheelEvent = __esm({
  "node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs"() {
    init_define_AnParams();
    init_FederatedMouseEvent();
    FederatedWheelEvent = class extends FederatedMouseEvent {
      constructor() {
        super(...arguments);
        this.DOM_DELTA_PIXEL = 0;
        this.DOM_DELTA_LINE = 1;
        this.DOM_DELTA_PAGE = 2;
      }
    };
    FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
    FederatedWheelEvent.DOM_DELTA_LINE = 1;
    FederatedWheelEvent.DOM_DELTA_PAGE = 2;
  }
});

// node_modules/pixi.js/lib/events/EventBoundary.mjs
var PROPAGATION_LIMIT, tempHitLocation, tempLocalMapping, EventBoundary;
var init_EventBoundary = __esm({
  "node_modules/pixi.js/lib/events/EventBoundary.mjs"() {
    init_define_AnParams();
    init_eventemitter3();
    init_Point();
    init_warn();
    init_EventTicker();
    init_FederatedMouseEvent();
    init_FederatedPointerEvent();
    init_FederatedWheelEvent();
    PROPAGATION_LIMIT = 2048;
    tempHitLocation = new Point();
    tempLocalMapping = new Point();
    EventBoundary = class {
      /**
       * @param rootTarget - The holder of the event boundary.
       */
      constructor(rootTarget) {
        this.dispatch = new eventemitter3_default();
        this.moveOnAll = false;
        this.enableGlobalMoveEvents = true;
        this.mappingState = {
          trackingData: {}
        };
        this.eventPool = /* @__PURE__ */ new Map();
        this._allInteractiveElements = [];
        this._hitElements = [];
        this._isPointerMoveEvent = false;
        this.rootTarget = rootTarget;
        this.hitPruneFn = this.hitPruneFn.bind(this);
        this.hitTestFn = this.hitTestFn.bind(this);
        this.mapPointerDown = this.mapPointerDown.bind(this);
        this.mapPointerMove = this.mapPointerMove.bind(this);
        this.mapPointerOut = this.mapPointerOut.bind(this);
        this.mapPointerOver = this.mapPointerOver.bind(this);
        this.mapPointerUp = this.mapPointerUp.bind(this);
        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
        this.mapWheel = this.mapWheel.bind(this);
        this.mappingTable = {};
        this.addEventMapping("pointerdown", this.mapPointerDown);
        this.addEventMapping("pointermove", this.mapPointerMove);
        this.addEventMapping("pointerout", this.mapPointerOut);
        this.addEventMapping("pointerleave", this.mapPointerOut);
        this.addEventMapping("pointerover", this.mapPointerOver);
        this.addEventMapping("pointerup", this.mapPointerUp);
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
        this.addEventMapping("wheel", this.mapWheel);
      }
      /**
       * Adds an event mapping for the event `type` handled by `fn`.
       *
       * Event mappings can be used to implement additional or custom events. They take an event
       * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
       * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
       *
       * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
       * instead.
       * @param type - The type of upstream event to map.
       * @param fn - The mapping method. The context of this function must be bound manually, if desired.
       */
      addEventMapping(type, fn) {
        if (!this.mappingTable[type]) {
          this.mappingTable[type] = [];
        }
        this.mappingTable[type].push({
          fn,
          priority: 0
        });
        this.mappingTable[type].sort((a2, b3) => a2.priority - b3.priority);
      }
      /**
       * Dispatches the given event
       * @param e - The event to dispatch.
       * @param type - The type of event to dispatch. Defaults to `e.type`.
       */
      dispatchEvent(e2, type) {
        e2.propagationStopped = false;
        e2.propagationImmediatelyStopped = false;
        this.propagate(e2, type);
        this.dispatch.emit(type || e2.type, e2);
      }
      /**
       * Maps the given upstream event through the event boundary and propagates it downstream.
       * @param e - The event to map.
       */
      mapEvent(e2) {
        if (!this.rootTarget) {
          return;
        }
        const mappers = this.mappingTable[e2.type];
        if (mappers) {
          for (let i3 = 0, j2 = mappers.length; i3 < j2; i3++) {
            mappers[i3].fn(e2);
          }
        } else {
          warn(`[EventBoundary]: Event mapping not defined for ${e2.type}`);
        }
      }
      /**
       * Finds the Container that is the target of a event at the given coordinates.
       *
       * The passed (x,y) coordinates are in the world space above this event boundary.
       * @param x - The x coordinate of the event.
       * @param y - The y coordinate of the event.
       */
      hitTest(x2, y2) {
        EventsTicker.pauseUpdate = true;
        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
        const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
        const invertedPath = this[fn](
          this.rootTarget,
          this.rootTarget.eventMode,
          tempHitLocation.set(x2, y2),
          this.hitTestFn,
          this.hitPruneFn
        );
        return invertedPath && invertedPath[0];
      }
      /**
       * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
       * target {@code e.target}.
       * @param e - The event to propagate.
       * @param type - The type of event to propagate. Defaults to `e.type`.
       */
      propagate(e2, type) {
        if (!e2.target) {
          return;
        }
        const composedPath = e2.composedPath();
        e2.eventPhase = e2.CAPTURING_PHASE;
        for (let i3 = 0, j2 = composedPath.length - 1; i3 < j2; i3++) {
          e2.currentTarget = composedPath[i3];
          this.notifyTarget(e2, type);
          if (e2.propagationStopped || e2.propagationImmediatelyStopped)
            return;
        }
        e2.eventPhase = e2.AT_TARGET;
        e2.currentTarget = e2.target;
        this.notifyTarget(e2, type);
        if (e2.propagationStopped || e2.propagationImmediatelyStopped)
          return;
        e2.eventPhase = e2.BUBBLING_PHASE;
        for (let i3 = composedPath.length - 2; i3 >= 0; i3--) {
          e2.currentTarget = composedPath[i3];
          this.notifyTarget(e2, type);
          if (e2.propagationStopped || e2.propagationImmediatelyStopped)
            return;
        }
      }
      /**
       * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.
       *
       * This is used in the `globalpointermove` event.
       * @param e - The emitted event.
       * @param type - The listeners to notify.
       * @param targets - The targets to notify.
       */
      all(e2, type, targets = this._allInteractiveElements) {
        if (targets.length === 0)
          return;
        e2.eventPhase = e2.BUBBLING_PHASE;
        const events = Array.isArray(type) ? type : [type];
        for (let i3 = targets.length - 1; i3 >= 0; i3--) {
          events.forEach((event) => {
            e2.currentTarget = targets[i3];
            this.notifyTarget(e2, event);
          });
        }
      }
      /**
       * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
       * {@code target}. The last element in the path is {@code target}.
       * @param target - The target to find the propagation path to.
       */
      propagationPath(target) {
        const propagationPath = [target];
        for (let i3 = 0; i3 < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i3++) {
          if (!target.parent) {
            throw new Error("Cannot find propagation path to disconnected target");
          }
          propagationPath.push(target.parent);
          target = target.parent;
        }
        propagationPath.reverse();
        return propagationPath;
      }
      hitTestMoveRecursive(currentTarget, eventMode, location2, testFn, pruneFn, ignore = false) {
        let shouldReturn = false;
        if (this._interactivePrune(currentTarget))
          return null;
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children = currentTarget.children;
          for (let i3 = children.length - 1; i3 >= 0; i3--) {
            const child = children[i3];
            const nestedHit = this.hitTestMoveRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              location2,
              testFn,
              pruneFn,
              ignore || pruneFn(currentTarget, location2)
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive) {
                if (isInteractive)
                  this._allInteractiveElements.push(currentTarget);
                nestedHit.push(currentTarget);
              }
              if (this._hitElements.length === 0)
                this._hitElements = nestedHit;
              shouldReturn = true;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveTarget && isInteractiveTarget)
          this._allInteractiveElements.push(currentTarget);
        if (ignore || this._hitElements.length > 0)
          return null;
        if (shouldReturn)
          return this._hitElements;
        if (isInteractiveMode && (!pruneFn(currentTarget, location2) && testFn(currentTarget, location2))) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      /**
       * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
       * @param currentTarget - The Container that is to be hit tested.
       * @param eventMode - The event mode for the `currentTarget` or one of its parents.
       * @param location - The location that is being tested for overlap.
       * @param testFn - Callback that determines whether the target passes hit testing. This callback
       *  can assume that `pruneFn` failed to prune the container.
       * @param pruneFn - Callback that determiness whether the target and all of its children
       *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
       *  of the scene graph.
       * @returns An array holding the hit testing target and all its ancestors in order. The first element
       *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
       *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
       */
      hitTestRecursive(currentTarget, eventMode, location2, testFn, pruneFn) {
        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location2)) {
          return null;
        }
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children = currentTarget.children;
          const relativeLocation = location2;
          for (let i3 = children.length - 1; i3 >= 0; i3--) {
            const child = children[i3];
            const nestedHit = this.hitTestRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              relativeLocation,
              testFn,
              pruneFn
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive)
                nestedHit.push(currentTarget);
              return nestedHit;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveMode && testFn(currentTarget, location2)) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      _isInteractive(int) {
        return int === "static" || int === "dynamic";
      }
      _interactivePrune(container) {
        if (!container || !container.visible || !container.renderable || !container.measurable) {
          return true;
        }
        if (container.eventMode === "none") {
          return true;
        }
        if (container.eventMode === "passive" && !container.interactiveChildren) {
          return true;
        }
        return false;
      }
      /**
       * Checks whether the container or any of its children cannot pass the hit test at all.
       *
       * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
       * and {@link Container._maskEffect} for pruning.
       * @param container - The container to prune.
       * @param location - The location to test for overlap.
       */
      hitPruneFn(container, location2) {
        if (container.hitArea) {
          container.worldTransform.applyInverse(location2, tempLocalMapping);
          if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
            return true;
          }
        }
        if (container.effects && container.effects.length) {
          for (let i3 = 0; i3 < container.effects.length; i3++) {
            const effect = container.effects[i3];
            if (effect.containsPoint) {
              const effectContainsPoint = effect.containsPoint(location2, this.hitTestFn);
              if (!effectContainsPoint) {
                return true;
              }
            }
          }
        }
        return false;
      }
      /**
       * Checks whether the container passes hit testing for the given location.
       * @param container - The container to test.
       * @param location - The location to test for overlap.
       * @returns - Whether `container` passes hit testing for `location`.
       */
      hitTestFn(container, location2) {
        if (container.hitArea) {
          return true;
        }
        if (container?.containsPoint) {
          container.worldTransform.applyInverse(location2, tempLocalMapping);
          return container.containsPoint(tempLocalMapping);
        }
        return false;
      }
      /**
       * Notify all the listeners to the event's `currentTarget`.
       *
       * If the `currentTarget` contains the property `on<type>`, then it is called here,
       * simulating the behavior from version 6.x and prior.
       * @param e - The event passed to the target.
       * @param type - The type of event to notify. Defaults to `e.type`.
       */
      notifyTarget(e2, type) {
        if (!e2.currentTarget.isInteractive()) {
          return;
        }
        type ?? (type = e2.type);
        const handlerKey = `on${type}`;
        e2.currentTarget[handlerKey]?.(e2);
        const key = e2.eventPhase === e2.CAPTURING_PHASE || e2.eventPhase === e2.AT_TARGET ? `${type}capture` : type;
        this._notifyListeners(e2, key);
        if (e2.eventPhase === e2.AT_TARGET) {
          this._notifyListeners(e2, type);
        }
      }
      /**
       * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
       *
       * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
       * @param from - The upstream `pointerdown` event.
       */
      mapPointerDown(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const e2 = this.createPointerEvent(from);
        this.dispatchEvent(e2, "pointerdown");
        if (e2.pointerType === "touch") {
          this.dispatchEvent(e2, "touchstart");
        } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
          const isRightButton = e2.button === 2;
          this.dispatchEvent(e2, isRightButton ? "rightdown" : "mousedown");
        }
        const trackingData = this.trackingData(from.pointerId);
        trackingData.pressTargetsByButton[from.button] = e2.composedPath();
        this.freeEvent(e2);
      }
      /**
       * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
       *
       * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
       * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
       * @param from - The upstream `pointermove` event.
       */
      mapPointerMove(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        this._isPointerMoveEvent = true;
        const e2 = this.createPointerEvent(from);
        this._isPointerMoveEvent = false;
        const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
        const trackingData = this.trackingData(from.pointerId);
        const outTarget = this.findMountedTarget(trackingData.overTargets);
        if (trackingData.overTargets?.length > 0 && outTarget !== e2.target) {
          const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
          const outEvent = this.createPointerEvent(from, outType, outTarget);
          this.dispatchEvent(outEvent, "pointerout");
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          if (!e2.composedPath().includes(outTarget)) {
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && !e2.composedPath().includes(leaveEvent.target)) {
              leaveEvent.currentTarget = leaveEvent.target;
              this.notifyTarget(leaveEvent);
              if (isMouse)
                this.notifyTarget(leaveEvent, "mouseleave");
              leaveEvent.target = leaveEvent.target.parent;
            }
            this.freeEvent(leaveEvent);
          }
          this.freeEvent(outEvent);
        }
        if (outTarget !== e2.target) {
          const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
          const overEvent = this.clonePointerEvent(e2, overType);
          this.dispatchEvent(overEvent, "pointerover");
          if (isMouse)
            this.dispatchEvent(overEvent, "mouseover");
          let overTargetAncestor = outTarget?.parent;
          while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
            if (overTargetAncestor === e2.target)
              break;
            overTargetAncestor = overTargetAncestor.parent;
          }
          const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
          if (didPointerEnter) {
            const enterEvent = this.clonePointerEvent(e2, "pointerenter");
            enterEvent.eventPhase = enterEvent.AT_TARGET;
            while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
              enterEvent.currentTarget = enterEvent.target;
              this.notifyTarget(enterEvent);
              if (isMouse)
                this.notifyTarget(enterEvent, "mouseenter");
              enterEvent.target = enterEvent.target.parent;
            }
            this.freeEvent(enterEvent);
          }
          this.freeEvent(overEvent);
        }
        const allMethods = [];
        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
        this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e2, "pointermove");
        allowGlobalPointerEvents && allMethods.push("globalpointermove");
        if (e2.pointerType === "touch") {
          this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e2, "touchmove");
          allowGlobalPointerEvents && allMethods.push("globaltouchmove");
        }
        if (isMouse) {
          this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e2, "mousemove");
          allowGlobalPointerEvents && allMethods.push("globalmousemove");
          this.cursor = e2.target?.cursor;
        }
        if (allMethods.length > 0) {
          this.all(e2, allMethods);
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        trackingData.overTargets = e2.composedPath();
        this.freeEvent(e2);
      }
      /**
       * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
       *
       * The tracking data for the specific pointer gets a new `overTarget`.
       * @param from - The upstream `pointerover` event.
       */
      mapPointerOver(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const e2 = this.createPointerEvent(from);
        const isMouse = e2.pointerType === "mouse" || e2.pointerType === "pen";
        this.dispatchEvent(e2, "pointerover");
        if (isMouse)
          this.dispatchEvent(e2, "mouseover");
        if (e2.pointerType === "mouse")
          this.cursor = e2.target?.cursor;
        const enterEvent = this.clonePointerEvent(e2, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        trackingData.overTargets = e2.composedPath();
        this.freeEvent(e2);
        this.freeEvent(enterEvent);
      }
      /**
       * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
       *
       * The tracking data for the specific pointer is cleared of a `overTarget`.
       * @param from - The upstream `pointerout` event.
       */
      mapPointerOut(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        if (trackingData.overTargets) {
          const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
          this.dispatchEvent(outEvent);
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
            leaveEvent.currentTarget = leaveEvent.target;
            this.notifyTarget(leaveEvent);
            if (isMouse)
              this.notifyTarget(leaveEvent, "mouseleave");
            leaveEvent.target = leaveEvent.target.parent;
          }
          trackingData.overTargets = null;
          this.freeEvent(outEvent);
          this.freeEvent(leaveEvent);
        }
        this.cursor = null;
      }
      /**
       * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
       * and `click`/`rightclick`/`pointertap` events, in that order.
       *
       * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
       * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
       * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
       * specific pointer types.
       * @param from - The upstream `pointerup` event.
       */
      mapPointerUp(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const now = performance.now();
        const e2 = this.createPointerEvent(from);
        this.dispatchEvent(e2, "pointerup");
        if (e2.pointerType === "touch") {
          this.dispatchEvent(e2, "touchend");
        } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
          const isRightButton = e2.button === 2;
          this.dispatchEvent(e2, isRightButton ? "rightup" : "mouseup");
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        let clickTarget = pressTarget;
        if (pressTarget && !e2.composedPath().includes(pressTarget)) {
          let currentTarget = pressTarget;
          while (currentTarget && !e2.composedPath().includes(currentTarget)) {
            e2.currentTarget = currentTarget;
            this.notifyTarget(e2, "pointerupoutside");
            if (e2.pointerType === "touch") {
              this.notifyTarget(e2, "touchendoutside");
            } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
              const isRightButton = e2.button === 2;
              this.notifyTarget(e2, isRightButton ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
          clickTarget = currentTarget;
        }
        if (clickTarget) {
          const clickEvent = this.clonePointerEvent(e2, "click");
          clickEvent.target = clickTarget;
          clickEvent.path = null;
          if (!trackingData.clicksByButton[from.button]) {
            trackingData.clicksByButton[from.button] = {
              clickCount: 0,
              target: clickEvent.target,
              timeStamp: now
            };
          }
          const clickHistory = trackingData.clicksByButton[from.button];
          if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
            ++clickHistory.clickCount;
          } else {
            clickHistory.clickCount = 1;
          }
          clickHistory.target = clickEvent.target;
          clickHistory.timeStamp = now;
          clickEvent.detail = clickHistory.clickCount;
          if (clickEvent.pointerType === "mouse") {
            const isRightButton = clickEvent.button === 2;
            this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
          } else if (clickEvent.pointerType === "touch") {
            this.dispatchEvent(clickEvent, "tap");
          }
          this.dispatchEvent(clickEvent, "pointertap");
          this.freeEvent(clickEvent);
        }
        this.freeEvent(e2);
      }
      /**
       * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
       * `pointerdown` target to `rootTarget`.
       *
       * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
       * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
       *
       * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
       * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
       * @param from - The upstream `pointerupoutside` event.
       */
      mapPointerUpOutside(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        const e2 = this.createPointerEvent(from);
        if (pressTarget) {
          let currentTarget = pressTarget;
          while (currentTarget) {
            e2.currentTarget = currentTarget;
            this.notifyTarget(e2, "pointerupoutside");
            if (e2.pointerType === "touch") {
              this.notifyTarget(e2, "touchendoutside");
            } else if (e2.pointerType === "mouse" || e2.pointerType === "pen") {
              this.notifyTarget(e2, e2.button === 2 ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
        }
        this.freeEvent(e2);
      }
      /**
       * Maps the upstream `wheel` event to a downstream `wheel` event.
       * @param from - The upstream `wheel` event.
       */
      mapWheel(from) {
        if (!(from instanceof FederatedWheelEvent)) {
          warn("EventBoundary cannot map a non-wheel event as a wheel event");
          return;
        }
        const wheelEvent = this.createWheelEvent(from);
        this.dispatchEvent(wheelEvent);
        this.freeEvent(wheelEvent);
      }
      /**
       * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
       *
       * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
       * or `pointerover` target was unmounted from the scene graph.
       * @param propagationPath - The propagation path was valid in the past.
       * @returns - The most specific event-target still mounted at the same location in the scene graph.
       */
      findMountedTarget(propagationPath) {
        if (!propagationPath) {
          return null;
        }
        let currentTarget = propagationPath[0];
        for (let i3 = 1; i3 < propagationPath.length; i3++) {
          if (propagationPath[i3].parent === currentTarget) {
            currentTarget = propagationPath[i3];
          } else {
            break;
          }
        }
        return currentTarget;
      }
      /**
       * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The {@code originalEvent} for the returned event.
       * @param [type=from.type] - The type of the returned event.
       * @param target - The target of the returned event.
       */
      createPointerEvent(from, type, target) {
        const event = this.allocateEvent(FederatedPointerEvent);
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
        if (typeof type === "string") {
          event.type = type;
        }
        return event;
      }
      /**
       * Creates a wheel event whose {@code originalEvent} is {@code from}.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The upstream wheel event.
       */
      createWheelEvent(from) {
        const event = this.allocateEvent(FederatedWheelEvent);
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = this.hitTest(event.global.x, event.global.y);
        return event;
      }
      /**
       * Clones the event {@code from}, with an optional {@code type} override.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The event to clone.
       * @param [type=from.type] - The type of the returned event.
       */
      clonePointerEvent(from, type) {
        const event = this.allocateEvent(FederatedPointerEvent);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = type ?? event.type;
        return event;
      }
      /**
       * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + deltaMode
       * + deltaX
       * + deltaY
       * + deltaZ
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyWheelData(from, to) {
        to.deltaMode = from.deltaMode;
        to.deltaX = from.deltaX;
        to.deltaY = from.deltaY;
        to.deltaZ = from.deltaZ;
      }
      /**
       * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + pointerId
       * + width
       * + height
       * + isPrimary
       * + pointerType
       * + pressure
       * + tangentialPressure
       * + tiltX
       * + tiltY
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyPointerData(from, to) {
        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
          return;
        to.pointerId = from.pointerId;
        to.width = from.width;
        to.height = from.height;
        to.isPrimary = from.isPrimary;
        to.pointerType = from.pointerType;
        to.pressure = from.pressure;
        to.tangentialPressure = from.tangentialPressure;
        to.tiltX = from.tiltX;
        to.tiltY = from.tiltY;
        to.twist = from.twist;
      }
      /**
       * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.
       *
       * The following properties are copied:
       * + altKey
       * + button
       * + buttons
       * + clientX
       * + clientY
       * + metaKey
       * + movementX
       * + movementY
       * + pageX
       * + pageY
       * + x
       * + y
       * + screen
       * + shiftKey
       * + global
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyMouseData(from, to) {
        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
          return;
        to.altKey = from.altKey;
        to.button = from.button;
        to.buttons = from.buttons;
        to.client.copyFrom(from.client);
        to.ctrlKey = from.ctrlKey;
        to.metaKey = from.metaKey;
        to.movement.copyFrom(from.movement);
        to.screen.copyFrom(from.screen);
        to.shiftKey = from.shiftKey;
        to.global.copyFrom(from.global);
      }
      /**
       * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + isTrusted
       * + srcElement
       * + timeStamp
       * + type
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyData(from, to) {
        to.isTrusted = from.isTrusted;
        to.srcElement = from.srcElement;
        to.timeStamp = performance.now();
        to.type = from.type;
        to.detail = from.detail;
        to.view = from.view;
        to.which = from.which;
        to.layer.copyFrom(from.layer);
        to.page.copyFrom(from.page);
      }
      /**
       * @param id - The pointer ID.
       * @returns The tracking data stored for the given pointer. If no data exists, a blank
       *  state will be created.
       */
      trackingData(id) {
        if (!this.mappingState.trackingData[id]) {
          this.mappingState.trackingData[id] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
          };
        }
        return this.mappingState.trackingData[id];
      }
      /**
       * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
       *
       * This allocation is constructor-agnostic, as long as it only takes one argument - this event
       * boundary.
       * @param constructor - The event's constructor.
       */
      allocateEvent(constructor) {
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        const event = this.eventPool.get(constructor).pop() || new constructor(this);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.defaultPrevented = false;
        event.path = null;
        event.target = null;
        return event;
      }
      /**
       * Frees the event and puts it back into the event pool.
       *
       * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
       *
       * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
       * not be freed. This is because of the possibility that the same event is freed twice, which can cause
       * it to be allocated twice & result in overwriting.
       * @param event - The event to be freed.
       * @throws Error if the event is managed by another event boundary.
       */
      freeEvent(event) {
        if (event.manager !== this)
          throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const constructor = event.constructor;
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        this.eventPool.get(constructor).push(event);
      }
      /**
       * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
       * is set on the event.
       * @param e - The event to call each listener with.
       * @param type - The event key.
       */
      _notifyListeners(e2, type) {
        const listeners = e2.currentTarget._events[type];
        if (!listeners)
          return;
        if ("fn" in listeners) {
          if (listeners.once)
            e2.currentTarget.removeListener(type, listeners.fn, void 0, true);
          listeners.fn.call(listeners.context, e2);
        } else {
          for (let i3 = 0, j2 = listeners.length; i3 < j2 && !e2.propagationImmediatelyStopped; i3++) {
            if (listeners[i3].once)
              e2.currentTarget.removeListener(type, listeners[i3].fn, void 0, true);
            listeners[i3].fn.call(listeners[i3].context, e2);
          }
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/events/EventSystem.mjs
var MOUSE_POINTER_ID, TOUCH_TO_POINTER, _EventSystem, EventSystem;
var init_EventSystem = __esm({
  "node_modules/pixi.js/lib/events/EventSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_EventBoundary();
    init_EventTicker();
    init_FederatedPointerEvent();
    init_FederatedWheelEvent();
    MOUSE_POINTER_ID = 1;
    TOUCH_TO_POINTER = {
      touchstart: "pointerdown",
      touchend: "pointerup",
      touchendoutside: "pointerupoutside",
      touchmove: "pointermove",
      touchcancel: "pointercancel"
    };
    _EventSystem = class _EventSystem2 {
      /**
       * @param {Renderer} renderer
       */
      constructor(renderer) {
        this.supportsTouchEvents = "ontouchstart" in globalThis;
        this.supportsPointerEvents = !!globalThis.PointerEvent;
        this.domElement = null;
        this.resolution = 1;
        this.renderer = renderer;
        this.rootBoundary = new EventBoundary(null);
        EventsTicker.init(this);
        this.autoPreventDefault = true;
        this._eventsAdded = false;
        this._rootPointerEvent = new FederatedPointerEvent(null);
        this._rootWheelEvent = new FederatedWheelEvent(null);
        this.cursorStyles = {
          default: "inherit",
          pointer: "pointer"
        };
        this.features = new Proxy({ ..._EventSystem2.defaultEventFeatures }, {
          set: (target, key, value) => {
            if (key === "globalMove") {
              this.rootBoundary.enableGlobalMoveEvents = value;
            }
            target[key] = value;
            return true;
          }
        });
        this._onPointerDown = this._onPointerDown.bind(this);
        this._onPointerMove = this._onPointerMove.bind(this);
        this._onPointerUp = this._onPointerUp.bind(this);
        this._onPointerOverOut = this._onPointerOverOut.bind(this);
        this.onWheel = this.onWheel.bind(this);
      }
      /**
       * The default interaction mode for all display objects.
       * @see Container.eventMode
       * @type {EventMode}
       * @readonly
       * @since 7.2.0
       */
      static get defaultEventMode() {
        return this._defaultEventMode;
      }
      /**
       * Runner init called, view is available at this point.
       * @ignore
       */
      init(options) {
        const { canvas, resolution } = this.renderer;
        this.setTargetElement(canvas);
        this.resolution = resolution;
        _EventSystem2._defaultEventMode = options.eventMode ?? "passive";
        Object.assign(this.features, options.eventFeatures ?? {});
        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
      }
      /**
       * Handle changing resolution.
       * @ignore
       */
      resolutionChange(resolution) {
        this.resolution = resolution;
      }
      /** Destroys all event listeners and detaches the renderer. */
      destroy() {
        this.setTargetElement(null);
        this.renderer = null;
        this._currentCursor = null;
      }
      /**
       * Sets the current cursor mode, handling any callbacks or CSS style changes.
       * @param mode - cursor mode, a key from the cursorStyles dictionary
       */
      setCursor(mode) {
        mode || (mode = "default");
        let applyStyles = true;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
          applyStyles = false;
        }
        if (this._currentCursor === mode) {
          return;
        }
        this._currentCursor = mode;
        const style = this.cursorStyles[mode];
        if (style) {
          switch (typeof style) {
            case "string":
              if (applyStyles) {
                this.domElement.style.cursor = style;
              }
              break;
            case "function":
              style(mode);
              break;
            case "object":
              if (applyStyles) {
                Object.assign(this.domElement.style, style);
              }
              break;
          }
        } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
          this.domElement.style.cursor = mode;
        }
      }
      /**
       * The global pointer event.
       * Useful for getting the pointer position without listening to events.
       * @since 7.2.0
       */
      get pointer() {
        return this._rootPointerEvent;
      }
      /**
       * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerDown(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const events = this._normalizeToPointerData(nativeEvent);
        if (this.autoPreventDefault && events[0].isNormalized) {
          const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
          if (cancelable) {
            nativeEvent.preventDefault();
          }
        }
        for (let i3 = 0, j2 = events.length; i3 < j2; i3++) {
          const nativeEvent2 = events[i3];
          const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
          this.rootBoundary.mapEvent(federatedEvent);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch events.
       */
      _onPointerMove(nativeEvent) {
        if (!this.features.move)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        EventsTicker.pointerMoved();
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i3 = 0, j2 = normalizedEvents.length; i3 < j2; i3++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerUp(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let target = nativeEvent.target;
        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
          target = nativeEvent.composedPath()[0];
        }
        const outside = target !== this.domElement ? "outside" : "";
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i3 = 0, j2 = normalizedEvents.length; i3 < j2; i3++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
          event.type += outside;
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerOverOut(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i3 = 0, j2 = normalizedEvents.length; i3 < j2; i3++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i3]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
       * @param nativeEvent - The native wheel event.
       */
      onWheel(nativeEvent) {
        if (!this.features.wheel)
          return;
        const wheelEvent = this.normalizeWheelEvent(nativeEvent);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        this.rootBoundary.mapEvent(wheelEvent);
      }
      /**
       * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
       *
       * To deregister the current DOM element without setting a new one, pass {@code null}.
       * @param element - The new DOM element.
       */
      setTargetElement(element) {
        this._removeEvents();
        this.domElement = element;
        EventsTicker.domElement = element;
        this._addEvents();
      }
      /** Register event listeners on {@link Renderer#domElement this.domElement}. */
      _addEvents() {
        if (this._eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker.addTickerListener();
        const style = this.domElement.style;
        if (style) {
          if (globalThis.navigator.msPointerEnabled) {
            style.msContentZooming = "none";
            style.msTouchAction = "none";
          } else if (this.supportsPointerEvents) {
            style.touchAction = "none";
          }
        }
        if (this.supportsPointerEvents) {
          globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
          this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
          this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
          this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
          globalThis.addEventListener("pointerup", this._onPointerUp, true);
        } else {
          globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
          this.domElement.addEventListener("mousedown", this._onPointerDown, true);
          this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
          this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
          globalThis.addEventListener("mouseup", this._onPointerUp, true);
          if (this.supportsTouchEvents) {
            this.domElement.addEventListener("touchstart", this._onPointerDown, true);
            this.domElement.addEventListener("touchend", this._onPointerUp, true);
            this.domElement.addEventListener("touchmove", this._onPointerMove, true);
          }
        }
        this.domElement.addEventListener("wheel", this.onWheel, {
          passive: true,
          capture: true
        });
        this._eventsAdded = true;
      }
      /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */
      _removeEvents() {
        if (!this._eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker.removeTickerListener();
        const style = this.domElement.style;
        if (style) {
          if (globalThis.navigator.msPointerEnabled) {
            style.msContentZooming = "";
            style.msTouchAction = "";
          } else if (this.supportsPointerEvents) {
            style.touchAction = "";
          }
        }
        if (this.supportsPointerEvents) {
          globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
          this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
          this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
          this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
          globalThis.removeEventListener("pointerup", this._onPointerUp, true);
        } else {
          globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
          this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
          this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
          this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
          globalThis.removeEventListener("mouseup", this._onPointerUp, true);
          if (this.supportsTouchEvents) {
            this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
            this.domElement.removeEventListener("touchend", this._onPointerUp, true);
            this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
          }
        }
        this.domElement.removeEventListener("wheel", this.onWheel, true);
        this.domElement = null;
        this._eventsAdded = false;
      }
      /**
       * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
       * resulting value is stored in the point. This takes into account the fact that the DOM
       * element could be scaled and positioned anywhere on the screen.
       * @param  {PointData} point - the point that the result will be stored in
       * @param  {number} x - the x coord of the position to map
       * @param  {number} y - the y coord of the position to map
       */
      mapPositionToPoint(point, x2, y2) {
        const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
          x: 0,
          y: 0,
          width: this.domElement.width,
          height: this.domElement.height,
          left: 0,
          top: 0
        };
        const resolutionMultiplier = 1 / this.resolution;
        point.x = (x2 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
        point.y = (y2 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
      }
      /**
       * Ensures that the original event object contains all data that a regular pointer event would have
       * @param event - The original event data from a touch or mouse event
       * @returns An array containing a single normalized pointer event, in the case of a pointer
       *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
       */
      _normalizeToPointerData(event) {
        const normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
          for (let i3 = 0, li = event.changedTouches.length; i3 < li; i3++) {
            const touch = event.changedTouches[i3];
            if (typeof touch.button === "undefined")
              touch.button = 0;
            if (typeof touch.buttons === "undefined")
              touch.buttons = 1;
            if (typeof touch.isPrimary === "undefined") {
              touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
            }
            if (typeof touch.width === "undefined")
              touch.width = touch.radiusX || 1;
            if (typeof touch.height === "undefined")
              touch.height = touch.radiusY || 1;
            if (typeof touch.tiltX === "undefined")
              touch.tiltX = 0;
            if (typeof touch.tiltY === "undefined")
              touch.tiltY = 0;
            if (typeof touch.pointerType === "undefined")
              touch.pointerType = "touch";
            if (typeof touch.pointerId === "undefined")
              touch.pointerId = touch.identifier || 0;
            if (typeof touch.pressure === "undefined")
              touch.pressure = touch.force || 0.5;
            if (typeof touch.twist === "undefined")
              touch.twist = 0;
            if (typeof touch.tangentialPressure === "undefined")
              touch.tangentialPressure = 0;
            if (typeof touch.layerX === "undefined")
              touch.layerX = touch.offsetX = touch.clientX;
            if (typeof touch.layerY === "undefined")
              touch.layerY = touch.offsetY = touch.clientY;
            touch.isNormalized = true;
            touch.type = event.type;
            normalizedEvents.push(touch);
          }
        } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
          const tempEvent = event;
          if (typeof tempEvent.isPrimary === "undefined")
            tempEvent.isPrimary = true;
          if (typeof tempEvent.width === "undefined")
            tempEvent.width = 1;
          if (typeof tempEvent.height === "undefined")
            tempEvent.height = 1;
          if (typeof tempEvent.tiltX === "undefined")
            tempEvent.tiltX = 0;
          if (typeof tempEvent.tiltY === "undefined")
            tempEvent.tiltY = 0;
          if (typeof tempEvent.pointerType === "undefined")
            tempEvent.pointerType = "mouse";
          if (typeof tempEvent.pointerId === "undefined")
            tempEvent.pointerId = MOUSE_POINTER_ID;
          if (typeof tempEvent.pressure === "undefined")
            tempEvent.pressure = 0.5;
          if (typeof tempEvent.twist === "undefined")
            tempEvent.twist = 0;
          if (typeof tempEvent.tangentialPressure === "undefined")
            tempEvent.tangentialPressure = 0;
          tempEvent.isNormalized = true;
          normalizedEvents.push(tempEvent);
        } else {
          normalizedEvents.push(event);
        }
        return normalizedEvents;
      }
      /**
       * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
       *
       * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
       * multiple native wheel events.
       * @param nativeEvent - The native wheel event that occurred on the canvas.
       * @returns A federated wheel event.
       */
      normalizeWheelEvent(nativeEvent) {
        const event = this._rootWheelEvent;
        this._transferMouseData(event, nativeEvent);
        event.deltaX = nativeEvent.deltaX;
        event.deltaY = nativeEvent.deltaY;
        event.deltaZ = nativeEvent.deltaZ;
        event.deltaMode = nativeEvent.deltaMode;
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.nativeEvent = nativeEvent;
        event.type = nativeEvent.type;
        return event;
      }
      /**
       * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
       * @param event
       * @param nativeEvent
       */
      _bootstrapEvent(event, nativeEvent) {
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = nativeEvent.pointerId;
        event.width = nativeEvent.width;
        event.height = nativeEvent.height;
        event.isPrimary = nativeEvent.isPrimary;
        event.pointerType = nativeEvent.pointerType;
        event.pressure = nativeEvent.pressure;
        event.tangentialPressure = nativeEvent.tangentialPressure;
        event.tiltX = nativeEvent.tiltX;
        event.tiltY = nativeEvent.tiltY;
        event.twist = nativeEvent.twist;
        this._transferMouseData(event, nativeEvent);
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === "pointerleave") {
          event.type = "pointerout";
        }
        if (event.type.startsWith("mouse")) {
          event.type = event.type.replace("mouse", "pointer");
        }
        if (event.type.startsWith("touch")) {
          event.type = TOUCH_TO_POINTER[event.type] || event.type;
        }
        return event;
      }
      /**
       * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
       * @param event
       * @param nativeEvent
       */
      _transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = performance.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.metaKey = nativeEvent.metaKey;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.relatedTarget = null;
        event.shiftKey = nativeEvent.shiftKey;
      }
    };
    _EventSystem.extension = {
      name: "events",
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.CanvasSystem,
        ExtensionType.WebGPUSystem
      ],
      priority: -1
    };
    _EventSystem.defaultEventFeatures = {
      /** Enables pointer events associated with pointer movement. */
      move: true,
      /** Enables global pointer move events. */
      globalMove: true,
      /** Enables pointer events associated with clicking. */
      click: true,
      /** Enables wheel events. */
      wheel: true
    };
    EventSystem = _EventSystem;
  }
});

// node_modules/pixi.js/lib/events/FederatedEventTarget.mjs
var FederatedContainer;
var init_FederatedEventTarget = __esm({
  "node_modules/pixi.js/lib/events/FederatedEventTarget.mjs"() {
    init_define_AnParams();
    init_EventSystem();
    init_FederatedEvent();
    FederatedContainer = {
      /**
       * Property-based event handler for the `click` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onclick = (event) => {
       *  //some function here that happens on click
       * }
       */
      onclick: null,
      /**
       * Property-based event handler for the `mousedown` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmousedown = (event) => {
       *  //some function here that happens on mousedown
       * }
       */
      onmousedown: null,
      /**
       * Property-based event handler for the `mouseenter` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmouseenter = (event) => {
       *  //some function here that happens on mouseenter
       * }
       */
      onmouseenter: null,
      /**
       * Property-based event handler for the `mouseleave` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmouseleave = (event) => {
       *  //some function here that happens on mouseleave
       * }
       */
      onmouseleave: null,
      /**
       * Property-based event handler for the `mousemove` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmousemove = (event) => {
       *  //some function here that happens on mousemove
       * }
       */
      onmousemove: null,
      /**
       * Property-based event handler for the `globalmousemove` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onglobalmousemove = (event) => {
       *  //some function here that happens on globalmousemove
       * }
       */
      onglobalmousemove: null,
      /**
       * Property-based event handler for the `mouseout` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmouseout = (event) => {
       *  //some function here that happens on mouseout
       * }
       */
      onmouseout: null,
      /**
       * Property-based event handler for the `mouseover` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmouseover = (event) => {
       *  //some function here that happens on mouseover
       * }
       */
      onmouseover: null,
      /**
       * Property-based event handler for the `mouseup` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmouseup = (event) => {
       *  //some function here that happens on mouseup
       * }
       */
      onmouseup: null,
      /**
       * Property-based event handler for the `mouseupoutside` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmouseupoutside = (event) => {
       *  //some function here that happens on mouseupoutside
       * }
       */
      onmouseupoutside: null,
      /**
       * Property-based event handler for the `pointercancel` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointercancel = (event) => {
       *  //some function here that happens on pointercancel
       * }
       */
      onpointercancel: null,
      /**
       * Property-based event handler for the `pointerdown` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerdown = (event) => {
       *  //some function here that happens on pointerdown
       * }
       */
      onpointerdown: null,
      /**
       * Property-based event handler for the `pointerenter` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerenter = (event) => {
       *  //some function here that happens on pointerenter
       * }
       */
      onpointerenter: null,
      /**
       * Property-based event handler for the `pointerleave` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerleave = (event) => {
       *  //some function here that happens on pointerleave
       * }
       */
      onpointerleave: null,
      /**
       * Property-based event handler for the `pointermove` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointermove = (event) => {
       *  //some function here that happens on pointermove
       * }
       */
      onpointermove: null,
      /**
       * Property-based event handler for the `globalpointermove` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onglobalpointermove = (event) => {
       *  //some function here that happens on globalpointermove
       * }
       */
      onglobalpointermove: null,
      /**
       * Property-based event handler for the `pointerout` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerout = (event) => {
       *  //some function here that happens on pointerout
       * }
       */
      onpointerout: null,
      /**
       * Property-based event handler for the `pointerover` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerover = (event) => {
       *  //some function here that happens on pointerover
       * }
       */
      onpointerover: null,
      /**
       * Property-based event handler for the `pointertap` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointertap = (event) => {
       *  //some function here that happens on pointertap
       * }
       */
      onpointertap: null,
      /**
       * Property-based event handler for the `pointerup` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerup = (event) => {
       *  //some function here that happens on pointerup
       * }
       */
      onpointerup: null,
      /**
       * Property-based event handler for the `pointerupoutside` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerupoutside = (event) => {
       *  //some function here that happens on pointerupoutside
       * }
       */
      onpointerupoutside: null,
      /**
       * Property-based event handler for the `rightclick` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onrightclick = (event) => {
       *  //some function here that happens on rightclick
       * }
       */
      onrightclick: null,
      /**
       * Property-based event handler for the `rightdown` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onrightdown = (event) => {
       *  //some function here that happens on rightdown
       * }
       */
      onrightdown: null,
      /**
       * Property-based event handler for the `rightup` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onrightup = (event) => {
       *  //some function here that happens on rightup
       * }
       */
      onrightup: null,
      /**
       * Property-based event handler for the `rightupoutside` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onrightupoutside = (event) => {
       *  //some function here that happens on rightupoutside
       * }
       */
      onrightupoutside: null,
      /**
       * Property-based event handler for the `tap` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.ontap = (event) => {
       *  //some function here that happens on tap
       * }
       */
      ontap: null,
      /**
       * Property-based event handler for the `touchcancel` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.ontouchcancel = (event) => {
       *  //some function here that happens on touchcancel
       * }
       */
      ontouchcancel: null,
      /**
       * Property-based event handler for the `touchend` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.ontouchend = (event) => {
       *  //some function here that happens on touchend
       * }
       */
      ontouchend: null,
      /**
       * Property-based event handler for the `touchendoutside` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.ontouchendoutside = (event) => {
       *  //some function here that happens on touchendoutside
       * }
       */
      ontouchendoutside: null,
      /**
       * Property-based event handler for the `touchmove` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.ontouchmove = (event) => {
       *  //some function here that happens on touchmove
       * }
       */
      ontouchmove: null,
      /**
       * Property-based event handler for the `globaltouchmove` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onglobaltouchmove = (event) => {
       *  //some function here that happens on globaltouchmove
       * }
       */
      onglobaltouchmove: null,
      /**
       * Property-based event handler for the `touchstart` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.ontouchstart = (event) => {
       *  //some function here that happens on touchstart
       * }
       */
      ontouchstart: null,
      /**
       * Property-based event handler for the `wheel` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onwheel = (event) => {
       *  //some function here that happens on wheel
       * }
       */
      onwheel: null,
      /**
       * Enable interaction events for the Container. Touch, pointer and mouse
       * @memberof scene.Container#
       */
      get interactive() {
        return this.eventMode === "dynamic" || this.eventMode === "static";
      },
      set interactive(value) {
        this.eventMode = value ? "static" : "passive";
      },
      /**
       * @ignore
       */
      _internalEventMode: void 0,
      /**
       * Enable interaction events for the Container. Touch, pointer and mouse.
       * There are 5 types of interaction settings:
       * - `'none'`: Ignores all interaction events, even on its children.
       * - `'passive'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.
       * Interactive children will still emit events.
       * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7
       * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7
       * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to
       * allow for interaction when the mouse isn't moving
       * @example
       * import { Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.eventMode = 'static';
       * sprite.on('tap', (event) => {
       *     // Handle event
       * });
       * @memberof scene.Container#
       * @since 7.2.0
       */
      get eventMode() {
        return this._internalEventMode ?? EventSystem.defaultEventMode;
      },
      set eventMode(value) {
        this._internalEventMode = value;
      },
      /**
       * Determines if the container is interactive or not
       * @returns {boolean} Whether the container is interactive or not
       * @memberof scene.Container#
       * @since 7.2.0
       * @example
       * import { Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.eventMode = 'static';
       * sprite.isInteractive(); // true
       *
       * sprite.eventMode = 'dynamic';
       * sprite.isInteractive(); // true
       *
       * sprite.eventMode = 'none';
       * sprite.isInteractive(); // false
       *
       * sprite.eventMode = 'passive';
       * sprite.isInteractive(); // false
       *
       * sprite.eventMode = 'auto';
       * sprite.isInteractive(); // false
       */
      isInteractive() {
        return this.eventMode === "static" || this.eventMode === "dynamic";
      },
      /**
       * Determines if the children to the container can be clicked/touched
       * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
       * @memberof scene.Container#
       */
      interactiveChildren: true,
      /**
       * Interaction shape. Children will be hit first, then this shape will be checked.
       * Setting this will cause this shape to be checked in hit tests rather than the container's bounds.
       * @example
       * import { Rectangle, Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.interactive = true;
       * sprite.hitArea = new Rectangle(0, 0, 100, 100);
       * @member {IHitArea}
       * @memberof scene.Container#
       */
      hitArea: null,
      /**
       * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`
       * seeks to be compatible with the DOM's `addEventListener` with support for options.
       * @memberof scene.Container
       * @param type - The type of event to listen to.
       * @param listener - The listener callback or object.
       * @param options - Listener options, used for capture phase.
       * @example
       * // Tell the user whether they did a single, double, triple, or nth click.
       * button.addEventListener('click', {
       *     handleEvent(e): {
       *         let prefix;
       *
       *         switch (e.detail) {
       *             case 1: prefix = 'single'; break;
       *             case 2: prefix = 'double'; break;
       *             case 3: prefix = 'triple'; break;
       *             default: prefix = e.detail + 'th'; break;
       *         }
       *
       *         console.log('That was a ' + prefix + 'click');
       *     }
       * });
       *
       * // But skip the first click!
       * button.parent.addEventListener('click', function blockClickOnce(e) {
       *     e.stopImmediatePropagation();
       *     button.parent.removeEventListener('click', blockClickOnce, true);
       * }, {
       *     capture: true,
       * });
       */
      addEventListener(type, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const signal = typeof options === "object" ? options.signal : void 0;
        const once = typeof options === "object" ? options.once === true : false;
        const context2 = typeof listener === "function" ? void 0 : listener;
        type = capture ? `${type}capture` : type;
        const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
        const emitter = this;
        if (signal) {
          signal.addEventListener("abort", () => {
            emitter.off(type, listenerFn, context2);
          });
        }
        if (once) {
          emitter.once(type, listenerFn, context2);
        } else {
          emitter.on(type, listenerFn, context2);
        }
      },
      /**
       * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`
       * seeks to be compatible with the DOM's `removeEventListener` with support for options.
       * @memberof scene.Container
       * @param type - The type of event the listener is bound to.
       * @param listener - The listener callback or object.
       * @param options - The original listener options. This is required to deregister a capture phase listener.
       */
      removeEventListener(type, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const context2 = typeof listener === "function" ? void 0 : listener;
        type = capture ? `${type}capture` : type;
        listener = typeof listener === "function" ? listener : listener.handleEvent;
        this.off(type, listener, context2);
      },
      /**
       * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.
       *
       * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.
       * @memberof scene.Container
       * @param e - The event to dispatch.
       * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.
       * @example
       * // Reuse a click event!
       * button.dispatchEvent(clickEvent);
       */
      dispatchEvent(e2) {
        if (!(e2 instanceof FederatedEvent)) {
          throw new Error("Container cannot propagate events outside of the Federated Events API");
        }
        e2.defaultPrevented = false;
        e2.path = null;
        e2.target = this;
        e2.manager.dispatchEvent(e2);
        return !e2.defaultPrevented;
      }
    };
  }
});

// node_modules/pixi.js/lib/events/init.mjs
var init_init3 = __esm({
  "node_modules/pixi.js/lib/events/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Container();
    init_EventSystem();
    init_FederatedEventTarget();
    extensions.add(EventSystem);
    extensions.mixin(Container, FederatedContainer);
  }
});

// node_modules/pixi.js/lib/dom/DOMPipe.mjs
var DOMPipe;
var init_DOMPipe = __esm({
  "node_modules/pixi.js/lib/dom/DOMPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    DOMPipe = class {
      /**
       * Constructor for the DOMPipe class.
       * @param renderer - The renderer instance that this DOMPipe will be associated with.
       */
      constructor(renderer) {
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this._attachedDomElements = [];
        this._renderer = renderer;
        this._renderer.runners.postrender.add(this);
        this._domElement = document.createElement("div");
        this._domElement.style.position = "absolute";
        this._domElement.style.top = "0";
        this._domElement.style.left = "0";
        this._domElement.style.pointerEvents = "none";
        this._domElement.style.zIndex = "1000";
      }
      /**
       * Adds a renderable DOM container to the list of attached elements.
       * @param domContainer - The DOM container to be added.
       * @param _instructionSet - The instruction set (unused).
       */
      addRenderable(domContainer, _instructionSet) {
        if (!this._attachedDomElements.includes(domContainer)) {
          this._attachedDomElements.push(domContainer);
          domContainer.on("destroyed", this._destroyRenderableBound);
        }
      }
      /**
       * Updates a renderable DOM container.
       * @param _domContainer - The DOM container to be updated (unused).
       */
      updateRenderable(_domContainer) {
      }
      /**
       * Validates a renderable DOM container.
       * @param _domContainer - The DOM container to be validated (unused).
       * @returns Always returns true as validation is not required.
       */
      validateRenderable(_domContainer) {
        return true;
      }
      /**
       * Destroys a renderable DOM container, removing it from the list of attached elements.
       * @param domContainer - The DOM container to be destroyed.
       */
      destroyRenderable(domContainer) {
        const index = this._attachedDomElements.indexOf(domContainer);
        if (index !== -1) {
          this._attachedDomElements.splice(index, 1);
        }
        domContainer.off("destroyed", this._destroyRenderableBound);
      }
      /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */
      postrender() {
        const attachedDomElements = this._attachedDomElements;
        if (attachedDomElements.length === 0) {
          this._domElement.remove();
          return;
        }
        const canvas = this._renderer.view.canvas;
        if (this._domElement.parentNode !== canvas.parentNode) {
          canvas.parentNode?.appendChild(this._domElement);
        }
        this._domElement.style.transform = `translate(${canvas.offsetLeft}px, ${canvas.offsetTop}px)`;
        for (let i3 = 0; i3 < attachedDomElements.length; i3++) {
          const domContainer = attachedDomElements[i3];
          const element = domContainer.element;
          if (!domContainer.parent || domContainer.globalDisplayStatus < 7) {
            element.remove();
            attachedDomElements.splice(i3, 1);
            i3--;
          } else {
            if (!this._domElement.contains(element)) {
              element.style.position = "absolute";
              element.style.pointerEvents = "auto";
              this._domElement.appendChild(element);
            }
            const wt = domContainer.worldTransform;
            const anchor = domContainer._anchor;
            const ax = domContainer.width * anchor.x;
            const ay = domContainer.height * anchor.y;
            element.style.transformOrigin = `${ax}px ${ay}px`;
            element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;
            element.style.opacity = domContainer.groupAlpha.toString();
          }
        }
      }
      /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */
      destroy() {
        this._renderer.runners.postrender.remove(this);
        for (let i3 = 0; i3 < this._attachedDomElements.length; i3++) {
          const domContainer = this._attachedDomElements[i3];
          domContainer.off("destroyed", this._destroyRenderableBound);
          domContainer.element.remove();
        }
        this._attachedDomElements.length = 0;
        this._domElement.remove();
        this._renderer = null;
      }
    };
    DOMPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "dom"
    };
  }
});

// node_modules/pixi.js/lib/scene/view/ViewContainer.mjs
var ViewContainer;
var init_ViewContainer = __esm({
  "node_modules/pixi.js/lib/scene/view/ViewContainer.mjs"() {
    init_define_AnParams();
    init_Bounds();
    init_Container();
    ViewContainer = class extends Container {
      // eslint-disable-next-line @typescript-eslint/no-useless-constructor
      constructor(options) {
        super(options);
        this.canBundle = true;
        this.allowChildren = false;
        this._roundPixels = 0;
        this._lastUsed = -1;
        this._bounds = new Bounds(0, 1, 0, 0);
        this._boundsDirty = true;
      }
      /**
       * The local bounds of the view.
       * @type {rendering.Bounds}
       */
      get bounds() {
        if (!this._boundsDirty)
          return this._bounds;
        this.updateBounds();
        this._boundsDirty = false;
        return this._bounds;
      }
      /**
       * Whether or not to round the x/y position of the sprite.
       * @type {boolean}
       */
      get roundPixels() {
        return !!this._roundPixels;
      }
      set roundPixels(value) {
        this._roundPixels = value ? 1 : 0;
      }
      /**
       * Checks if the object contains the given point.
       * @param point - The point to check
       */
      containsPoint(point) {
        const bounds = this.bounds;
        const { x: x2, y: y2 } = point;
        return x2 >= bounds.minX && x2 <= bounds.maxX && y2 >= bounds.minY && y2 <= bounds.maxY;
      }
      /** @private */
      onViewUpdate() {
        this._didViewChangeTick++;
        this._boundsDirty = true;
        if (this.didViewUpdate)
          return;
        this.didViewUpdate = true;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.onChildViewUpdate(this);
        }
      }
      destroy(options) {
        super.destroy(options);
        this._bounds = null;
      }
      collectRenderablesSimple(instructionSet, renderer, currentLayer) {
        const { renderPipes: renderPipes3, renderableGC } = renderer;
        renderPipes3.blendMode.setBlendMode(this, this.groupBlendMode, instructionSet);
        const rp = renderPipes3;
        rp[this.renderPipeId].addRenderable(this, instructionSet);
        renderableGC.addRenderable(this);
        this.didViewUpdate = false;
        const children = this.children;
        const length = children.length;
        for (let i3 = 0; i3 < length; i3++) {
          children[i3].collectRenderables(instructionSet, renderer, currentLayer);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/dom/DOMContainer.mjs
var DOMContainer;
var init_DOMContainer = __esm({
  "node_modules/pixi.js/lib/dom/DOMContainer.mjs"() {
    init_define_AnParams();
    init_Point();
    init_ViewContainer();
    DOMContainer = class extends ViewContainer {
      /**
       * @param options - The options for creating the DOM container.
       */
      constructor(options = {}) {
        const { element, anchor, ...rest } = options;
        super({
          label: "DOMContainer",
          ...rest
        });
        this.renderPipeId = "dom";
        this.batched = false;
        this._anchor = new Point(0, 0);
        if (anchor) {
          this.anchor = anchor;
        }
        this.element = options.element || document.createElement("div");
      }
      /**
       * The anchor sets the origin point of the container.
       * The default is `(0,0)`, this means the container's origin is the top left.
       *
       * Setting the anchor to `(0.5,0.5)` means the container's origin is centered.
       * Setting the anchor to `(1,1)` would mean the container's origin point will be the bottom right corner.
       *
       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
       */
      get anchor() {
        return this._anchor;
      }
      set anchor(value) {
        typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
      }
      set element(value) {
        if (this._element === value)
          return;
        this._element = value;
        this.onViewUpdate();
      }
      /** The DOM element that this container is using. */
      get element() {
        return this._element;
      }
      /** @private */
      updateBounds() {
        const bounds = this._bounds;
        const element = this._element;
        if (!element) {
          bounds.minX = 0;
          bounds.minY = 0;
          bounds.maxX = 0;
          bounds.maxY = 0;
          return;
        }
        const { offsetWidth, offsetHeight } = element;
        bounds.minX = 0;
        bounds.maxX = offsetWidth;
        bounds.minY = 0;
        bounds.maxY = offsetHeight;
      }
      /**
       * Destroys this DOM container.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       */
      destroy(options = false) {
        super.destroy(options);
        this._element?.parentNode?.removeChild(this._element);
        this._element = null;
        this._anchor = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/dom/init.mjs
var init_init4 = __esm({
  "node_modules/pixi.js/lib/dom/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_DOMPipe();
    extensions.add(DOMPipe);
  }
});

// node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs
var LoaderParserPriority;
var init_LoaderParser = __esm({
  "node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs"() {
    "use strict";
    init_define_AnParams();
    LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
      LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
      LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
      LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
      return LoaderParserPriority2;
    })(LoaderParserPriority || {});
  }
});

// node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs
var BrowserAdapter;
var init_BrowserAdapter = __esm({
  "node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs"() {
    "use strict";
    init_define_AnParams();
    BrowserAdapter = {
      createCanvas: (width, height) => {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        return canvas;
      },
      getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
      getWebGLRenderingContext: () => WebGLRenderingContext,
      getNavigator: () => navigator,
      getBaseUrl: () => document.baseURI ?? window.location.href,
      getFontFaceSet: () => document.fonts,
      fetch: (url, options) => fetch(url, options),
      parseXML: (xml) => {
        const parser = new DOMParser();
        return parser.parseFromString(xml, "text/xml");
      }
    };
  }
});

// node_modules/pixi.js/lib/environment/adapter.mjs
var currentAdapter, DOMAdapter;
var init_adapter = __esm({
  "node_modules/pixi.js/lib/environment/adapter.mjs"() {
    init_define_AnParams();
    init_BrowserAdapter();
    currentAdapter = BrowserAdapter;
    DOMAdapter = {
      /**
       * Returns the current adapter.
       * @returns {environment.Adapter} The current adapter.
       */
      get() {
        return currentAdapter;
      },
      /**
       * Sets the current adapter.
       * @param adapter - The new adapter.
       */
      set(adapter) {
        currentAdapter = adapter;
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/path.mjs
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url) {
  const re = url.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i3 = 0; i3 <= path2.length; ++i3) {
    if (i3 < path2.length) {
      code = path2.charCodeAt(i3);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i3 - 1 || dots === 1) {
      } else if (lastSlash !== i3 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i3;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i3;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i3)}`;
        } else {
          res = path2.slice(lastSlash + 1, i3);
        }
        lastSegmentLength = i3 - lastSlash - 1;
      }
      lastSlash = i3;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var path;
var init_path = __esm({
  "node_modules/pixi.js/lib/utils/path.mjs"() {
    init_define_AnParams();
    init_adapter();
    path = {
      /**
       * Converts a path to posix format.
       * @param path - The path to convert to posix
       */
      toPosix(path2) {
        return replaceAll(path2, "\\", "/");
      },
      /**
       * Checks if the path is a URL e.g. http://, https://
       * @param path - The path to check
       */
      isUrl(path2) {
        return /^https?:/.test(this.toPosix(path2));
      },
      /**
       * Checks if the path is a data URL
       * @param path - The path to check
       */
      isDataUrl(path2) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
      },
      /**
       * Checks if the path is a blob URL
       * @param path - The path to check
       */
      isBlobUrl(path2) {
        return path2.startsWith("blob:");
      },
      /**
       * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
       * This will return true for windows file paths
       * @param path - The path to check
       */
      hasProtocol(path2) {
        return /^[^/:]+:/.test(this.toPosix(path2));
      },
      /**
       * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
       * @param path - The path to get the protocol from
       */
      getProtocol(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        const matchFile = /^file:\/\/\//.exec(path2);
        if (matchFile) {
          return matchFile[0];
        }
        const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
        if (matchProtocol) {
          return matchProtocol[0];
        }
        return "";
      },
      /**
       * Converts URL to an absolute path.
       * When loading from a Web Worker, we must use absolute paths.
       * If the URL is already absolute we return it as is
       * If it's not, we convert it
       * @param url - The URL to test
       * @param customBaseUrl - The base URL to use
       * @param customRootUrl - The root URL to use
       */
      toAbsolute(url, customBaseUrl, customRootUrl) {
        assertPath(url);
        if (this.isDataUrl(url) || this.isBlobUrl(url))
          return url;
        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));
        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
        url = this.toPosix(url);
        if (url.startsWith("/")) {
          return path.join(rootUrl, url.slice(1));
        }
        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
        return absolutePath;
      },
      /**
       * Normalizes the given path, resolving '..' and '.' segments
       * @param path - The path to normalize
       */
      normalize(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        if (this.isDataUrl(path2) || this.isBlobUrl(path2))
          return path2;
        path2 = this.toPosix(path2);
        let protocol = "";
        const isAbsolute = path2.startsWith("/");
        if (this.hasProtocol(path2)) {
          protocol = this.rootname(path2);
          path2 = path2.slice(protocol.length);
        }
        const trailingSeparator = path2.endsWith("/");
        path2 = normalizeStringPosix(path2, false);
        if (path2.length > 0 && trailingSeparator)
          path2 += "/";
        if (isAbsolute)
          return `/${path2}`;
        return protocol + path2;
      },
      /**
       * Determines if path is an absolute path.
       * Absolute paths can be urls, data urls, or paths on disk
       * @param path - The path to test
       */
      isAbsolute(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        if (this.hasProtocol(path2))
          return true;
        return path2.startsWith("/");
      },
      /**
       * Joins all given path segments together using the platform-specific separator as a delimiter,
       * then normalizes the resulting path
       * @param segments - The segments of the path to join
       */
      join(...segments) {
        if (segments.length === 0) {
          return ".";
        }
        let joined;
        for (let i3 = 0; i3 < segments.length; ++i3) {
          const arg = segments[i3];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else {
              const prevArg = segments[i3 - 1] ?? "";
              if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
                joined += `/../${arg}`;
              } else {
                joined += `/${arg}`;
              }
            }
          }
        }
        if (joined === void 0) {
          return ".";
        }
        return this.normalize(joined);
      },
      /**
       * Returns the directory name of a path
       * @param path - The path to parse
       */
      dirname(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        path2 = this.toPosix(path2);
        let code = path2.charCodeAt(0);
        const hasRoot = code === 47;
        let end = -1;
        let matchedSlash = true;
        const proto = this.getProtocol(path2);
        const origpath = path2;
        path2 = path2.slice(proto.length);
        for (let i3 = path2.length - 1; i3 >= 1; --i3) {
          code = path2.charCodeAt(i3);
          if (code === 47) {
            if (!matchedSlash) {
              end = i3;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
        if (hasRoot && end === 1)
          return "//";
        return proto + path2.slice(0, end);
      },
      /**
       * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
       * @param path - The path to parse
       */
      rootname(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        let root = "";
        if (path2.startsWith("/"))
          root = "/";
        else {
          root = this.getProtocol(path2);
        }
        if (this.isUrl(path2)) {
          const index = path2.indexOf("/", root.length);
          if (index !== -1) {
            root = path2.slice(0, index);
          } else
            root = path2;
          if (!root.endsWith("/"))
            root += "/";
        }
        return root;
      },
      /**
       * Returns the last portion of a path
       * @param path - The path to test
       * @param ext - Optional extension to remove
       */
      basename(path2, ext) {
        assertPath(path2);
        if (ext)
          assertPath(ext);
        path2 = removeUrlParams(this.toPosix(path2));
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i3;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2)
            return "";
          let extIdx = ext.length - 1;
          let firstNonSlashEnd = -1;
          for (i3 = path2.length - 1; i3 >= 0; --i3) {
            const code = path2.charCodeAt(i3);
            if (code === 47) {
              if (!matchedSlash) {
                start = i3 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i3 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i3;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path2.length;
          return path2.slice(start, end);
        }
        for (i3 = path2.length - 1; i3 >= 0; --i3) {
          if (path2.charCodeAt(i3) === 47) {
            if (!matchedSlash) {
              start = i3 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
          }
        }
        if (end === -1)
          return "";
        return path2.slice(start, end);
      },
      /**
       * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
       * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
       * the first character of the basename of path, an empty string is returned.
       * @param path - The path to parse
       */
      extname(path2) {
        assertPath(path2);
        path2 = removeUrlParams(this.toPosix(path2));
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i3 = path2.length - 1; i3 >= 0; --i3) {
          const code = path2.charCodeAt(i3);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i3 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i3;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      /**
       * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
       * @param path - The path to parse
       */
      parse(path2) {
        assertPath(path2);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path2.length === 0)
          return ret;
        path2 = removeUrlParams(this.toPosix(path2));
        let code = path2.charCodeAt(0);
        const isAbsolute = this.isAbsolute(path2);
        let start;
        const protocol = "";
        ret.root = this.rootname(path2);
        if (isAbsolute || this.hasProtocol(path2)) {
          start = 1;
        } else {
          start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i3 = path2.length - 1;
        let preDotState = 0;
        for (; i3 >= start; --i3) {
          code = path2.charCodeAt(i3);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i3 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i3 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i3;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path2.slice(1, end);
            else
              ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        ret.dir = this.dirname(path2);
        if (protocol)
          ret.dir = protocol + ret.dir;
        return ret;
      },
      sep: "/",
      delimiter: ":",
      joinExtensions: [".html"]
    };
  }
});

// node_modules/pixi.js/lib/assets/utils/convertToList.mjs
var convertToList;
var init_convertToList = __esm({
  "node_modules/pixi.js/lib/assets/utils/convertToList.mjs"() {
    "use strict";
    init_define_AnParams();
    convertToList = (input, transform2, forceTransform = false) => {
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!transform2) {
        return input;
      }
      return input.map((item) => {
        if (typeof item === "string" || forceTransform) {
          return transform2(item);
        }
        return item;
      });
    };
  }
});

// node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs
function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i3 = 0; i3 < id.length; i3++) {
    const value = id[i3];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}
var init_createStringVariations = __esm({
  "node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs
var isSingleItem;
var init_isSingleItem = __esm({
  "node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs"() {
    "use strict";
    init_define_AnParams();
    isSingleItem = (item) => !Array.isArray(item);
  }
});

// node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
function getUrlExtension(url) {
  return url.split(".").pop().split("?").shift().split("#").shift();
}
var Resolver;
var init_Resolver = __esm({
  "node_modules/pixi.js/lib/assets/resolver/Resolver.mjs"() {
    init_define_AnParams();
    init_warn();
    init_path();
    init_convertToList();
    init_createStringVariations();
    init_isSingleItem();
    Resolver = class {
      constructor() {
        this._defaultBundleIdentifierOptions = {
          connector: "-",
          createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
          extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
        };
        this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
        this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
        this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
        this._assetMap = {};
        this._preferredOrder = [];
        this._parsers = [];
        this._resolverHash = {};
        this._bundles = {};
      }
      /**
       * Override how the resolver deals with generating bundle ids.
       * must be called before any bundles are added
       * @param bundleIdentifier - the bundle identifier options
       */
      setBundleIdentifier(bundleIdentifier) {
        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
        if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
          throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
        }
      }
      /**
       * Let the resolver know which assets you prefer to use when resolving assets.
       * Multiple prefer user defined rules can be added.
       * @example
       * resolver.prefer({
       *     // first look for something with the correct format, and then then correct resolution
       *     priority: ['format', 'resolution'],
       *     params:{
       *         format:'webp', // prefer webp images
       *         resolution: 2, // prefer a resolution of 2
       *     }
       * })
       * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
       * resolver.resolveUrl('foo') // => 'bar@2x.webp'
       * @param preferOrders - the prefer options
       */
      prefer(...preferOrders) {
        preferOrders.forEach((prefer) => {
          this._preferredOrder.push(prefer);
          if (!prefer.priority) {
            prefer.priority = Object.keys(prefer.params);
          }
        });
        this._resolverHash = {};
      }
      /**
       * Set the base path to prepend to all urls when resolving
       * @example
       * resolver.basePath = 'https://home.com/';
       * resolver.add('foo', 'bar.ong');
       * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
       * @param basePath - the base path to use
       */
      set basePath(basePath) {
        this._basePath = basePath;
      }
      get basePath() {
        return this._basePath;
      }
      /**
       * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
       * default value for browsers is `window.location.origin`
       * @example
       * // Application hosted on https://home.com/some-path/index.html
       * resolver.basePath = 'https://home.com/some-path/';
       * resolver.rootPath = 'https://home.com/';
       * resolver.add('foo', '/bar.png');
       * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
       * @param rootPath - the root path to use
       */
      set rootPath(rootPath) {
        this._rootPath = rootPath;
      }
      get rootPath() {
        return this._rootPath;
      }
      /**
       * All the active URL parsers that help the parser to extract information and create
       * an asset object-based on parsing the URL itself.
       *
       * Can be added using the extensions API
       * @example
       * resolver.add('foo', [
       *     {
       *         resolution: 2,
       *         format: 'png',
       *         src: 'image@2x.png',
       *     },
       *     {
       *         resolution:1,
       *         format:'png',
       *         src: 'image.png',
       *     },
       * ]);
       *
       * // With a url parser the information such as resolution and file format could extracted from the url itself:
       * extensions.add({
       *     extension: ExtensionType.ResolveParser,
       *     test: loadTextures.test, // test if url ends in an image
       *     parse: (value: string) =>
       *     ({
       *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
       *         format: value.split('.').pop(),
       *         src: value,
       *     }),
       * });
       *
       * // Now resolution and format can be extracted from the url
       * resolver.add('foo', [
       *     'image@2x.png',
       *     'image.png',
       * ]);
       */
      get parsers() {
        return this._parsers;
      }
      /** Used for testing, this resets the resolver to its initial state */
      reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
        this._assetMap = {};
        this._preferredOrder = [];
        this._resolverHash = {};
        this._rootPath = null;
        this._basePath = null;
        this._manifest = null;
        this._bundles = {};
        this._defaultSearchParams = null;
      }
      /**
       * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
       * @param searchParams - the default url parameters to append when resolving urls
       */
      setDefaultSearchParams(searchParams) {
        if (typeof searchParams === "string") {
          this._defaultSearchParams = searchParams;
        } else {
          const queryValues = searchParams;
          this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
        }
      }
      /**
       * Returns the aliases for a given asset
       * @param asset - the asset to get the aliases for
       */
      getAlias(asset) {
        const { alias, src } = asset;
        const aliasesToUse = convertToList(
          alias || src,
          (value) => {
            if (typeof value === "string")
              return value;
            if (Array.isArray(value))
              return value.map((v2) => v2?.src ?? v2);
            if (value?.src)
              return value.src;
            return value;
          },
          true
        );
        return aliasesToUse;
      }
      /**
       * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
       * generally a manifest would be built using a tool.
       * @param manifest - the manifest to add to the resolver
       */
      addManifest(manifest) {
        if (this._manifest) {
          warn("[Resolver] Manifest already exists, this will be overwritten");
        }
        this._manifest = manifest;
        manifest.bundles.forEach((bundle) => {
          this.addBundle(bundle.name, bundle.assets);
        });
      }
      /**
       * This adds a bundle of assets in one go so that you can resolve them as a group.
       * For example you could add a bundle for each screen in you pixi app
       * @example
       * resolver.addBundle('animals', [
       *  { alias: 'bunny', src: 'bunny.png' },
       *  { alias: 'chicken', src: 'chicken.png' },
       *  { alias: 'thumper', src: 'thumper.png' },
       * ]);
       * // or
       * resolver.addBundle('animals', {
       *     bunny: 'bunny.png',
       *     chicken: 'chicken.png',
       *     thumper: 'thumper.png',
       * });
       *
       * const resolvedAssets = await resolver.resolveBundle('animals');
       * @param bundleId - The id of the bundle to add
       * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
       */
      addBundle(bundleId, assets) {
        const assetNames = [];
        let convertedAssets = assets;
        if (!Array.isArray(assets)) {
          convertedAssets = Object.entries(assets).map(([alias, src]) => {
            if (typeof src === "string" || Array.isArray(src)) {
              return { alias, src };
            }
            return { alias, ...src };
          });
        }
        convertedAssets.forEach((asset) => {
          const srcs = asset.src;
          const aliases = asset.alias;
          let ids;
          if (typeof aliases === "string") {
            const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
            assetNames.push(bundleAssetId);
            ids = [aliases, bundleAssetId];
          } else {
            const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
            assetNames.push(...bundleIds);
            ids = [...aliases, ...bundleIds];
          }
          this.add({
            ...asset,
            ...{
              alias: ids,
              src: srcs
            }
          });
        });
        this._bundles[bundleId] = assetNames;
      }
      /**
       * Tells the resolver what keys are associated with witch asset.
       * The most important thing the resolver does
       * @example
       * // Single key, single asset:
       * resolver.add({alias: 'foo', src: 'bar.png');
       * resolver.resolveUrl('foo') // => 'bar.png'
       *
       * // Multiple keys, single asset:
       * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
       * resolver.resolveUrl('foo') // => 'bar.png'
       * resolver.resolveUrl('boo') // => 'bar.png'
       *
       * // Multiple keys, multiple assets:
       * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
       * resolver.resolveUrl('foo') // => 'bar.png'
       *
       * // Add custom data attached to the resolver
       * Resolver.add({
       *     alias: 'bunnyBooBooSmooth',
       *     src: 'bunny{png,webp}',
       *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
       * });
       *
       * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
       * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
       */
      add(aliases) {
        const assets = [];
        if (Array.isArray(aliases)) {
          assets.push(...aliases);
        } else {
          assets.push(aliases);
        }
        let keyCheck;
        keyCheck = (key) => {
          if (this.hasKey(key)) {
            warn(`[Resolver] already has key: ${key} overwriting`);
          }
        };
        const assetArray = convertToList(assets);
        assetArray.forEach((asset) => {
          const { src } = asset;
          let { data, format, loadParser } = asset;
          const srcsToUse = convertToList(src).map((src2) => {
            if (typeof src2 === "string") {
              return createStringVariations(src2);
            }
            return Array.isArray(src2) ? src2 : [src2];
          });
          const aliasesToUse = this.getAlias(asset);
          Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
          const resolvedAssets = [];
          srcsToUse.forEach((srcs) => {
            srcs.forEach((src2) => {
              let formattedAsset = {};
              if (typeof src2 !== "object") {
                formattedAsset.src = src2;
                for (let i3 = 0; i3 < this._parsers.length; i3++) {
                  const parser = this._parsers[i3];
                  if (parser.test(src2)) {
                    formattedAsset = parser.parse(src2);
                    break;
                  }
                }
              } else {
                data = src2.data ?? data;
                format = src2.format ?? format;
                loadParser = src2.loadParser ?? loadParser;
                formattedAsset = {
                  ...formattedAsset,
                  ...src2
                };
              }
              if (!aliasesToUse) {
                throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
              }
              formattedAsset = this._buildResolvedAsset(formattedAsset, {
                aliases: aliasesToUse,
                data,
                format,
                loadParser
              });
              resolvedAssets.push(formattedAsset);
            });
          });
          aliasesToUse.forEach((alias) => {
            this._assetMap[alias] = resolvedAssets;
          });
        });
      }
      // TODO: this needs an overload like load did in Assets
      /**
       * If the resolver has had a manifest set via setManifest, this will return the assets urls for
       * a given bundleId or bundleIds.
       * @example
       * // Manifest Example
       * const manifest = {
       *     bundles: [
       *         {
       *             name: 'load-screen',
       *             assets: [
       *                 {
       *                     alias: 'background',
       *                     src: 'sunset.png',
       *                 },
       *                 {
       *                     alias: 'bar',
       *                     src: 'load-bar.{png,webp}',
       *                 },
       *             ],
       *         },
       *         {
       *             name: 'game-screen',
       *             assets: [
       *                 {
       *                     alias: 'character',
       *                     src: 'robot.png',
       *                 },
       *                 {
       *                     alias: 'enemy',
       *                     src: 'bad-guy.png',
       *                 },
       *             ],
       *         },
       *     ]
       * };
       *
       * resolver.setManifest(manifest);
       * const resolved = resolver.resolveBundle('load-screen');
       * @param bundleIds - The bundle ids to resolve
       * @returns All the bundles assets or a hash of assets for each bundle specified
       */
      resolveBundle(bundleIds) {
        const singleAsset = isSingleItem(bundleIds);
        bundleIds = convertToList(bundleIds);
        const out2 = {};
        bundleIds.forEach((bundleId) => {
          const assetNames = this._bundles[bundleId];
          if (assetNames) {
            const results = this.resolve(assetNames);
            const assets = {};
            for (const key in results) {
              const asset = results[key];
              assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
            }
            out2[bundleId] = assets;
          }
        });
        return singleAsset ? out2[bundleIds[0]] : out2;
      }
      /**
       * Does exactly what resolve does, but returns just the URL rather than the whole asset object
       * @param key - The key or keys to resolve
       * @returns - The URLs associated with the key(s)
       */
      resolveUrl(key) {
        const result = this.resolve(key);
        if (typeof key !== "string") {
          const out2 = {};
          for (const i3 in result) {
            out2[i3] = result[i3].src;
          }
          return out2;
        }
        return result.src;
      }
      resolve(keys) {
        const singleAsset = isSingleItem(keys);
        keys = convertToList(keys);
        const result = {};
        keys.forEach((key) => {
          if (!this._resolverHash[key]) {
            if (this._assetMap[key]) {
              let assets = this._assetMap[key];
              const preferredOrder = this._getPreferredOrder(assets);
              preferredOrder?.priority.forEach((priorityKey) => {
                preferredOrder.params[priorityKey].forEach((value) => {
                  const filteredAssets = assets.filter((asset) => {
                    if (asset[priorityKey]) {
                      return asset[priorityKey] === value;
                    }
                    return false;
                  });
                  if (filteredAssets.length) {
                    assets = filteredAssets;
                  }
                });
              });
              this._resolverHash[key] = assets[0];
            } else {
              this._resolverHash[key] = this._buildResolvedAsset({
                alias: [key],
                src: key
              }, {});
            }
          }
          result[key] = this._resolverHash[key];
        });
        return singleAsset ? result[keys[0]] : result;
      }
      /**
       * Checks if an asset with a given key exists in the resolver
       * @param key - The key of the asset
       */
      hasKey(key) {
        return !!this._assetMap[key];
      }
      /**
       * Checks if a bundle with the given key exists in the resolver
       * @param key - The key of the bundle
       */
      hasBundle(key) {
        return !!this._bundles[key];
      }
      /**
       * Internal function for figuring out what prefer criteria an asset should use.
       * @param assets
       */
      _getPreferredOrder(assets) {
        for (let i3 = 0; i3 < assets.length; i3++) {
          const asset = assets[i3];
          const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
          if (preferred) {
            return preferred;
          }
        }
        return this._preferredOrder[0];
      }
      /**
       * Appends the default url parameters to the url
       * @param url - The url to append the default parameters to
       * @returns - The url with the default parameters appended
       */
      _appendDefaultSearchParams(url) {
        if (!this._defaultSearchParams)
          return url;
        const paramConnector = /\?/.test(url) ? "&" : "?";
        return `${url}${paramConnector}${this._defaultSearchParams}`;
      }
      _buildResolvedAsset(formattedAsset, data) {
        const { aliases, data: assetData, loadParser, format } = data;
        if (this._basePath || this._rootPath) {
          formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
        }
        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
        return formattedAsset;
      }
    };
    Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
  }
});

// node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs
var copySearchParams;
var init_copySearchParams = __esm({
  "node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs"() {
    "use strict";
    init_define_AnParams();
    copySearchParams = (targetUrl, sourceUrl) => {
      const searchParams = sourceUrl.split("?")[1];
      if (searchParams) {
        targetUrl += `?${searchParams}`;
      }
      return targetUrl;
    };
  }
});

// node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs
var _Spritesheet, Spritesheet;
var init_Spritesheet = __esm({
  "node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs"() {
    init_define_AnParams();
    init_Rectangle();
    init_Texture();
    _Spritesheet = class _Spritesheet2 {
      /**
       * @param texture - Reference to the source BaseTexture object.
       * @param {object} data - Spritesheet image data.
       */
      constructor(texture, data) {
        this.linkedSheets = [];
        this._texture = texture instanceof Texture ? texture : null;
        this.textureSource = texture.source;
        this.textures = {};
        this.animations = {};
        this.data = data;
        const metaResolution = parseFloat(data.meta.scale);
        if (metaResolution) {
          this.resolution = metaResolution;
          texture.source.resolution = this.resolution;
        } else {
          this.resolution = texture.source._resolution;
        }
        this._frames = this.data.frames;
        this._frameKeys = Object.keys(this._frames);
        this._batchIndex = 0;
        this._callback = null;
      }
      /**
       * Parser spritesheet from loaded data. This is done asynchronously
       * to prevent creating too many Texture within a single process.
       */
      parse() {
        return new Promise((resolve) => {
          this._callback = resolve;
          this._batchIndex = 0;
          if (this._frameKeys.length <= _Spritesheet2.BATCH_SIZE) {
            this._processFrames(0);
            this._processAnimations();
            this._parseComplete();
          } else {
            this._nextBatch();
          }
        });
      }
      /**
       * Process a batch of frames
       * @param initialFrameIndex - The index of frame to start.
       */
      _processFrames(initialFrameIndex) {
        let frameIndex = initialFrameIndex;
        const maxFrames = _Spritesheet2.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
          const i3 = this._frameKeys[frameIndex];
          const data = this._frames[i3];
          const rect = data.frame;
          if (rect) {
            let frame = null;
            let trim = null;
            const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
            const orig = new Rectangle(
              0,
              0,
              Math.floor(sourceSize.w) / this.resolution,
              Math.floor(sourceSize.h) / this.resolution
            );
            if (data.rotated) {
              frame = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.h) / this.resolution,
                Math.floor(rect.w) / this.resolution
              );
            } else {
              frame = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
            }
            if (data.trimmed !== false && data.spriteSourceSize) {
              trim = new Rectangle(
                Math.floor(data.spriteSourceSize.x) / this.resolution,
                Math.floor(data.spriteSourceSize.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
            }
            this.textures[i3] = new Texture({
              source: this.textureSource,
              frame,
              orig,
              trim,
              rotate: data.rotated ? 2 : 0,
              defaultAnchor: data.anchor,
              defaultBorders: data.borders,
              label: i3.toString()
            });
          }
          frameIndex++;
        }
      }
      /** Parse animations config. */
      _processAnimations() {
        const animations = this.data.animations || {};
        for (const animName in animations) {
          this.animations[animName] = [];
          for (let i3 = 0; i3 < animations[animName].length; i3++) {
            const frameName = animations[animName][i3];
            this.animations[animName].push(this.textures[frameName]);
          }
        }
      }
      /** The parse has completed. */
      _parseComplete() {
        const callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
      }
      /** Begin the next batch of textures. */
      _nextBatch() {
        this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(() => {
          if (this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length) {
            this._nextBatch();
          } else {
            this._processAnimations();
            this._parseComplete();
          }
        }, 0);
      }
      /**
       * Destroy Spritesheet and don't use after this.
       * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
       */
      destroy(destroyBase = false) {
        for (const i3 in this.textures) {
          this.textures[i3].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
          this._texture?.destroy();
          this.textureSource.destroy();
        }
        this._texture = null;
        this.textureSource = null;
        this.linkedSheets = [];
      }
    };
    _Spritesheet.BATCH_SIZE = 1e3;
    Spritesheet = _Spritesheet;
  }
});

// node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out2 = {};
  keys.forEach((key) => {
    out2[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out2[key] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i3) => {
      const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i3]}`], item, true);
      Object.assign(out2, out22);
    });
  }
  return out2;
}
var validImages, spritesheetAsset;
var init_spritesheetAsset = __esm({
  "node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs"() {
    init_define_AnParams();
    init_LoaderParser();
    init_Resolver();
    init_copySearchParams();
    init_Extensions();
    init_Texture();
    init_path();
    init_Spritesheet();
    validImages = [
      "jpg",
      "png",
      "jpeg",
      "avif",
      "webp",
      "basis",
      "etc2",
      "bc7",
      "bc6h",
      "bc5",
      "bc4",
      "bc3",
      "bc2",
      "bc1",
      "eac",
      "astc"
    ];
    spritesheetAsset = {
      extension: ExtensionType.Asset,
      /** Handle the caching of the related Spritesheet Textures */
      cache: {
        test: (asset) => asset instanceof Spritesheet,
        getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
      },
      /** Resolve the resolution of the asset. */
      resolver: {
        extension: {
          type: ExtensionType.ResolveParser,
          name: "resolveSpritesheet"
        },
        test: (value) => {
          const tempURL = value.split("?")[0];
          const split = tempURL.split(".");
          const extension = split.pop();
          const format = split.pop();
          return extension === "json" && validImages.includes(format);
        },
        parse: (value) => {
          const split = value.split(".");
          return {
            resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
            format: split[split.length - 2],
            src: value
          };
        }
      },
      /**
       * Loader plugin that parses sprite sheets!
       * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
       * If it is, we load the spritesheets image and parse the data into Spritesheet
       * All textures in the sprite sheet are then added to the cache
       */
      loader: {
        name: "spritesheetLoader",
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Normal,
          name: "spritesheetLoader"
        },
        async testParse(asset, options) {
          return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
        },
        async parse(asset, options, loader) {
          const {
            texture: imageTexture,
            // if user need to use preloaded texture
            imageFilename,
            // if user need to use custom filename (not from jsonFile.meta.image)
            textureOptions
            // if user need to set texture options on texture
          } = options?.data ?? {};
          let basePath = path.dirname(options.src);
          if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
            basePath += "/";
          }
          let texture;
          if (imageTexture instanceof Texture) {
            texture = imageTexture;
          } else {
            const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);
            const assets = await loader.load([{ src: imagePath, data: textureOptions }]);
            texture = assets[imagePath];
          }
          const spritesheet = new Spritesheet(
            texture.source,
            asset
          );
          await spritesheet.parse();
          const multiPacks = asset?.meta?.related_multi_packs;
          if (Array.isArray(multiPacks)) {
            const promises = [];
            for (const item of multiPacks) {
              if (typeof item !== "string") {
                continue;
              }
              let itemUrl = basePath + item;
              if (options.data?.ignoreMultiPack) {
                continue;
              }
              itemUrl = copySearchParams(itemUrl, options.src);
              promises.push(loader.load({
                src: itemUrl,
                data: {
                  textureOptions,
                  ignoreMultiPack: true
                }
              }));
            }
            const res = await Promise.all(promises);
            spritesheet.linkedSheets = res;
            res.forEach((item) => {
              item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
            });
          }
          return spritesheet;
        },
        async unload(spritesheet, _resolvedAsset, loader) {
          await loader.unload(spritesheet.textureSource._sourceOrigin);
          spritesheet.destroy(false);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/spritesheet/init.mjs
var init_init5 = __esm({
  "node_modules/pixi.js/lib/spritesheet/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_spritesheetAsset();
    extensions.add(spritesheetAsset);
  }
});

// node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs
function updateQuadBounds(bounds, anchor, texture) {
  const { width, height } = texture.orig;
  const trim = texture.trim;
  if (trim) {
    const sourceWidth = trim.width;
    const sourceHeight = trim.height;
    bounds.minX = trim.x - anchor._x * width;
    bounds.maxX = bounds.minX + sourceWidth;
    bounds.minY = trim.y - anchor._y * height;
    bounds.maxY = bounds.minY + sourceHeight;
  } else {
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }
}
var init_updateQuadBounds = __esm({
  "node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/sprite/Sprite.mjs
var Sprite;
var init_Sprite = __esm({
  "node_modules/pixi.js/lib/scene/sprite/Sprite.mjs"() {
    init_define_AnParams();
    init_ObservablePoint();
    init_Texture();
    init_updateQuadBounds();
    init_deprecation();
    init_ViewContainer();
    Sprite = class _Sprite extends ViewContainer {
      /**
       * @param options - The options for creating the sprite.
       */
      constructor(options = Texture.EMPTY) {
        if (options instanceof Texture) {
          options = { texture: options };
        }
        const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;
        super({
          label: "Sprite",
          ...rest
        });
        this.renderPipeId = "sprite";
        this.batched = true;
        this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
        this._anchor = new ObservablePoint(
          {
            _onUpdate: () => {
              this.onViewUpdate();
            }
          }
        );
        if (anchor) {
          this.anchor = anchor;
        } else if (texture.defaultAnchor) {
          this.anchor = texture.defaultAnchor;
        }
        this.texture = texture;
        this.allowChildren = false;
        this.roundPixels = roundPixels ?? false;
        if (width !== void 0)
          this.width = width;
        if (height !== void 0)
          this.height = height;
      }
      /**
       * Helper function that creates a new sprite based on the source you provide.
       * The source can be - frame id, image, video, canvas element, video element, texture
       * @param source - Source to create texture from
       * @param [skipCache] - Whether to skip the cache or not
       * @returns The newly created sprite
       */
      static from(source9, skipCache = false) {
        if (source9 instanceof Texture) {
          return new _Sprite(source9);
        }
        return new _Sprite(Texture.from(source9, skipCache));
      }
      set texture(value) {
        value || (value = Texture.EMPTY);
        const currentTexture = this._texture;
        if (currentTexture === value)
          return;
        if (currentTexture && currentTexture.dynamic)
          currentTexture.off("update", this.onViewUpdate, this);
        if (value.dynamic)
          value.on("update", this.onViewUpdate, this);
        this._texture = value;
        if (this._width) {
          this._setWidth(this._width, this._texture.orig.width);
        }
        if (this._height) {
          this._setHeight(this._height, this._texture.orig.height);
        }
        this.onViewUpdate();
      }
      /** The texture that the sprite is using. */
      get texture() {
        return this._texture;
      }
      /**
       * The bounds of the sprite, taking the texture's trim into account.
       * @type {rendering.Bounds}
       */
      get visualBounds() {
        updateQuadBounds(this._visualBounds, this._anchor, this._texture);
        return this._visualBounds;
      }
      /**
       * @deprecated
       */
      get sourceBounds() {
        deprecation("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead.");
        return this.visualBounds;
      }
      /** @private */
      updateBounds() {
        const anchor = this._anchor;
        const texture = this._texture;
        const bounds = this._bounds;
        const { width, height } = texture.orig;
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * height;
        bounds.maxY = bounds.minY + height;
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options = false) {
        super.destroy(options);
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
        this._visualBounds = null;
        this._bounds = null;
        this._anchor = null;
      }
      /**
       * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
       * and passed to the constructor.
       *
       * The default is `(0,0)`, this means the sprite's origin is the top left.
       *
       * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
       *
       * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
       *
       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
       * @example
       * import { Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite({texture: Texture.WHITE});
       * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
       */
      get anchor() {
        return this._anchor;
      }
      set anchor(value) {
        typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
      }
      /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
      get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
      }
      set width(value) {
        this._setWidth(value, this._texture.orig.width);
        this._width = value;
      }
      /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
      get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
      }
      set height(value) {
        this._setHeight(value, this._texture.orig.height);
        this._height = value;
      }
      /**
       * Retrieves the size of the Sprite as a [Size]{@link Size} object.
       * This is faster than get the width and height separately.
       * @param out - Optional object to store the size in.
       * @returns - The size of the Sprite.
       */
      getSize(out2) {
        out2 || (out2 = {});
        out2.width = Math.abs(this.scale.x) * this._texture.orig.width;
        out2.height = Math.abs(this.scale.y) * this._texture.orig.height;
        return out2;
      }
      /**
       * Sets the size of the Sprite to the specified width and height.
       * This is faster than setting the width and height separately.
       * @param value - This can be either a number or a [Size]{@link Size} object.
       * @param height - The height to set. Defaults to the value of `width` if not provided.
       */
      setSize(value, height) {
        if (typeof value === "object") {
          height = value.height ?? value.width;
          value = value.width;
        } else {
          height ?? (height = value);
        }
        value !== void 0 && this._setWidth(value, this._texture.orig.width);
        height !== void 0 && this._setHeight(height, this._texture.orig.height);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs
function addMaskBounds(mask, bounds, skipUpdateTransform) {
  const boundsToMask = tempBounds;
  mask.measurable = true;
  getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
  bounds.addBoundsMask(boundsToMask);
  mask.measurable = false;
}
var tempBounds;
var init_addMaskBounds = __esm({
  "node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs"() {
    init_define_AnParams();
    init_Bounds();
    init_getGlobalBounds();
    tempBounds = new Bounds();
  }
});

// node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs
function addMaskLocalBounds(mask, bounds, localRoot) {
  const boundsToMask = boundsPool.get();
  mask.measurable = true;
  const tempMatrix8 = matrixPool.get().identity();
  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix8);
  getLocalBounds(mask, boundsToMask, relativeMask);
  mask.measurable = false;
  bounds.addBoundsMask(boundsToMask);
  matrixPool.return(tempMatrix8);
  boundsPool.return(boundsToMask);
}
function getMatrixRelativeToParent(target, root, matrix) {
  if (!target) {
    warn("Mask bounds, renderable is not inside the root container");
    return matrix;
  }
  if (target !== root) {
    getMatrixRelativeToParent(target.parent, root, matrix);
    target.updateLocalTransform();
    matrix.append(target.localTransform);
  }
  return matrix;
}
var init_addMaskLocalBounds = __esm({
  "node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs"() {
    init_define_AnParams();
    init_getLocalBounds();
    init_matrixAndBoundsPool();
    init_warn();
  }
});

// node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs
var AlphaMask;
var init_AlphaMask = __esm({
  "node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Sprite();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    AlphaMask = class {
      constructor(options) {
        this.priority = 0;
        this.inverse = false;
        this.pipe = "alphaMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
        this.renderMaskToTexture = !(mask instanceof Sprite);
        this.mask.renderable = this.renderMaskToTexture;
        this.mask.includeInBuild = !this.renderMaskToTexture;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        if (!this.inverse) {
          addMaskBounds(this.mask, bounds, skipUpdateTransform);
        }
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds(this.mask, bounds, localRoot);
      }
      containsPoint(point, hitTestFn) {
        const mask = this.mask;
        return hitTestFn(mask, point);
      }
      destroy() {
        this.reset();
      }
      static test(mask) {
        return mask instanceof Sprite;
      }
    };
    AlphaMask.extension = ExtensionType.MaskEffect;
  }
});

// node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs
var ColorMask;
var init_ColorMask = __esm({
  "node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs"() {
    init_define_AnParams();
    init_Extensions();
    ColorMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "colorMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
      }
      destroy() {
      }
      static test(mask) {
        return typeof mask === "number";
      }
    };
    ColorMask.extension = ExtensionType.MaskEffect;
  }
});

// node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs
var StencilMask;
var init_StencilMask = __esm({
  "node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Container();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    StencilMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "stencilMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
        this.mask.includeInBuild = false;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask.includeInBuild = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        addMaskBounds(this.mask, bounds, skipUpdateTransform);
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds(this.mask, bounds, localRoot);
      }
      containsPoint(point, hitTestFn) {
        const mask = this.mask;
        return hitTestFn(mask, point);
      }
      destroy() {
        this.reset();
      }
      static test(mask) {
        return mask instanceof Container;
      }
    };
    StencilMask.extension = ExtensionType.MaskEffect;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
var CanvasSource;
var init_CanvasSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_Extensions();
    init_TextureSource();
    CanvasSource = class extends TextureSource {
      constructor(options) {
        if (!options.resource) {
          options.resource = DOMAdapter.get().createCanvas();
        }
        if (!options.width) {
          options.width = options.resource.width;
          if (!options.autoDensity) {
            options.width /= options.resolution;
          }
        }
        if (!options.height) {
          options.height = options.resource.height;
          if (!options.autoDensity) {
            options.height /= options.resolution;
          }
        }
        super(options);
        this.uploadMethodId = "image";
        this.autoDensity = options.autoDensity;
        this.resizeCanvas();
        this.transparent = !!options.transparent;
      }
      resizeCanvas() {
        if (this.autoDensity && "style" in this.resource) {
          this.resource.style.width = `${this.width}px`;
          this.resource.style.height = `${this.height}px`;
        }
        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {
          this.resource.width = this.pixelWidth;
          this.resource.height = this.pixelHeight;
        }
      }
      resize(width = this.width, height = this.height, resolution = this._resolution) {
        const didResize = super.resize(width, height, resolution);
        if (didResize) {
          this.resizeCanvas();
        }
        return didResize;
      }
      static test(resource) {
        return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
      }
      /**
       * Returns the 2D rendering context for the canvas.
       * Caches the context after creating it.
       * @returns The 2D rendering context of the canvas.
       */
      get context2D() {
        return this._context2D || (this._context2D = this.resource.getContext("2d"));
      }
    };
    CanvasSource.extension = ExtensionType.TextureSource;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
var ImageSource;
var init_ImageSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_Extensions();
    init_warn();
    init_TextureSource();
    ImageSource = class extends TextureSource {
      constructor(options) {
        if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {
          const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);
          const context2 = canvas.getContext("2d");
          context2.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);
          options.resource = canvas;
          warn("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
        }
        super(options);
        this.uploadMethodId = "image";
        this.autoGarbageCollect = true;
      }
      static test(resource) {
        return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;
      }
    };
    ImageSource.extension = ExtensionType.TextureSource;
  }
});

// node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs
async function detectVideoAlphaMode() {
  promise ?? (promise = (async () => {
    const canvas = document.createElement("canvas");
    const gl = canvas.getContext("webgl");
    if (!gl) {
      return "premultiply-alpha-on-upload";
    }
    const video = await new Promise((resolve) => {
      const video2 = document.createElement("video");
      video2.onloadeddata = () => resolve(video2);
      video2.onerror = () => resolve(null);
      video2.autoplay = false;
      video2.crossOrigin = "anonymous";
      video2.preload = "auto";
      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
      video2.load();
    });
    if (!video) {
      return "premultiply-alpha-on-upload";
    }
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture,
      0
    );
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    const pixel = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    gl.deleteFramebuffer(framebuffer);
    gl.deleteTexture(texture);
    gl.getExtension("WEBGL_lose_context")?.loseContext();
    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })());
  return promise;
}
var promise;
var init_detectVideoAlphaMode = __esm({
  "node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
var _VideoSource, VideoSource;
var init_VideoSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Ticker();
    init_detectVideoAlphaMode();
    init_TextureSource();
    _VideoSource = class _VideoSource2 extends TextureSource {
      constructor(options) {
        super(options);
        this.isReady = false;
        this.uploadMethodId = "video";
        options = {
          ..._VideoSource2.defaultOptions,
          ...options
        };
        this._autoUpdate = true;
        this._isConnectedToTicker = false;
        this._updateFPS = options.updateFPS || 0;
        this._msToNextUpdate = 0;
        this.autoPlay = options.autoPlay !== false;
        this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
        this._videoFrameRequestCallbackHandle = null;
        this._load = null;
        this._resolve = null;
        this._reject = null;
        this._onCanPlay = this._onCanPlay.bind(this);
        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
        this._onError = this._onError.bind(this);
        this._onPlayStart = this._onPlayStart.bind(this);
        this._onPlayStop = this._onPlayStop.bind(this);
        this._onSeeked = this._onSeeked.bind(this);
        if (options.autoLoad !== false) {
          void this.load();
        }
      }
      /** Update the video frame if the source is not destroyed and meets certain conditions. */
      updateFrame() {
        if (this.destroyed) {
          return;
        }
        if (this._updateFPS) {
          const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
        }
        if (!this._updateFPS || this._msToNextUpdate <= 0) {
          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
        }
        if (this.isValid) {
          this.update();
        }
      }
      /** Callback to update the video frame and potentially request the next frame update. */
      _videoFrameRequestCallback() {
        this.updateFrame();
        if (this.destroyed) {
          this._videoFrameRequestCallbackHandle = null;
        } else {
          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
            this._videoFrameRequestCallback
          );
        }
      }
      /**
       * Checks if the resource has valid dimensions.
       * @returns {boolean} True if width and height are set, otherwise false.
       */
      get isValid() {
        return !!this.resource.videoWidth && !!this.resource.videoHeight;
      }
      /**
       * Start preloading the video resource.
       * @returns {Promise<this>} Handle the validate event
       */
      async load() {
        if (this._load) {
          return this._load;
        }
        const source9 = this.resource;
        const options = this.options;
        if ((source9.readyState === source9.HAVE_ENOUGH_DATA || source9.readyState === source9.HAVE_FUTURE_DATA) && source9.width && source9.height) {
          source9.complete = true;
        }
        source9.addEventListener("play", this._onPlayStart);
        source9.addEventListener("pause", this._onPlayStop);
        source9.addEventListener("seeked", this._onSeeked);
        if (!this._isSourceReady()) {
          if (!options.preload) {
            source9.addEventListener("canplay", this._onCanPlay);
          }
          source9.addEventListener("canplaythrough", this._onCanPlayThrough);
          source9.addEventListener("error", this._onError, true);
        } else {
          this._mediaReady();
        }
        this.alphaMode = await detectVideoAlphaMode();
        this._load = new Promise((resolve, reject) => {
          if (this.isValid) {
            resolve(this);
          } else {
            this._resolve = resolve;
            this._reject = reject;
            if (options.preloadTimeoutMs !== void 0) {
              this._preloadTimeout = setTimeout(() => {
                this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));
              });
            }
            source9.load();
          }
        });
        return this._load;
      }
      /**
       * Handle video error events.
       * @param event - The error event
       */
      _onError(event) {
        this.resource.removeEventListener("error", this._onError, true);
        this.emit("error", event);
        if (this._reject) {
          this._reject(event);
          this._reject = null;
          this._resolve = null;
        }
      }
      /**
       * Checks if the underlying source is playing.
       * @returns True if playing.
       */
      _isSourcePlaying() {
        const source9 = this.resource;
        return !source9.paused && !source9.ended;
      }
      /**
       * Checks if the underlying source is ready for playing.
       * @returns True if ready.
       */
      _isSourceReady() {
        const source9 = this.resource;
        return source9.readyState > 2;
      }
      /** Runs the update loop when the video is ready to play. */
      _onPlayStart() {
        if (!this.isValid) {
          this._mediaReady();
        }
        this._configureAutoUpdate();
      }
      /** Stops the update loop when a pause event is triggered. */
      _onPlayStop() {
        this._configureAutoUpdate();
      }
      /** Handles behavior when the video completes seeking to the current playback position. */
      _onSeeked() {
        if (this._autoUpdate && !this._isSourcePlaying()) {
          this._msToNextUpdate = 0;
          this.updateFrame();
          this._msToNextUpdate = 0;
        }
      }
      _onCanPlay() {
        const source9 = this.resource;
        source9.removeEventListener("canplay", this._onCanPlay);
        this._mediaReady();
      }
      _onCanPlayThrough() {
        const source9 = this.resource;
        source9.removeEventListener("canplaythrough", this._onCanPlay);
        if (this._preloadTimeout) {
          clearTimeout(this._preloadTimeout);
          this._preloadTimeout = void 0;
        }
        this._mediaReady();
      }
      /** Fired when the video is loaded and ready to play. */
      _mediaReady() {
        const source9 = this.resource;
        if (this.isValid) {
          this.isReady = true;
          this.resize(source9.videoWidth, source9.videoHeight);
        }
        this._msToNextUpdate = 0;
        this.updateFrame();
        this._msToNextUpdate = 0;
        if (this._resolve) {
          this._resolve(this);
          this._resolve = null;
          this._reject = null;
        }
        if (this._isSourcePlaying()) {
          this._onPlayStart();
        } else if (this.autoPlay) {
          void this.resource.play();
        }
      }
      /** Cleans up resources and event listeners associated with this texture. */
      destroy() {
        this._configureAutoUpdate();
        const source9 = this.resource;
        if (source9) {
          source9.removeEventListener("play", this._onPlayStart);
          source9.removeEventListener("pause", this._onPlayStop);
          source9.removeEventListener("seeked", this._onSeeked);
          source9.removeEventListener("canplay", this._onCanPlay);
          source9.removeEventListener("canplaythrough", this._onCanPlayThrough);
          source9.removeEventListener("error", this._onError, true);
          source9.pause();
          source9.src = "";
          source9.load();
        }
        super.destroy();
      }
      /** Should the base texture automatically update itself, set to true by default. */
      get autoUpdate() {
        return this._autoUpdate;
      }
      set autoUpdate(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          this._configureAutoUpdate();
        }
      }
      /**
       * How many times a second to update the texture from the video.
       * Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get updateFPS() {
        return this._updateFPS;
      }
      set updateFPS(value) {
        if (value !== this._updateFPS) {
          this._updateFPS = value;
          this._configureAutoUpdate();
        }
      }
      /**
       * Configures the updating mechanism based on the current state and settings.
       *
       * This method decides between using the browser's native video frame callback or a custom ticker
       * for updating the video frame. It ensures optimal performance and responsiveness
       * based on the video's state, playback status, and the desired frames-per-second setting.
       *
       * - If `_autoUpdate` is enabled and the video source is playing:
       *   - It will prefer the native video frame callback if available and no specific FPS is set.
       *   - Otherwise, it will use a custom ticker for manual updates.
       * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
       */
      _configureAutoUpdate() {
        if (this._autoUpdate && this._isSourcePlaying()) {
          if (!this._updateFPS && this.resource.requestVideoFrameCallback) {
            if (this._isConnectedToTicker) {
              Ticker.shared.remove(this.updateFrame, this);
              this._isConnectedToTicker = false;
              this._msToNextUpdate = 0;
            }
            if (this._videoFrameRequestCallbackHandle === null) {
              this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
                this._videoFrameRequestCallback
              );
            }
          } else {
            if (this._videoFrameRequestCallbackHandle !== null) {
              this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
              this._videoFrameRequestCallbackHandle = null;
            }
            if (!this._isConnectedToTicker) {
              Ticker.shared.add(this.updateFrame, this);
              this._isConnectedToTicker = true;
              this._msToNextUpdate = 0;
            }
          }
        } else {
          if (this._videoFrameRequestCallbackHandle !== null) {
            this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
            this._videoFrameRequestCallbackHandle = null;
          }
          if (this._isConnectedToTicker) {
            Ticker.shared.remove(this.updateFrame, this);
            this._isConnectedToTicker = false;
            this._msToNextUpdate = 0;
          }
        }
      }
      static test(resource) {
        return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;
      }
    };
    _VideoSource.extension = ExtensionType.TextureSource;
    _VideoSource.defaultOptions = {
      ...TextureSource.defaultOptions,
      /** If true, the video will start loading immediately. */
      autoLoad: true,
      /** If true, the video will start playing as soon as it is loaded. */
      autoPlay: true,
      /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
      updateFPS: 0,
      /** If true, the video will be loaded with the `crossorigin` attribute. */
      crossorigin: true,
      /** If true, the video will loop when it ends. */
      loop: false,
      /** If true, the video will be muted. */
      muted: true,
      /** If true, the video will play inline. */
      playsinline: true,
      /** If true, the video will be preloaded. */
      preload: false
    };
    _VideoSource.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    };
    VideoSource = _VideoSource;
  }
});

// node_modules/pixi.js/lib/assets/cache/Cache.mjs
var CacheClass, Cache;
var init_Cache = __esm({
  "node_modules/pixi.js/lib/assets/cache/Cache.mjs"() {
    init_define_AnParams();
    init_warn();
    init_convertToList();
    CacheClass = class {
      constructor() {
        this._parsers = [];
        this._cache = /* @__PURE__ */ new Map();
        this._cacheMap = /* @__PURE__ */ new Map();
      }
      /** Clear all entries. */
      reset() {
        this._cacheMap.clear();
        this._cache.clear();
      }
      /**
       * Check if the key exists
       * @param key - The key to check
       */
      has(key) {
        return this._cache.has(key);
      }
      /**
       * Fetch entry by key
       * @param key - The key of the entry to get
       */
      get(key) {
        const result = this._cache.get(key);
        if (!result) {
          warn(`[Assets] Asset id ${key} was not found in the Cache`);
        }
        return result;
      }
      /**
       * Set a value by key or keys name
       * @param key - The key or keys to set
       * @param value - The value to store in the cache or from which cacheable assets will be derived.
       */
      set(key, value) {
        const keys = convertToList(key);
        let cacheableAssets;
        for (let i3 = 0; i3 < this.parsers.length; i3++) {
          const parser = this.parsers[i3];
          if (parser.test(value)) {
            cacheableAssets = parser.getCacheableAssets(keys, value);
            break;
          }
        }
        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
        if (!cacheableAssets) {
          keys.forEach((key2) => {
            cacheableMap.set(key2, value);
          });
        }
        const cacheKeys = [...cacheableMap.keys()];
        const cachedAssets = {
          cacheKeys,
          keys
        };
        keys.forEach((key2) => {
          this._cacheMap.set(key2, cachedAssets);
        });
        cacheKeys.forEach((key2) => {
          const val = cacheableAssets ? cacheableAssets[key2] : value;
          if (this._cache.has(key2) && this._cache.get(key2) !== val) {
            warn("[Cache] already has key:", key2);
          }
          this._cache.set(key2, cacheableMap.get(key2));
        });
      }
      /**
       * Remove entry by key
       *
       * This function will also remove any associated alias from the cache also.
       * @param key - The key of the entry to remove
       */
      remove(key) {
        if (!this._cacheMap.has(key)) {
          warn(`[Assets] Asset id ${key} was not found in the Cache`);
          return;
        }
        const cacheMap2 = this._cacheMap.get(key);
        const cacheKeys = cacheMap2.cacheKeys;
        cacheKeys.forEach((key2) => {
          this._cache.delete(key2);
        });
        cacheMap2.keys.forEach((key2) => {
          this._cacheMap.delete(key2);
        });
      }
      /** All loader parsers registered */
      get parsers() {
        return this._parsers;
      }
    };
    Cache = new CacheClass();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs
function autoDetectSource(options = {}) {
  return textureSourceFrom(options);
}
function textureSourceFrom(options = {}) {
  const hasResource = options && options.resource;
  const res = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  for (let i3 = 0; i3 < sources.length; i3++) {
    const Source = sources[i3];
    if (Source.test(res)) {
      return new Source(opts);
    }
  }
  throw new Error(`Could not find a source type for resource: ${opts.resource}`);
}
function resourceToTexture(options = {}, skipCache = false) {
  const hasResource = options && options.resource;
  const resource = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  if (!skipCache && Cache.has(resource)) {
    return Cache.get(resource);
  }
  const texture = new Texture({ source: textureSourceFrom(opts) });
  texture.on("destroy", () => {
    if (Cache.has(resource)) {
      Cache.remove(resource);
    }
  });
  if (!skipCache) {
    Cache.set(resource, texture);
  }
  return texture;
}
function textureFrom(id, skipCache = false) {
  if (typeof id === "string") {
    return Cache.get(id);
  } else if (id instanceof TextureSource) {
    return new Texture({ source: id });
  }
  return resourceToTexture(id, skipCache);
}
var sources;
var init_textureFrom = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs"() {
    init_define_AnParams();
    init_Cache();
    init_Extensions();
    init_TextureSource();
    init_Texture();
    sources = [];
    extensions.handleByList(ExtensionType.TextureSource, sources);
    Texture.from = textureFrom;
    TextureSource.from = textureSourceFrom;
  }
});

// node_modules/pixi.js/lib/rendering/init.mjs
var init_init6 = __esm({
  "node_modules/pixi.js/lib/rendering/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_AlphaMask();
    init_ColorMask();
    init_StencilMask();
    init_BufferImageSource();
    init_CanvasSource();
    init_ImageSource();
    init_VideoSource();
    init_textureFrom();
    extensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs
var BindGroup;
var init_BindGroup = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"() {
    "use strict";
    init_define_AnParams();
    BindGroup = class {
      /**
       * Create a new instance eof the Bind Group.
       * @param resources - The resources that are bound together for use by a shader.
       */
      constructor(resources) {
        this.resources = /* @__PURE__ */ Object.create(null);
        this._dirty = true;
        let index = 0;
        for (const i3 in resources) {
          const resource = resources[i3];
          this.setResource(resource, index++);
        }
        this._updateKey();
      }
      /**
       * Updates the key if its flagged as dirty. This is used internally to
       * match this bind group to a WebGPU BindGroup.
       * @internal
       * @ignore
       */
      _updateKey() {
        if (!this._dirty)
          return;
        this._dirty = false;
        const keyParts = [];
        let index = 0;
        for (const i3 in this.resources) {
          keyParts[index++] = this.resources[i3]._resourceId;
        }
        this._key = keyParts.join("|");
      }
      /**
       * Set a resource at a given index. this function will
       * ensure that listeners will be removed from the current resource
       * and added to the new resource.
       * @param resource - The resource to set.
       * @param index - The index to set the resource at.
       */
      setResource(resource, index) {
        const currentResource = this.resources[index];
        if (resource === currentResource)
          return;
        if (currentResource) {
          resource.off?.("change", this.onResourceChange, this);
        }
        resource.on?.("change", this.onResourceChange, this);
        this.resources[index] = resource;
        this._dirty = true;
      }
      /**
       * Returns the resource at the current specified index.
       * @param index - The index of the resource to get.
       * @returns - The resource at the specified index.
       */
      getResource(index) {
        return this.resources[index];
      }
      /**
       * Used internally to 'touch' each resource, to ensure that the GC
       * knows that all resources in this bind group are still being used.
       * @param tick - The current tick.
       * @internal
       * @ignore
       */
      _touch(tick) {
        const resources = this.resources;
        for (const i3 in resources) {
          resources[i3]._touched = tick;
        }
      }
      /** Destroys this bind group and removes all listeners. */
      destroy() {
        const resources = this.resources;
        for (const i3 in resources) {
          const resource = resources[i3];
          resource.off?.("change", this.onResourceChange, this);
        }
        this.resources = null;
      }
      onResourceChange(resource) {
        this._dirty = true;
        if (resource.destroyed) {
          const resources = this.resources;
          for (const i3 in resources) {
            if (resources[i3] === resource) {
              resources[i3] = null;
            }
          }
        } else {
          this._updateKey();
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
function getTestContext() {
  if (!context || context?.isContextLost()) {
    const canvas = DOMAdapter.get().createCanvas();
    context = canvas.getContext("webgl", {});
  }
  return context;
}
var context;
var init_getTestContext = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs"() {
    init_define_AnParams();
    init_adapter();
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i3 = 0; i3 < maxIfs; ++i3) {
    if (i3 > 0) {
      src += "\nelse ";
    }
    if (i3 < maxIfs - 1) {
      src += `if(test == ${i3}.0){}`;
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  try {
    while (true) {
      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
      gl.shaderSource(shader, fragmentSrc);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        maxIfs = maxIfs / 2 | 0;
      } else {
        break;
      }
    }
  } finally {
    gl.deleteShader(shader);
  }
  return maxIfs;
}
var fragTemplate;
var init_checkMaxIfStatementsInShader = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs"() {
    "use strict";
    init_define_AnParams();
    fragTemplate = [
      "precision mediump float;",
      "void main(void){",
      "float test = 0.1;",
      "%forloop%",
      "gl_FragColor = vec4(0.0);",
      "}"
    ].join("\n");
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs
function getMaxTexturesPerBatch() {
  if (maxTexturesPerBatchCache)
    return maxTexturesPerBatchCache;
  const gl = getTestContext();
  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(
    maxTexturesPerBatchCache,
    gl
  );
  gl.getExtension("WEBGL_lose_context")?.loseContext();
  return maxTexturesPerBatchCache;
}
var maxTexturesPerBatchCache;
var init_maxRecommendedTextures = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs"() {
    init_define_AnParams();
    init_getTestContext();
    init_checkMaxIfStatementsInShader();
    maxTexturesPerBatchCache = null;
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
function getTextureBatchBindGroup(textures, size) {
  let uid3 = 2166136261;
  for (let i3 = 0; i3 < size; i3++) {
    uid3 ^= textures[i3].uid;
    uid3 = Math.imul(uid3, 16777619);
    uid3 >>>= 0;
  }
  return cachedGroups[uid3] || generateTextureBatchBindGroup(textures, size, uid3);
}
function generateTextureBatchBindGroup(textures, size, key) {
  const bindGroupResources = {};
  let bindIndex = 0;
  if (!maxTextures)
    maxTextures = getMaxTexturesPerBatch();
  for (let i3 = 0; i3 < maxTextures; i3++) {
    const texture = i3 < size ? textures[i3] : Texture.EMPTY.source;
    bindGroupResources[bindIndex++] = texture.source;
    bindGroupResources[bindIndex++] = texture.style;
  }
  const bindGroup = new BindGroup(bindGroupResources);
  cachedGroups[key] = bindGroup;
  return bindGroup;
}
var cachedGroups, maxTextures;
var init_getTextureBatchBindGroup = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs"() {
    init_define_AnParams();
    init_BindGroup();
    init_Texture();
    init_maxRecommendedTextures();
    cachedGroups = {};
    maxTextures = 0;
  }
});

// node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs
var ViewableBuffer;
var init_ViewableBuffer = __esm({
  "node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs"() {
    "use strict";
    init_define_AnParams();
    ViewableBuffer = class {
      constructor(sizeOrBuffer) {
        if (typeof sizeOrBuffer === "number") {
          this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
        } else if (sizeOrBuffer instanceof Uint8Array) {
          this.rawBinaryData = sizeOrBuffer.buffer;
        } else {
          this.rawBinaryData = sizeOrBuffer;
        }
        this.uint32View = new Uint32Array(this.rawBinaryData);
        this.float32View = new Float32Array(this.rawBinaryData);
        this.size = this.rawBinaryData.byteLength;
      }
      /** View on the raw binary data as a `Int8Array`. */
      get int8View() {
        if (!this._int8View) {
          this._int8View = new Int8Array(this.rawBinaryData);
        }
        return this._int8View;
      }
      /** View on the raw binary data as a `Uint8Array`. */
      get uint8View() {
        if (!this._uint8View) {
          this._uint8View = new Uint8Array(this.rawBinaryData);
        }
        return this._uint8View;
      }
      /**  View on the raw binary data as a `Int16Array`. */
      get int16View() {
        if (!this._int16View) {
          this._int16View = new Int16Array(this.rawBinaryData);
        }
        return this._int16View;
      }
      /** View on the raw binary data as a `Int32Array`. */
      get int32View() {
        if (!this._int32View) {
          this._int32View = new Int32Array(this.rawBinaryData);
        }
        return this._int32View;
      }
      /** View on the raw binary data as a `Float64Array`. */
      get float64View() {
        if (!this._float64Array) {
          this._float64Array = new Float64Array(this.rawBinaryData);
        }
        return this._float64Array;
      }
      /** View on the raw binary data as a `BigUint64Array`. */
      get bigUint64View() {
        if (!this._bigUint64Array) {
          this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
        }
        return this._bigUint64Array;
      }
      /**
       * Returns the view of the given type.
       * @param type - One of `int8`, `uint8`, `int16`,
       *    `uint16`, `int32`, `uint32`, and `float32`.
       * @returns - typed array of given type
       */
      view(type) {
        return this[`${type}View`];
      }
      /** Destroys all buffer references. Do not use after calling this. */
      destroy() {
        this.rawBinaryData = null;
        this._int8View = null;
        this._uint8View = null;
        this._int16View = null;
        this.uint16View = null;
        this._int32View = null;
        this.uint32View = null;
        this.float32View = null;
      }
      /**
       * Returns the size of the given type in bytes.
       * @param type - One of `int8`, `uint8`, `int16`,
       *   `uint16`, `int32`, `uint32`, and `float32`.
       * @returns - size of the type in bytes
       */
      static sizeOf(type) {
        switch (type) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          default:
            throw new Error(`${type} isn't a valid view type`);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
function fastCopy(sourceBuffer, destinationBuffer) {
  const lengthDouble = sourceBuffer.byteLength / 8 | 0;
  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
  destinationFloat64View.set(sourceFloat64View);
  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;
  if (remainingBytes > 0) {
    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);
    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);
    destinationUint8View.set(sourceUint8View);
  }
}
var init_fastCopy = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs
var BLEND_TO_NPM, STENCIL_MODES;
var init_const3 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs"() {
    "use strict";
    init_define_AnParams();
    BLEND_TO_NPM = {
      normal: "normal-npm",
      add: "add-npm",
      screen: "screen-npm"
    };
    STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
      STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
      STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
      STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
      STENCIL_MODES2[STENCIL_MODES2["INVERSE_MASK_ACTIVE"] = 3] = "INVERSE_MASK_ACTIVE";
      STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 4] = "RENDERING_MASK_REMOVE";
      STENCIL_MODES2[STENCIL_MODES2["NONE"] = 5] = "NONE";
      return STENCIL_MODES2;
    })(STENCIL_MODES || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs
function getAdjustedBlendModeBlend(blendMode, textureSource) {
  if (textureSource.alphaMode === "no-premultiply-alpha") {
    return BLEND_TO_NPM[blendMode] || blendMode;
  }
  return blendMode;
}
var init_getAdjustedBlendModeBlend = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"() {
    init_define_AnParams();
    init_const3();
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs
var BatchTextureArray;
var init_BatchTextureArray = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs"() {
    "use strict";
    init_define_AnParams();
    BatchTextureArray = class {
      constructor() {
        this.ids = /* @__PURE__ */ Object.create(null);
        this.textures = [];
        this.count = 0;
      }
      /** Clear the textures and their locations. */
      clear() {
        for (let i3 = 0; i3 < this.count; i3++) {
          const t2 = this.textures[i3];
          this.textures[i3] = null;
          this.ids[t2.uid] = null;
        }
        this.count = 0;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs
function getBatchFromPool() {
  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();
}
function returnBatchToPool(batch) {
  batchPool[batchPoolIndex++] = batch;
}
var Batch, batchPool, batchPoolIndex, BATCH_TICK, _Batcher, Batcher;
var init_Batcher = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs"() {
    init_define_AnParams();
    init_uid();
    init_ViewableBuffer();
    init_fastCopy();
    init_getAdjustedBlendModeBlend();
    init_maxRecommendedTextures();
    init_BatchTextureArray();
    Batch = class {
      constructor() {
        this.renderPipeId = "batch";
        this.action = "startBatch";
        this.start = 0;
        this.size = 0;
        this.textures = new BatchTextureArray();
        this.blendMode = "normal";
        this.topology = "triangle-strip";
        this.canBundle = true;
      }
      destroy() {
        this.textures = null;
        this.gpuBindGroup = null;
        this.bindGroup = null;
        this.batcher = null;
      }
    };
    batchPool = [];
    batchPoolIndex = 0;
    BATCH_TICK = 0;
    _Batcher = class _Batcher2 {
      constructor(options = {}) {
        this.uid = uid("batcher");
        this.dirty = true;
        this.batchIndex = 0;
        this.batches = [];
        this._elements = [];
        _Batcher2.defaultOptions.maxTextures = _Batcher2.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();
        options = { ..._Batcher2.defaultOptions, ...options };
        const { maxTextures: maxTextures2, attributesInitialSize, indicesInitialSize } = options;
        this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);
        this.indexBuffer = new Uint16Array(indicesInitialSize);
        this.maxTextures = maxTextures2;
      }
      begin() {
        this.elementSize = 0;
        this.elementStart = 0;
        this.indexSize = 0;
        this.attributeSize = 0;
        for (let i3 = 0; i3 < this.batchIndex; i3++) {
          returnBatchToPool(this.batches[i3]);
        }
        this.batchIndex = 0;
        this._batchIndexStart = 0;
        this._batchIndexSize = 0;
        this.dirty = true;
      }
      add(batchableObject) {
        this._elements[this.elementSize++] = batchableObject;
        batchableObject._indexStart = this.indexSize;
        batchableObject._attributeStart = this.attributeSize;
        batchableObject._batcher = this;
        this.indexSize += batchableObject.indexSize;
        this.attributeSize += batchableObject.attributeSize * this.vertexSize;
      }
      checkAndUpdateTexture(batchableObject, texture) {
        const textureId = batchableObject._batch.textures.ids[texture._source.uid];
        if (!textureId && textureId !== 0)
          return false;
        batchableObject._textureId = textureId;
        batchableObject.texture = texture;
        return true;
      }
      updateElement(batchableObject) {
        this.dirty = true;
        const attributeBuffer = this.attributeBuffer;
        if (batchableObject.packAsQuad) {
          this.packQuadAttributes(
            batchableObject,
            attributeBuffer.float32View,
            attributeBuffer.uint32View,
            batchableObject._attributeStart,
            batchableObject._textureId
          );
        } else {
          this.packAttributes(
            batchableObject,
            attributeBuffer.float32View,
            attributeBuffer.uint32View,
            batchableObject._attributeStart,
            batchableObject._textureId
          );
        }
      }
      /**
       * breaks the batcher. This happens when a batch gets too big,
       * or we need to switch to a different type of rendering (a filter for example)
       * @param instructionSet
       */
      break(instructionSet) {
        const elements = this._elements;
        if (!elements[this.elementStart])
          return;
        let batch = getBatchFromPool();
        let textureBatch = batch.textures;
        textureBatch.clear();
        const firstElement = elements[this.elementStart];
        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);
        let topology = firstElement.topology;
        if (this.attributeSize * 4 > this.attributeBuffer.size) {
          this._resizeAttributeBuffer(this.attributeSize * 4);
        }
        if (this.indexSize > this.indexBuffer.length) {
          this._resizeIndexBuffer(this.indexSize);
        }
        const f32 = this.attributeBuffer.float32View;
        const u32 = this.attributeBuffer.uint32View;
        const indexBuffer = this.indexBuffer;
        let size = this._batchIndexSize;
        let start = this._batchIndexStart;
        let action = "startBatch";
        const maxTextures2 = this.maxTextures;
        for (let i3 = this.elementStart; i3 < this.elementSize; ++i3) {
          const element = elements[i3];
          elements[i3] = null;
          const texture = element.texture;
          const source9 = texture._source;
          const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source9);
          const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;
          if (source9._batchTick === BATCH_TICK && !breakRequired) {
            element._textureId = source9._textureBindLocation;
            size += element.indexSize;
            if (element.packAsQuad) {
              this.packQuadAttributes(
                element,
                f32,
                u32,
                element._attributeStart,
                element._textureId
              );
              this.packQuadIndex(
                indexBuffer,
                element._indexStart,
                element._attributeStart / this.vertexSize
              );
            } else {
              this.packAttributes(
                element,
                f32,
                u32,
                element._attributeStart,
                element._textureId
              );
              this.packIndex(
                element,
                indexBuffer,
                element._indexStart,
                element._attributeStart / this.vertexSize
              );
            }
            element._batch = batch;
            continue;
          }
          source9._batchTick = BATCH_TICK;
          if (textureBatch.count >= maxTextures2 || breakRequired) {
            this._finishBatch(
              batch,
              start,
              size - start,
              textureBatch,
              blendMode,
              topology,
              instructionSet,
              action
            );
            action = "renderBatch";
            start = size;
            blendMode = adjustedBlendMode;
            topology = element.topology;
            batch = getBatchFromPool();
            textureBatch = batch.textures;
            textureBatch.clear();
            ++BATCH_TICK;
          }
          element._textureId = source9._textureBindLocation = textureBatch.count;
          textureBatch.ids[source9.uid] = textureBatch.count;
          textureBatch.textures[textureBatch.count++] = source9;
          element._batch = batch;
          size += element.indexSize;
          if (element.packAsQuad) {
            this.packQuadAttributes(
              element,
              f32,
              u32,
              element._attributeStart,
              element._textureId
            );
            this.packQuadIndex(
              indexBuffer,
              element._indexStart,
              element._attributeStart / this.vertexSize
            );
          } else {
            this.packAttributes(
              element,
              f32,
              u32,
              element._attributeStart,
              element._textureId
            );
            this.packIndex(
              element,
              indexBuffer,
              element._indexStart,
              element._attributeStart / this.vertexSize
            );
          }
        }
        if (textureBatch.count > 0) {
          this._finishBatch(
            batch,
            start,
            size - start,
            textureBatch,
            blendMode,
            topology,
            instructionSet,
            action
          );
          start = size;
          ++BATCH_TICK;
        }
        this.elementStart = this.elementSize;
        this._batchIndexStart = start;
        this._batchIndexSize = size;
      }
      _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action) {
        batch.gpuBindGroup = null;
        batch.bindGroup = null;
        batch.action = action;
        batch.batcher = this;
        batch.textures = textureBatch;
        batch.blendMode = blendMode;
        batch.topology = topology;
        batch.start = indexStart;
        batch.size = indexSize;
        ++BATCH_TICK;
        this.batches[this.batchIndex++] = batch;
        instructionSet.add(batch);
      }
      finish(instructionSet) {
        this.break(instructionSet);
      }
      /**
       * Resizes the attribute buffer to the given size (1 = 1 float32)
       * @param size - the size in vertices to ensure (not bytes!)
       */
      ensureAttributeBuffer(size) {
        if (size * 4 <= this.attributeBuffer.size)
          return;
        this._resizeAttributeBuffer(size * 4);
      }
      /**
       * Resizes the index buffer to the given size (1 = 1 float32)
       * @param size - the size in vertices to ensure (not bytes!)
       */
      ensureIndexBuffer(size) {
        if (size <= this.indexBuffer.length)
          return;
        this._resizeIndexBuffer(size);
      }
      _resizeAttributeBuffer(size) {
        const newSize = Math.max(size, this.attributeBuffer.size * 2);
        const newArrayBuffer = new ViewableBuffer(newSize);
        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
        this.attributeBuffer = newArrayBuffer;
      }
      _resizeIndexBuffer(size) {
        const indexBuffer = this.indexBuffer;
        let newSize = Math.max(size, indexBuffer.length * 1.5);
        newSize += newSize % 2;
        const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
          for (let i3 = 0; i3 < indexBuffer.length; i3++) {
            newIndexBuffer[i3] = indexBuffer[i3];
          }
        } else {
          fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
        }
        this.indexBuffer = newIndexBuffer;
      }
      packQuadIndex(indexBuffer, index, indicesOffset) {
        indexBuffer[index] = indicesOffset + 0;
        indexBuffer[index + 1] = indicesOffset + 1;
        indexBuffer[index + 2] = indicesOffset + 2;
        indexBuffer[index + 3] = indicesOffset + 0;
        indexBuffer[index + 4] = indicesOffset + 2;
        indexBuffer[index + 5] = indicesOffset + 3;
      }
      packIndex(element, indexBuffer, index, indicesOffset) {
        const indices = element.indices;
        const size = element.indexSize;
        const indexOffset = element.indexOffset;
        const attributeOffset = element.attributeOffset;
        for (let i3 = 0; i3 < size; i3++) {
          indexBuffer[index++] = indicesOffset + indices[i3 + indexOffset] - attributeOffset;
        }
      }
      destroy() {
        for (let i3 = 0; i3 < this.batches.length; i3++) {
          returnBatchToPool(this.batches[i3]);
        }
        this.batches = null;
        for (let i3 = 0; i3 < this._elements.length; i3++) {
          this._elements[i3]._batch = null;
        }
        this._elements = null;
        this.indexBuffer = null;
        this.attributeBuffer.destroy();
        this.attributeBuffer = null;
      }
    };
    _Batcher.defaultOptions = {
      maxTextures: null,
      attributesInitialSize: 4,
      indicesInitialSize: 6
    };
    Batcher = _Batcher;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs
var BufferUsage;
var init_const4 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"() {
    "use strict";
    init_define_AnParams();
    BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
      BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
      BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
      BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
      BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
      BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
      BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
      BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
      BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
      BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
      BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
      BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
      return BufferUsage2;
    })(BufferUsage || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs
var Buffer2;
var init_Buffer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"() {
    init_define_AnParams();
    init_eventemitter3();
    init_uid();
    init_const4();
    Buffer2 = class extends eventemitter3_default {
      /**
       * Creates a new Buffer with the given options
       * @param options - the options for the buffer
       */
      constructor(options) {
        let { data, size } = options;
        const { usage, label, shrinkToFit } = options;
        super();
        this.uid = uid("buffer");
        this._resourceType = "buffer";
        this._resourceId = uid("resource");
        this._touched = 0;
        this._updateID = 1;
        this._dataInt32 = null;
        this.shrinkToFit = true;
        this.destroyed = false;
        if (data instanceof Array) {
          data = new Float32Array(data);
        }
        this._data = data;
        size ?? (size = data?.byteLength);
        const mappedAtCreation = !!data;
        this.descriptor = {
          size,
          usage,
          mappedAtCreation,
          label
        };
        this.shrinkToFit = shrinkToFit ?? true;
      }
      /** the data in the buffer */
      get data() {
        return this._data;
      }
      set data(value) {
        this.setDataWithSize(value, value.length, true);
      }
      get dataInt32() {
        if (!this._dataInt32) {
          this._dataInt32 = new Int32Array(this.data.buffer);
        }
        return this._dataInt32;
      }
      /** whether the buffer is static or not */
      get static() {
        return !!(this.descriptor.usage & BufferUsage.STATIC);
      }
      set static(value) {
        if (value) {
          this.descriptor.usage |= BufferUsage.STATIC;
        } else {
          this.descriptor.usage &= ~BufferUsage.STATIC;
        }
      }
      /**
       * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
       * If you only want to update a subset of the buffer, you can pass in the size of the data.
       * @param value - the data to set
       * @param size - the size of the data in bytes
       * @param syncGPU - should the buffer be updated on the GPU immediately?
       */
      setDataWithSize(value, size, syncGPU) {
        this._updateID++;
        this._updateSize = size * value.BYTES_PER_ELEMENT;
        if (this._data === value) {
          if (syncGPU)
            this.emit("update", this);
          return;
        }
        const oldData = this._data;
        this._data = value;
        this._dataInt32 = null;
        if (!oldData || oldData.length !== value.length) {
          if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {
            if (syncGPU)
              this.emit("update", this);
          } else {
            this.descriptor.size = value.byteLength;
            this._resourceId = uid("resource");
            this.emit("change", this);
          }
          return;
        }
        if (syncGPU)
          this.emit("update", this);
      }
      /**
       * updates the buffer on the GPU to reflect the data in the buffer.
       * By default it will update the entire buffer. If you only want to update a subset of the buffer,
       * you can pass in the size of the buffer to update.
       * @param sizeInBytes - the new size of the buffer in bytes
       */
      update(sizeInBytes) {
        this._updateSize = sizeInBytes ?? this._updateSize;
        this._updateID++;
        this.emit("update", this);
      }
      /** Destroys the buffer */
      destroy() {
        this.destroyed = true;
        this.emit("destroy", this);
        this.emit("change", this);
        this._data = null;
        this.descriptor = null;
        this.removeAllListeners();
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
function ensureIsBuffer(buffer, index) {
  if (!(buffer instanceof Buffer2)) {
    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
    if (buffer instanceof Array) {
      if (index) {
        buffer = new Uint32Array(buffer);
        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
      } else {
        buffer = new Float32Array(buffer);
        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
      }
    }
    buffer = new Buffer2({
      data: buffer,
      label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",
      usage
    });
  }
  return buffer;
}
var init_ensureIsBuffer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs"() {
    init_define_AnParams();
    init_Buffer();
    init_const4();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs
function getGeometryBounds(geometry, attributeId, bounds) {
  const attribute = geometry.getAttribute(attributeId);
  if (!attribute) {
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = 0;
    bounds.maxY = 0;
    return bounds;
  }
  const data = attribute.buffer.data;
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  const byteSize = data.BYTES_PER_ELEMENT;
  const offset = (attribute.offset || 0) / byteSize;
  const stride = (attribute.stride || 2 * 4) / byteSize;
  for (let i3 = offset; i3 < data.length; i3 += stride) {
    const x2 = data[i3];
    const y2 = data[i3 + 1];
    if (x2 > maxX)
      maxX = x2;
    if (y2 > maxY)
      maxY = y2;
    if (x2 < minX)
      minX = x2;
    if (y2 < minY)
      minY = y2;
  }
  bounds.minX = minX;
  bounds.minY = minY;
  bounds.maxX = maxX;
  bounds.maxY = maxY;
  return bounds;
}
var init_getGeometryBounds = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs
function ensureIsAttribute(attribute) {
  if (attribute instanceof Buffer2 || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
    attribute = {
      buffer: attribute
    };
  }
  attribute.buffer = ensureIsBuffer(attribute.buffer, false);
  return attribute;
}
var Geometry;
var init_Geometry = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"() {
    init_define_AnParams();
    init_eventemitter3();
    init_Bounds();
    init_uid();
    init_Buffer();
    init_ensureIsBuffer();
    init_getGeometryBounds();
    Geometry = class extends eventemitter3_default {
      /**
       * Create a new instance of a geometry
       * @param options - The options for the geometry.
       */
      constructor(options = {}) {
        super();
        this.uid = uid("geometry");
        this._layoutKey = 0;
        this.instanceCount = 1;
        this._bounds = new Bounds();
        this._boundsDirty = true;
        const { attributes, indexBuffer, topology } = options;
        this.buffers = [];
        this.attributes = {};
        if (attributes) {
          for (const i3 in attributes) {
            this.addAttribute(i3, attributes[i3]);
          }
        }
        this.instanceCount = options.instanceCount ?? 1;
        if (indexBuffer) {
          this.addIndex(indexBuffer);
        }
        this.topology = topology || "triangle-list";
      }
      onBufferUpdate() {
        this._boundsDirty = true;
        this.emit("update", this);
      }
      /**
       * Returns the requested attribute.
       * @param id - The name of the attribute required
       * @returns - The attribute requested.
       */
      getAttribute(id) {
        return this.attributes[id];
      }
      /**
       * Returns the index buffer
       * @returns - The index buffer.
       */
      getIndex() {
        return this.indexBuffer;
      }
      /**
       * Returns the requested buffer.
       * @param id - The name of the buffer required.
       * @returns - The buffer requested.
       */
      getBuffer(id) {
        return this.getAttribute(id).buffer;
      }
      /**
       * Used to figure out how many vertices there are in this geometry
       * @returns the number of vertices in the geometry
       */
      getSize() {
        for (const i3 in this.attributes) {
          const attribute = this.attributes[i3];
          const buffer = attribute.buffer;
          return buffer.data.length / (attribute.stride / 4 || attribute.size);
        }
        return 0;
      }
      /**
       * Adds an attribute to the geometry.
       * @param name - The name of the attribute to add.
       * @param attributeOption - The attribute option to add.
       */
      addAttribute(name, attributeOption) {
        const attribute = ensureIsAttribute(attributeOption);
        const bufferIndex = this.buffers.indexOf(attribute.buffer);
        if (bufferIndex === -1) {
          this.buffers.push(attribute.buffer);
          attribute.buffer.on("update", this.onBufferUpdate, this);
          attribute.buffer.on("change", this.onBufferUpdate, this);
        }
        this.attributes[name] = attribute;
      }
      /**
       * Adds an index buffer to the geometry.
       * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
       */
      addIndex(indexBuffer) {
        this.indexBuffer = ensureIsBuffer(indexBuffer, true);
        this.buffers.push(this.indexBuffer);
      }
      /** Returns the bounds of the geometry. */
      get bounds() {
        if (!this._boundsDirty)
          return this._bounds;
        this._boundsDirty = false;
        return getGeometryBounds(this, "aPosition", this._bounds);
      }
      /**
       * destroys the geometry.
       * @param destroyBuffers - destroy the buffers associated with this geometry
       */
      destroy(destroyBuffers = false) {
        this.emit("destroy", this);
        this.removeAllListeners();
        if (destroyBuffers) {
          this.buffers.forEach((buffer) => buffer.destroy());
        }
        this.attributes = null;
        this.buffers = null;
        this.indexBuffer = null;
        this._bounds = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs
var placeHolderBufferData, placeHolderIndexData, BatchGeometry;
var init_BatchGeometry = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs"() {
    init_define_AnParams();
    init_Buffer();
    init_const4();
    init_Geometry();
    placeHolderBufferData = new Float32Array(1);
    placeHolderIndexData = new Uint32Array(1);
    BatchGeometry = class extends Geometry {
      constructor() {
        const vertexSize = 6;
        const attributeBuffer = new Buffer2({
          data: placeHolderBufferData,
          label: "attribute-batch-buffer",
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
          shrinkToFit: false
        });
        const indexBuffer = new Buffer2({
          data: placeHolderIndexData,
          label: "index-batch-buffer",
          usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
          // | BufferUsage.STATIC,
          shrinkToFit: false
        });
        const stride = vertexSize * 4;
        super({
          attributes: {
            aPosition: {
              buffer: attributeBuffer,
              format: "float32x2",
              stride,
              offset: 0
            },
            aUV: {
              buffer: attributeBuffer,
              format: "float32x2",
              stride,
              offset: 2 * 4
            },
            aColor: {
              buffer: attributeBuffer,
              format: "unorm8x4",
              stride,
              offset: 4 * 4
            },
            aTextureIdAndRound: {
              buffer: attributeBuffer,
              format: "uint16x2",
              stride,
              offset: 5 * 4
            }
          },
          indexBuffer
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs
function createIdFromString(value, groupId) {
  let id = idHash2[value];
  if (id === void 0) {
    if (idCounts[groupId] === void 0) {
      idCounts[groupId] = 1;
    }
    idHash2[value] = id = idCounts[groupId]++;
  }
  return id;
}
var idCounts, idHash2;
var init_createIdFromString = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs"() {
    "use strict";
    init_define_AnParams();
    idCounts = /* @__PURE__ */ Object.create(null);
    idHash2 = /* @__PURE__ */ Object.create(null);
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = "mediump";
    const gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
      }
    }
  }
  return maxFragmentPrecision;
}
var maxFragmentPrecision;
var init_getMaxFragmentPrecision = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs"() {
    init_define_AnParams();
    init_getTestContext();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs
function addProgramDefines(src, isES300, isFragment) {
  if (isES300)
    return src;
  if (isFragment) {
    src = src.replace("out vec4 finalColor;", "");
    return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src}
        `;
  }
  return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src}
        `;
}
var init_addProgramDefines = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs
function ensurePrecision(src, options, isFragment) {
  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
  if (src.substring(0, 9) !== "precision") {
    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
    if (precision === "highp" && maxSupportedPrecision !== "highp") {
      precision = "mediump";
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var init_ensurePrecision = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs
function insertVersion(src, isES300) {
  if (!isES300)
    return src;
  return `#version 300 es
${src}`;
}
var init_insertVersion = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs
function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
  name = name.replace(/\s+/g, "-");
  name += isFragment ? "-fragment" : "-vertex";
  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
  if (nameCache[name]) {
    nameCache[name]++;
    name += `-${nameCache[name]}`;
  } else {
    nameCache[name] = 1;
  }
  if (src.indexOf("#define SHADER_NAME") !== -1)
    return src;
  const shaderName = `#define SHADER_NAME ${name}`;
  return `${shaderName}
${src}`;
}
var fragmentNameCache, VertexNameCache;
var init_setProgramName = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs"() {
    "use strict";
    init_define_AnParams();
    fragmentNameCache = {};
    VertexNameCache = {};
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs
function stripVersion(src, isES300) {
  if (!isES300)
    return src;
  return src.replace("#version 300 es", "");
}
var init_stripVersion = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs
var processes, programCache, _GlProgram, GlProgram;
var init_GlProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"() {
    init_define_AnParams();
    init_createIdFromString();
    init_getMaxFragmentPrecision();
    init_addProgramDefines();
    init_ensurePrecision();
    init_insertVersion();
    init_setProgramName();
    init_stripVersion();
    processes = {
      // strips any version headers..
      stripVersion,
      // adds precision string if not already present
      ensurePrecision,
      // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
      addProgramDefines,
      // add the program name to the shader
      setProgramName,
      // add the version string to the shader header
      insertVersion
    };
    programCache = /* @__PURE__ */ Object.create(null);
    _GlProgram = class _GlProgram2 {
      /**
       * Creates a shiny new GlProgram. Used by WebGL renderer.
       * @param options - The options for the program.
       */
      constructor(options) {
        options = { ..._GlProgram2.defaultOptions, ...options };
        const isES300 = options.fragment.indexOf("#version 300 es") !== -1;
        const preprocessorOptions = {
          stripVersion: isES300,
          ensurePrecision: {
            requestedFragmentPrecision: options.preferredFragmentPrecision,
            requestedVertexPrecision: options.preferredVertexPrecision,
            maxSupportedVertexPrecision: "highp",
            maxSupportedFragmentPrecision: getMaxFragmentPrecision()
          },
          setProgramName: {
            name: options.name
          },
          addProgramDefines: isES300,
          insertVersion: isES300
        };
        let fragment9 = options.fragment;
        let vertex6 = options.vertex;
        Object.keys(processes).forEach((processKey) => {
          const processOptions = preprocessorOptions[processKey];
          fragment9 = processes[processKey](fragment9, processOptions, true);
          vertex6 = processes[processKey](vertex6, processOptions, false);
        });
        this.fragment = fragment9;
        this.vertex = vertex6;
        this.transformFeedbackVaryings = options.transformFeedbackVaryings;
        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, "gl-program");
      }
      /** destroys the program */
      destroy() {
        this.fragment = null;
        this.vertex = null;
        this._attributeData = null;
        this._uniformData = null;
        this._uniformBlockData = null;
        this.transformFeedbackVaryings = null;
      }
      /**
       * Helper function that creates a program for a given source.
       * It will check the program cache if the program has already been created.
       * If it has that one will be returned, if not a new one will be created and cached.
       * @param options - The options for the program.
       * @returns A program using the same source
       */
      static from(options) {
        const key = `${options.vertex}:${options.fragment}`;
        if (!programCache[key]) {
          programCache[key] = new _GlProgram2(options);
        }
        return programCache[key];
      }
    };
    _GlProgram.defaultOptions = {
      preferredVertexPrecision: "highp",
      preferredFragmentPrecision: "mediump"
    };
    GlProgram = _GlProgram;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs
function getAttributeInfoFromFormat(format) {
  return attributeFormatData[format] ?? attributeFormatData.float32;
}
var attributeFormatData;
var init_getAttributeInfoFromFormat = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs"() {
    "use strict";
    init_define_AnParams();
    attributeFormatData = {
      uint8x2: { size: 2, stride: 2, normalised: false },
      uint8x4: { size: 4, stride: 4, normalised: false },
      sint8x2: { size: 2, stride: 2, normalised: false },
      sint8x4: { size: 4, stride: 4, normalised: false },
      unorm8x2: { size: 2, stride: 2, normalised: true },
      unorm8x4: { size: 4, stride: 4, normalised: true },
      snorm8x2: { size: 2, stride: 2, normalised: true },
      snorm8x4: { size: 4, stride: 4, normalised: true },
      uint16x2: { size: 2, stride: 4, normalised: false },
      uint16x4: { size: 4, stride: 8, normalised: false },
      sint16x2: { size: 2, stride: 4, normalised: false },
      sint16x4: { size: 4, stride: 8, normalised: false },
      unorm16x2: { size: 2, stride: 4, normalised: true },
      unorm16x4: { size: 4, stride: 8, normalised: true },
      snorm16x2: { size: 2, stride: 4, normalised: true },
      snorm16x4: { size: 4, stride: 8, normalised: true },
      float16x2: { size: 2, stride: 4, normalised: false },
      float16x4: { size: 4, stride: 8, normalised: false },
      float32: { size: 1, stride: 4, normalised: false },
      float32x2: { size: 2, stride: 8, normalised: false },
      float32x3: { size: 3, stride: 12, normalised: false },
      float32x4: { size: 4, stride: 16, normalised: false },
      uint32: { size: 1, stride: 4, normalised: false },
      uint32x2: { size: 2, stride: 8, normalised: false },
      uint32x3: { size: 3, stride: 12, normalised: false },
      uint32x4: { size: 4, stride: 16, normalised: false },
      sint32: { size: 1, stride: 4, normalised: false },
      sint32x2: { size: 2, stride: 8, normalised: false },
      sint32x3: { size: 3, stride: 12, normalised: false },
      sint32x4: { size: 4, stride: 16, normalised: false }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs
function extractAttributesFromGpuProgram({ source: source9, entryPoint }) {
  const results = {};
  const mainVertStart = source9.indexOf(`fn ${entryPoint}`);
  if (mainVertStart !== -1) {
    const arrowFunctionStart = source9.indexOf("->", mainVertStart);
    if (arrowFunctionStart !== -1) {
      const functionArgsSubstring = source9.substring(mainVertStart, arrowFunctionStart);
      const inputsRegex = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
      let match;
      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {
        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? "float32";
        results[match[2]] = {
          location: parseInt(match[1], 10),
          format,
          stride: getAttributeInfoFromFormat(format).stride,
          offset: 0,
          instance: false,
          start: 0
        };
      }
    }
  }
  return results;
}
var WGSL_TO_VERTEX_TYPES;
var init_extractAttributesFromGpuProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs"() {
    init_define_AnParams();
    init_getAttributeInfoFromFormat();
    WGSL_TO_VERTEX_TYPES = {
      f32: "float32",
      "vec2<f32>": "float32x2",
      "vec3<f32>": "float32x3",
      "vec4<f32>": "float32x4",
      vec2f: "float32x2",
      vec3f: "float32x3",
      vec4f: "float32x4",
      i32: "sint32",
      "vec2<i32>": "sint32x2",
      "vec3<i32>": "sint32x3",
      "vec4<i32>": "sint32x4",
      u32: "uint32",
      "vec2<u32>": "uint32x2",
      "vec3<u32>": "uint32x3",
      "vec4<u32>": "uint32x4",
      bool: "uint32",
      "vec2<bool>": "uint32x2",
      "vec3<bool>": "uint32x3",
      "vec4<bool>": "uint32x4"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs
function extractStructAndGroups(wgsl2) {
  const linePattern = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g;
  const groupPattern = /@group\((\d+)\)/;
  const bindingPattern = /@binding\((\d+)\)/;
  const namePattern = /var(<[^>]+>)? (\w+)/;
  const typePattern = /:\s*(\w+)/;
  const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
  const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
  const structName = /struct\s+(\w+)/;
  const groups = wgsl2.match(linePattern)?.map((item) => ({
    group: parseInt(item.match(groupPattern)[1], 10),
    binding: parseInt(item.match(bindingPattern)[1], 10),
    name: item.match(namePattern)[2],
    isUniform: item.match(namePattern)[1] === "<uniform>",
    type: item.match(typePattern)[1]
  }));
  if (!groups) {
    return {
      groups: [],
      structs: []
    };
  }
  const structs = wgsl2.match(structPattern)?.map((struct5) => {
    const name = struct5.match(structName)[1];
    const members = struct5.match(structMemberPattern).reduce((acc, member) => {
      const [name2, type] = member.split(":");
      acc[name2.trim()] = type.trim();
      return acc;
    }, {});
    if (!members) {
      return null;
    }
    return { name, members };
  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];
  return {
    groups,
    structs
  };
}
var init_extractStructAndGroups = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs
var ShaderStage;
var init_const5 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs"() {
    "use strict";
    init_define_AnParams();
    ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
      ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
      ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
      ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
      return ShaderStage2;
    })(ShaderStage || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs
function generateGpuLayoutGroups({ groups }) {
  const layout = [];
  for (let i3 = 0; i3 < groups.length; i3++) {
    const group = groups[i3];
    if (!layout[group.group]) {
      layout[group.group] = [];
    }
    if (group.isUniform) {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      });
    } else if (group.type === "sampler") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      });
    } else if (group.type === "texture_2d") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
  }
  return layout;
}
var init_generateGpuLayoutGroups = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs"() {
    init_define_AnParams();
    init_const5();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs
function generateLayoutHash({ groups }) {
  const layout = [];
  for (let i3 = 0; i3 < groups.length; i3++) {
    const group = groups[i3];
    if (!layout[group.group]) {
      layout[group.group] = {};
    }
    layout[group.group][group.name] = group.binding;
  }
  return layout;
}
var init_generateLayoutHash = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs
function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
  const structNameSet = /* @__PURE__ */ new Set();
  const dupeGroupKeySet = /* @__PURE__ */ new Set();
  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct5) => {
    if (structNameSet.has(struct5.name)) {
      return false;
    }
    structNameSet.add(struct5.name);
    return true;
  });
  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
    const key = `${group.name}-${group.binding}`;
    if (dupeGroupKeySet.has(key)) {
      return false;
    }
    dupeGroupKeySet.add(key);
    return true;
  });
  return { structs, groups };
}
var init_removeStructAndGroupDuplicates = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
var programCache2, GpuProgram;
var init_GpuProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"() {
    init_define_AnParams();
    init_createIdFromString();
    init_extractAttributesFromGpuProgram();
    init_extractStructAndGroups();
    init_generateGpuLayoutGroups();
    init_generateLayoutHash();
    init_removeStructAndGroupDuplicates();
    programCache2 = /* @__PURE__ */ Object.create(null);
    GpuProgram = class _GpuProgram {
      /**
       * Create a new GpuProgram
       * @param options - The options for the gpu program
       */
      constructor(options) {
        this._layoutKey = 0;
        this._attributeLocationsKey = 0;
        const { fragment: fragment9, vertex: vertex6, layout, gpuLayout, name } = options;
        this.name = name;
        this.fragment = fragment9;
        this.vertex = vertex6;
        if (fragment9.source === vertex6.source) {
          const structsAndGroups = extractStructAndGroups(fragment9.source);
          this.structsAndGroups = structsAndGroups;
        } else {
          const vertexStructsAndGroups = extractStructAndGroups(vertex6.source);
          const fragmentStructsAndGroups = extractStructAndGroups(fragment9.source);
          this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
        }
        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);
        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);
        this._generateProgramKey();
      }
      // TODO maker this pure
      _generateProgramKey() {
        const { vertex: vertex6, fragment: fragment9 } = this;
        const bigKey = vertex6.source + fragment9.source + vertex6.entryPoint + fragment9.entryPoint;
        this._layoutKey = createIdFromString(bigKey, "program");
      }
      get attributeData() {
        this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));
        return this._attributeData;
      }
      /** destroys the program */
      destroy() {
        this.gpuLayout = null;
        this.layout = null;
        this.structsAndGroups = null;
        this.fragment = null;
        this.vertex = null;
      }
      /**
       * Helper function that creates a program for a given source.
       * It will check the program cache if the program has already been created.
       * If it has that one will be returned, if not a new one will be created and cached.
       * @param options - The options for the program.
       * @returns A program using the same source
       */
      static from(options) {
        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
        if (!programCache2[key]) {
          programCache2[key] = new _GpuProgram(options);
        }
        return programCache2[key];
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs
function addBits(srcParts, parts, name) {
  if (srcParts) {
    for (const i3 in srcParts) {
      const id = i3.toLocaleLowerCase();
      const part = parts[id];
      if (part) {
        let sanitisedPart = srcParts[i3];
        if (i3 === "header") {
          sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
        }
        if (name) {
          part.push(`//----${name}----//`);
        }
        part.push(sanitisedPart);
      } else {
        warn(`${i3} placement hook does not exist in shader`);
      }
    }
  }
}
var init_addBits = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs"() {
    init_define_AnParams();
    init_warn();
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs
function compileHooks(programSrc) {
  const parts = {};
  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
  partMatches.forEach((hook) => {
    parts[hook] = [];
  });
  return parts;
}
var findHooksRx;
var init_compileHooks = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs"() {
    "use strict";
    init_define_AnParams();
    findHooksRx = /\{\{(.*?)\}\}/g;
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs
function extractInputs(fragmentSource, out2) {
  let match;
  const regex = /@in\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out2.push(match[1]);
  }
}
function compileInputs(fragments, template, sort = false) {
  const results = [];
  extractInputs(template, results);
  fragments.forEach((fragment9) => {
    if (fragment9.header) {
      extractInputs(fragment9.header, results);
    }
  });
  const mainInput = results;
  if (sort) {
    mainInput.sort();
  }
  const finalString = mainInput.map((inValue, i3) => `       @location(${i3}) ${inValue},`).join("\n");
  let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
  cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
  return cleanedString;
}
var init_compileInputs = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs
function extractOutputs(fragmentSource, out2) {
  let match;
  const regex = /@out\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out2.push(match[1]);
  }
}
function extractVariableName(value) {
  const regex = /\b(\w+)\s*:/g;
  const match = regex.exec(value);
  return match ? match[1] : "";
}
function stripVariable(value) {
  const regex = /@.*?\s+/g;
  return value.replace(regex, "");
}
function compileOutputs(fragments, template) {
  const results = [];
  extractOutputs(template, results);
  fragments.forEach((fragment9) => {
    if (fragment9.header) {
      extractOutputs(fragment9.header, results);
    }
  });
  let index = 0;
  const mainStruct = results.sort().map((inValue) => {
    if (inValue.indexOf("builtin") > -1) {
      return inValue;
    }
    return `@location(${index++}) ${inValue}`;
  }).join(",\n");
  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
  const mainEnd = `return VSOutput(
            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
  let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
  compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
  compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
  compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
  return compiledCode;
}
var init_compileOutputs = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs
function injectBits(templateSrc, fragmentParts) {
  let out2 = templateSrc;
  for (const i3 in fragmentParts) {
    const parts = fragmentParts[i3];
    const toInject = parts.join("\n");
    if (toInject.length) {
      out2 = out2.replace(`{{${i3}}}`, `//-----${i3} START-----//
${parts.join("\n")}
//----${i3} FINISH----//`);
    } else {
      out2 = out2.replace(`{{${i3}}}`, "");
    }
  }
  return out2;
}
var init_injectBits = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs
function compileHighShader({
  template,
  bits: bits2
}) {
  const cacheId = generateCacheId(template, bits2);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  const { vertex: vertex6, fragment: fragment9 } = compileInputsAndOutputs(template, bits2);
  cacheMap[cacheId] = compileBits(vertex6, fragment9, bits2);
  return cacheMap[cacheId];
}
function compileHighShaderGl({
  template,
  bits: bits2
}) {
  const cacheId = generateCacheId(template, bits2);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits2);
  return cacheMap[cacheId];
}
function compileInputsAndOutputs(template, bits2) {
  const vertexFragments = bits2.map((shaderBit) => shaderBit.vertex).filter((v2) => !!v2);
  const fragmentFragments = bits2.map((shaderBit) => shaderBit.fragment).filter((v2) => !!v2);
  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);
  compiledVertex = compileOutputs(vertexFragments, compiledVertex);
  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
  return {
    vertex: compiledVertex,
    fragment: compiledFragment
  };
}
function generateCacheId(template, bits2) {
  return bits2.map((highFragment) => {
    if (!bitCacheMap.has(highFragment)) {
      bitCacheMap.set(highFragment, CACHE_UID++);
    }
    return bitCacheMap.get(highFragment);
  }).sort((a2, b3) => a2 - b3).join("-") + template.vertex + template.fragment;
}
function compileBits(vertex6, fragment9, bits2) {
  const vertexParts = compileHooks(vertex6);
  const fragmentParts = compileHooks(fragment9);
  bits2.forEach((shaderBit) => {
    addBits(shaderBit.vertex, vertexParts, shaderBit.name);
    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
  });
  return {
    vertex: injectBits(vertex6, vertexParts),
    fragment: injectBits(fragment9, fragmentParts)
  };
}
var cacheMap, bitCacheMap, CACHE_UID;
var init_compileHighShader = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs"() {
    init_define_AnParams();
    init_addBits();
    init_compileHooks();
    init_compileInputs();
    init_compileOutputs();
    init_injectBits();
    cacheMap = /* @__PURE__ */ Object.create(null);
    bitCacheMap = /* @__PURE__ */ new Map();
    CACHE_UID = 0;
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs
var vertexGPUTemplate, fragmentGPUTemplate, vertexGlTemplate, fragmentGlTemplate;
var init_defaultProgramTemplate = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs"() {
    "use strict";
    init_define_AnParams();
    vertexGPUTemplate = /* wgsl */
    `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`;
    fragmentGPUTemplate = /* wgsl */
    `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`;
    vertexGlTemplate = /* glsl */
    `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`;
    fragmentGlTemplate = /* glsl */
    `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`;
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs
var globalUniformsBit, globalUniformsUBOBitGl, globalUniformsBitGl;
var init_globalUniformsBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs"() {
    "use strict";
    init_define_AnParams();
    globalUniformsBit = {
      name: "global-uniforms-bit",
      vertex: {
        header: (
          /* wgsl */
          `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        )
      }
    };
    globalUniformsUBOBitGl = {
      name: "global-uniforms-ubo-bit",
      vertex: {
        header: (
          /* glsl */
          `
          uniform globalUniforms {
            mat3 uProjectionMatrix;
            mat3 uWorldTransformMatrix;
            vec4 uWorldColorAlpha;
            vec2 uResolution;
          };
        `
        )
      }
    };
    globalUniformsBitGl = {
      name: "global-uniforms-bit",
      vertex: {
        header: (
          /* glsl */
          `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs
function compileHighShaderGpuProgram({ bits: bits2, name }) {
  const source9 = compileHighShader({
    template: {
      fragment: fragmentGPUTemplate,
      vertex: vertexGPUTemplate
    },
    bits: [
      globalUniformsBit,
      ...bits2
    ]
  });
  return GpuProgram.from({
    name,
    vertex: {
      source: source9.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: source9.fragment,
      entryPoint: "main"
    }
  });
}
function compileHighShaderGlProgram({ bits: bits2, name }) {
  return new GlProgram({
    name,
    ...compileHighShaderGl({
      template: {
        vertex: vertexGlTemplate,
        fragment: fragmentGlTemplate
      },
      bits: [
        globalUniformsBitGl,
        ...bits2
      ]
    })
  });
}
var init_compileHighShaderToProgram = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"() {
    init_define_AnParams();
    init_GlProgram();
    init_GpuProgram();
    init_compileHighShader();
    init_defaultProgramTemplate();
    init_globalUniformsBit();
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs
var colorBit, colorBitGl;
var init_colorBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs"() {
    "use strict";
    init_define_AnParams();
    colorBit = {
      name: "color-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            @in aColor: vec4<f32>;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        )
      }
    };
    colorBitGl = {
      name: "color-bit",
      vertex: {
        header: (
          /* glsl */
          `
            in vec4 aColor;
        `
        ),
        main: (
          /* glsl */
          `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs
function generateBindingSrc(maxTextures2) {
  const src = [];
  if (maxTextures2 === 1) {
    src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
    src.push("@group(1) @binding(1) var textureSampler1: sampler;");
  } else {
    let bindingIndex = 0;
    for (let i3 = 0; i3 < maxTextures2; i3++) {
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i3 + 1}: texture_2d<f32>;`);
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i3 + 1}: sampler;`);
    }
  }
  return src.join("\n");
}
function generateSampleSrc(maxTextures2) {
  const src = [];
  if (maxTextures2 === 1) {
    src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  } else {
    src.push("switch vTextureId {");
    for (let i3 = 0; i3 < maxTextures2; i3++) {
      if (i3 === maxTextures2 - 1) {
        src.push(`  default:{`);
      } else {
        src.push(`  case ${i3}:{`);
      }
      src.push(`      outColor = textureSampleGrad(textureSource${i3 + 1}, textureSampler${i3 + 1}, vUV, uvDx, uvDy);`);
      src.push(`      break;}`);
    }
    src.push(`}`);
  }
  return src.join("\n");
}
function generateTextureBatchBit(maxTextures2) {
  if (!textureBatchBitGpuCache[maxTextures2]) {
    textureBatchBitGpuCache[maxTextures2] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(maxTextures2)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(maxTextures2)}
            `
      }
    };
  }
  return textureBatchBitGpuCache[maxTextures2];
}
function generateSampleGlSrc(maxTextures2) {
  const src = [];
  for (let i3 = 0; i3 < maxTextures2; i3++) {
    if (i3 > 0) {
      src.push("else");
    }
    if (i3 < maxTextures2 - 1) {
      src.push(`if(vTextureId < ${i3}.5)`);
    }
    src.push("{");
    src.push(`	outColor = texture(uTextures[${i3}], vUV);`);
    src.push("}");
  }
  return src.join("\n");
}
function generateTextureBatchBitGl(maxTextures2) {
  if (!textureBatchBitGlCache[maxTextures2]) {
    textureBatchBitGlCache[maxTextures2] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures2}];

            `,
        main: `

                ${generateSampleGlSrc(maxTextures2)}
            `
      }
    };
  }
  return textureBatchBitGlCache[maxTextures2];
}
var textureBatchBitGpuCache, textureBatchBitGlCache;
var init_generateTextureBatchBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"() {
    "use strict";
    init_define_AnParams();
    textureBatchBitGpuCache = {};
    textureBatchBitGlCache = {};
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs
var roundPixelsBit, roundPixelsBitGl;
var init_roundPixelsBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"() {
    "use strict";
    init_define_AnParams();
    roundPixelsBit = {
      name: "round-pixels-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        )
      }
    };
    roundPixelsBitGl = {
      name: "round-pixels-bit",
      vertex: {
        header: (
          /* glsl */
          `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs
var UNIFORM_TYPES_VALUES, UNIFORM_TYPES_MAP;
var init_types = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs"() {
    "use strict";
    init_define_AnParams();
    UNIFORM_TYPES_VALUES = [
      "f32",
      "i32",
      "vec2<f32>",
      "vec3<f32>",
      "vec4<f32>",
      "mat2x2<f32>",
      "mat3x3<f32>",
      "mat4x4<f32>",
      "mat3x2<f32>",
      "mat4x2<f32>",
      "mat2x3<f32>",
      "mat4x3<f32>",
      "mat2x4<f32>",
      "mat3x4<f32>",
      "vec2<i32>",
      "vec3<i32>",
      "vec4<i32>"
    ];
    UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {
      acc[type] = true;
      return acc;
    }, {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs
function getDefaultUniformValue(type, size) {
  switch (type) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * size);
    case "vec3<f32>":
      return new Float32Array(3 * size);
    case "vec4<f32>":
      return new Float32Array(4 * size);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_getDefaultUniformValue = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs
var _UniformGroup, UniformGroup;
var init_UniformGroup = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"() {
    init_define_AnParams();
    init_uid();
    init_createIdFromString();
    init_types();
    init_getDefaultUniformValue();
    _UniformGroup = class _UniformGroup2 {
      /**
       * Create a new Uniform group
       * @param uniformStructures - The structures of the uniform group
       * @param options - The optional parameters of this uniform group
       */
      constructor(uniformStructures, options) {
        this._touched = 0;
        this.uid = uid("uniform");
        this._resourceType = "uniformGroup";
        this._resourceId = uid("resource");
        this.isUniformGroup = true;
        this._dirtyId = 0;
        this.destroyed = false;
        options = { ..._UniformGroup2.defaultOptions, ...options };
        this.uniformStructures = uniformStructures;
        const uniforms = {};
        for (const i3 in uniformStructures) {
          const uniformData = uniformStructures[i3];
          uniformData.name = i3;
          uniformData.size = uniformData.size ?? 1;
          if (!UNIFORM_TYPES_MAP[uniformData.type]) {
            throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);
          }
          uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));
          uniforms[i3] = uniformData.value;
        }
        this.uniforms = uniforms;
        this._dirtyId = 1;
        this.ubo = options.ubo;
        this.isStatic = options.isStatic;
        this._signature = createIdFromString(Object.keys(uniforms).map(
          (i3) => `${i3}-${uniformStructures[i3].type}`
        ).join("-"), "uniform-group");
      }
      /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
      update() {
        this._dirtyId++;
      }
    };
    _UniformGroup.defaultOptions = {
      /** if true the UniformGroup is handled as an Uniform buffer object. */
      ubo: false,
      /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
      isStatic: false
    };
    UniformGroup = _UniformGroup;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs
function getBatchSamplersUniformGroup(maxTextures2) {
  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures2];
  if (batchSamplersUniformGroup)
    return batchSamplersUniformGroup;
  const sampleValues = new Int32Array(maxTextures2);
  for (let i3 = 0; i3 < maxTextures2; i3++) {
    sampleValues[i3] = i3;
  }
  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures2] = new UniformGroup({
    uTextures: { value: sampleValues, type: `i32`, size: maxTextures2 }
  }, { isStatic: true });
  return batchSamplersUniformGroup;
}
var batchSamplersUniformGroupHash;
var init_getBatchSamplersUniformGroup = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs"() {
    init_define_AnParams();
    init_UniformGroup();
    batchSamplersUniformGroupHash = {};
  }
});

// node_modules/pixi.js/lib/rendering/renderers/types.mjs
var RendererType;
var init_types2 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/types.mjs"() {
    "use strict";
    init_define_AnParams();
    RendererType = /* @__PURE__ */ ((RendererType2) => {
      RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
      RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
      RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
      return RendererType2;
    })(RendererType || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs
var Shader;
var init_Shader = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"() {
    init_define_AnParams();
    init_eventemitter3();
    init_uid();
    init_GlProgram();
    init_BindGroup();
    init_GpuProgram();
    init_types2();
    init_UniformGroup();
    Shader = class _Shader extends eventemitter3_default {
      constructor(options) {
        super();
        this.uid = uid("shader");
        this._uniformBindMap = /* @__PURE__ */ Object.create(null);
        this._ownedBindGroups = [];
        let {
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          groups,
          resources,
          compatibleRenderers,
          groupMap
        } = options;
        this.gpuProgram = gpuProgram3;
        this.glProgram = glProgram3;
        if (compatibleRenderers === void 0) {
          compatibleRenderers = 0;
          if (gpuProgram3)
            compatibleRenderers |= RendererType.WEBGPU;
          if (glProgram3)
            compatibleRenderers |= RendererType.WEBGL;
        }
        this.compatibleRenderers = compatibleRenderers;
        const nameHash = {};
        if (!resources && !groups) {
          resources = {};
        }
        if (resources && groups) {
          throw new Error("[Shader] Cannot have both resources and groups");
        } else if (!gpuProgram3 && groups && !groupMap) {
          throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
        } else if (!gpuProgram3 && groups && groupMap) {
          for (const i3 in groupMap) {
            for (const j2 in groupMap[i3]) {
              const uniformName = groupMap[i3][j2];
              nameHash[uniformName] = {
                group: i3,
                binding: j2,
                name: uniformName
              };
            }
          }
        } else if (gpuProgram3 && groups && !groupMap) {
          const groupData = gpuProgram3.structsAndGroups.groups;
          groupMap = {};
          groupData.forEach((data) => {
            groupMap[data.group] = groupMap[data.group] || {};
            groupMap[data.group][data.binding] = data.name;
            nameHash[data.name] = data;
          });
        } else if (resources) {
          groups = {};
          groupMap = {};
          if (gpuProgram3) {
            const groupData = gpuProgram3.structsAndGroups.groups;
            groupData.forEach((data) => {
              groupMap[data.group] = groupMap[data.group] || {};
              groupMap[data.group][data.binding] = data.name;
              nameHash[data.name] = data;
            });
          }
          let bindTick = 0;
          for (const i3 in resources) {
            if (nameHash[i3])
              continue;
            if (!groups[99]) {
              groups[99] = new BindGroup();
              this._ownedBindGroups.push(groups[99]);
            }
            nameHash[i3] = { group: 99, binding: bindTick, name: i3 };
            groupMap[99] = groupMap[99] || {};
            groupMap[99][bindTick] = i3;
            bindTick++;
          }
          for (const i3 in resources) {
            const name = i3;
            let value = resources[i3];
            if (!value.source && !value._resourceType) {
              value = new UniformGroup(value);
            }
            const data = nameHash[name];
            if (data) {
              if (!groups[data.group]) {
                groups[data.group] = new BindGroup();
                this._ownedBindGroups.push(groups[data.group]);
              }
              groups[data.group].setResource(value, data.binding);
            }
          }
        }
        this.groups = groups;
        this._uniformBindMap = groupMap;
        this.resources = this._buildResourceAccessor(groups, nameHash);
      }
      /**
       * Sometimes a resource group will be provided later (for example global uniforms)
       * In such cases, this method can be used to let the shader know about the group.
       * @param name - the name of the resource group
       * @param groupIndex - the index of the group (should match the webGPU shader group location)
       * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
       */
      addResource(name, groupIndex, bindIndex) {
        var _a2, _b2;
        (_a2 = this._uniformBindMap)[groupIndex] || (_a2[groupIndex] = {});
        (_b2 = this._uniformBindMap[groupIndex])[bindIndex] || (_b2[bindIndex] = name);
        if (!this.groups[groupIndex]) {
          this.groups[groupIndex] = new BindGroup();
          this._ownedBindGroups.push(this.groups[groupIndex]);
        }
      }
      _buildResourceAccessor(groups, nameHash) {
        const uniformsOut = {};
        for (const i3 in nameHash) {
          const data = nameHash[i3];
          Object.defineProperty(uniformsOut, data.name, {
            get() {
              return groups[data.group].getResource(data.binding);
            },
            set(value) {
              groups[data.group].setResource(value, data.binding);
            }
          });
        }
        return uniformsOut;
      }
      /**
       * Use to destroy the shader when its not longer needed.
       * It will destroy the resources and remove listeners.
       * @param destroyPrograms - if the programs should be destroyed as well.
       * Make sure its not being used by other shaders!
       */
      destroy(destroyPrograms = false) {
        this.emit("destroy", this);
        if (destroyPrograms) {
          this.gpuProgram?.destroy();
          this.glProgram?.destroy();
        }
        this.gpuProgram = null;
        this.glProgram = null;
        this.removeAllListeners();
        this._uniformBindMap = null;
        this._ownedBindGroups.forEach((bindGroup) => {
          bindGroup.destroy();
        });
        this._ownedBindGroups = null;
        this.resources = null;
        this.groups = null;
      }
      static from(options) {
        const { gpu, gl, ...rest } = options;
        let gpuProgram3;
        let glProgram3;
        if (gpu) {
          gpuProgram3 = GpuProgram.from(gpu);
        }
        if (gl) {
          glProgram3 = GlProgram.from(gl);
        }
        return new _Shader({
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          ...rest
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs
var DefaultShader;
var init_DefaultShader = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs"() {
    init_define_AnParams();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_roundPixelsBit();
    init_getBatchSamplersUniformGroup();
    init_Shader();
    DefaultShader = class extends Shader {
      constructor(maxTextures2) {
        const glProgram3 = compileHighShaderGlProgram({
          name: "batch",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(maxTextures2),
            roundPixelsBitGl
          ]
        });
        const gpuProgram3 = compileHighShaderGpuProgram({
          name: "batch",
          bits: [
            colorBit,
            generateTextureBatchBit(maxTextures2),
            roundPixelsBit
          ]
        });
        super({
          glProgram: glProgram3,
          gpuProgram: gpuProgram3,
          resources: {
            batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
          }
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs
var defaultShader, _DefaultBatcher, DefaultBatcher;
var init_DefaultBatcher = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Batcher();
    init_BatchGeometry();
    init_DefaultShader();
    defaultShader = null;
    _DefaultBatcher = class _DefaultBatcher2 extends Batcher {
      constructor() {
        super(...arguments);
        this.geometry = new BatchGeometry();
        this.shader = defaultShader || (defaultShader = new DefaultShader(this.maxTextures));
        this.name = _DefaultBatcher2.extension.name;
        this.vertexSize = 6;
      }
      /**
       * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
       * @param element - The DefaultBatchableMeshElement to pack.
       * @param float32View - The Float32Array view to pack into.
       * @param uint32View - The Uint32Array view to pack into.
       * @param index - The starting index in the views.
       * @param textureId - The texture ID to use.
       */
      packAttributes(element, float32View, uint32View, index, textureId) {
        const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
        const wt = element.transform;
        const a2 = wt.a;
        const b3 = wt.b;
        const c2 = wt.c;
        const d2 = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const { positions, uvs } = element;
        const argb = element.color;
        const offset = element.attributeOffset;
        const end = offset + element.attributeSize;
        for (let i3 = offset; i3 < end; i3++) {
          const i22 = i3 * 2;
          const x2 = positions[i22];
          const y2 = positions[i22 + 1];
          float32View[index++] = a2 * x2 + c2 * y2 + tx;
          float32View[index++] = d2 * y2 + b3 * x2 + ty;
          float32View[index++] = uvs[i22];
          float32View[index++] = uvs[i22 + 1];
          uint32View[index++] = argb;
          uint32View[index++] = textureIdAndRound;
        }
      }
      /**
       * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
       * @param element - The DefaultBatchableQuadElement to pack.
       * @param float32View - The Float32Array view to pack into.
       * @param uint32View - The Uint32Array view to pack into.
       * @param index - The starting index in the views.
       * @param textureId - The texture ID to use.
       */
      packQuadAttributes(element, float32View, uint32View, index, textureId) {
        const texture = element.texture;
        const wt = element.transform;
        const a2 = wt.a;
        const b3 = wt.b;
        const c2 = wt.c;
        const d2 = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const bounds = element.bounds;
        const w0 = bounds.maxX;
        const w1 = bounds.minX;
        const h0 = bounds.maxY;
        const h1 = bounds.minY;
        const uvs = texture.uvs;
        const argb = element.color;
        const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
        float32View[index + 0] = a2 * w1 + c2 * h1 + tx;
        float32View[index + 1] = d2 * h1 + b3 * w1 + ty;
        float32View[index + 2] = uvs.x0;
        float32View[index + 3] = uvs.y0;
        uint32View[index + 4] = argb;
        uint32View[index + 5] = textureIdAndRound;
        float32View[index + 6] = a2 * w0 + c2 * h1 + tx;
        float32View[index + 7] = d2 * h1 + b3 * w0 + ty;
        float32View[index + 8] = uvs.x1;
        float32View[index + 9] = uvs.y1;
        uint32View[index + 10] = argb;
        uint32View[index + 11] = textureIdAndRound;
        float32View[index + 12] = a2 * w0 + c2 * h0 + tx;
        float32View[index + 13] = d2 * h0 + b3 * w0 + ty;
        float32View[index + 14] = uvs.x2;
        float32View[index + 15] = uvs.y2;
        uint32View[index + 16] = argb;
        uint32View[index + 17] = textureIdAndRound;
        float32View[index + 18] = a2 * w1 + c2 * h0 + tx;
        float32View[index + 19] = d2 * h0 + b3 * w1 + ty;
        float32View[index + 20] = uvs.x3;
        float32View[index + 21] = uvs.y3;
        uint32View[index + 22] = argb;
        uint32View[index + 23] = textureIdAndRound;
      }
    };
    _DefaultBatcher.extension = {
      type: [
        ExtensionType.Batcher
      ],
      name: "default"
    };
    DefaultBatcher = _DefaultBatcher;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {
  let index = 0;
  verticesOffset *= verticesStride;
  uvsOffset *= uvsStride;
  const a2 = matrix.a;
  const b3 = matrix.b;
  const c2 = matrix.c;
  const d2 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  while (index < size) {
    const x2 = vertices[verticesOffset];
    const y2 = vertices[verticesOffset + 1];
    uvs[uvsOffset] = a2 * x2 + c2 * y2 + tx;
    uvs[uvsOffset + 1] = b3 * x2 + d2 * y2 + ty;
    uvsOffset += uvsStride;
    verticesOffset += verticesStride;
    index++;
  }
}
function buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {
  let index = 0;
  uvsOffset *= uvsStride;
  while (index < size) {
    uvs[uvsOffset] = 0;
    uvs[uvsOffset + 1] = 0;
    uvsOffset += uvsStride;
    index++;
  }
}
var init_buildUvs = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
function transformVertices(vertices, m2, offset, stride, size) {
  const a2 = m2.a;
  const b3 = m2.b;
  const c2 = m2.c;
  const d2 = m2.d;
  const tx = m2.tx;
  const ty = m2.ty;
  offset || (offset = 0);
  stride || (stride = 2);
  size || (size = vertices.length / stride - offset);
  let index = offset * stride;
  for (let i3 = 0; i3 < size; i3++) {
    const x2 = vertices[index];
    const y2 = vertices[index + 1];
    vertices[index] = a2 * x2 + c2 * y2 + tx;
    vertices[index + 1] = b3 * x2 + d2 * y2 + ty;
    index += stride;
  }
}
var init_transformVertices = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs
var identityMatrix2, BatchableGraphics;
var init_BatchableGraphics = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_multiplyHexColors();
    identityMatrix2 = new Matrix();
    BatchableGraphics = class {
      constructor() {
        this.packAsQuad = false;
        this.batcherName = "default";
        this.topology = "triangle-list";
        this.applyTransform = true;
        this.roundPixels = 0;
        this._batcher = null;
        this._batch = null;
      }
      get uvs() {
        return this.geometryData.uvs;
      }
      get positions() {
        return this.geometryData.vertices;
      }
      get indices() {
        return this.geometryData.indices;
      }
      get blendMode() {
        if (this.applyTransform) {
          return this.renderable.groupBlendMode;
        }
        return "normal";
      }
      get color() {
        const rgb = this.baseColor;
        const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
        const renderable = this.renderable;
        if (renderable) {
          return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);
        }
        return bgr + (this.alpha * 255 << 24);
      }
      get transform() {
        return this.renderable?.groupTransform || identityMatrix2;
      }
      copyTo(gpuBuffer) {
        gpuBuffer.indexOffset = this.indexOffset;
        gpuBuffer.indexSize = this.indexSize;
        gpuBuffer.attributeOffset = this.attributeOffset;
        gpuBuffer.attributeSize = this.attributeSize;
        gpuBuffer.baseColor = this.baseColor;
        gpuBuffer.alpha = this.alpha;
        gpuBuffer.texture = this.texture;
        gpuBuffer.geometryData = this.geometryData;
        gpuBuffer.topology = this.topology;
      }
      reset() {
        this.applyTransform = true;
        this.renderable = null;
        this.topology = "triangle-list";
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs
var buildCircle, buildEllipse, buildRoundedRectangle;
var init_buildCircle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs"() {
    init_define_AnParams();
    init_Extensions();
    buildCircle = {
      extension: {
        type: ExtensionType.ShapeBuilder,
        name: "circle"
      },
      build(shape, points) {
        let x2;
        let y2;
        let dx;
        let dy;
        let rx;
        let ry;
        if (shape.type === "circle") {
          const circle = shape;
          x2 = circle.x;
          y2 = circle.y;
          rx = ry = circle.radius;
          dx = dy = 0;
        } else if (shape.type === "ellipse") {
          const ellipse = shape;
          x2 = ellipse.x;
          y2 = ellipse.y;
          rx = ellipse.halfWidth;
          ry = ellipse.halfHeight;
          dx = dy = 0;
        } else {
          const roundedRect = shape;
          const halfWidth = roundedRect.width / 2;
          const halfHeight = roundedRect.height / 2;
          x2 = roundedRect.x + halfWidth;
          y2 = roundedRect.y + halfHeight;
          rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
          dx = halfWidth - rx;
          dy = halfHeight - ry;
        }
        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
          return points;
        }
        const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
        const m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
        if (m2 === 0) {
          return points;
        }
        if (n2 === 0) {
          points[0] = points[6] = x2 + dx;
          points[1] = points[3] = y2 + dy;
          points[2] = points[4] = x2 - dx;
          points[5] = points[7] = y2 - dy;
          return points;
        }
        let j1 = 0;
        let j2 = n2 * 4 + (dx ? 2 : 0) + 2;
        let j3 = j2;
        let j4 = m2;
        let x0 = dx + rx;
        let y0 = dy;
        let x1 = x2 + x0;
        let x22 = x2 - x0;
        let y1 = y2 + y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j2] = y1;
        points[--j2] = x22;
        if (dy) {
          const y222 = y2 - y0;
          points[j3++] = x22;
          points[j3++] = y222;
          points[--j4] = y222;
          points[--j4] = x1;
        }
        for (let i3 = 1; i3 < n2; i3++) {
          const a2 = Math.PI / 2 * (i3 / n2);
          const x02 = dx + Math.cos(a2) * rx;
          const y02 = dy + Math.sin(a2) * ry;
          const x12 = x2 + x02;
          const x222 = x2 - x02;
          const y12 = y2 + y02;
          const y222 = y2 - y02;
          points[j1++] = x12;
          points[j1++] = y12;
          points[--j2] = y12;
          points[--j2] = x222;
          points[j3++] = x222;
          points[j3++] = y222;
          points[--j4] = y222;
          points[--j4] = x12;
        }
        x0 = dx;
        y0 = dy + ry;
        x1 = x2 + x0;
        x22 = x2 - x0;
        y1 = y2 + y0;
        const y22 = y2 - y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j4] = y22;
        points[--j4] = x1;
        if (dx) {
          points[j1++] = x22;
          points[j1++] = y1;
          points[--j4] = y22;
          points[--j4] = x22;
        }
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        if (points.length === 0) {
          return;
        }
        let centerX = 0;
        let centerY = 0;
        for (let i3 = 0; i3 < points.length; i3 += 2) {
          centerX += points[i3];
          centerY += points[i3 + 1];
        }
        centerX /= points.length / 2;
        centerY /= points.length / 2;
        let count2 = verticesOffset;
        vertices[count2 * verticesStride] = centerX;
        vertices[count2 * verticesStride + 1] = centerY;
        const centerIndex = count2++;
        for (let i3 = 0; i3 < points.length; i3 += 2) {
          vertices[count2 * verticesStride] = points[i3];
          vertices[count2 * verticesStride + 1] = points[i3 + 1];
          if (i3 > 0) {
            indices[indicesOffset++] = count2;
            indices[indicesOffset++] = centerIndex;
            indices[indicesOffset++] = count2 - 1;
          }
          count2++;
        }
        indices[indicesOffset++] = centerIndex + 1;
        indices[indicesOffset++] = centerIndex;
        indices[indicesOffset++] = count2 - 1;
      }
    };
    buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: "ellipse" } };
    buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: "roundedRectangle" } };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/const.mjs
var closePointEps, curveEps;
var init_const6 = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/const.mjs"() {
    "use strict";
    init_define_AnParams();
    closePointEps = 1e-4;
    curveEps = 1e-4;
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs
function getOrientationOfPoints(points) {
  const m2 = points.length;
  if (m2 < 6) {
    return 1;
  }
  let area = 0;
  for (let i3 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i3 < m2; i3 += 2) {
    const x2 = points[i3];
    const y2 = points[i3 + 1];
    area += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (area < 0) {
    return -1;
  }
  return 1;
}
var init_getOrientationOfPoints = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs
function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x2 - nx * innerWeight;
  const iy = y2 - ny * innerWeight;
  const ox = x2 + nx * outerWeight;
  const oy = y2 + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (let i3 = 1, angle = startAngle; i3 < segCount; i3++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (let i3 = 1, angle = startAngle; i3 < segCount; i3++, angle += angleInc) {
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildLine(points, lineStyle, flipAlignment, closed, vertices, indices) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = lineStyle;
  let alignment = style.alignment;
  if (lineStyle.alignment !== 0.5) {
    let orientation = getOrientationOfPoints(points);
    if (flipAlignment)
      orientation *= -1;
    alignment = (alignment - 0.5) * orientation + 0.5;
  }
  const firstPoint = new Point(points[0], points[1]);
  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = closed;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = vertices;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpX = -(y0 - y1);
  let perpY = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  const ratio = alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x0 - perpX * (innerWeight - outerWeight) * 0.5,
        y0 - perpY * (innerWeight - outerWeight) * 0.5,
        x0 - perpX * innerWeight,
        y0 - perpY * innerWeight,
        x0 + perpX * outerWeight,
        y0 + perpY * outerWeight,
        verts,
        true
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(
    x0 - perpX * innerWeight,
    y0 - perpY * innerWeight
  );
  verts.push(
    x0 + perpX * outerWeight,
    y0 + perpY * outerWeight
  );
  for (let i3 = 1; i3 < length - 1; ++i3) {
    x0 = points[(i3 - 1) * 2];
    y0 = points[(i3 - 1) * 2 + 1];
    x1 = points[i3 * 2];
    y1 = points[i3 * 2 + 1];
    x2 = points[(i3 + 1) * 2];
    y2 = points[(i3 + 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight
      );
      verts.push(
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight
      );
      if (dot >= 0) {
        if (style.join === "round") {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(
          x1 - perp1x * outerWeight,
          y1 - perp1y * outerWeight
        );
        verts.push(
          x1 + perp1x * innerWeight,
          y1 + perp1y * innerWeight
        );
      }
      continue;
    }
    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pDist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === "round") {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
      if (style.join === "round") {
        if (clockwise) {
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 2;
        } else {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 2;
        }
      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpX = -(y0 - y1);
  perpY = x0 - x1;
  dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x1 - perpX * (innerWeight - outerWeight) * 0.5,
        y1 - perpY * (innerWeight - outerWeight) * 0.5,
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight,
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight,
        verts,
        false
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
    }
  }
  const eps2 = curveEps * curveEps;
  for (let i3 = indexStart; i3 < indexCount + indexStart - 2; ++i3) {
    x0 = verts[i3 * 2];
    y0 = verts[i3 * 2 + 1];
    x1 = verts[(i3 + 1) * 2];
    y1 = verts[(i3 + 1) * 2 + 1];
    x2 = verts[(i3 + 2) * 2];
    y2 = verts[(i3 + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i3, i3 + 1, i3 + 2);
  }
}
var init_buildLine = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs"() {
    init_define_AnParams();
    init_Point();
    init_const6();
    init_getOrientationOfPoints();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs
function buildPixelLine(points, closed, vertices, indices) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const fx = points[0];
  const fy = points[1];
  const lx = points[points.length - 2];
  const ly = points[points.length - 1];
  const closePath = closed || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;
  const verts = vertices;
  const length = points.length / 2;
  const indexStart = verts.length / 2;
  for (let i3 = 0; i3 < length; i3++) {
    verts.push(points[i3 * 2]);
    verts.push(points[i3 * 2 + 1]);
  }
  for (let i3 = 0; i3 < length - 1; i3++) {
    indices.push(indexStart + i3, indexStart + i3 + 1);
  }
  if (closePath) {
    indices.push(indexStart + length - 1, indexStart);
  }
}
var init_buildPixelLine = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs"() {
    init_define_AnParams();
    init_const6();
  }
});

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    init_define_AnParams();
    module.exports = earcut2;
    module.exports.default = earcut2;
    function earcut2(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev) return triangles;
      var minX, minY, maxX, maxY, x2, y2, invSize;
      if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i3 = dim; i3 < outerLen; i3 += dim) {
          x2 = data[i3];
          y2 = data[i3 + 1];
          if (x2 < minX) minX = x2;
          if (y2 < minY) minY = y2;
          if (x2 > maxX) maxX = x2;
          if (y2 > maxY) maxY = y2;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i3, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i3 = start; i3 < end; i3 += dim) last = insertNode(i3, data[i3], data[i3 + 1], last);
      } else {
        for (i3 = end - dim; i3 >= start; i3 -= dim) last = insertNode(i3, data[i3], data[i3 + 1], last);
      }
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start) return start;
      if (!end) end = start;
      var p2 = start, again;
      do {
        again = false;
        if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
          removeNode(p2);
          p2 = end = p2.prev;
          if (p2 === p2.next) break;
          again = true;
        } else {
          p2 = p2.next;
        }
      } while (again || p2 !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear) return;
      if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a2 = ear.prev, b3 = ear, c2 = ear.next;
      if (area(a2, b3, c2) >= 0) return false;
      var ax = a2.x, bx = b3.x, cx = c2.x, ay = a2.y, by = b3.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p2 = c2.next;
      while (p2 !== a2) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle2(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
        p2 = p2.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a2 = ear.prev, b3 = ear, c2 = ear.next;
      if (area(a2, b3, c2) >= 0) return false;
      var ax = a2.x, bx = b3.x, cx = c2.x, ay = a2.y, by = b3.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p2 = ear.prevZ, n2 = ear.nextZ;
      while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
        p2 = p2.prevZ;
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
        n2 = n2.nextZ;
      }
      while (p2 && p2.z >= minZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
        p2 = p2.prevZ;
      }
      while (n2 && n2.z <= maxZ) {
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
        n2 = n2.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p2 = start;
      do {
        var a2 = p2.prev, b3 = p2.next.next;
        if (!equals(a2, b3) && intersects(a2, p2, p2.next, b3) && locallyInside(a2, b3) && locallyInside(b3, a2)) {
          triangles.push(a2.i / dim | 0);
          triangles.push(p2.i / dim | 0);
          triangles.push(b3.i / dim | 0);
          removeNode(p2);
          removeNode(p2.next);
          p2 = start = b3;
        }
        p2 = p2.next;
      } while (p2 !== start);
      return filterPoints(p2);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a2 = start;
      do {
        var b3 = a2.next.next;
        while (b3 !== a2.prev) {
          if (a2.i !== b3.i && isValidDiagonal(a2, b3)) {
            var c2 = splitPolygon(a2, b3);
            a2 = filterPoints(a2, a2.next);
            c2 = filterPoints(c2, c2.next);
            earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b3 = b3.next;
        }
        a2 = a2.next;
      } while (a2 !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i3, len, start, end, list;
      for (i3 = 0, len = holeIndices.length; i3 < len; i3++) {
        start = holeIndices[i3] * dim;
        end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i3 = 0; i3 < queue.length; i3++) {
        outerNode = eliminateHole(queue[i3], outerNode);
      }
      return outerNode;
    }
    function compareX(a2, b3) {
      return a2.x - b3.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
      do {
        if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
          var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
          if (x2 <= hx && x2 > qx) {
            qx = x2;
            m2 = p2.x < p2.next.x ? p2 : p2.next;
            if (x2 === hx) return m2;
          }
        }
        p2 = p2.next;
      } while (p2 !== outerNode);
      if (!m2) return null;
      var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan;
      p2 = m2;
      do {
        if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle2(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
          tan = Math.abs(hy - p2.y) / (hx - p2.x);
          if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
            m2 = p2;
            tanMin = tan;
          }
        }
        p2 = p2.next;
      } while (p2 !== stop);
      return m2;
    }
    function sectorContainsSector(m2, p2) {
      return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p2 = start;
      do {
        if (p2.z === 0) p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
        p2.prevZ = p2.prev;
        p2.nextZ = p2.next;
        p2 = p2.next;
      } while (p2 !== start);
      p2.prevZ.nextZ = null;
      p2.prevZ = null;
      sortLinked(p2);
    }
    function sortLinked(list) {
      var i3, p2, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p2 = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p2) {
          numMerges++;
          q = p2;
          pSize = 0;
          for (i3 = 0; i3 < inSize; i3++) {
            pSize++;
            q = q.nextZ;
            if (!q) break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
              e2 = p2;
              p2 = p2.nextZ;
              pSize--;
            } else {
              e2 = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail) tail.nextZ = e2;
            else list = e2;
            e2.prevZ = tail;
            tail = e2;
          }
          p2 = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x2, y2, minX, minY, invSize) {
      x2 = (x2 - minX) * invSize | 0;
      y2 = (y2 - minY) * invSize | 0;
      x2 = (x2 | x2 << 8) & 16711935;
      x2 = (x2 | x2 << 4) & 252645135;
      x2 = (x2 | x2 << 2) & 858993459;
      x2 = (x2 | x2 << 1) & 1431655765;
      y2 = (y2 | y2 << 8) & 16711935;
      y2 = (y2 | y2 << 4) & 252645135;
      y2 = (y2 | y2 << 2) & 858993459;
      y2 = (y2 | y2 << 1) & 1431655765;
      return x2 | y2 << 1;
    }
    function getLeftmost(start) {
      var p2 = start, leftmost = start;
      do {
        if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y) leftmost = p2;
        p2 = p2.next;
      } while (p2 !== start);
      return leftmost;
    }
    function pointInTriangle2(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a2, b3) {
      return a2.next.i !== b3.i && a2.prev.i !== b3.i && !intersectsPolygon(a2, b3) && // dones't intersect other edges
      (locallyInside(a2, b3) && locallyInside(b3, a2) && middleInside(a2, b3) && // locally visible
      (area(a2.prev, a2, b3.prev) || area(a2, b3.prev, b3)) || // does not create opposite-facing sectors
      equals(a2, b3) && area(a2.prev, a2, a2.next) > 0 && area(b3.prev, b3, b3.next) > 0);
    }
    function area(p2, q, r2) {
      return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4) return true;
      if (o1 === 0 && onSegment(p1, p2, q1)) return true;
      if (o2 === 0 && onSegment(p1, q2, q1)) return true;
      if (o3 === 0 && onSegment(p2, p1, q2)) return true;
      if (o4 === 0 && onSegment(p2, q1, q2)) return true;
      return false;
    }
    function onSegment(p2, q, r2) {
      return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a2, b3) {
      var p2 = a2;
      do {
        if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b3.i && p2.next.i !== b3.i && intersects(p2, p2.next, a2, b3)) return true;
        p2 = p2.next;
      } while (p2 !== a2);
      return false;
    }
    function locallyInside(a2, b3) {
      return area(a2.prev, a2, a2.next) < 0 ? area(a2, b3, a2.next) >= 0 && area(a2, a2.prev, b3) >= 0 : area(a2, b3, a2.prev) < 0 || area(a2, a2.next, b3) < 0;
    }
    function middleInside(a2, b3) {
      var p2 = a2, inside = false, px = (a2.x + b3.x) / 2, py = (a2.y + b3.y) / 2;
      do {
        if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
          inside = !inside;
        p2 = p2.next;
      } while (p2 !== a2);
      return inside;
    }
    function splitPolygon(a2, b3) {
      var a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b3.i, b3.x, b3.y), an = a2.next, bp = b3.prev;
      a2.next = b3;
      b3.prev = a2;
      a22.next = an;
      an.prev = a22;
      b22.next = a22;
      a22.prev = b22;
      bp.next = b22;
      b22.prev = bp;
      return b22;
    }
    function insertNode(i3, x2, y2, last) {
      var p2 = new Node(i3, x2, y2);
      if (!last) {
        p2.prev = p2;
        p2.next = p2;
      } else {
        p2.next = last.next;
        p2.prev = last;
        last.next.prev = p2;
        last.next = p2;
      }
      return p2;
    }
    function removeNode(p2) {
      p2.next.prev = p2.prev;
      p2.prev.next = p2.next;
      if (p2.prevZ) p2.prevZ.nextZ = p2.nextZ;
      if (p2.nextZ) p2.nextZ.prevZ = p2.prevZ;
    }
    function Node(i3, x2, y2) {
      this.i = i3;
      this.x = x2;
      this.y = y2;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut2.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i3 = 0, len = holeIndices.length; i3 < len; i3++) {
          var start = holeIndices[i3] * dim;
          var end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i3 = 0; i3 < triangles.length; i3 += 3) {
        var a2 = triangles[i3] * dim;
        var b3 = triangles[i3 + 1] * dim;
        var c2 = triangles[i3 + 2] * dim;
        trianglesArea += Math.abs(
          (data[a2] - data[c2]) * (data[b3 + 1] - data[a2 + 1]) - (data[a2] - data[b3]) * (data[c2 + 1] - data[a2 + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i3 = start, j2 = end - dim; i3 < end; i3 += dim) {
        sum += (data[j2] - data[i3]) * (data[i3 + 1] + data[j2 + 1]);
        j2 = i3;
      }
      return sum;
    }
    earcut2.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i3 = 0; i3 < data.length; i3++) {
        for (var j2 = 0; j2 < data[i3].length; j2++) {
          for (var d2 = 0; d2 < dim; d2++) result.vertices.push(data[i3][j2][d2]);
        }
        if (i3 > 0) {
          holeIndex += data[i3 - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs
function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
  const triangles = (0, import_earcut.default)(points, holes, 2);
  if (!triangles) {
    return;
  }
  for (let i3 = 0; i3 < triangles.length; i3 += 3) {
    indices[indicesOffset++] = triangles[i3] + verticesOffset;
    indices[indicesOffset++] = triangles[i3 + 1] + verticesOffset;
    indices[indicesOffset++] = triangles[i3 + 2] + verticesOffset;
  }
  let index = verticesOffset * verticesStride;
  for (let i3 = 0; i3 < points.length; i3 += 2) {
    vertices[index] = points[i3];
    vertices[index + 1] = points[i3 + 1];
    index += verticesStride;
  }
}
var import_earcut;
var init_triangulateWithHoles = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs"() {
    init_define_AnParams();
    import_earcut = __toESM(require_earcut(), 1);
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs
var emptyArray, buildPolygon;
var init_buildPolygon = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_triangulateWithHoles();
    emptyArray = [];
    buildPolygon = {
      extension: {
        type: ExtensionType.ShapeBuilder,
        name: "polygon"
      },
      build(shape, points) {
        for (let i3 = 0; i3 < shape.points.length; i3++) {
          points[i3] = shape.points[i3];
        }
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs
var buildRectangle;
var init_buildRectangle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs"() {
    init_define_AnParams();
    init_Extensions();
    buildRectangle = {
      extension: {
        type: ExtensionType.ShapeBuilder,
        name: "rectangle"
      },
      build(shape, points) {
        const rectData = shape;
        const x2 = rectData.x;
        const y2 = rectData.y;
        const width = rectData.width;
        const height = rectData.height;
        if (!(width >= 0 && height >= 0)) {
          return points;
        }
        points[0] = x2;
        points[1] = y2;
        points[2] = x2 + width;
        points[3] = y2;
        points[4] = x2 + width;
        points[5] = y2 + height;
        points[6] = x2;
        points[7] = y2 + height;
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count2 = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count2] = points[0];
        vertices[verticesOffset + count2 + 1] = points[1];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[2];
        vertices[verticesOffset + count2 + 1] = points[3];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[6];
        vertices[verticesOffset + count2 + 1] = points[7];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[4];
        vertices[verticesOffset + count2 + 1] = points[5];
        count2 += verticesStride;
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 3;
        indices[indicesOffset++] = verticesIndex + 2;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs
var buildTriangle;
var init_buildTriangle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs"() {
    init_define_AnParams();
    init_Extensions();
    buildTriangle = {
      extension: {
        type: ExtensionType.ShapeBuilder,
        name: "triangle"
      },
      build(shape, points) {
        points[0] = shape.x;
        points[1] = shape.y;
        points[2] = shape.x2;
        points[3] = shape.y2;
        points[4] = shape.x3;
        points[5] = shape.y3;
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count2 = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count2] = points[0];
        vertices[verticesOffset + count2 + 1] = points[1];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[2];
        vertices[verticesOffset + count2 + 1] = points[3];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[4];
        vertices[verticesOffset + count2 + 1] = points[5];
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs
function generateTextureMatrix(out2, style, shape, matrix) {
  const textureMatrix = style.matrix ? out2.copyFrom(style.matrix).invert() : out2.identity();
  if (style.textureSpace === "local") {
    const bounds = shape.getBounds(tempRect);
    textureMatrix.translate(-bounds.x, -bounds.y);
    textureMatrix.scale(1 / bounds.width, 1 / bounds.height);
  } else {
    textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);
    textureMatrix.scale(1 / style.texture.source.width, 1 / style.texture.source.height);
    const sourceStyle = style.texture.source.style;
    if (sourceStyle.addressMode === "clamp-to-edge") {
      sourceStyle.addressMode = "repeat";
      sourceStyle.update();
    }
  }
  if (matrix) {
    textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());
  }
  return textureMatrix;
}
var tempTextureMatrix, tempRect;
var init_generateTextureFillMatrix = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/generateTextureFillMatrix.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_Rectangle();
    tempTextureMatrix = new Matrix();
    tempRect = new Rectangle();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs
function buildContextBatches(context2, gpuContext) {
  const { geometryData, batches } = gpuContext;
  batches.length = 0;
  geometryData.indices.length = 0;
  geometryData.vertices.length = 0;
  geometryData.uvs.length = 0;
  for (let i3 = 0; i3 < context2.instructions.length; i3++) {
    const instruction = context2.instructions[i3];
    if (instruction.action === "texture") {
      addTextureToGeometryData(instruction.data, batches, geometryData);
    } else if (instruction.action === "fill" || instruction.action === "stroke") {
      const isStroke = instruction.action === "stroke";
      const shapePath = instruction.data.path.shapePath;
      const style = instruction.data.style;
      const hole = instruction.data.hole;
      if (isStroke && hole) {
        addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);
      }
      if (hole) {
        shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;
      }
      addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);
    }
  }
}
function addTextureToGeometryData(data, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  const indexOffset = indices.length;
  const vertOffset = vertices.length / 2;
  const points = [];
  const build = shapeBuilders.rectangle;
  const rect = tempRect2;
  const texture = data.image;
  rect.x = data.dx;
  rect.y = data.dy;
  rect.width = data.dw;
  rect.height = data.dh;
  const matrix = data.transform;
  build.build(rect, points);
  if (matrix) {
    transformVertices(points, matrix);
  }
  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
  const textureUvs = texture.uvs;
  uvs.push(
    textureUvs.x0,
    textureUvs.y0,
    textureUvs.x1,
    textureUvs.y1,
    textureUvs.x3,
    textureUvs.y3,
    textureUvs.x2,
    textureUvs.y2
  );
  const graphicsBatch = BigPool.get(BatchableGraphics);
  graphicsBatch.indexOffset = indexOffset;
  graphicsBatch.indexSize = indices.length - indexOffset;
  graphicsBatch.attributeOffset = vertOffset;
  graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
  graphicsBatch.baseColor = data.style;
  graphicsBatch.alpha = data.alpha;
  graphicsBatch.texture = texture;
  graphicsBatch.geometryData = geometryData;
  batches.push(graphicsBatch);
}
function addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) => {
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build = shapeBuilders[shape.type];
    let topology = "triangle-list";
    build.build(shape, points);
    if (matrix) {
      transformVertices(points, matrix);
    }
    if (!isStroke) {
      if (holes) {
        const holeIndices = [];
        const otherPoints = points.slice();
        const holeArrays = getHoleArrays(holes);
        holeArrays.forEach((holePoints) => {
          holeIndices.push(otherPoints.length / 2);
          otherPoints.push(...holePoints);
        });
        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
      } else {
        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      }
    } else {
      const close = shape.closePath ?? true;
      const lineStyle = style;
      if (!lineStyle.pixelLine) {
        buildLine(points, lineStyle, false, close, vertices, indices);
      } else {
        buildPixelLine(points, close, vertices, indices);
        topology = "line-list";
      }
    }
    const uvsOffset = uvs.length / 2;
    const texture = style.texture;
    if (texture !== Texture.WHITE) {
      const textureMatrix = generateTextureMatrix(tempTextureMatrix2, style, shape, matrix);
      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
    } else {
      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
    }
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.attributeOffset = vertOffset;
    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
    graphicsBatch.baseColor = style.color;
    graphicsBatch.alpha = style.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    graphicsBatch.topology = topology;
    batches.push(graphicsBatch);
  });
}
function getHoleArrays(holePrimitives) {
  const holeArrays = [];
  for (let k2 = 0; k2 < holePrimitives.length; k2++) {
    const holePrimitive = holePrimitives[k2].shape;
    const holePoints = [];
    const holeBuilder = shapeBuilders[holePrimitive.type];
    holeBuilder.build(holePrimitive, holePoints);
    holeArrays.push(holePoints);
  }
  return holeArrays;
}
var shapeBuilders, tempRect2, tempTextureMatrix2;
var init_buildContextBatches = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Matrix();
    init_Rectangle();
    init_buildUvs();
    init_transformVertices();
    init_Texture();
    init_PoolGroup();
    init_BatchableGraphics();
    init_buildCircle();
    init_buildLine();
    init_buildPixelLine();
    init_buildPolygon();
    init_buildRectangle();
    init_buildTriangle();
    init_generateTextureFillMatrix();
    init_triangulateWithHoles();
    shapeBuilders = {};
    extensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);
    extensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);
    tempRect2 = new Rectangle();
    tempTextureMatrix2 = new Matrix();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs
var GpuGraphicsContext, GraphicsContextRenderData, _GraphicsContextSystem, GraphicsContextSystem;
var init_GraphicsContextSystem = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_getTextureBatchBindGroup();
    init_DefaultBatcher();
    init_InstructionSet();
    init_deprecation();
    init_PoolGroup();
    init_buildContextBatches();
    GpuGraphicsContext = class {
      constructor() {
        this.batches = [];
        this.geometryData = {
          vertices: [],
          uvs: [],
          indices: []
        };
      }
    };
    GraphicsContextRenderData = class {
      constructor() {
        this.batcher = new DefaultBatcher();
        this.instructions = new InstructionSet();
      }
      init() {
        this.instructions.reset();
      }
      /**
       * @deprecated since version 8.0.0
       * Use `batcher.geometry` instead.
       * @see {Batcher#geometry}
       */
      get geometry() {
        deprecation(v8_3_4, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
        return this.batcher.geometry;
      }
    };
    _GraphicsContextSystem = class _GraphicsContextSystem2 {
      constructor(renderer) {
        this._gpuContextHash = {};
        this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
        renderer.renderableGC.addManagedHash(this, "_gpuContextHash");
        renderer.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
      }
      /**
       * Runner init called, update the default options
       * @ignore
       */
      init(options) {
        _GraphicsContextSystem2.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem2.defaultOptions.bezierSmoothness;
      }
      getContextRenderData(context2) {
        return this._graphicsDataContextHash[context2.uid] || this._initContextRenderData(context2);
      }
      // Context management functions
      updateGpuContext(context2) {
        let gpuContext = this._gpuContextHash[context2.uid] || this._initContext(context2);
        if (context2.dirty) {
          if (gpuContext) {
            this._cleanGraphicsContextData(context2);
          } else {
            gpuContext = this._initContext(context2);
          }
          buildContextBatches(context2, gpuContext);
          const batchMode = context2.batchMode;
          if (context2.customShader || batchMode === "no-batch") {
            gpuContext.isBatchable = false;
          } else if (batchMode === "auto") {
            gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
          }
          context2.dirty = false;
        }
        return gpuContext;
      }
      getGpuContext(context2) {
        return this._gpuContextHash[context2.uid] || this._initContext(context2);
      }
      _initContextRenderData(context2) {
        const graphicsData = BigPool.get(GraphicsContextRenderData);
        const { batches, geometryData } = this._gpuContextHash[context2.uid];
        const vertexSize = geometryData.vertices.length;
        const indexSize = geometryData.indices.length;
        for (let i3 = 0; i3 < batches.length; i3++) {
          batches[i3].applyTransform = false;
        }
        const batcher = graphicsData.batcher;
        batcher.ensureAttributeBuffer(vertexSize);
        batcher.ensureIndexBuffer(indexSize);
        batcher.begin();
        for (let i3 = 0; i3 < batches.length; i3++) {
          const batch = batches[i3];
          batcher.add(batch);
        }
        batcher.finish(graphicsData.instructions);
        const geometry = batcher.geometry;
        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
        const drawBatches = batcher.batches;
        for (let i3 = 0; i3 < drawBatches.length; i3++) {
          const batch = drawBatches[i3];
          batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);
        }
        this._graphicsDataContextHash[context2.uid] = graphicsData;
        return graphicsData;
      }
      _initContext(context2) {
        const gpuContext = new GpuGraphicsContext();
        gpuContext.context = context2;
        this._gpuContextHash[context2.uid] = gpuContext;
        context2.on("destroy", this.onGraphicsContextDestroy, this);
        return this._gpuContextHash[context2.uid];
      }
      onGraphicsContextDestroy(context2) {
        this._cleanGraphicsContextData(context2);
        context2.off("destroy", this.onGraphicsContextDestroy, this);
        this._gpuContextHash[context2.uid] = null;
      }
      _cleanGraphicsContextData(context2) {
        const gpuContext = this._gpuContextHash[context2.uid];
        if (!gpuContext.isBatchable) {
          if (this._graphicsDataContextHash[context2.uid]) {
            BigPool.return(this.getContextRenderData(context2));
            this._graphicsDataContextHash[context2.uid] = null;
          }
        }
        if (gpuContext.batches) {
          gpuContext.batches.forEach((batch) => {
            BigPool.return(batch);
          });
        }
      }
      destroy() {
        for (const i3 in this._gpuContextHash) {
          if (this._gpuContextHash[i3]) {
            this.onGraphicsContextDestroy(this._gpuContextHash[i3].context);
          }
        }
      }
    };
    _GraphicsContextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "graphicsContext"
    };
    _GraphicsContextSystem.defaultOptions = {
      /**
       * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
       * @default 0.5
       */
      bezierSmoothness: 0.5
    };
    GraphicsContextSystem = _GraphicsContextSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs
var blendModeIds, BLEND, OFFSET, CULLING, DEPTH_TEST, WINDING, DEPTH_MASK, _State, State;
var init_State = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"() {
    "use strict";
    init_define_AnParams();
    blendModeIds = {
      normal: 0,
      add: 1,
      multiply: 2,
      screen: 3,
      overlay: 4,
      erase: 5,
      "normal-npm": 6,
      "add-npm": 7,
      "screen-npm": 8,
      min: 9,
      max: 10
    };
    BLEND = 0;
    OFFSET = 1;
    CULLING = 2;
    DEPTH_TEST = 3;
    WINDING = 4;
    DEPTH_MASK = 5;
    _State = class _State2 {
      constructor() {
        this.data = 0;
        this.blendMode = "normal";
        this.polygonOffset = 0;
        this.blend = true;
        this.depthMask = true;
      }
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get blend() {
        return !!(this.data & 1 << BLEND);
      }
      set blend(value) {
        if (!!(this.data & 1 << BLEND) !== value) {
          this.data ^= 1 << BLEND;
        }
      }
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get offsets() {
        return !!(this.data & 1 << OFFSET);
      }
      set offsets(value) {
        if (!!(this.data & 1 << OFFSET) !== value) {
          this.data ^= 1 << OFFSET;
        }
      }
      /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
      set cullMode(value) {
        if (value === "none") {
          this.culling = false;
          return;
        }
        this.culling = true;
        this.clockwiseFrontFace = value === "front";
      }
      get cullMode() {
        if (!this.culling) {
          return "none";
        }
        return this.clockwiseFrontFace ? "front" : "back";
      }
      /**
       * Activates culling of polygons.
       * @default false
       */
      get culling() {
        return !!(this.data & 1 << CULLING);
      }
      set culling(value) {
        if (!!(this.data & 1 << CULLING) !== value) {
          this.data ^= 1 << CULLING;
        }
      }
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get depthTest() {
        return !!(this.data & 1 << DEPTH_TEST);
      }
      set depthTest(value) {
        if (!!(this.data & 1 << DEPTH_TEST) !== value) {
          this.data ^= 1 << DEPTH_TEST;
        }
      }
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get depthMask() {
        return !!(this.data & 1 << DEPTH_MASK);
      }
      set depthMask(value) {
        if (!!(this.data & 1 << DEPTH_MASK) !== value) {
          this.data ^= 1 << DEPTH_MASK;
        }
      }
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get clockwiseFrontFace() {
        return !!(this.data & 1 << WINDING);
      }
      set clockwiseFrontFace(value) {
        if (!!(this.data & 1 << WINDING) !== value) {
          this.data ^= 1 << WINDING;
        }
      }
      /**
       * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default 'normal'
       */
      get blendMode() {
        return this._blendMode;
      }
      set blendMode(value) {
        this.blend = value !== "none";
        this._blendMode = value;
        this._blendModeId = blendModeIds[value] || 0;
      }
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get polygonOffset() {
        return this._polygonOffset;
      }
      set polygonOffset(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
      }
      toString() {
        return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
      }
      /**
       * A quickly getting an instance of a State that is configured for 2d rendering.
       * @returns a new State with values set for 2d rendering
       */
      static for2d() {
        const state = new _State2();
        state.depthTest = false;
        state.blend = true;
        return state;
      }
    };
    _State.default2d = _State.for2d();
    State = _State;
  }
});

// node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs
function colorToUniform(rgb, alpha, out2, offset) {
  out2[offset++] = (rgb >> 16 & 255) / 255;
  out2[offset++] = (rgb >> 8 & 255) / 255;
  out2[offset++] = (rgb & 255) / 255;
  out2[offset++] = alpha;
}
function color32BitToUniform(abgr, out2, offset) {
  const alpha = (abgr >> 24 & 255) / 255;
  out2[offset++] = (abgr & 255) / 255 * alpha;
  out2[offset++] = (abgr >> 8 & 255) / 255 * alpha;
  out2[offset++] = (abgr >> 16 & 255) / 255 * alpha;
  out2[offset++] = alpha;
}
var init_colorToUniform = __esm({
  "node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs
var GraphicsPipe;
var init_GraphicsPipe = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_State();
    init_PoolGroup();
    init_colorToUniform();
    init_BatchableGraphics();
    GraphicsPipe = class {
      constructor(renderer, adaptor) {
        this.state = State.for2d();
        this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init();
        this.renderer.renderableGC.addManagedHash(this, "_graphicsBatchesHash");
      }
      validateRenderable(graphics) {
        const context2 = graphics.context;
        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context2);
        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
          return true;
        }
        return false;
      }
      addRenderable(graphics, instructionSet) {
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
        if (graphics.didViewUpdate) {
          this._rebuild(graphics);
        }
        if (gpuContext.isBatchable) {
          this._addToBatcher(graphics, instructionSet);
        } else {
          this.renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(graphics);
        }
      }
      updateRenderable(graphics) {
        const batches = this._graphicsBatchesHash[graphics.uid];
        if (batches) {
          for (let i3 = 0; i3 < batches.length; i3++) {
            const batch = batches[i3];
            batch._batcher.updateElement(batch);
          }
        }
      }
      destroyRenderable(graphics) {
        if (this._graphicsBatchesHash[graphics.uid]) {
          this._removeBatchForRenderable(graphics.uid);
        }
        graphics.off("destroyed", this._destroyRenderableBound);
      }
      execute(graphics) {
        if (!graphics.isRenderable)
          return;
        const renderer = this.renderer;
        const context2 = graphics.context;
        const contextSystem = renderer.graphicsContext;
        if (!contextSystem.getGpuContext(context2).batches.length) {
          return;
        }
        const shader = context2.customShader || this._adaptor.shader;
        this.state.blendMode = graphics.groupBlendMode;
        const localUniforms = shader.resources.localUniforms.uniforms;
        localUniforms.uTransformMatrix = graphics.groupTransform;
        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
        color32BitToUniform(
          graphics.groupColorAlpha,
          localUniforms.uColor,
          0
        );
        this._adaptor.execute(this, graphics);
      }
      _rebuild(graphics) {
        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
        if (wasBatched) {
          this._removeBatchForRenderable(graphics.uid);
        }
        if (gpuContext.isBatchable) {
          this._initBatchesForRenderable(graphics);
        }
        graphics.batched = gpuContext.isBatchable;
      }
      _addToBatcher(graphics, instructionSet) {
        const batchPipe = this.renderer.renderPipes.batch;
        const batches = this._getBatchesForRenderable(graphics);
        for (let i3 = 0; i3 < batches.length; i3++) {
          const batch = batches[i3];
          batchPipe.addToBatch(batch, instructionSet);
        }
      }
      _getBatchesForRenderable(graphics) {
        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);
      }
      _initBatchesForRenderable(graphics) {
        const context2 = graphics.context;
        const gpuContext = this.renderer.graphicsContext.getGpuContext(context2);
        const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
        const batches = gpuContext.batches.map((batch) => {
          const batchClone = BigPool.get(BatchableGraphics);
          batch.copyTo(batchClone);
          batchClone.renderable = graphics;
          batchClone.roundPixels = roundPixels;
          return batchClone;
        });
        if (this._graphicsBatchesHash[graphics.uid] === void 0) {
          graphics.on("destroyed", this._destroyRenderableBound);
        }
        this._graphicsBatchesHash[graphics.uid] = batches;
        return batches;
      }
      _removeBatchForRenderable(graphicsUid) {
        this._graphicsBatchesHash[graphicsUid].forEach((batch) => {
          BigPool.return(batch);
        });
        this._graphicsBatchesHash[graphicsUid] = null;
      }
      destroy() {
        this.renderer = null;
        this._adaptor.destroy();
        this._adaptor = null;
        this.state = null;
        for (const i3 in this._graphicsBatchesHash) {
          this._removeBatchForRenderable(i3);
        }
        this._graphicsBatchesHash = null;
      }
    };
    GraphicsPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "graphics"
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/init.mjs
var init_init7 = __esm({
  "node_modules/pixi.js/lib/scene/graphics/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_GraphicsContextSystem();
    init_GraphicsPipe();
    extensions.add(GraphicsPipe);
    extensions.add(GraphicsContextSystem);
  }
});

// node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs
var BatchableMesh;
var init_BatchableMesh = __esm({
  "node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"() {
    "use strict";
    init_define_AnParams();
    BatchableMesh = class {
      constructor() {
        this.batcherName = "default";
        this.packAsQuad = false;
        this.indexOffset = 0;
        this.attributeOffset = 0;
        this.roundPixels = 0;
        this._batcher = null;
        this._batch = null;
        this._textureMatrixUpdateId = -1;
        this._uvUpdateId = -1;
      }
      get blendMode() {
        return this.renderable.groupBlendMode;
      }
      get topology() {
        return this._topology || this.geometry.topology;
      }
      set topology(value) {
        this._topology = value;
      }
      reset() {
        this.renderable = null;
        this.texture = null;
        this._batcher = null;
        this._batch = null;
        this.geometry = null;
        this._uvUpdateId = -1;
        this._textureMatrixUpdateId = -1;
      }
      /**
       * Sets the texture for the batchable mesh.
       * As it does so, it resets the texture matrix update ID.
       * this is to ensure that the texture matrix is recalculated when the uvs are referenced
       * @param value - The texture to set.
       */
      setTexture(value) {
        if (this.texture === value)
          return;
        this.texture = value;
        this._textureMatrixUpdateId = -1;
      }
      get uvs() {
        const geometry = this.geometry;
        const uvBuffer = geometry.getBuffer("aUV");
        const uvs = uvBuffer.data;
        let transformedUvs = uvs;
        const textureMatrix = this.texture.textureMatrix;
        if (!textureMatrix.isSimple) {
          transformedUvs = this._transformedUvs;
          if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
            if (!transformedUvs || transformedUvs.length < uvs.length) {
              transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
            }
            this._textureMatrixUpdateId = textureMatrix._updateID;
            this._uvUpdateId = uvBuffer._updateID;
            textureMatrix.multiplyUvs(uvs, transformedUvs);
          }
        }
        return transformedUvs;
      }
      get positions() {
        return this.geometry.positions;
      }
      get indices() {
        return this.geometry.indices;
      }
      get color() {
        return this.renderable.groupColorAlpha;
      }
      get groupTransform() {
        return this.renderable.groupTransform;
      }
      get attributeSize() {
        return this.geometry.positions.length / 2;
      }
      get indexSize() {
        return this.geometry.indices.length;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs
var MeshPipe;
var init_MeshPipe = __esm({
  "node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Matrix();
    init_BindGroup();
    init_UniformGroup();
    init_getAdjustedBlendModeBlend();
    init_PoolGroup();
    init_colorToUniform();
    init_BatchableMesh();
    MeshPipe = class {
      constructor(renderer, adaptor) {
        this.localUniforms = new UniformGroup({
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uRound: { value: 0, type: "f32" }
        });
        this.localUniformsBindGroup = new BindGroup({
          0: this.localUniforms
        });
        this._meshDataHash = /* @__PURE__ */ Object.create(null);
        this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init();
        renderer.renderableGC.addManagedHash(this, "_gpuBatchableMeshHash");
        renderer.renderableGC.addManagedHash(this, "_meshDataHash");
      }
      validateRenderable(mesh) {
        const meshData = this._getMeshData(mesh);
        const wasBatched = meshData.batched;
        const isBatched = mesh.batched;
        meshData.batched = isBatched;
        if (wasBatched !== isBatched) {
          return true;
        } else if (isBatched) {
          const geometry = mesh._geometry;
          if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
            meshData.indexSize = geometry.indices.length;
            meshData.vertexSize = geometry.positions.length;
            return true;
          }
          const batchableMesh = this._getBatchableMesh(mesh);
          if (batchableMesh.texture.uid !== mesh._texture.uid) {
            batchableMesh._textureMatrixUpdateId = -1;
          }
          return !batchableMesh._batcher.checkAndUpdateTexture(
            batchableMesh,
            mesh._texture
          );
        }
        return false;
      }
      addRenderable(mesh, instructionSet) {
        const batcher = this.renderer.renderPipes.batch;
        const { batched } = this._getMeshData(mesh);
        if (batched) {
          const gpuBatchableMesh = this._getBatchableMesh(mesh);
          gpuBatchableMesh.setTexture(mesh._texture);
          gpuBatchableMesh.geometry = mesh._geometry;
          batcher.addToBatch(gpuBatchableMesh, instructionSet);
        } else {
          batcher.break(instructionSet);
          instructionSet.add(mesh);
        }
      }
      updateRenderable(mesh) {
        if (mesh.batched) {
          const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];
          gpuBatchableMesh.setTexture(mesh._texture);
          gpuBatchableMesh.geometry = mesh._geometry;
          gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);
        }
      }
      destroyRenderable(mesh) {
        this._meshDataHash[mesh.uid] = null;
        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];
        if (gpuMesh) {
          BigPool.return(gpuMesh);
          this._gpuBatchableMeshHash[mesh.uid] = null;
        }
        mesh.off("destroyed", this._destroyRenderableBound);
      }
      execute(mesh) {
        if (!mesh.isRenderable)
          return;
        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);
        const localUniforms = this.localUniforms;
        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
        localUniforms.update();
        color32BitToUniform(
          mesh.groupColorAlpha,
          localUniforms.uniforms.uColor,
          0
        );
        this._adaptor.execute(this, mesh);
      }
      _getMeshData(mesh) {
        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);
      }
      _initMeshData(mesh) {
        this._meshDataHash[mesh.uid] = {
          batched: mesh.batched,
          indexSize: mesh._geometry.indices?.length,
          vertexSize: mesh._geometry.positions?.length
        };
        mesh.on("destroyed", this._destroyRenderableBound);
        return this._meshDataHash[mesh.uid];
      }
      _getBatchableMesh(mesh) {
        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);
      }
      _initBatchableMesh(mesh) {
        const gpuMesh = BigPool.get(BatchableMesh);
        gpuMesh.renderable = mesh;
        gpuMesh.setTexture(mesh._texture);
        gpuMesh.transform = mesh.groupTransform;
        gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;
        return gpuMesh;
      }
      destroy() {
        for (const i3 in this._gpuBatchableMeshHash) {
          if (this._gpuBatchableMeshHash[i3]) {
            BigPool.return(this._gpuBatchableMeshHash[i3]);
          }
        }
        this._gpuBatchableMeshHash = null;
        this._meshDataHash = null;
        this.localUniforms = null;
        this.localUniformsBindGroup = null;
        this._adaptor.destroy();
        this._adaptor = null;
        this.renderer = null;
      }
    };
    MeshPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "mesh"
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh/init.mjs
var init_init8 = __esm({
  "node_modules/pixi.js/lib/scene/mesh/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_MeshPipe();
    extensions.add(MeshPipe);
  }
});

// node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs
var GlParticleContainerAdaptor;
var init_GlParticleContainerAdaptor = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs"() {
    "use strict";
    init_define_AnParams();
    GlParticleContainerAdaptor = class {
      execute(particleContainerPipe, container) {
        const state = particleContainerPipe.state;
        const renderer = particleContainerPipe.renderer;
        const shader = container.shader || particleContainerPipe.defaultShader;
        shader.resources.uTexture = container.texture._source;
        shader.resources.uniforms = particleContainerPipe.localUniforms;
        const gl = renderer.gl;
        const buffer = particleContainerPipe.getBuffers(container);
        renderer.shader.bind(shader);
        renderer.state.set(state);
        renderer.geometry.bind(buffer.geometry, shader.glProgram);
        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;
        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs
function createIndicesForQuads(size, outBuffer = null) {
  const totalIndices = size * 6;
  if (totalIndices > 65535) {
    outBuffer || (outBuffer = new Uint32Array(totalIndices));
  } else {
    outBuffer || (outBuffer = new Uint16Array(totalIndices));
  }
  if (outBuffer.length !== totalIndices) {
    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);
  }
  for (let i3 = 0, j2 = 0; i3 < totalIndices; i3 += 6, j2 += 4) {
    outBuffer[i3 + 0] = j2 + 0;
    outBuffer[i3 + 1] = j2 + 1;
    outBuffer[i3 + 2] = j2 + 2;
    outBuffer[i3 + 3] = j2 + 0;
    outBuffer[i3 + 4] = j2 + 2;
    outBuffer[i3 + 5] = j2 + 3;
  }
  return outBuffer;
}
var init_createIndicesForQuads = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs
function generateParticleUpdateFunction(properties) {
  return {
    dynamicUpdate: generateUpdateFunction(properties, true),
    staticUpdate: generateUpdateFunction(properties, false)
  };
}
function generateUpdateFunction(properties, dynamic) {
  const funcFragments = [];
  funcFragments.push(`
      
        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
  let offset = 0;
  for (const i3 in properties) {
    const property = properties[i3];
    if (dynamic !== property.dynamic)
      continue;
    funcFragments.push(`offset = index + ${offset}`);
    funcFragments.push(property.code);
    const attributeInfo = getAttributeInfoFromFormat(property.format);
    offset += attributeInfo.stride / 4;
  }
  funcFragments.push(`
            index += stride * 4;
        }
    `);
  funcFragments.unshift(`
        var stride = ${offset};
    `);
  const functionSource = funcFragments.join("\n");
  return new Function("ps", "f32v", "u32v", functionSource);
}
var init_generateParticleUpdateFunction = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs"() {
    init_define_AnParams();
    init_getAttributeInfoFromFormat();
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs
function getParticleSyncKey(properties) {
  const keyGen = [];
  for (const key in properties) {
    const property = properties[key];
    keyGen.push(key, property.code, property.dynamic ? "d" : "s");
  }
  return keyGen.join("_");
}
var ParticleBuffer;
var init_ParticleBuffer = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs"() {
    init_define_AnParams();
    init_Buffer();
    init_const4();
    init_Geometry();
    init_getAttributeInfoFromFormat();
    init_ViewableBuffer();
    init_createIndicesForQuads();
    init_generateParticleUpdateFunction();
    ParticleBuffer = class {
      constructor(options) {
        this._size = 0;
        this._generateParticleUpdateCache = {};
        const size = this._size = options.size ?? 1e3;
        const properties = options.properties;
        let staticVertexSize = 0;
        let dynamicVertexSize = 0;
        for (const i3 in properties) {
          const property = properties[i3];
          const attributeInfo = getAttributeInfoFromFormat(property.format);
          if (property.dynamic) {
            dynamicVertexSize += attributeInfo.stride;
          } else {
            staticVertexSize += attributeInfo.stride;
          }
        }
        this._dynamicStride = dynamicVertexSize / 4;
        this._staticStride = staticVertexSize / 4;
        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);
        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);
        this.indexBuffer = createIndicesForQuads(size);
        const geometry = new Geometry();
        let dynamicOffset = 0;
        let staticOffset = 0;
        this._staticBuffer = new Buffer2({
          data: new Float32Array(1),
          label: "static-particle-buffer",
          shrinkToFit: false,
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        this._dynamicBuffer = new Buffer2({
          data: new Float32Array(1),
          label: "dynamic-particle-buffer",
          shrinkToFit: false,
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        for (const i3 in properties) {
          const property = properties[i3];
          const attributeInfo = getAttributeInfoFromFormat(property.format);
          if (property.dynamic) {
            geometry.addAttribute(property.attributeName, {
              buffer: this._dynamicBuffer,
              stride: this._dynamicStride * 4,
              offset: dynamicOffset * 4,
              format: property.format
            });
            dynamicOffset += attributeInfo.size;
          } else {
            geometry.addAttribute(property.attributeName, {
              buffer: this._staticBuffer,
              stride: this._staticStride * 4,
              offset: staticOffset * 4,
              format: property.format
            });
            staticOffset += attributeInfo.size;
          }
        }
        geometry.addIndex(this.indexBuffer);
        const uploadFunction = this.getParticleUpdate(properties);
        this._dynamicUpload = uploadFunction.dynamicUpdate;
        this._staticUpload = uploadFunction.staticUpdate;
        this.geometry = geometry;
      }
      getParticleUpdate(properties) {
        const key = getParticleSyncKey(properties);
        if (this._generateParticleUpdateCache[key]) {
          return this._generateParticleUpdateCache[key];
        }
        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);
        return this._generateParticleUpdateCache[key];
      }
      generateParticleUpdate(properties) {
        return generateParticleUpdateFunction(properties);
      }
      update(particles, uploadStatic) {
        if (particles.length > this._size) {
          uploadStatic = true;
          this._size = Math.max(particles.length, this._size * 1.5 | 0);
          this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);
          this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);
          this.indexBuffer = createIndicesForQuads(this._size);
          this.geometry.indexBuffer.setDataWithSize(
            this.indexBuffer,
            this.indexBuffer.byteLength,
            true
          );
        }
        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;
        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);
        this._dynamicBuffer.setDataWithSize(
          this.dynamicAttributeBuffer.float32View,
          particles.length * this._dynamicStride * 4,
          true
        );
        if (uploadStatic) {
          const staticAttributeBuffer = this.staticAttributeBuffer;
          this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);
          this._staticBuffer.setDataWithSize(
            staticAttributeBuffer.float32View,
            particles.length * this._staticStride * 4,
            true
          );
        }
      }
      destroy() {
        this._staticBuffer.destroy();
        this._dynamicBuffer.destroy();
        this.geometry.destroy();
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs
var fragment;
var init_particles_frag = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs"() {
    init_define_AnParams();
    fragment = "varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}";
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs
var vertex;
var init_particles_vert = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs"() {
    init_define_AnParams();
    vertex = "attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n";
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs
var wgsl;
var init_particles_wgsl = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs"() {
    init_define_AnParams();
    wgsl = "\nstruct ParticleUniforms {\n  uProjectionMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uResolution:vec2<f32>,\n  uRoundPixels:f32,\n};\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs
var ParticleShader;
var init_ParticleShader = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs"() {
    init_define_AnParams();
    init_Color();
    init_Matrix();
    init_GlProgram();
    init_GpuProgram();
    init_Shader();
    init_Texture();
    init_TextureStyle();
    init_particles_frag();
    init_particles_vert();
    init_particles_wgsl();
    ParticleShader = class extends Shader {
      constructor() {
        const glProgram3 = GlProgram.from({
          vertex,
          fragment
        });
        const gpuProgram3 = GpuProgram.from({
          fragment: {
            source: wgsl,
            entryPoint: "mainFragment"
          },
          vertex: {
            source: wgsl,
            entryPoint: "mainVertex"
          }
        });
        super({
          glProgram: glProgram3,
          gpuProgram: gpuProgram3,
          resources: {
            // this will be replaced with the texture from the particle container
            uTexture: Texture.WHITE.source,
            // this will be replaced with the texture style from the particle container
            uSampler: new TextureStyle({}),
            // this will be replaced with the local uniforms from the particle container
            uniforms: {
              uTranslationMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
              uColor: { value: new Color(16777215), type: "vec4<f32>" },
              uRound: { value: 1, type: "f32" },
              uResolution: { value: [0, 0], type: "vec2<f32>" }
            }
          }
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs
var ParticleContainerPipe;
var init_ParticleContainerPipe = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_UniformGroup();
    init_getAdjustedBlendModeBlend();
    init_State();
    init_colorToUniform();
    init_ParticleBuffer();
    init_ParticleShader();
    ParticleContainerPipe = class {
      /**
       * @param renderer - The renderer this sprite batch works for.
       * @param adaptor
       */
      constructor(renderer, adaptor) {
        this.state = State.for2d();
        this._gpuBufferHash = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this.localUniforms = new UniformGroup({
          uTranslationMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array(4), type: "vec4<f32>" },
          uRound: { value: 1, type: "f32" },
          uResolution: { value: [0, 0], type: "vec2<f32>" }
        });
        this.renderer = renderer;
        this.adaptor = adaptor;
        this.defaultShader = new ParticleShader();
        this.state = State.for2d();
      }
      validateRenderable(_renderable) {
        return false;
      }
      addRenderable(renderable, instructionSet) {
        this.renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add(renderable);
      }
      getBuffers(renderable) {
        return this._gpuBufferHash[renderable.uid] || this._initBuffer(renderable);
      }
      _initBuffer(renderable) {
        this._gpuBufferHash[renderable.uid] = new ParticleBuffer({
          size: renderable.particleChildren.length,
          properties: renderable._properties
        });
        renderable.on("destroyed", this._destroyRenderableBound);
        return this._gpuBufferHash[renderable.uid];
      }
      updateRenderable(_renderable) {
      }
      destroyRenderable(renderable) {
        const buffer = this._gpuBufferHash[renderable.uid];
        buffer.destroy();
        this._gpuBufferHash[renderable.uid] = null;
        renderable.off("destroyed", this._destroyRenderableBound);
      }
      execute(container) {
        const children = container.particleChildren;
        if (children.length === 0) {
          return;
        }
        const renderer = this.renderer;
        const buffer = this.getBuffers(container);
        container.texture || (container.texture = children[0].texture);
        const state = this.state;
        buffer.update(children, container._childrenDirty);
        container._childrenDirty = false;
        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);
        const uniforms = this.localUniforms.uniforms;
        const transformationMatrix = uniforms.uTranslationMatrix;
        container.worldTransform.copyTo(transformationMatrix);
        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);
        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;
        uniforms.uRound = renderer._roundPixels | container._roundPixels;
        color32BitToUniform(
          container.groupColorAlpha,
          uniforms.uColor,
          0
        );
        this.adaptor.execute(this, container);
      }
      /** Destroys the ParticleRenderer. */
      destroy() {
        if (this.defaultShader) {
          this.defaultShader.destroy();
          this.defaultShader = null;
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs
var GlParticleContainerPipe;
var init_GlParticleContainerPipe = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_GlParticleContainerAdaptor();
    init_ParticleContainerPipe();
    GlParticleContainerPipe = class extends ParticleContainerPipe {
      constructor(renderer) {
        super(renderer, new GlParticleContainerAdaptor());
      }
    };
    GlParticleContainerPipe.extension = {
      type: [
        ExtensionType.WebGLPipes
      ],
      name: "particle"
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs
var GpuParticleContainerAdaptor;
var init_GpuParticleContainerAdaptor = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs"() {
    "use strict";
    init_define_AnParams();
    GpuParticleContainerAdaptor = class {
      execute(particleContainerPipe, container) {
        const renderer = particleContainerPipe.renderer;
        const shader = container.shader || particleContainerPipe.defaultShader;
        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);
        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);
        const state = particleContainerPipe.state;
        const buffer = particleContainerPipe.getBuffers(container);
        renderer.encoder.draw({
          geometry: buffer.geometry,
          shader: container.shader || particleContainerPipe.defaultShader,
          state,
          size: container.particleChildren.length * 6
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs
var GpuParticleContainerPipe;
var init_GpuParticleContainerPipe = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_GpuParticleContainerAdaptor();
    init_ParticleContainerPipe();
    GpuParticleContainerPipe = class extends ParticleContainerPipe {
      constructor(renderer) {
        super(renderer, new GpuParticleContainerAdaptor());
      }
    };
    GpuParticleContainerPipe.extension = {
      type: [
        ExtensionType.WebGPUPipes
      ],
      name: "particle"
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/init.mjs
var init_init9 = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_GlParticleContainerPipe();
    init_GpuParticleContainerPipe();
    extensions.add(GlParticleContainerPipe);
    extensions.add(GpuParticleContainerPipe);
  }
});

// node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs
var BatchableSprite;
var init_BatchableSprite = __esm({
  "node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs"() {
    "use strict";
    init_define_AnParams();
    BatchableSprite = class {
      constructor() {
        this.batcherName = "default";
        this.topology = "triangle-list";
        this.attributeSize = 4;
        this.indexSize = 6;
        this.packAsQuad = true;
        this.roundPixels = 0;
        this._attributeStart = 0;
        this._batcher = null;
        this._batch = null;
      }
      get blendMode() {
        return this.renderable.groupBlendMode;
      }
      get color() {
        return this.renderable.groupColorAlpha;
      }
      reset() {
        this.renderable = null;
        this.texture = null;
        this._batcher = null;
        this._batch = null;
        this.bounds = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs
function updateTextBounds(batchableSprite, text) {
  const { texture, bounds } = batchableSprite;
  updateQuadBounds(bounds, text._anchor, texture);
  const padding = text._style.padding;
  bounds.minX -= padding;
  bounds.minY -= padding;
  bounds.maxX -= padding;
  bounds.maxY -= padding;
}
var init_updateTextBounds = __esm({
  "node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs"() {
    init_define_AnParams();
    init_updateQuadBounds();
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs
var CanvasTextPipe;
var init_CanvasTextPipe = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_PoolGroup();
    init_BatchableSprite();
    init_updateTextBounds();
    CanvasTextPipe = class {
      constructor(renderer) {
        this._gpuText = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this._renderer = renderer;
        this._renderer.runners.resolutionChange.add(this);
        this._renderer.renderableGC.addManagedHash(this, "_gpuText");
      }
      resolutionChange() {
        for (const i3 in this._gpuText) {
          const gpuText = this._gpuText[i3];
          if (!gpuText)
            continue;
          const text = gpuText.batchableSprite.renderable;
          if (text._autoResolution) {
            text._resolution = this._renderer.resolution;
            text.onViewUpdate();
          }
        }
      }
      validateRenderable(text) {
        const gpuText = this._getGpuText(text);
        const newKey = text._getKey();
        if (gpuText.currentKey !== newKey) {
          return true;
        }
        return false;
      }
      addRenderable(text, instructionSet) {
        const gpuText = this._getGpuText(text);
        const batchableSprite = gpuText.batchableSprite;
        if (text._didTextUpdate) {
          this._updateText(text);
        }
        this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);
      }
      updateRenderable(text) {
        const gpuText = this._getGpuText(text);
        const batchableSprite = gpuText.batchableSprite;
        if (text._didTextUpdate) {
          this._updateText(text);
        }
        batchableSprite._batcher.updateElement(batchableSprite);
      }
      destroyRenderable(text) {
        text.off("destroyed", this._destroyRenderableBound);
        this._destroyRenderableById(text.uid);
      }
      _destroyRenderableById(textUid) {
        const gpuText = this._gpuText[textUid];
        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
        BigPool.return(gpuText.batchableSprite);
        this._gpuText[textUid] = null;
      }
      _updateText(text) {
        const newKey = text._getKey();
        const gpuText = this._getGpuText(text);
        const batchableSprite = gpuText.batchableSprite;
        if (gpuText.currentKey !== newKey) {
          this._updateGpuText(text);
        }
        text._didTextUpdate = false;
        updateTextBounds(batchableSprite, text);
      }
      _updateGpuText(text) {
        const gpuText = this._getGpuText(text);
        const batchableSprite = gpuText.batchableSprite;
        if (gpuText.texture) {
          this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
        }
        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);
        gpuText.currentKey = text._getKey();
        batchableSprite.texture = gpuText.texture;
      }
      _getGpuText(text) {
        return this._gpuText[text.uid] || this.initGpuText(text);
      }
      initGpuText(text) {
        const gpuTextData = {
          texture: null,
          currentKey: "--",
          batchableSprite: BigPool.get(BatchableSprite)
        };
        gpuTextData.batchableSprite.renderable = text;
        gpuTextData.batchableSprite.transform = text.groupTransform;
        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
        gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;
        this._gpuText[text.uid] = gpuTextData;
        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
        this._updateText(text);
        text.on("destroyed", this._destroyRenderableBound);
        return gpuTextData;
      }
      destroy() {
        for (const i3 in this._gpuText) {
          this._destroyRenderableById(i3);
        }
        this._gpuText = null;
        this._renderer = null;
      }
    };
    CanvasTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "text"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs
var CanvasPoolClass, CanvasPool;
var init_CanvasPool = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_pow2();
    CanvasPoolClass = class {
      constructor(canvasOptions) {
        this._canvasPool = /* @__PURE__ */ Object.create(null);
        this.canvasOptions = canvasOptions || {};
        this.enableFullScreen = false;
      }
      /**
       * Creates texture with params that were specified in pool constructor.
       * @param pixelWidth - Width of texture in pixels.
       * @param pixelHeight - Height of texture in pixels.
       */
      _createCanvasAndContext(pixelWidth, pixelHeight) {
        const canvas = DOMAdapter.get().createCanvas();
        canvas.width = pixelWidth;
        canvas.height = pixelHeight;
        const context2 = canvas.getContext("2d");
        return { canvas, context: context2 };
      }
      /**
       * Gets a Power-of-Two render texture or fullScreen texture
       * @param minWidth - The minimum width of the render texture.
       * @param minHeight - The minimum height of the render texture.
       * @param resolution - The resolution of the render texture.
       * @returns The new render texture.
       */
      getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
        minWidth = Math.ceil(minWidth * resolution - 1e-6);
        minHeight = Math.ceil(minHeight * resolution - 1e-6);
        minWidth = nextPow2(minWidth);
        minHeight = nextPow2(minHeight);
        const key = (minWidth << 17) + (minHeight << 1);
        if (!this._canvasPool[key]) {
          this._canvasPool[key] = [];
        }
        let canvasAndContext = this._canvasPool[key].pop();
        if (!canvasAndContext) {
          canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
        }
        return canvasAndContext;
      }
      /**
       * Place a render texture back into the pool.
       * @param canvasAndContext
       */
      returnCanvasAndContext(canvasAndContext) {
        const canvas = canvasAndContext.canvas;
        const { width, height } = canvas;
        const key = (width << 17) + (height << 1);
        canvasAndContext.context.clearRect(0, 0, width, height);
        this._canvasPool[key].push(canvasAndContext);
      }
      clear() {
        this._canvasPool = {};
      }
    };
    CanvasPool = new CanvasPoolClass();
  }
});

// node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs
function checkRow(data, width, y2) {
  for (let x2 = 0, index = 4 * y2 * width; x2 < width; ++x2, index += 4) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function checkColumn(data, width, x2, top, bottom) {
  const stride = 4 * width;
  for (let y2 = top, index = top * stride + 4 * x2; y2 <= bottom; ++y2, index += stride) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function getCanvasBoundingBox(canvas, resolution = 1) {
  const { width, height } = canvas;
  const context2 = canvas.getContext("2d", {
    willReadFrequently: true
  });
  if (context2 === null) {
    throw new TypeError("Failed to get canvas 2D context");
  }
  const imageData = context2.getImageData(0, 0, width, height);
  const data = imageData.data;
  let left = 0;
  let top = 0;
  let right = width - 1;
  let bottom = height - 1;
  while (top < height && checkRow(data, width, top))
    ++top;
  if (top === height)
    return Rectangle.EMPTY;
  while (checkRow(data, width, bottom))
    --bottom;
  while (checkColumn(data, width, left, top, bottom))
    ++left;
  while (checkColumn(data, width, right, top, bottom))
    --right;
  ++right;
  ++bottom;
  return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);
}
var init_getCanvasBoundingBox = __esm({
  "node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs"() {
    init_define_AnParams();
    init_Rectangle();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs
function addColorStops(gradient, colorStops) {
  for (let i3 = 0; i3 < colorStops.length; i3++) {
    const stop = colorStops[i3];
    gradient.addColorStop(stop.offset, stop.color);
  }
}
function getCanvas(width, height) {
  const canvas = DOMAdapter.get().createCanvas(width, height);
  const context2 = canvas.getContext("2d");
  return { canvas, context: context2 };
}
function ensureGradientOptions(args) {
  let options = args[0] ?? {};
  if (typeof options === "number" || args[1]) {
    deprecation("8.5.2", `use options object instead`);
    options = {
      type: "linear",
      start: { x: args[0], y: args[1] },
      end: { x: args[2], y: args[3] },
      textureSpace: args[4],
      textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize
    };
  }
  return options;
}
var emptyColorStops, _FillGradient, FillGradient;
var init_FillGradient = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs"() {
    init_define_AnParams();
    init_Color();
    init_adapter();
    init_Matrix();
    init_ImageSource();
    init_Texture();
    init_uid();
    init_deprecation();
    init_definedProps();
    emptyColorStops = [{ offset: 0, color: "white" }, { offset: 1, color: "black" }];
    _FillGradient = class _FillGradient2 {
      constructor(...args) {
        this.uid = uid("fillGradient");
        this.type = "linear";
        this.colorStops = [];
        let options = ensureGradientOptions(args);
        const defaults = options.type === "radial" ? _FillGradient2.defaultRadialOptions : _FillGradient2.defaultLinearOptions;
        options = { ...defaults, ...definedProps(options) };
        this._textureSize = options.textureSize;
        if (options.type === "radial") {
          this.center = options.center;
          this.outerCenter = options.outerCenter ?? this.center;
          this.innerRadius = options.innerRadius;
          this.outerRadius = options.outerRadius;
          this.scale = options.scale;
          this.rotation = options.rotation;
        } else {
          this.start = options.start;
          this.end = options.end;
        }
        this.textureSpace = options.textureSpace;
        this.type = options.type;
        options.colorStops.forEach((stop) => {
          this.addColorStop(stop.offset, stop.color);
        });
      }
      /**
       * Adds a color stop to the gradient
       * @param offset - Position of the stop (0-1)
       * @param color - Color of the stop
       * @returns This gradient instance for chaining
       */
      addColorStop(offset, color) {
        this.colorStops.push({ offset, color: Color.shared.setValue(color).toHexa() });
        return this;
      }
      /**
       * Builds the internal texture and transform for the gradient.
       * Called automatically when the gradient is first used.
       * @internal
       */
      buildLinearGradient() {
        if (this.texture)
          return;
        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
        const defaultSize = this._textureSize;
        const { canvas, context: context2 } = getCanvas(defaultSize, 1);
        const gradient = context2.createLinearGradient(0, 0, this._textureSize, 0);
        addColorStops(gradient, colorStops);
        context2.fillStyle = gradient;
        context2.fillRect(0, 0, defaultSize, 1);
        this.texture = new Texture({
          source: new ImageSource({
            resource: canvas
          })
        });
        const { x: x0, y: y0 } = this.start;
        const { x: x1, y: y1 } = this.end;
        const m2 = new Matrix();
        const dx = x1 - x0;
        const dy = y1 - y0;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        m2.scale(dist / defaultSize, 1);
        m2.rotate(angle);
        m2.translate(x0, y0);
        if (this.textureSpace === "local") {
          m2.scale(defaultSize, defaultSize);
        }
        this.transform = m2;
      }
      buildGradient() {
        if (this.type === "linear") {
          this.buildLinearGradient();
        } else {
          this.buildRadialGradient();
        }
      }
      buildRadialGradient() {
        if (this.texture)
          return;
        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
        const defaultSize = this._textureSize;
        const { canvas, context: context2 } = getCanvas(defaultSize, defaultSize);
        const { x: x0, y: y0 } = this.center;
        const { x: x1, y: y1 } = this.outerCenter;
        const r0 = this.innerRadius;
        const r1 = this.outerRadius;
        const ox = x1 - r1;
        const oy = y1 - r1;
        const scale = defaultSize / (r1 * 2);
        const cx = (x0 - ox) * scale;
        const cy = (y0 - oy) * scale;
        const gradient = context2.createRadialGradient(
          cx,
          cy,
          r0 * scale,
          (x1 - ox) * scale,
          (y1 - oy) * scale,
          r1 * scale
        );
        addColorStops(gradient, colorStops);
        context2.fillStyle = colorStops[colorStops.length - 1].color;
        context2.fillRect(0, 0, defaultSize, defaultSize);
        context2.fillStyle = gradient;
        context2.translate(cx, cy);
        context2.rotate(this.rotation);
        context2.scale(1, this.scale);
        context2.translate(-cx, -cy);
        context2.fillRect(0, 0, defaultSize, defaultSize);
        this.texture = new Texture({
          source: new ImageSource({
            resource: canvas,
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge"
          })
        });
        const m2 = new Matrix();
        m2.scale(1 / scale, 1 / scale);
        m2.translate(ox, oy);
        if (this.textureSpace === "local") {
          m2.scale(defaultSize, defaultSize);
        }
        this.transform = m2;
      }
      /**
       * Gets a unique key representing the current state of the gradient.
       * Used internally for caching.
       * @returns Unique string key
       */
      get styleKey() {
        return this.uid;
      }
      destroy() {
        this.texture?.destroy(true);
        this.texture = null;
      }
    };
    _FillGradient.defaultLinearOptions = {
      start: { x: 0, y: 0 },
      end: { x: 0, y: 1 },
      colorStops: [],
      textureSpace: "local",
      type: "linear",
      textureSize: 256
    };
    _FillGradient.defaultRadialOptions = {
      center: { x: 0.5, y: 0.5 },
      innerRadius: 0,
      outerRadius: 0.5,
      colorStops: [],
      scale: 1,
      textureSpace: "local",
      type: "radial",
      textureSize: 256
    };
    FillGradient = _FillGradient;
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs
var repetitionMap, FillPattern;
var init_FillPattern = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_uid();
    repetitionMap = {
      repeat: {
        addressModeU: "repeat",
        addressModeV: "repeat"
      },
      "repeat-x": {
        addressModeU: "repeat",
        addressModeV: "clamp-to-edge"
      },
      "repeat-y": {
        addressModeU: "clamp-to-edge",
        addressModeV: "repeat"
      },
      "no-repeat": {
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    };
    FillPattern = class {
      constructor(texture, repetition) {
        this.uid = uid("fillPattern");
        this.transform = new Matrix();
        this._styleKey = null;
        this.texture = texture;
        this.transform.scale(
          1 / texture.frame.width,
          1 / texture.frame.height
        );
        if (repetition) {
          texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
          texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
        }
      }
      setTransform(transform2) {
        const texture = this.texture;
        this.transform.copyFrom(transform2);
        this.transform.invert();
        this.transform.scale(
          1 / texture.frame.width,
          1 / texture.frame.height
        );
        this._styleKey = null;
      }
      get styleKey() {
        if (this._styleKey)
          return this._styleKey;
        this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`;
        return this._styleKey;
      }
    };
  }
});

// node_modules/parse-svg-path/index.js
var require_parse_svg_path = __commonJS({
  "node_modules/parse-svg-path/index.js"(exports, module) {
    init_define_AnParams();
    module.exports = parse2;
    var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
    var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function parse2(path2) {
      var data = [];
      path2.replace(segment, function(_, command, args) {
        var type = command.toLowerCase();
        args = parseValues(args);
        if (type == "m" && args.length > 2) {
          data.push([command].concat(args.splice(0, 2)));
          type = "l";
          command = command == "m" ? "l" : "L";
        }
        while (true) {
          if (args.length == length[type]) {
            args.unshift(command);
            return data.push(args);
          }
          if (args.length < length[type]) throw new Error("malformed path data");
          data.push([command].concat(args.splice(0, length[type])));
        }
      });
      return data;
    }
    var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function parseValues(args) {
      var numbers = args.match(number);
      return numbers ? numbers.map(Number) : [];
    }
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs
function parseSVGPath(svgPath, path2) {
  const commands = (0, import_parse_svg_path.default)(svgPath);
  const subpaths = [];
  let currentSubPath = null;
  let lastX = 0;
  let lastY = 0;
  for (let i3 = 0; i3 < commands.length; i3++) {
    const command = commands[i3];
    const type = command[0];
    const data = command;
    switch (type) {
      case "M":
        lastX = data[1];
        lastY = data[2];
        path2.moveTo(lastX, lastY);
        break;
      case "m":
        lastX += data[1];
        lastY += data[2];
        path2.moveTo(lastX, lastY);
        break;
      case "H":
        lastX = data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "h":
        lastX += data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "V":
        lastY = data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "v":
        lastY += data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "L":
        lastX = data[1];
        lastY = data[2];
        path2.lineTo(lastX, lastY);
        break;
      case "l":
        lastX += data[1];
        lastY += data[2];
        path2.lineTo(lastX, lastY);
        break;
      case "C":
        lastX = data[5];
        lastY = data[6];
        path2.bezierCurveTo(
          data[1],
          data[2],
          // First control point
          data[3],
          data[4],
          // Second control point
          lastX,
          lastY
          // End point
        );
        break;
      case "c":
        path2.bezierCurveTo(
          lastX + data[1],
          lastY + data[2],
          // First control point
          lastX + data[3],
          lastY + data[4],
          // Second control point
          lastX + data[5],
          lastY + data[6]
          // End point
        );
        lastX += data[5];
        lastY += data[6];
        break;
      case "S":
        lastX = data[3];
        lastY = data[4];
        path2.bezierCurveToShort(
          data[1],
          data[2],
          // Control point
          lastX,
          lastY
          // End point
        );
        break;
      case "s":
        path2.bezierCurveToShort(
          lastX + data[1],
          lastY + data[2],
          // Control point
          lastX + data[3],
          lastY + data[4]
          // End point
        );
        lastX += data[3];
        lastY += data[4];
        break;
      case "Q":
        lastX = data[3];
        lastY = data[4];
        path2.quadraticCurveTo(
          data[1],
          data[2],
          // Control point
          lastX,
          lastY
          // End point
        );
        break;
      case "q":
        path2.quadraticCurveTo(
          lastX + data[1],
          lastY + data[2],
          // Control point
          lastX + data[3],
          lastY + data[4]
          // End point
        );
        lastX += data[3];
        lastY += data[4];
        break;
      case "T":
        lastX = data[1];
        lastY = data[2];
        path2.quadraticCurveToShort(
          lastX,
          lastY
          // End point
        );
        break;
      case "t":
        lastX += data[1];
        lastY += data[2];
        path2.quadraticCurveToShort(
          lastX,
          lastY
          // End point
        );
        break;
      case "A":
        lastX = data[6];
        lastY = data[7];
        path2.arcToSvg(
          data[1],
          // rx
          data[2],
          // ry
          data[3],
          // x-axis-rotation
          data[4],
          // large-arc-flag
          data[5],
          // sweep-flag
          lastX,
          lastY
          // End point
        );
        break;
      case "a":
        lastX += data[6];
        lastY += data[7];
        path2.arcToSvg(
          data[1],
          // rx
          data[2],
          // ry
          data[3],
          // x-axis-rotation
          data[4],
          // large-arc-flag
          data[5],
          // sweep-flag
          lastX,
          lastY
          // End point
        );
        break;
      case "Z":
      case "z":
        path2.closePath();
        if (subpaths.length > 0) {
          currentSubPath = subpaths.pop();
          if (currentSubPath) {
            lastX = currentSubPath.startX;
            lastY = currentSubPath.startY;
          } else {
            lastX = 0;
            lastY = 0;
          }
        }
        currentSubPath = null;
        break;
      default:
        warn(`Unknown SVG path command: ${type}`);
    }
    if (type !== "Z" && type !== "z") {
      if (currentSubPath === null) {
        currentSubPath = { startX: lastX, startY: lastY };
        subpaths.push(currentSubPath);
      }
    }
  }
  return path2;
}
var import_parse_svg_path;
var init_parseSVGPath = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGPath.mjs"() {
    init_define_AnParams();
    import_parse_svg_path = __toESM(require_parse_svg_path(), 1);
    init_warn();
  }
});

// node_modules/pixi.js/lib/maths/shapes/Circle.mjs
var Circle;
var init_Circle = __esm({
  "node_modules/pixi.js/lib/maths/shapes/Circle.mjs"() {
    init_define_AnParams();
    init_Rectangle();
    Circle = class _Circle {
      /**
       * @param x - The X coordinate of the center of this circle
       * @param y - The Y coordinate of the center of this circle
       * @param radius - The radius of the circle
       */
      constructor(x2 = 0, y2 = 0, radius = 0) {
        this.type = "circle";
        this.x = x2;
        this.y = y2;
        this.radius = radius;
      }
      /**
       * Creates a clone of this Circle instance
       * @returns A copy of the Circle
       */
      clone() {
        return new _Circle(this.x, this.y, this.radius);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this circle
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Circle
       */
      contains(x2, y2) {
        if (this.radius <= 0)
          return false;
        const r2 = this.radius * this.radius;
        let dx = this.x - x2;
        let dy = this.y - y2;
        dx *= dx;
        dy *= dy;
        return dx + dy <= r2;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this circle including the stroke.
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @param width - The width of the line to check
       * @param alignment - The alignment of the stroke, 0.5 by default
       * @returns Whether the x/y coordinates are within this Circle
       */
      strokeContains(x2, y2, width, alignment = 0.5) {
        if (this.radius === 0)
          return false;
        const dx = this.x - x2;
        const dy = this.y - y2;
        const radius = this.radius;
        const outerWidth = (1 - alignment) * width;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance <= radius + outerWidth && distance > radius - (width - outerWidth);
      }
      /**
       * Returns the framing rectangle of the circle as a Rectangle object
       * @param out
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 || (out2 = new Rectangle());
        out2.x = this.x - this.radius;
        out2.y = this.y - this.radius;
        out2.width = this.radius * 2;
        out2.height = this.radius * 2;
        return out2;
      }
      /**
       * Copies another circle to this one.
       * @param circle - The circle to copy from.
       * @returns Returns itself.
       */
      copyFrom(circle) {
        this.x = circle.x;
        this.y = circle.y;
        this.radius = circle.radius;
        return this;
      }
      /**
       * Copies this circle to another one.
       * @param circle - The circle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(circle) {
        circle.copyFrom(this);
        return circle;
      }
      toString() {
        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs
var Ellipse;
var init_Ellipse = __esm({
  "node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs"() {
    init_define_AnParams();
    init_Rectangle();
    Ellipse = class _Ellipse {
      /**
       * @param x - The X coordinate of the center of this ellipse
       * @param y - The Y coordinate of the center of this ellipse
       * @param halfWidth - The half width of this ellipse
       * @param halfHeight - The half height of this ellipse
       */
      constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
        this.type = "ellipse";
        this.x = x2;
        this.y = y2;
        this.halfWidth = halfWidth;
        this.halfHeight = halfHeight;
      }
      /**
       * Creates a clone of this Ellipse instance
       * @returns {Ellipse} A copy of the ellipse
       */
      clone() {
        return new _Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this ellipse
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coords are within this ellipse
       */
      contains(x2, y2) {
        if (this.halfWidth <= 0 || this.halfHeight <= 0) {
          return false;
        }
        let normx = (x2 - this.x) / this.halfWidth;
        let normy = (y2 - this.y) / this.halfHeight;
        normx *= normx;
        normy *= normy;
        return normx + normy <= 1;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this ellipse including stroke
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @param strokeWidth - The width of the line to check
       * @param alignment - The alignment of the stroke
       * @returns Whether the x/y coords are within this ellipse
       */
      strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
        const { halfWidth, halfHeight } = this;
        if (halfWidth <= 0 || halfHeight <= 0) {
          return false;
        }
        const strokeOuterWidth = strokeWidth * (1 - alignment);
        const strokeInnerWidth = strokeWidth - strokeOuterWidth;
        const innerHorizontal = halfWidth - strokeInnerWidth;
        const innerVertical = halfHeight - strokeInnerWidth;
        const outerHorizontal = halfWidth + strokeOuterWidth;
        const outerVertical = halfHeight + strokeOuterWidth;
        const normalizedX = x2 - this.x;
        const normalizedY = y2 - this.y;
        const innerEllipse = normalizedX * normalizedX / (innerHorizontal * innerHorizontal) + normalizedY * normalizedY / (innerVertical * innerVertical);
        const outerEllipse = normalizedX * normalizedX / (outerHorizontal * outerHorizontal) + normalizedY * normalizedY / (outerVertical * outerVertical);
        return innerEllipse > 1 && outerEllipse <= 1;
      }
      /**
       * Returns the framing rectangle of the ellipse as a Rectangle object
       * @param out
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 || (out2 = new Rectangle());
        out2.x = this.x - this.halfWidth;
        out2.y = this.y - this.halfHeight;
        out2.width = this.halfWidth * 2;
        out2.height = this.halfHeight * 2;
        return out2;
      }
      /**
       * Copies another ellipse to this one.
       * @param ellipse - The ellipse to copy from.
       * @returns Returns itself.
       */
      copyFrom(ellipse) {
        this.x = ellipse.x;
        this.y = ellipse.y;
        this.halfWidth = ellipse.halfWidth;
        this.halfHeight = ellipse.halfHeight;
        return this;
      }
      /**
       * Copies this ellipse to another one.
       * @param ellipse - The ellipse to copy to.
       * @returns Returns given parameter.
       */
      copyTo(ellipse) {
        ellipse.copyFrom(this);
        return ellipse;
      }
      toString() {
        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs
function squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22) {
  const a2 = x2 - x1;
  const b3 = y2 - y1;
  const c2 = x22 - x1;
  const d2 = y22 - y1;
  const dot = a2 * c2 + b3 * d2;
  const lenSq = c2 * c2 + d2 * d2;
  let param = -1;
  if (lenSq !== 0) {
    param = dot / lenSq;
  }
  let xx;
  let yy;
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x22;
    yy = y22;
  } else {
    xx = x1 + param * c2;
    yy = y1 + param * d2;
  }
  const dx = x2 - xx;
  const dy = y2 - yy;
  return dx * dx + dy * dy;
}
var init_squaredDistanceToLineSegment = __esm({
  "node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/maths/shapes/Polygon.mjs
var tempRect3, tempRect22, Polygon;
var init_Polygon = __esm({
  "node_modules/pixi.js/lib/maths/shapes/Polygon.mjs"() {
    init_define_AnParams();
    init_squaredDistanceToLineSegment();
    init_Rectangle();
    Polygon = class _Polygon {
      /**
       * @param points - This can be an array of Points
       *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
       *  the arguments passed can be all the points of the polygon e.g.
       *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
       *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
       */
      constructor(...points) {
        this.type = "polygon";
        let flat = Array.isArray(points[0]) ? points[0] : points;
        if (typeof flat[0] !== "number") {
          const p2 = [];
          for (let i3 = 0, il = flat.length; i3 < il; i3++) {
            p2.push(flat[i3].x, flat[i3].y);
          }
          flat = p2;
        }
        this.points = flat;
        this.closePath = true;
      }
      /**
       * Determines whether the polygon's points are arranged in a clockwise direction.
       * This is calculated using the "shoelace formula" (also known as surveyor's formula) to find the signed area.
       * A positive area indicates clockwise winding, while negative indicates counter-clockwise.
       *
       * The formula sums up the cross products of adjacent vertices:
       * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)
       * The final sum divided by 2 gives the signed area - positive for clockwise.
       * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise
       */
      isClockwise() {
        let area = 0;
        const points = this.points;
        const length = points.length;
        for (let i3 = 0; i3 < length; i3 += 2) {
          const x1 = points[i3];
          const y1 = points[i3 + 1];
          const x2 = points[(i3 + 2) % length];
          const y2 = points[(i3 + 3) % length];
          area += (x2 - x1) * (y2 + y1);
        }
        return area < 0;
      }
      /**
       * Checks if this polygon completely contains another polygon.
       *
       * This is useful for detecting holes in shapes, like when parsing SVG paths.
       * For example, if you have two polygons:
       * ```ts
       * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square
       * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside
       *
       * outerSquare.containsPolygon(innerSquare); // Returns true
       * innerSquare.containsPolygon(outerSquare); // Returns false
       * ```
       * @param polygon - The polygon to test for containment
       * @returns True if this polygon completely contains the other polygon
       */
      containsPolygon(polygon) {
        const thisBounds = this.getBounds(tempRect3);
        const otherBounds = polygon.getBounds(tempRect22);
        if (!thisBounds.containsRect(otherBounds)) {
          return false;
        }
        const points = polygon.points;
        for (let i3 = 0; i3 < points.length; i3 += 2) {
          const x2 = points[i3];
          const y2 = points[i3 + 1];
          if (!this.contains(x2, y2)) {
            return false;
          }
        }
        return true;
      }
      /**
       * Creates a clone of this polygon.
       * @returns - A copy of the polygon.
       */
      clone() {
        const points = this.points.slice();
        const polygon = new _Polygon(points);
        polygon.closePath = this.closePath;
        return polygon;
      }
      /**
       * Checks whether the x and y coordinates passed to this function are contained within this polygon.
       * @param x - The X coordinate of the point to test.
       * @param y - The Y coordinate of the point to test.
       * @returns - Whether the x/y coordinates are within this polygon.
       */
      contains(x2, y2) {
        let inside = false;
        const length = this.points.length / 2;
        for (let i3 = 0, j2 = length - 1; i3 < length; j2 = i3++) {
          const xi = this.points[i3 * 2];
          const yi = this.points[i3 * 2 + 1];
          const xj = this.points[j2 * 2];
          const yj = this.points[j2 * 2 + 1];
          const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
          if (intersect) {
            inside = !inside;
          }
        }
        return inside;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @param strokeWidth - The width of the line to check
       * @param alignment - The alignment of the stroke, 0.5 by default
       * @returns Whether the x/y coordinates are within this polygon
       */
      strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
        const strokeWidthSquared = strokeWidth * strokeWidth;
        const rightWidthSquared = strokeWidthSquared * (1 - alignment);
        const leftWidthSquared = strokeWidthSquared - rightWidthSquared;
        const { points } = this;
        const iterationLength = points.length - (this.closePath ? 0 : 2);
        for (let i3 = 0; i3 < iterationLength; i3 += 2) {
          const x1 = points[i3];
          const y1 = points[i3 + 1];
          const x22 = points[(i3 + 2) % points.length];
          const y22 = points[(i3 + 3) % points.length];
          const distanceSquared = squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22);
          const sign = Math.sign((x22 - x1) * (y2 - y1) - (y22 - y1) * (x2 - x1));
          if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Returns the framing rectangle of the polygon as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 || (out2 = new Rectangle());
        const points = this.points;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (let i3 = 0, n2 = points.length; i3 < n2; i3 += 2) {
          const x2 = points[i3];
          const y2 = points[i3 + 1];
          minX = x2 < minX ? x2 : minX;
          maxX = x2 > maxX ? x2 : maxX;
          minY = y2 < minY ? y2 : minY;
          maxY = y2 > maxY ? y2 : maxY;
        }
        out2.x = minX;
        out2.width = maxX - minX;
        out2.y = minY;
        out2.height = maxY - minY;
        return out2;
      }
      /**
       * Copies another polygon to this one.
       * @param polygon - The polygon to copy from.
       * @returns Returns itself.
       */
      copyFrom(polygon) {
        this.points = polygon.points.slice();
        this.closePath = polygon.closePath;
        return this;
      }
      /**
       * Copies this polygon to another one.
       * @param polygon - The polygon to copy to.
       * @returns Returns given parameter.
       */
      copyTo(polygon) {
        polygon.copyFrom(this);
        return polygon;
      }
      toString() {
        return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
      }
      /**
       * Get the last X coordinate of the polygon
       * @readonly
       */
      get lastX() {
        return this.points[this.points.length - 2];
      }
      /**
       * Get the last Y coordinate of the polygon
       * @readonly
       */
      get lastY() {
        return this.points[this.points.length - 1];
      }
      /**
       * Get the first X coordinate of the polygon
       * @readonly
       */
      get x() {
        return this.points[this.points.length - 2];
      }
      /**
       * Get the first Y coordinate of the polygon
       * @readonly
       */
      get y() {
        return this.points[this.points.length - 1];
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs
var isCornerWithinStroke, RoundedRectangle;
var init_RoundedRectangle = __esm({
  "node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs"() {
    init_define_AnParams();
    init_Rectangle();
    isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, strokeWidthInner, strokeWidthOuter) => {
      const dx = pX - cornerX;
      const dy = pY - cornerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;
    };
    RoundedRectangle = class _RoundedRectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rounded rectangle
       * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
       * @param width - The overall width of this rounded rectangle
       * @param height - The overall height of this rounded rectangle
       * @param radius - Controls the radius of the rounded corners
       */
      constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
        this.type = "roundedRectangle";
        this.x = x2;
        this.y = y2;
        this.width = width;
        this.height = height;
        this.radius = radius;
      }
      /**
       * Returns the framing rectangle of the rounded rectangle as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 || (out2 = new Rectangle());
        out2.x = this.x;
        out2.y = this.y;
        out2.width = this.width;
        out2.height = this.height;
        return out2;
      }
      /**
       * Creates a clone of this Rounded Rectangle.
       * @returns - A copy of the rounded rectangle.
       */
      clone() {
        return new _RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
      }
      /**
       * Copies another rectangle to this one.
       * @param rectangle - The rectangle to copy from.
       * @returns Returns itself.
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @param rectangle - The rectangle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
       * @param x - The X coordinate of the point to test.
       * @param y - The Y coordinate of the point to test.
       * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
       */
      contains(x2, y2) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x2 >= this.x && x2 <= this.x + this.width) {
          if (y2 >= this.y && y2 <= this.y + this.height) {
            const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
              return true;
            }
            let dx = x2 - (this.x + radius);
            let dy = y2 - (this.y + radius);
            const radius2 = radius * radius;
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x2 - (this.x + this.width - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dy = y2 - (this.y + this.height - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x2 - (this.x + radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
       * @param pX - The X coordinate of the point to test
       * @param pY - The Y coordinate of the point to test
       * @param strokeWidth - The width of the line to check
       * @param alignment - The alignment of the stroke, 0.5 by default
       * @returns Whether the x/y coordinates are within this rectangle
       */
      strokeContains(pX, pY, strokeWidth, alignment = 0.5) {
        const { x: x2, y: y2, width, height, radius } = this;
        const strokeWidthOuter = strokeWidth * (1 - alignment);
        const strokeWidthInner = strokeWidth - strokeWidthOuter;
        const innerX = x2 + radius;
        const innerY = y2 + radius;
        const innerWidth = width - radius * 2;
        const innerHeight = height - radius * 2;
        const rightBound = x2 + width;
        const bottomBound = y2 + height;
        if ((pX >= x2 - strokeWidthOuter && pX <= x2 + strokeWidthInner || pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter) && pY >= innerY && pY <= innerY + innerHeight) {
          return true;
        }
        if ((pY >= y2 - strokeWidthOuter && pY <= y2 + strokeWidthInner || pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter) && pX >= innerX && pX <= innerX + innerWidth) {
          return true;
        }
        return (
          // Top-left
          pX < innerX && pY < innerY && isCornerWithinStroke(
            pX,
            pY,
            innerX,
            innerY,
            radius,
            strokeWidthInner,
            strokeWidthOuter
          ) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(
            pX,
            pY,
            rightBound - radius,
            innerY,
            radius,
            strokeWidthInner,
            strokeWidthOuter
          ) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(
            pX,
            pY,
            rightBound - radius,
            bottomBound - radius,
            radius,
            strokeWidthInner,
            strokeWidthOuter
          ) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(
            pX,
            pY,
            innerX,
            bottomBound - radius,
            radius,
            strokeWidthInner,
            strokeWidthOuter
          )
        );
      }
      toString() {
        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
  );
  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
  return points;
}
function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
  if (level > RECURSION_LIMIT) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x34 = (x3 + x4) / 2;
  const y34 = (y3 + y4) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  const x234 = (x23 + x34) / 2;
  const y234 = (y23 + y34) / 2;
  const x1234 = (x123 + x234) / 2;
  const y1234 = (y123 + y234) / 2;
  if (level > 0) {
    let dx = x4 - x1;
    let dy = y4 - y1;
    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
    let da1;
    let da2;
    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        const a23 = Math.atan2(y3 - y2, x3 - x2);
        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da2 >= pi)
          da2 = 2 * pi - da2;
        if (da1 + da2 < mAngleTolerance) {
          points.push(x1234, y1234);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x2, y2);
            return;
          }
          if (da2 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else if (d2 > FLT_EPSILON) {
      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x2, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x2, y2);
            return;
          }
        }
      }
    } else if (d3 > FLT_EPSILON) {
      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x2, y2);
          points.push(x3, y3);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x3, y3);
            return;
          }
        }
      }
    } else {
      dx = x1234 - (x1 + x4) / 2;
      dy = y1234 - (y1 + y4) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x1234, y1234);
        return;
      }
    }
  }
  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
}
var RECURSION_LIMIT, FLT_EPSILON, PATH_DISTANCE_EPSILON, curveAngleToleranceEpsilon, mAngleTolerance, mCuspLimit;
var init_buildAdaptiveBezier = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"() {
    init_define_AnParams();
    init_GraphicsContextSystem();
    RECURSION_LIMIT = 8;
    FLT_EPSILON = 11920929e-14;
    PATH_DISTANCE_EPSILON = 1;
    curveAngleToleranceEpsilon = 0.01;
    mAngleTolerance = 0;
    mCuspLimit = 0;
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
  );
  let distanceTolerance = (PATH_DISTANCE_EPSILON2 - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
  return points;
}
function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
  recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive2(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
  if (level > RECURSION_LIMIT2) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  let dx = x3 - x1;
  let dy = y3 - y1;
  const d2 = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
  if (d2 > FLT_EPSILON2) {
    if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
      if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
        points.push(x123, y123);
        return;
      }
      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
      if (da >= pi)
        da = 2 * pi - da;
      if (da < mAngleTolerance2) {
        points.push(x123, y123);
        return;
      }
    }
  } else {
    dx = x123 - (x1 + x3) / 2;
    dy = y123 - (y1 + y3) / 2;
    if (dx * dx + dy * dy <= distanceTolerance) {
      points.push(x123, y123);
      return;
    }
  }
  recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
  recursive2(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
}
var RECURSION_LIMIT2, FLT_EPSILON2, PATH_DISTANCE_EPSILON2, curveAngleToleranceEpsilon2, mAngleTolerance2;
var init_buildAdaptiveQuadratic = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"() {
    init_define_AnParams();
    init_GraphicsContextSystem();
    RECURSION_LIMIT2 = 8;
    FLT_EPSILON2 = 11920929e-14;
    PATH_DISTANCE_EPSILON2 = 1;
    curveAngleToleranceEpsilon2 = 0.01;
    mAngleTolerance2 = 0;
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs
function buildArc(points, x2, y2, radius, start, end, clockwise, steps) {
  let dist = Math.abs(start - end);
  if (!clockwise && start > end) {
    dist = 2 * Math.PI - dist;
  } else if (clockwise && end > start) {
    dist = 2 * Math.PI - dist;
  }
  steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI))));
  steps = Math.max(steps, 3);
  let f2 = dist / steps;
  let t2 = start;
  f2 *= clockwise ? -1 : 1;
  for (let i3 = 0; i3 < steps + 1; i3++) {
    const cs = Math.cos(t2);
    const sn = Math.sin(t2);
    const nx = x2 + cs * radius;
    const ny = y2 + sn * radius;
    points.push(nx, ny);
    t2 += f2;
  }
}
var init_buildArc = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
function buildArcTo(points, x1, y1, x2, y2, radius) {
  const fromX = points[points.length - 2];
  const fromY = points[points.length - 1];
  const a1 = fromY - y1;
  const b1 = fromX - x1;
  const a2 = y2 - y1;
  const b22 = x2 - x1;
  const mm = Math.abs(a1 * b22 - b1 * a2);
  if (mm < 1e-8 || radius === 0) {
    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
      points.push(x1, y1);
    }
    return;
  }
  const dd = a1 * a1 + b1 * b1;
  const cc = a2 * a2 + b22 * b22;
  const tt = a1 * a2 + b1 * b22;
  const k1 = radius * Math.sqrt(dd) / mm;
  const k2 = radius * Math.sqrt(cc) / mm;
  const j1 = k1 * tt / dd;
  const j2 = k2 * tt / cc;
  const cx = k1 * b22 + k2 * b1;
  const cy = k1 * a2 + k2 * a1;
  const px = b1 * (k2 + j1);
  const py = a1 * (k2 + j1);
  const qx = b22 * (k1 + j2);
  const qy = a2 * (k1 + j2);
  const startAngle = Math.atan2(py - cy, px - cx);
  const endAngle = Math.atan2(qy - cy, qx - cx);
  buildArc(
    points,
    cx + x1,
    cy + y1,
    radius,
    startAngle,
    endAngle,
    b1 * a2 > b22 * a1
  );
}
var init_buildArcTo = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs"() {
    init_define_AnParams();
    init_buildArc();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
function approxUnitArc(ang1, ang2) {
  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
  const x1 = Math.cos(ang1);
  const y1 = Math.sin(ang1);
  const x2 = Math.cos(ang1 + ang2);
  const y2 = Math.sin(ang1 + ang2);
  return [
    {
      x: x1 - y1 * a2,
      y: y1 + x1 * a2
    },
    {
      x: x2 + y2 * a2,
      y: y2 - x2 * a2
    },
    {
      x: x2,
      y: y2
    }
  ];
}
function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
  if (rx === 0 || ry === 0) {
    return;
  }
  const sinPhi = Math.sin(xAxisRotation * TAU / 360);
  const cosPhi = Math.cos(xAxisRotation * TAU / 360);
  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return;
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  getArcCenter(
    px,
    py,
    cx,
    cy,
    rx,
    ry,
    largeArcFlag,
    sweepFlag,
    sinPhi,
    cosPhi,
    pxp,
    pyp,
    out
  );
  let { ang1, ang2 } = out;
  const { centerX, centerY } = out;
  let ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  const segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  let lastX = points[points.length - 2];
  let lastY = points[points.length - 1];
  const outCurvePoint = { x: 0, y: 0 };
  for (let i3 = 0; i3 < segments; i3++) {
    const curve = approxUnitArc(ang1, ang2);
    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x3, y: y3 } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    buildAdaptiveBezier(
      points,
      lastX,
      lastY,
      x1,
      y1,
      x2,
      y2,
      x3,
      y3
    );
    lastX = x3;
    lastY = y3;
    ang1 += ang2;
  }
}
var TAU, out, mapToEllipse, vectorAngle, getArcCenter;
var init_buildArcToSvg = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs"() {
    init_define_AnParams();
    init_buildAdaptiveBezier();
    TAU = Math.PI * 2;
    out = {
      centerX: 0,
      centerY: 0,
      ang1: 0,
      ang2: 0
    };
    mapToEllipse = ({ x: x2, y: y2 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
      x2 *= rx;
      y2 *= ry;
      const xp = cosPhi * x2 - sinPhi * y2;
      const yp = sinPhi * x2 + cosPhi * y2;
      out2.x = xp + centerX;
      out2.y = yp + centerY;
      return out2;
    };
    vectorAngle = (ux2, uy2, vx2, vy2) => {
      const sign = ux2 * vy2 - uy2 * vx2 < 0 ? -1 : 1;
      let dot = ux2 * vx2 + uy2 * vy2;
      if (dot > 1) {
        dot = 1;
      }
      if (dot < -1) {
        dot = -1;
      }
      return sign * Math.acos(dot);
    };
    getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
      const rxSq = Math.pow(rx, 2);
      const rySq = Math.pow(ry, 2);
      const pxpSq = Math.pow(pxp, 2);
      const pypSq = Math.pow(pyp, 2);
      let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
      if (radicant < 0) {
        radicant = 0;
      }
      radicant /= rxSq * pypSq + rySq * pxpSq;
      radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
      const centerXp = radicant * rx / ry * pyp;
      const centerYp = radicant * -ry / rx * pxp;
      const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
      const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
      const vx1 = (pxp - centerXp) / rx;
      const vy1 = (pyp - centerYp) / ry;
      const vx2 = (-pxp - centerXp) / rx;
      const vy2 = (-pyp - centerYp) / ry;
      const ang1 = vectorAngle(1, 0, vx1, vy1);
      let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
      if (sweepFlag === 0 && ang2 > 0) {
        ang2 -= TAU;
      }
      if (sweepFlag === 1 && ang2 < 0) {
        ang2 += TAU;
      }
      out2.centerX = centerX;
      out2.centerY = centerY;
      out2.ang1 = ang1;
      out2.ang2 = ang2;
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs
function roundedShapeArc(g2, points, radius) {
  const vecFrom = (p2, pp) => {
    const x2 = pp.x - p2.x;
    const y2 = pp.y - p2.y;
    const len = Math.sqrt(x2 * x2 + y2 * y2);
    const nx = x2 / len;
    const ny = y2 / len;
    return { len, nx, ny };
  };
  const sharpCorner = (i3, p2) => {
    if (i3 === 0) {
      g2.moveTo(p2.x, p2.y);
    } else {
      g2.lineTo(p2.x, p2.y);
    }
  };
  let p1 = points[points.length - 1];
  for (let i3 = 0; i3 < points.length; i3++) {
    const p2 = points[i3 % points.length];
    const pRadius = p2.radius ?? radius;
    if (pRadius <= 0) {
      sharpCorner(i3, p2);
      p1 = p2;
      continue;
    }
    const p3 = points[(i3 + 1) % points.length];
    const v1 = vecFrom(p2, p1);
    const v2 = vecFrom(p2, p3);
    if (v1.len < 1e-4 || v2.len < 1e-4) {
      sharpCorner(i3, p2);
      p1 = p2;
      continue;
    }
    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
    let radDirection = 1;
    let drawDirection = false;
    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else if (angle > 0) {
      radDirection = -1;
      drawDirection = true;
    }
    const halfAngle = angle / 2;
    let cRadius;
    let lenOut = Math.abs(
      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)
    );
    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = pRadius;
    }
    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
    if (i3 === 0) {
      g2.moveTo(
        cX + Math.cos(startAngle) * cRadius,
        cY + Math.sin(startAngle) * cRadius
      );
    }
    g2.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
    p1 = p2;
  }
}
function roundedShapeQuadraticCurve(g2, points, radius, smoothness) {
  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
  const pointLerp = (p1, p2, t2) => ({
    x: p1.x + (p2.x - p1.x) * t2,
    y: p1.y + (p2.y - p1.y) * t2
  });
  const numPoints = points.length;
  for (let i3 = 0; i3 < numPoints; i3++) {
    const thisPoint = points[(i3 + 1) % numPoints];
    const pRadius = thisPoint.radius ?? radius;
    if (pRadius <= 0) {
      if (i3 === 0) {
        g2.moveTo(thisPoint.x, thisPoint.y);
      } else {
        g2.lineTo(thisPoint.x, thisPoint.y);
      }
      continue;
    }
    const lastPoint = points[i3];
    const nextPoint = points[(i3 + 2) % numPoints];
    const lastEdgeLength = distance(lastPoint, thisPoint);
    let start;
    if (lastEdgeLength < 1e-4) {
      start = thisPoint;
    } else {
      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
      start = pointLerp(
        thisPoint,
        lastPoint,
        lastOffsetDistance / lastEdgeLength
      );
    }
    const nextEdgeLength = distance(nextPoint, thisPoint);
    let end;
    if (nextEdgeLength < 1e-4) {
      end = thisPoint;
    } else {
      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
      end = pointLerp(
        thisPoint,
        nextPoint,
        nextOffsetDistance / nextEdgeLength
      );
    }
    if (i3 === 0) {
      g2.moveTo(start.x, start.y);
    } else {
      g2.lineTo(start.x, start.y);
    }
    g2.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
  }
}
var init_roundShape = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs
var tempRectangle, ShapePath;
var init_ShapePath = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs"() {
    init_define_AnParams();
    init_Circle();
    init_Ellipse();
    init_Polygon();
    init_Rectangle();
    init_RoundedRectangle();
    init_Bounds();
    init_buildAdaptiveBezier();
    init_buildAdaptiveQuadratic();
    init_buildArc();
    init_buildArcTo();
    init_buildArcToSvg();
    init_roundShape();
    tempRectangle = new Rectangle();
    ShapePath = class {
      constructor(graphicsPath2D) {
        this.shapePrimitives = [];
        this._currentPoly = null;
        this._bounds = new Bounds();
        this._graphicsPath2D = graphicsPath2D;
        this.signed = graphicsPath2D.checkForHoles;
      }
      /**
       * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
       * @param x - The x-coordinate for the starting point.
       * @param y - The y-coordinate for the starting point.
       * @returns The instance of the current object for chaining.
       */
      moveTo(x2, y2) {
        this.startPoly(x2, y2);
        return this;
      }
      /**
       * Connects the current point to a new point with a straight line. This method updates the current path.
       * @param x - The x-coordinate of the new point to connect to.
       * @param y - The y-coordinate of the new point to connect to.
       * @returns The instance of the current object for chaining.
       */
      lineTo(x2, y2) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        const fromX = points[points.length - 2];
        const fromY = points[points.length - 1];
        if (fromX !== x2 || fromY !== y2) {
          points.push(x2, y2);
        }
        return this;
      }
      /**
       * Adds an arc to the path. The arc is centered at (x, y)
       *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
       * @param x - The x-coordinate of the arc's center.
       * @param y - The y-coordinate of the arc's center.
       * @param radius - The radius of the arc.
       * @param startAngle - The starting angle of the arc, in radians.
       * @param endAngle - The ending angle of the arc, in radians.
       * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
       * @returns The instance of the current object for chaining.
       */
      arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
        this._ensurePoly(false);
        const points = this._currentPoly.points;
        buildArc(points, x2, y2, radius, startAngle, endAngle, counterclockwise);
        return this;
      }
      /**
       * Adds an arc to the path with the arc tangent to the line joining two specified points.
       * The arc radius is specified by `radius`.
       * @param x1 - The x-coordinate of the first point.
       * @param y1 - The y-coordinate of the first point.
       * @param x2 - The x-coordinate of the second point.
       * @param y2 - The y-coordinate of the second point.
       * @param radius - The radius of the arc.
       * @returns The instance of the current object for chaining.
       */
      arcTo(x1, y1, x2, y2, radius) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        buildArcTo(points, x1, y1, x2, y2, radius);
        return this;
      }
      /**
       * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
       * @param rx - The x-radius of the ellipse.
       * @param ry - The y-radius of the ellipse.
       * @param xAxisRotation - The rotation of the ellipse's x-axis relative
       * to the x-axis of the coordinate system, in degrees.
       * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
       * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
       * @param x - The x-coordinate of the arc's end point.
       * @param y - The y-coordinate of the arc's end point.
       * @returns The instance of the current object for chaining.
       */
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
        const points = this._currentPoly.points;
        buildArcToSvg(
          points,
          this._currentPoly.lastX,
          this._currentPoly.lastY,
          x2,
          y2,
          rx,
          ry,
          xAxisRotation,
          largeArcFlag,
          sweepFlag
        );
        return this;
      }
      /**
       * Adds a cubic Bezier curve to the path.
       * It requires three points: the first two are control points and the third one is the end point.
       * The starting point is the last point in the current path.
       * @param cp1x - The x-coordinate of the first control point.
       * @param cp1y - The y-coordinate of the first control point.
       * @param cp2x - The x-coordinate of the second control point.
       * @param cp2y - The y-coordinate of the second control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        buildAdaptiveBezier(
          this._currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          cp2x,
          cp2y,
          x2,
          y2,
          smoothness
        );
        return this;
      }
      /**
       * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
       * The starting point is the last point in the current path.
       * @param cp1x - The x-coordinate of the control point.
       * @param cp1y - The y-coordinate of the control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothing - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      quadraticCurveTo(cp1x, cp1y, x2, y2, smoothing) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        buildAdaptiveQuadratic(
          this._currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          x2,
          y2,
          smoothing
        );
        return this;
      }
      /**
       * Closes the current path by drawing a straight line back to the start.
       * If the shape is already closed or there are no points in the path, this method does nothing.
       * @returns The instance of the current object for chaining.
       */
      closePath() {
        this.endPoly(true);
        return this;
      }
      /**
       * Adds another path to the current path. This method allows for the combination of multiple paths into one.
       * @param path - The `GraphicsPath` object representing the path to add.
       * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
       * @returns The instance of the current object for chaining.
       */
      addPath(path2, transform2) {
        this.endPoly();
        if (transform2 && !transform2.isIdentity()) {
          path2 = path2.clone(true);
          path2.transform(transform2);
        }
        const shapePrimitives = this.shapePrimitives;
        const start = shapePrimitives.length;
        for (let i3 = 0; i3 < path2.instructions.length; i3++) {
          const instruction = path2.instructions[i3];
          this[instruction.action](...instruction.data);
        }
        if (path2.checkForHoles && shapePrimitives.length - start > 1) {
          let mainShape = null;
          for (let i3 = start; i3 < shapePrimitives.length; i3++) {
            const shapePrimitive = shapePrimitives[i3];
            if (shapePrimitive.shape.type === "polygon") {
              const polygon = shapePrimitive.shape;
              const mainPolygon = mainShape?.shape;
              if (mainPolygon && mainPolygon.containsPolygon(polygon)) {
                mainShape.holes || (mainShape.holes = []);
                mainShape.holes.push(shapePrimitive);
                shapePrimitives.copyWithin(i3, i3 + 1);
                shapePrimitives.length--;
                i3--;
              } else {
                mainShape = shapePrimitive;
              }
            }
          }
        }
        return this;
      }
      /**
       * Finalizes the drawing of the current path. Optionally, it can close the path.
       * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
       */
      finish(closePath = false) {
        this.endPoly(closePath);
      }
      /**
       * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
       * @returns The instance of the current object for chaining.
       */
      rect(x2, y2, w2, h2, transform2) {
        this.drawShape(new Rectangle(x2, y2, w2, h2), transform2);
        return this;
      }
      /**
       * Draws a circle shape. This method adds a new circle path to the current drawing.
       * @param x - The x-coordinate of the center of the circle.
       * @param y - The y-coordinate of the center of the circle.
       * @param radius - The radius of the circle.
       * @param transform - An optional `Matrix` object to apply a transformation to the circle.
       * @returns The instance of the current object for chaining.
       */
      circle(x2, y2, radius, transform2) {
        this.drawShape(new Circle(x2, y2, radius), transform2);
        return this;
      }
      /**
       * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
       * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
       * representing the x and y coordinates of the polygon's vertices, in sequence.
       * @param close - A boolean indicating whether to close the polygon path. True by default.
       * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
       * @returns The instance of the current object for chaining.
       */
      poly(points, close, transform2) {
        const polygon = new Polygon(points);
        polygon.closePath = close;
        this.drawShape(polygon, transform2);
        return this;
      }
      /**
       * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
       * @param x - The x-coordinate of the center of the polygon.
       * @param y - The y-coordinate of the center of the polygon.
       * @param radius - The radius of the circumscribed circle of the polygon.
       * @param sides - The number of sides of the polygon. Must be 3 or more.
       * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
       * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
       * @returns The instance of the current object for chaining.
       */
      regularPoly(x2, y2, radius, sides, rotation = 0, transform2) {
        sides = Math.max(sides | 0, 3);
        const startAngle = -1 * Math.PI / 2 + rotation;
        const delta = Math.PI * 2 / sides;
        const polygon = [];
        for (let i3 = 0; i3 < sides; i3++) {
          const angle = startAngle - i3 * delta;
          polygon.push(
            x2 + radius * Math.cos(angle),
            y2 + radius * Math.sin(angle)
          );
        }
        this.poly(polygon, true, transform2);
        return this;
      }
      /**
       * Draws a polygon with rounded corners.
       * Similar to `regularPoly` but with the ability to round the corners of the polygon.
       * @param x - The x-coordinate of the center of the polygon.
       * @param y - The y-coordinate of the center of the polygon.
       * @param radius - The radius of the circumscribed circle of the polygon.
       * @param sides - The number of sides of the polygon. Must be 3 or more.
       * @param corner - The radius of the rounding of the corners.
       * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
       * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
       * @returns The instance of the current object for chaining.
       */
      roundPoly(x2, y2, radius, sides, corner, rotation = 0, smoothness) {
        sides = Math.max(sides | 0, 3);
        if (corner <= 0) {
          return this.regularPoly(x2, y2, radius, sides, rotation);
        }
        const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
        corner = Math.min(corner, sideLength);
        const startAngle = -1 * Math.PI / 2 + rotation;
        const delta = Math.PI * 2 / sides;
        const internalAngle = (sides - 2) * Math.PI / sides / 2;
        for (let i3 = 0; i3 < sides; i3++) {
          const angle = i3 * delta + startAngle;
          const x0 = x2 + radius * Math.cos(angle);
          const y0 = y2 + radius * Math.sin(angle);
          const a1 = angle + Math.PI + internalAngle;
          const a2 = angle - Math.PI - internalAngle;
          const x1 = x0 + corner * Math.cos(a1);
          const y1 = y0 + corner * Math.sin(a1);
          const x3 = x0 + corner * Math.cos(a2);
          const y3 = y0 + corner * Math.sin(a2);
          if (i3 === 0) {
            this.moveTo(x1, y1);
          } else {
            this.lineTo(x1, y1);
          }
          this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
        }
        return this.closePath();
      }
      /**
       * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
       * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
       * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
       * A minimum of 3 points is required.
       * @param radius - The default radius for the corners.
       * This radius is applied to all corners unless overridden in `points`.
       * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
       *  method instead of an arc method. Defaults to false.
       * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
       * Higher values make the curve smoother.
       * @returns The instance of the current object for chaining.
       */
      roundShape(points, radius, useQuadratic = false, smoothness) {
        if (points.length < 3) {
          return this;
        }
        if (useQuadratic) {
          roundedShapeQuadraticCurve(this, points, radius, smoothness);
        } else {
          roundedShapeArc(this, points, radius);
        }
        return this.closePath();
      }
      /**
       * Draw Rectangle with fillet corners. This is much like rounded rectangle
       * however it support negative numbers as well for the corner radius.
       * @param x - Upper left corner of rect
       * @param y - Upper right corner of rect
       * @param width - Width of rect
       * @param height - Height of rect
       * @param fillet - accept negative or positive values
       */
      filletRect(x2, y2, width, height, fillet) {
        if (fillet === 0) {
          return this.rect(x2, y2, width, height);
        }
        const maxFillet = Math.min(width, height) / 2;
        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
        const right = x2 + width;
        const bottom = y2 + height;
        const dir = inset < 0 ? -inset : 0;
        const size = Math.abs(inset);
        return this.moveTo(x2, y2 + size).arcTo(x2 + dir, y2 + dir, x2 + size, y2, size).lineTo(right - size, y2).arcTo(right - dir, y2 + dir, right, y2 + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x2 + width - size, bottom, size).lineTo(x2 + size, bottom).arcTo(x2 + dir, bottom - dir, x2, bottom - size, size).closePath();
      }
      /**
       * Draw Rectangle with chamfer corners. These are angled corners.
       * @param x - Upper left corner of rect
       * @param y - Upper right corner of rect
       * @param width - Width of rect
       * @param height - Height of rect
       * @param chamfer - non-zero real number, size of corner cutout
       * @param transform
       */
      chamferRect(x2, y2, width, height, chamfer, transform2) {
        if (chamfer <= 0) {
          return this.rect(x2, y2, width, height);
        }
        const inset = Math.min(chamfer, Math.min(width, height) / 2);
        const right = x2 + width;
        const bottom = y2 + height;
        const points = [
          x2 + inset,
          y2,
          right - inset,
          y2,
          right,
          y2 + inset,
          right,
          bottom - inset,
          right - inset,
          bottom,
          x2 + inset,
          bottom,
          x2,
          bottom - inset,
          x2,
          y2 + inset
        ];
        for (let i3 = points.length - 1; i3 >= 2; i3 -= 2) {
          if (points[i3] === points[i3 - 2] && points[i3 - 1] === points[i3 - 3]) {
            points.splice(i3 - 1, 2);
          }
        }
        return this.poly(points, true, transform2);
      }
      /**
       * Draws an ellipse at the specified location and with the given x and y radii.
       * An optional transformation can be applied, allowing for rotation, scaling, and translation.
       * @param x - The x-coordinate of the center of the ellipse.
       * @param y - The y-coordinate of the center of the ellipse.
       * @param radiusX - The horizontal radius of the ellipse.
       * @param radiusY - The vertical radius of the ellipse.
       * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
       * @returns The instance of the current object for chaining.
       */
      ellipse(x2, y2, radiusX, radiusY, transform2) {
        this.drawShape(new Ellipse(x2, y2, radiusX, radiusY), transform2);
        return this;
      }
      /**
       * Draws a rectangle with rounded corners.
       * The corner radius can be specified to determine how rounded the corners should be.
       * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
       * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
       * @returns The instance of the current object for chaining.
       */
      roundRect(x2, y2, w2, h2, radius, transform2) {
        this.drawShape(new RoundedRectangle(x2, y2, w2, h2, radius), transform2);
        return this;
      }
      /**
       * Draws a given shape on the canvas.
       * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
       * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
       * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
       * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
       * scaling, and translations.
       * @returns The instance of the current object for chaining.
       */
      drawShape(shape, matrix) {
        this.endPoly();
        this.shapePrimitives.push({ shape, transform: matrix });
        return this;
      }
      /**
       * Starts a new polygon path from the specified starting point.
       * This method initializes a new polygon or ends the current one if it exists.
       * @param x - The x-coordinate of the starting point of the new polygon.
       * @param y - The y-coordinate of the starting point of the new polygon.
       * @returns The instance of the current object for chaining.
       */
      startPoly(x2, y2) {
        let currentPoly = this._currentPoly;
        if (currentPoly) {
          this.endPoly();
        }
        currentPoly = new Polygon();
        currentPoly.points.push(x2, y2);
        this._currentPoly = currentPoly;
        return this;
      }
      /**
       * Ends the current polygon path. If `closePath` is set to true,
       * the path is closed by connecting the last point to the first one.
       * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
       * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
       *  back to the starting point. False by default.
       * @returns The instance of the current object for chaining.
       */
      endPoly(closePath = false) {
        const shape = this._currentPoly;
        if (shape && shape.points.length > 2) {
          shape.closePath = closePath;
          this.shapePrimitives.push({ shape });
        }
        this._currentPoly = null;
        return this;
      }
      _ensurePoly(start = true) {
        if (this._currentPoly)
          return;
        this._currentPoly = new Polygon();
        if (start) {
          const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
          if (lastShape) {
            let lx = lastShape.shape.x;
            let ly = lastShape.shape.y;
            if (lastShape.transform && !lastShape.transform.isIdentity()) {
              const t2 = lastShape.transform;
              const tempX = lx;
              lx = t2.a * lx + t2.c * ly + t2.tx;
              ly = t2.b * tempX + t2.d * ly + t2.ty;
            }
            this._currentPoly.points.push(lx, ly);
          } else {
            this._currentPoly.points.push(0, 0);
          }
        }
      }
      /** Builds the path. */
      buildPath() {
        const path2 = this._graphicsPath2D;
        this.shapePrimitives.length = 0;
        this._currentPoly = null;
        for (let i3 = 0; i3 < path2.instructions.length; i3++) {
          const instruction = path2.instructions[i3];
          this[instruction.action](...instruction.data);
        }
        this.finish();
      }
      /** Gets the bounds of the path. */
      get bounds() {
        const bounds = this._bounds;
        bounds.clear();
        const shapePrimitives = this.shapePrimitives;
        for (let i3 = 0; i3 < shapePrimitives.length; i3++) {
          const shapePrimitive = shapePrimitives[i3];
          const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
          if (shapePrimitive.transform) {
            bounds.addRect(boundsRect, shapePrimitive.transform);
          } else {
            bounds.addRect(boundsRect);
          }
        }
        return bounds;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs
function adjustTransform(currentMatrix, transform2) {
  if (currentMatrix) {
    return currentMatrix.prepend(transform2);
  }
  return transform2.clone();
}
var GraphicsPath;
var init_GraphicsPath = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs"() {
    init_define_AnParams();
    init_Point();
    init_uid();
    init_warn();
    init_parseSVGPath();
    init_ShapePath();
    GraphicsPath = class _GraphicsPath {
      /**
       * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
       * @param instructions - An SVG path string or an array of `PathInstruction` objects.
       * @param signed
       */
      constructor(instructions, signed = false) {
        this.instructions = [];
        this.uid = uid("graphicsPath");
        this._dirty = true;
        this.checkForHoles = signed;
        if (typeof instructions === "string") {
          parseSVGPath(instructions, this);
        } else {
          this.instructions = instructions?.slice() ?? [];
        }
      }
      /**
       * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
       * @returns The `ShapePath` instance associated with this `GraphicsPath`.
       */
      get shapePath() {
        if (!this._shapePath) {
          this._shapePath = new ShapePath(this);
        }
        if (this._dirty) {
          this._dirty = false;
          this._shapePath.buildPath();
        }
        return this._shapePath;
      }
      /**
       * Adds another `GraphicsPath` to this path, optionally applying a transformation.
       * @param path - The `GraphicsPath` to add.
       * @param transform - An optional transformation to apply to the added path.
       * @returns The instance of the current object for chaining.
       */
      addPath(path2, transform2) {
        path2 = path2.clone();
        this.instructions.push({ action: "addPath", data: [path2, transform2] });
        this._dirty = true;
        return this;
      }
      arc(...args) {
        this.instructions.push({ action: "arc", data: args });
        this._dirty = true;
        return this;
      }
      arcTo(...args) {
        this.instructions.push({ action: "arcTo", data: args });
        this._dirty = true;
        return this;
      }
      arcToSvg(...args) {
        this.instructions.push({ action: "arcToSvg", data: args });
        this._dirty = true;
        return this;
      }
      bezierCurveTo(...args) {
        this.instructions.push({ action: "bezierCurveTo", data: args });
        this._dirty = true;
        return this;
      }
      /**
       * Adds a cubic Bezier curve to the path.
       * It requires two points: the second control point and the end point. The first control point is assumed to be
       * The starting point is the last point in the current path.
       * @param cp2x - The x-coordinate of the second control point.
       * @param cp2y - The y-coordinate of the second control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      bezierCurveToShort(cp2x, cp2y, x2, y2, smoothness) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this.getLastPoint(Point.shared);
        let cp1x = 0;
        let cp1y = 0;
        if (!last || last.action !== "bezierCurveTo") {
          cp1x = lastPoint.x;
          cp1y = lastPoint.y;
        } else {
          cp1x = last.data[2];
          cp1y = last.data[3];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cp1x = currentX + (currentX - cp1x);
          cp1y = currentY + (currentY - cp1y);
        }
        this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness] });
        this._dirty = true;
        return this;
      }
      /**
       * Closes the current path by drawing a straight line back to the start.
       * If the shape is already closed or there are no points in the path, this method does nothing.
       * @returns The instance of the current object for chaining.
       */
      closePath() {
        this.instructions.push({ action: "closePath", data: [] });
        this._dirty = true;
        return this;
      }
      ellipse(...args) {
        this.instructions.push({ action: "ellipse", data: args });
        this._dirty = true;
        return this;
      }
      lineTo(...args) {
        this.instructions.push({ action: "lineTo", data: args });
        this._dirty = true;
        return this;
      }
      moveTo(...args) {
        this.instructions.push({ action: "moveTo", data: args });
        return this;
      }
      quadraticCurveTo(...args) {
        this.instructions.push({ action: "quadraticCurveTo", data: args });
        this._dirty = true;
        return this;
      }
      /**
       * Adds a quadratic curve to the path. It uses the previous point as the control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      quadraticCurveToShort(x2, y2, smoothness) {
        const last = this.instructions[this.instructions.length - 1];
        const lastPoint = this.getLastPoint(Point.shared);
        let cpx1 = 0;
        let cpy1 = 0;
        if (!last || last.action !== "quadraticCurveTo") {
          cpx1 = lastPoint.x;
          cpy1 = lastPoint.y;
        } else {
          cpx1 = last.data[0];
          cpy1 = last.data[1];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cpx1 = currentX + (currentX - cpx1);
          cpy1 = currentY + (currentY - cpy1);
        }
        this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x2, y2, smoothness] });
        this._dirty = true;
        return this;
      }
      /**
       * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
       * @returns The instance of the current object for chaining.
       */
      rect(x2, y2, w2, h2, transform2) {
        this.instructions.push({ action: "rect", data: [x2, y2, w2, h2, transform2] });
        this._dirty = true;
        return this;
      }
      /**
       * Draws a circle shape. This method adds a new circle path to the current drawing.
       * @param x - The x-coordinate of the center of the circle.
       * @param y - The y-coordinate of the center of the circle.
       * @param radius - The radius of the circle.
       * @param transform - An optional `Matrix` object to apply a transformation to the circle.
       * @returns The instance of the current object for chaining.
       */
      circle(x2, y2, radius, transform2) {
        this.instructions.push({ action: "circle", data: [x2, y2, radius, transform2] });
        this._dirty = true;
        return this;
      }
      roundRect(...args) {
        this.instructions.push({ action: "roundRect", data: args });
        this._dirty = true;
        return this;
      }
      poly(...args) {
        this.instructions.push({ action: "poly", data: args });
        this._dirty = true;
        return this;
      }
      regularPoly(...args) {
        this.instructions.push({ action: "regularPoly", data: args });
        this._dirty = true;
        return this;
      }
      roundPoly(...args) {
        this.instructions.push({ action: "roundPoly", data: args });
        this._dirty = true;
        return this;
      }
      roundShape(...args) {
        this.instructions.push({ action: "roundShape", data: args });
        this._dirty = true;
        return this;
      }
      filletRect(...args) {
        this.instructions.push({ action: "filletRect", data: args });
        this._dirty = true;
        return this;
      }
      chamferRect(...args) {
        this.instructions.push({ action: "chamferRect", data: args });
        this._dirty = true;
        return this;
      }
      /**
       * Draws a star shape centered at a specified location. This method allows for the creation
       *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
       * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
       * An optional transformation can be applied to scale, rotate, or translate the star as needed.
       * @param x - The x-coordinate of the center of the star.
       * @param y - The y-coordinate of the center of the star.
       * @param points - The number of points of the star.
       * @param radius - The outer radius of the star (distance from the center to the outer points).
       * @param innerRadius - Optional. The inner radius of the star
       * (distance from the center to the inner points between the outer points).
       * If not provided, defaults to half of the `radius`.
       * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
       * Defaults to 0, meaning one point is directly upward.
       * @param transform - An optional `Matrix` object to apply a transformation to the star.
       * This can include rotations, scaling, and translations.
       * @returns The instance of the current object for chaining further drawing commands.
       */
      // eslint-disable-next-line max-len
      star(x2, y2, points, radius, innerRadius, rotation, transform2) {
        innerRadius || (innerRadius = radius / 2);
        const startAngle = -1 * Math.PI / 2 + rotation;
        const len = points * 2;
        const delta = Math.PI * 2 / len;
        const polygon = [];
        for (let i3 = 0; i3 < len; i3++) {
          const r2 = i3 % 2 ? innerRadius : radius;
          const angle = i3 * delta + startAngle;
          polygon.push(
            x2 + r2 * Math.cos(angle),
            y2 + r2 * Math.sin(angle)
          );
        }
        this.poly(polygon, true, transform2);
        return this;
      }
      /**
       * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
       * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
       * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
       * do not affect the original `GraphicsPath` and vice versa.
       * @param deep - A boolean flag indicating whether the clone should be deep.
       * @returns A new `GraphicsPath` instance that is a clone of the current instance.
       */
      clone(deep = false) {
        const newGraphicsPath2D = new _GraphicsPath();
        newGraphicsPath2D.checkForHoles = this.checkForHoles;
        if (!deep) {
          newGraphicsPath2D.instructions = this.instructions.slice();
        } else {
          for (let i3 = 0; i3 < this.instructions.length; i3++) {
            const instruction = this.instructions[i3];
            newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
          }
        }
        return newGraphicsPath2D;
      }
      clear() {
        this.instructions.length = 0;
        this._dirty = true;
        return this;
      }
      /**
       * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
       * This method enables the modification of the path's geometry according to the provided
       * transformation matrix, which can include translations, rotations, scaling, and skewing.
       *
       * Each drawing instruction in the path is updated to reflect the transformation,
       * ensuring the visual representation of the path is consistent with the applied matrix.
       *
       * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
       * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
       * allowing for fine-grained control over the path's appearance.
       * @param matrix - A `Matrix` object representing the transformation to apply.
       * @returns The instance of the current object for chaining further operations.
       */
      transform(matrix) {
        if (matrix.isIdentity())
          return this;
        const a2 = matrix.a;
        const b3 = matrix.b;
        const c2 = matrix.c;
        const d2 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let x2 = 0;
        let y2 = 0;
        let cpx1 = 0;
        let cpy1 = 0;
        let cpx2 = 0;
        let cpy2 = 0;
        let rx = 0;
        let ry = 0;
        for (let i3 = 0; i3 < this.instructions.length; i3++) {
          const instruction = this.instructions[i3];
          const data = instruction.data;
          switch (instruction.action) {
            case "moveTo":
            case "lineTo":
              x2 = data[0];
              y2 = data[1];
              data[0] = a2 * x2 + c2 * y2 + tx;
              data[1] = b3 * x2 + d2 * y2 + ty;
              break;
            case "bezierCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              cpx2 = data[2];
              cpy2 = data[3];
              x2 = data[4];
              y2 = data[5];
              data[0] = a2 * cpx1 + c2 * cpy1 + tx;
              data[1] = b3 * cpx1 + d2 * cpy1 + ty;
              data[2] = a2 * cpx2 + c2 * cpy2 + tx;
              data[3] = b3 * cpx2 + d2 * cpy2 + ty;
              data[4] = a2 * x2 + c2 * y2 + tx;
              data[5] = b3 * x2 + d2 * y2 + ty;
              break;
            case "quadraticCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              x2 = data[2];
              y2 = data[3];
              data[0] = a2 * cpx1 + c2 * cpy1 + tx;
              data[1] = b3 * cpx1 + d2 * cpy1 + ty;
              data[2] = a2 * x2 + c2 * y2 + tx;
              data[3] = b3 * x2 + d2 * y2 + ty;
              break;
            case "arcToSvg":
              x2 = data[5];
              y2 = data[6];
              rx = data[0];
              ry = data[1];
              data[0] = a2 * rx + c2 * ry;
              data[1] = b3 * rx + d2 * ry;
              data[5] = a2 * x2 + c2 * y2 + tx;
              data[6] = b3 * x2 + d2 * y2 + ty;
              break;
            case "circle":
              data[4] = adjustTransform(data[3], matrix);
              break;
            case "rect":
              data[4] = adjustTransform(data[4], matrix);
              break;
            case "ellipse":
              data[8] = adjustTransform(data[8], matrix);
              break;
            case "roundRect":
              data[5] = adjustTransform(data[5], matrix);
              break;
            case "addPath":
              data[0].transform(matrix);
              break;
            case "poly":
              data[2] = adjustTransform(data[2], matrix);
              break;
            default:
              warn("unknown transform action", instruction.action);
              break;
          }
        }
        this._dirty = true;
        return this;
      }
      get bounds() {
        return this.shapePath.bounds;
      }
      /**
       * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
       * This method is useful for operations that depend on the path's current endpoint,
       * such as connecting subsequent shapes or paths. It supports various drawing instructions,
       * ensuring the last point's position is accurately determined regardless of the path's complexity.
       *
       * If the last instruction is a `closePath`, the method iterates backward through the instructions
       *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
       * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
       * the last point from the nested path.
       * @param out - A `Point` object where the last point's coordinates will be stored.
       * This object is modified directly to contain the result.
       * @returns The `Point` object containing the last point's coordinates.
       */
      getLastPoint(out2) {
        let index = this.instructions.length - 1;
        let lastInstruction = this.instructions[index];
        if (!lastInstruction) {
          out2.x = 0;
          out2.y = 0;
          return out2;
        }
        while (lastInstruction.action === "closePath") {
          index--;
          if (index < 0) {
            out2.x = 0;
            out2.y = 0;
            return out2;
          }
          lastInstruction = this.instructions[index];
        }
        switch (lastInstruction.action) {
          case "moveTo":
          case "lineTo":
            out2.x = lastInstruction.data[0];
            out2.y = lastInstruction.data[1];
            break;
          case "quadraticCurveTo":
            out2.x = lastInstruction.data[2];
            out2.y = lastInstruction.data[3];
            break;
          case "bezierCurveTo":
            out2.x = lastInstruction.data[4];
            out2.y = lastInstruction.data[5];
            break;
          case "arc":
          case "arcToSvg":
            out2.x = lastInstruction.data[5];
            out2.y = lastInstruction.data[6];
            break;
          case "addPath":
            lastInstruction.data[0].getLastPoint(out2);
            break;
        }
        return out2;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs
function parseSVGFloatAttribute(svg, id, defaultValue2) {
  const value = svg.getAttribute(id);
  return value ? Number(value) : defaultValue2;
}
var init_parseSVGFloatAttribute = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGFloatAttribute.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs
function parseSVGDefinitions(svg, session) {
  const definitions = svg.querySelectorAll("defs");
  for (let i3 = 0; i3 < definitions.length; i3++) {
    const definition = definitions[i3];
    for (let j2 = 0; j2 < definition.children.length; j2++) {
      const child = definition.children[j2];
      switch (child.nodeName.toLowerCase()) {
        case "lineargradient":
          session.defs[child.id] = parseLinearGradient(child);
          break;
        case "radialgradient":
          session.defs[child.id] = parseRadialGradient(child);
          break;
        default:
          break;
      }
    }
  }
}
function parseLinearGradient(child) {
  const x0 = parseSVGFloatAttribute(child, "x1", 0);
  const y0 = parseSVGFloatAttribute(child, "y1", 0);
  const x1 = parseSVGFloatAttribute(child, "x2", 1);
  const y1 = parseSVGFloatAttribute(child, "y2", 0);
  const gradientUnit = child.getAttribute("gradientUnits") || "objectBoundingBox";
  const gradient = new FillGradient(
    x0,
    y0,
    x1,
    y1,
    gradientUnit === "objectBoundingBox" ? "local" : "global"
  );
  for (let k2 = 0; k2 < child.children.length; k2++) {
    const stop = child.children[k2];
    const offset = parseSVGFloatAttribute(stop, "offset", 0);
    const color = Color.shared.setValue(stop.getAttribute("stop-color")).toNumber();
    gradient.addColorStop(offset, color);
  }
  return gradient;
}
function parseRadialGradient(_child) {
  warn("[SVG Parser] Radial gradients are not yet supported");
  return new FillGradient(0, 0, 1, 0);
}
var init_parseSVGDefinitions = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGDefinitions.mjs"() {
    init_define_AnParams();
    init_Color();
    init_warn();
    init_FillGradient();
    init_parseSVGFloatAttribute();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs
function extractSvgUrlId(url) {
  const match = url.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
  return match ? match[1] : "";
}
var init_extractSvgUrlId = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/utils/extractSvgUrlId.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs
function parseSVGStyle(svg, session) {
  const style = svg.getAttribute("style");
  const strokeStyle = {};
  const fillStyle = {};
  const result = {
    strokeStyle,
    fillStyle,
    useFill: false,
    useStroke: false
  };
  for (const key in styleAttributes) {
    const attribute = svg.getAttribute(key);
    if (attribute) {
      parseAttribute(session, result, key, attribute.trim());
    }
  }
  if (style) {
    const styleParts = style.split(";");
    for (let i3 = 0; i3 < styleParts.length; i3++) {
      const stylePart = styleParts[i3].trim();
      const [key, value] = stylePart.split(":");
      if (styleAttributes[key]) {
        parseAttribute(session, result, key, value.trim());
      }
    }
  }
  return {
    strokeStyle: result.useStroke ? strokeStyle : null,
    fillStyle: result.useFill ? fillStyle : null,
    useFill: result.useFill,
    useStroke: result.useStroke
  };
}
function parseAttribute(session, result, id, value) {
  switch (id) {
    case "stroke":
      if (value !== "none") {
        if (value.startsWith("url(")) {
          const id2 = extractSvgUrlId(value);
          result.strokeStyle.fill = session.defs[id2];
        } else {
          result.strokeStyle.color = Color.shared.setValue(value).toNumber();
        }
        result.useStroke = true;
      }
      break;
    case "stroke-width":
      result.strokeStyle.width = Number(value);
      break;
    case "fill":
      if (value !== "none") {
        if (value.startsWith("url(")) {
          const id2 = extractSvgUrlId(value);
          result.fillStyle.fill = session.defs[id2];
        } else {
          result.fillStyle.color = Color.shared.setValue(value).toNumber();
        }
        result.useFill = true;
      }
      break;
    case "fill-opacity":
      result.fillStyle.alpha = Number(value);
      break;
    case "stroke-opacity":
      result.strokeStyle.alpha = Number(value);
      break;
    case "opacity":
      result.fillStyle.alpha = Number(value);
      result.strokeStyle.alpha = Number(value);
      break;
  }
}
var styleAttributes;
var init_parseSVGStyle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/parseSVGStyle.mjs"() {
    init_define_AnParams();
    init_Color();
    init_extractSvgUrlId();
    styleAttributes = {
      // Fill properties
      fill: { type: "paint", default: 0 },
      // Fill color/gradient
      "fill-opacity": { type: "number", default: 1 },
      // Fill transparency
      // Stroke properties
      stroke: { type: "paint", default: 0 },
      // Stroke color/gradient
      "stroke-width": { type: "number", default: 1 },
      // Width of stroke
      "stroke-opacity": { type: "number", default: 1 },
      // Stroke transparency
      "stroke-linecap": { type: "string", default: "butt" },
      // End cap style: butt, round, square
      "stroke-linejoin": { type: "string", default: "miter" },
      // Join style: miter, round, bevel
      "stroke-miterlimit": { type: "number", default: 10 },
      // Limit on miter join sharpness
      "stroke-dasharray": { type: "string", default: "none" },
      // Dash pattern
      "stroke-dashoffset": { type: "number", default: 0 },
      // Offset for dash pattern
      // Global properties
      opacity: { type: "number", default: 1 }
      // Overall opacity
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs
function SVGParser(svg, graphicsContext) {
  if (typeof svg === "string") {
    const div = document.createElement("div");
    div.innerHTML = svg.trim();
    svg = div.querySelector("svg");
  }
  const session = {
    context: graphicsContext,
    defs: {},
    path: new GraphicsPath()
  };
  parseSVGDefinitions(svg, session);
  const children = svg.children;
  const { fillStyle, strokeStyle } = parseSVGStyle(svg, session);
  for (let i3 = 0; i3 < children.length; i3++) {
    const child = children[i3];
    if (child.nodeName.toLowerCase() === "defs")
      continue;
    renderChildren(child, session, fillStyle, strokeStyle);
  }
  return graphicsContext;
}
function renderChildren(svg, session, fillStyle, strokeStyle) {
  const children = svg.children;
  const { fillStyle: f1, strokeStyle: s1 } = parseSVGStyle(svg, session);
  if (f1 && fillStyle) {
    fillStyle = { ...fillStyle, ...f1 };
  } else if (f1) {
    fillStyle = f1;
  }
  if (s1 && strokeStyle) {
    strokeStyle = { ...strokeStyle, ...s1 };
  } else if (s1) {
    strokeStyle = s1;
  }
  const noStyle = !fillStyle && !strokeStyle;
  if (noStyle) {
    fillStyle = { color: 0 };
  }
  let x2;
  let y2;
  let x1;
  let y1;
  let x22;
  let y22;
  let cx;
  let cy;
  let r2;
  let rx;
  let ry;
  let points;
  let pointsString;
  let d2;
  let graphicsPath;
  let width;
  let height;
  switch (svg.nodeName.toLowerCase()) {
    case "path":
      d2 = svg.getAttribute("d");
      if (svg.getAttribute("fill-rule") === "evenodd") {
        warn("SVG Evenodd fill rule not supported, your svg may render incorrectly");
      }
      graphicsPath = new GraphicsPath(d2, true);
      session.context.path(graphicsPath);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "circle":
      cx = parseSVGFloatAttribute(svg, "cx", 0);
      cy = parseSVGFloatAttribute(svg, "cy", 0);
      r2 = parseSVGFloatAttribute(svg, "r", 0);
      session.context.ellipse(cx, cy, r2, r2);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "rect":
      x2 = parseSVGFloatAttribute(svg, "x", 0);
      y2 = parseSVGFloatAttribute(svg, "y", 0);
      width = parseSVGFloatAttribute(svg, "width", 0);
      height = parseSVGFloatAttribute(svg, "height", 0);
      rx = parseSVGFloatAttribute(svg, "rx", 0);
      ry = parseSVGFloatAttribute(svg, "ry", 0);
      if (rx || ry) {
        session.context.roundRect(x2, y2, width, height, rx || ry);
      } else {
        session.context.rect(x2, y2, width, height);
      }
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "ellipse":
      cx = parseSVGFloatAttribute(svg, "cx", 0);
      cy = parseSVGFloatAttribute(svg, "cy", 0);
      rx = parseSVGFloatAttribute(svg, "rx", 0);
      ry = parseSVGFloatAttribute(svg, "ry", 0);
      session.context.beginPath();
      session.context.ellipse(cx, cy, rx, ry);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "line":
      x1 = parseSVGFloatAttribute(svg, "x1", 0);
      y1 = parseSVGFloatAttribute(svg, "y1", 0);
      x22 = parseSVGFloatAttribute(svg, "x2", 0);
      y22 = parseSVGFloatAttribute(svg, "y2", 0);
      session.context.beginPath();
      session.context.moveTo(x1, y1);
      session.context.lineTo(x22, y22);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "polygon":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, true);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "polyline":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, false);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "g":
    case "svg":
      break;
    default: {
      warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);
      break;
    }
  }
  if (noStyle) {
    fillStyle = null;
  }
  for (let i3 = 0; i3 < children.length; i3++) {
    renderChildren(children[i3], session, fillStyle, strokeStyle);
  }
}
var init_SVGParser = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs"() {
    init_define_AnParams();
    init_warn();
    init_GraphicsPath();
    init_parseSVGDefinitions();
    init_parseSVGFloatAttribute();
    init_parseSVGStyle();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
function isColorLike(value) {
  return Color.isColorLike(value);
}
function isFillPattern(value) {
  return value instanceof FillPattern;
}
function isFillGradient(value) {
  return value instanceof FillGradient;
}
function isTexture(value) {
  return value instanceof Texture;
}
function handleColorLike(fill, value, defaultStyle) {
  const temp = Color.shared.setValue(value ?? 0);
  fill.color = temp.toNumber();
  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
  fill.texture = Texture.WHITE;
  return { ...defaultStyle, ...fill };
}
function handleTexture(fill, value, defaultStyle) {
  fill.texture = value;
  return { ...defaultStyle, ...fill };
}
function handleFillPattern(fill, value, defaultStyle) {
  fill.fill = value;
  fill.color = 16777215;
  fill.texture = value.texture;
  fill.matrix = value.transform;
  return { ...defaultStyle, ...fill };
}
function handleFillGradient(fill, value, defaultStyle) {
  value.buildGradient();
  fill.fill = value;
  fill.color = 16777215;
  fill.texture = value.texture;
  fill.matrix = value.transform;
  fill.textureSpace = value.textureSpace;
  return { ...defaultStyle, ...fill };
}
function handleFillObject(value, defaultStyle) {
  const style = { ...defaultStyle, ...value };
  const color = Color.shared.setValue(style.color);
  style.alpha *= color.alpha;
  style.color = color.toNumber();
  return style;
}
function toFillStyle(value, defaultStyle) {
  if (value === void 0 || value === null) {
    return null;
  }
  const fill = {};
  const objectStyle = value;
  if (isColorLike(value)) {
    return handleColorLike(fill, value, defaultStyle);
  } else if (isTexture(value)) {
    return handleTexture(fill, value, defaultStyle);
  } else if (isFillPattern(value)) {
    return handleFillPattern(fill, value, defaultStyle);
  } else if (isFillGradient(value)) {
    return handleFillGradient(fill, value, defaultStyle);
  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
  }
  return handleFillObject(objectStyle, defaultStyle);
}
function toStrokeStyle(value, defaultStyle) {
  const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;
  const fill = toFillStyle(value, rest);
  if (!fill) {
    return null;
  }
  return {
    width,
    alignment,
    miterLimit,
    cap,
    join,
    pixelLine,
    ...fill
  };
}
var init_convertFillInputToFillStyle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs"() {
    init_define_AnParams();
    init_Color();
    init_Texture();
    init_FillGradient();
    init_FillPattern();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs
var tmpPoint, tempMatrix4, _GraphicsContext, GraphicsContext;
var init_GraphicsContext = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs"() {
    init_define_AnParams();
    init_eventemitter3();
    init_Color();
    init_Matrix();
    init_Point();
    init_Texture();
    init_uid();
    init_deprecation();
    init_Bounds();
    init_GraphicsPath();
    init_SVGParser();
    init_convertFillInputToFillStyle();
    tmpPoint = new Point();
    tempMatrix4 = new Matrix();
    _GraphicsContext = class _GraphicsContext2 extends eventemitter3_default {
      constructor() {
        super(...arguments);
        this.uid = uid("graphicsContext");
        this.dirty = true;
        this.batchMode = "auto";
        this.instructions = [];
        this._activePath = new GraphicsPath();
        this._transform = new Matrix();
        this._fillStyle = { ..._GraphicsContext2.defaultFillStyle };
        this._strokeStyle = { ..._GraphicsContext2.defaultStrokeStyle };
        this._stateStack = [];
        this._tick = 0;
        this._bounds = new Bounds();
        this._boundsDirty = true;
      }
      /**
       * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
       * including the current drawing state, transformations, styles, and instructions.
       * @returns A new GraphicsContext instance with the same properties and state as this one.
       */
      clone() {
        const clone = new _GraphicsContext2();
        clone.batchMode = this.batchMode;
        clone.instructions = this.instructions.slice();
        clone._activePath = this._activePath.clone();
        clone._transform = this._transform.clone();
        clone._fillStyle = { ...this._fillStyle };
        clone._strokeStyle = { ...this._strokeStyle };
        clone._stateStack = this._stateStack.slice();
        clone._bounds = this._bounds.clone();
        clone._boundsDirty = true;
        return clone;
      }
      /**
       * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
       */
      get fillStyle() {
        return this._fillStyle;
      }
      set fillStyle(value) {
        this._fillStyle = toFillStyle(value, _GraphicsContext2.defaultFillStyle);
      }
      /**
       * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
       */
      get strokeStyle() {
        return this._strokeStyle;
      }
      set strokeStyle(value) {
        this._strokeStyle = toStrokeStyle(value, _GraphicsContext2.defaultStrokeStyle);
      }
      /**
       * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
       * pattern, or a more complex style defined by a FillStyle object.
       * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
       *                or a FillStyle or ConvertedFillStyle object.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      setFillStyle(style) {
        this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
        return this;
      }
      /**
       * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
       * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
       * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
       *                or a StrokeStyle or ConvertedStrokeStyle object.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      setStrokeStyle(style) {
        this._strokeStyle = toFillStyle(style, _GraphicsContext2.defaultStrokeStyle);
        return this;
      }
      texture(texture, tint, dx, dy, dw, dh) {
        this.instructions.push({
          action: "texture",
          data: {
            image: texture,
            dx: dx || 0,
            dy: dy || 0,
            dw: dw || texture.frame.width,
            dh: dh || texture.frame.height,
            transform: this._transform.clone(),
            alpha: this._fillStyle.alpha,
            style: tint ? Color.shared.setValue(tint).toNumber() : 16777215
          }
        });
        this.onUpdate();
        return this;
      }
      /**
       * Resets the current path. Any previous path and its commands are discarded and a new path is
       * started. This is typically called before beginning a new shape or series of drawing commands.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      beginPath() {
        this._activePath = new GraphicsPath();
        return this;
      }
      fill(style, alpha) {
        let path2;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
          path2 = lastInstruction.data.path;
        } else {
          path2 = this._activePath.clone();
        }
        if (!path2)
          return this;
        if (style != null) {
          if (alpha !== void 0 && typeof style === "number") {
            deprecation(v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
            style = { color: style, alpha };
          }
          this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
        }
        this.instructions.push({
          action: "fill",
          // TODO copy fill style!
          data: { style: this.fillStyle, path: path2 }
        });
        this.onUpdate();
        this._initNextPathLocation();
        this._tick = 0;
        return this;
      }
      _initNextPathLocation() {
        const { x: x2, y: y2 } = this._activePath.getLastPoint(Point.shared);
        this._activePath.clear();
        this._activePath.moveTo(x2, y2);
      }
      /**
       * Strokes the current path with the current stroke style. This method can take an optional
       * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
       * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      stroke(style) {
        let path2;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
          path2 = lastInstruction.data.path;
        } else {
          path2 = this._activePath.clone();
        }
        if (!path2)
          return this;
        if (style != null) {
          this._strokeStyle = toStrokeStyle(style, _GraphicsContext2.defaultStrokeStyle);
        }
        this.instructions.push({
          action: "stroke",
          // TODO copy fill style!
          data: { style: this.strokeStyle, path: path2 }
        });
        this.onUpdate();
        this._initNextPathLocation();
        this._tick = 0;
        return this;
      }
      /**
       * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
       * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
       * fail to cut correctly!
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      cut() {
        for (let i3 = 0; i3 < 2; i3++) {
          const lastInstruction = this.instructions[this.instructions.length - 1 - i3];
          const holePath = this._activePath.clone();
          if (lastInstruction) {
            if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
              if (lastInstruction.data.hole) {
                lastInstruction.data.hole.addPath(holePath);
              } else {
                lastInstruction.data.hole = holePath;
                break;
              }
            }
          }
        }
        this._initNextPathLocation();
        return this;
      }
      /**
       * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
       * starting and ending angles, and direction.
       * @param x - The x-coordinate of the arc's center.
       * @param y - The y-coordinate of the arc's center.
       * @param radius - The arc's radius.
       * @param startAngle - The starting angle, in radians.
       * @param endAngle - The ending angle, in radians.
       * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arc(
          t2.a * x2 + t2.c * y2 + t2.tx,
          t2.b * x2 + t2.d * y2 + t2.ty,
          radius,
          startAngle,
          endAngle,
          counterclockwise
        );
        return this;
      }
      /**
       * Adds an arc to the current path with the given control points and radius, connected to the previous point
       * by a straight line if necessary.
       * @param x1 - The x-coordinate of the first control point.
       * @param y1 - The y-coordinate of the first control point.
       * @param x2 - The x-coordinate of the second control point.
       * @param y2 - The y-coordinate of the second control point.
       * @param radius - The arc's radius.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      arcTo(x1, y1, x2, y2, radius) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arcTo(
          t2.a * x1 + t2.c * y1 + t2.tx,
          t2.b * x1 + t2.d * y1 + t2.ty,
          t2.a * x2 + t2.c * y2 + t2.tx,
          t2.b * x2 + t2.d * y2 + t2.ty,
          radius
        );
        return this;
      }
      /**
       * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
       * @param rx - The x-radius of the ellipse.
       * @param ry - The y-radius of the ellipse.
       * @param xAxisRotation - The rotation of the ellipse's x-axis relative
       * to the x-axis of the coordinate system, in degrees.
       * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
       * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
       * @param x - The x-coordinate of the arc's end point.
       * @param y - The y-coordinate of the arc's end point.
       * @returns The instance of the current object for chaining.
       */
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arcToSvg(
          rx,
          ry,
          xAxisRotation,
          // should we rotate this with transform??
          largeArcFlag,
          sweepFlag,
          t2.a * x2 + t2.c * y2 + t2.tx,
          t2.b * x2 + t2.d * y2 + t2.ty
        );
        return this;
      }
      /**
       * Adds a cubic Bezier curve to the path.
       * It requires three points: the first two are control points and the third one is the end point.
       * The starting point is the last point in the current path.
       * @param cp1x - The x-coordinate of the first control point.
       * @param cp1y - The y-coordinate of the first control point.
       * @param cp2x - The x-coordinate of the second control point.
       * @param cp2y - The y-coordinate of the second control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.bezierCurveTo(
          t2.a * cp1x + t2.c * cp1y + t2.tx,
          t2.b * cp1x + t2.d * cp1y + t2.ty,
          t2.a * cp2x + t2.c * cp2y + t2.tx,
          t2.b * cp2x + t2.d * cp2y + t2.ty,
          t2.a * x2 + t2.c * y2 + t2.tx,
          t2.b * x2 + t2.d * y2 + t2.ty,
          smoothness
        );
        return this;
      }
      /**
       * Closes the current path by drawing a straight line back to the start.
       * If the shape is already closed or there are no points in the path, this method does nothing.
       * @returns The instance of the current object for chaining.
       */
      closePath() {
        this._tick++;
        this._activePath?.closePath();
        return this;
      }
      /**
       * Draws an ellipse at the specified location and with the given x and y radii.
       * An optional transformation can be applied, allowing for rotation, scaling, and translation.
       * @param x - The x-coordinate of the center of the ellipse.
       * @param y - The y-coordinate of the center of the ellipse.
       * @param radiusX - The horizontal radius of the ellipse.
       * @param radiusY - The vertical radius of the ellipse.
       * @returns The instance of the current object for chaining.
       */
      ellipse(x2, y2, radiusX, radiusY) {
        this._tick++;
        this._activePath.ellipse(x2, y2, radiusX, radiusY, this._transform.clone());
        return this;
      }
      /**
       * Draws a circle shape. This method adds a new circle path to the current drawing.
       * @param x - The x-coordinate of the center of the circle.
       * @param y - The y-coordinate of the center of the circle.
       * @param radius - The radius of the circle.
       * @returns The instance of the current object for chaining.
       */
      circle(x2, y2, radius) {
        this._tick++;
        this._activePath.circle(x2, y2, radius, this._transform.clone());
        return this;
      }
      /**
       * Adds another `GraphicsPath` to this path, optionally applying a transformation.
       * @param path - The `GraphicsPath` to add.
       * @returns The instance of the current object for chaining.
       */
      path(path2) {
        this._tick++;
        this._activePath.addPath(path2, this._transform.clone());
        return this;
      }
      /**
       * Connects the current point to a new point with a straight line. This method updates the current path.
       * @param x - The x-coordinate of the new point to connect to.
       * @param y - The y-coordinate of the new point to connect to.
       * @returns The instance of the current object for chaining.
       */
      lineTo(x2, y2) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.lineTo(
          t2.a * x2 + t2.c * y2 + t2.tx,
          t2.b * x2 + t2.d * y2 + t2.ty
        );
        return this;
      }
      /**
       * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
       * @param x - The x-coordinate for the starting point.
       * @param y - The y-coordinate for the starting point.
       * @returns The instance of the current object for chaining.
       */
      moveTo(x2, y2) {
        this._tick++;
        const t2 = this._transform;
        const instructions = this._activePath.instructions;
        const transformedX = t2.a * x2 + t2.c * y2 + t2.tx;
        const transformedY = t2.b * x2 + t2.d * y2 + t2.ty;
        if (instructions.length === 1 && instructions[0].action === "moveTo") {
          instructions[0].data[0] = transformedX;
          instructions[0].data[1] = transformedY;
          return this;
        }
        this._activePath.moveTo(
          transformedX,
          transformedY
        );
        return this;
      }
      /**
       * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
       * The starting point is the last point in the current path.
       * @param cpx - The x-coordinate of the control point.
       * @param cpy - The y-coordinate of the control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      quadraticCurveTo(cpx, cpy, x2, y2, smoothness) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.quadraticCurveTo(
          t2.a * cpx + t2.c * cpy + t2.tx,
          t2.b * cpx + t2.d * cpy + t2.ty,
          t2.a * x2 + t2.c * y2 + t2.tx,
          t2.b * x2 + t2.d * y2 + t2.ty,
          smoothness
        );
        return this;
      }
      /**
       * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @returns The instance of the current object for chaining.
       */
      rect(x2, y2, w2, h2) {
        this._tick++;
        this._activePath.rect(x2, y2, w2, h2, this._transform.clone());
        return this;
      }
      /**
       * Draws a rectangle with rounded corners.
       * The corner radius can be specified to determine how rounded the corners should be.
       * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
       * @returns The instance of the current object for chaining.
       */
      roundRect(x2, y2, w2, h2, radius) {
        this._tick++;
        this._activePath.roundRect(x2, y2, w2, h2, radius, this._transform.clone());
        return this;
      }
      /**
       * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
       * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
       * rotated, or translated as needed.
       * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
       * representing the x and y coordinates, of the polygon's vertices, in sequence.
       * @param close - A boolean indicating whether to close the polygon path. True by default.
       */
      poly(points, close) {
        this._tick++;
        this._activePath.poly(points, close, this._transform.clone());
        return this;
      }
      /**
       * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
       * @param x - The x-coordinate of the center of the polygon.
       * @param y - The y-coordinate of the center of the polygon.
       * @param radius - The radius of the circumscribed circle of the polygon.
       * @param sides - The number of sides of the polygon. Must be 3 or more.
       * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
       * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
       * @returns The instance of the current object for chaining.
       */
      regularPoly(x2, y2, radius, sides, rotation = 0, transform2) {
        this._tick++;
        this._activePath.regularPoly(x2, y2, radius, sides, rotation, transform2);
        return this;
      }
      /**
       * Draws a polygon with rounded corners.
       * Similar to `regularPoly` but with the ability to round the corners of the polygon.
       * @param x - The x-coordinate of the center of the polygon.
       * @param y - The y-coordinate of the center of the polygon.
       * @param radius - The radius of the circumscribed circle of the polygon.
       * @param sides - The number of sides of the polygon. Must be 3 or more.
       * @param corner - The radius of the rounding of the corners.
       * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
       * @returns The instance of the current object for chaining.
       */
      roundPoly(x2, y2, radius, sides, corner, rotation) {
        this._tick++;
        this._activePath.roundPoly(x2, y2, radius, sides, corner, rotation);
        return this;
      }
      /**
       * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
       * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
       * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
       * A minimum of 3 points is required.
       * @param radius - The default radius for the corners.
       * This radius is applied to all corners unless overridden in `points`.
       * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
       *  method instead of an arc method. Defaults to false.
       * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
       * Higher values make the curve smoother.
       * @returns The instance of the current object for chaining.
       */
      roundShape(points, radius, useQuadratic, smoothness) {
        this._tick++;
        this._activePath.roundShape(points, radius, useQuadratic, smoothness);
        return this;
      }
      /**
       * Draw Rectangle with fillet corners. This is much like rounded rectangle
       * however it support negative numbers as well for the corner radius.
       * @param x - Upper left corner of rect
       * @param y - Upper right corner of rect
       * @param width - Width of rect
       * @param height - Height of rect
       * @param fillet - accept negative or positive values
       */
      filletRect(x2, y2, width, height, fillet) {
        this._tick++;
        this._activePath.filletRect(x2, y2, width, height, fillet);
        return this;
      }
      /**
       * Draw Rectangle with chamfer corners. These are angled corners.
       * @param x - Upper left corner of rect
       * @param y - Upper right corner of rect
       * @param width - Width of rect
       * @param height - Height of rect
       * @param chamfer - non-zero real number, size of corner cutout
       * @param transform
       */
      chamferRect(x2, y2, width, height, chamfer, transform2) {
        this._tick++;
        this._activePath.chamferRect(x2, y2, width, height, chamfer, transform2);
        return this;
      }
      /**
       * Draws a star shape centered at a specified location. This method allows for the creation
       *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
       * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
       * An optional transformation can be applied to scale, rotate, or translate the star as needed.
       * @param x - The x-coordinate of the center of the star.
       * @param y - The y-coordinate of the center of the star.
       * @param points - The number of points of the star.
       * @param radius - The outer radius of the star (distance from the center to the outer points).
       * @param innerRadius - Optional. The inner radius of the star
       * (distance from the center to the inner points between the outer points).
       * If not provided, defaults to half of the `radius`.
       * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
       * Defaults to 0, meaning one point is directly upward.
       * @returns The instance of the current object for chaining further drawing commands.
       */
      star(x2, y2, points, radius, innerRadius = 0, rotation = 0) {
        this._tick++;
        this._activePath.star(x2, y2, points, radius, innerRadius, rotation, this._transform.clone());
        return this;
      }
      /**
       * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
       * defined in SVG format to be drawn within the graphics context.
       * @param svg - The SVG string to be parsed and rendered.
       */
      svg(svg) {
        this._tick++;
        SVGParser(svg, this);
        return this;
      }
      /**
       * Restores the most recently saved graphics state by popping the top of the graphics state stack.
       * This includes transformations, fill styles, and stroke styles.
       */
      restore() {
        const state = this._stateStack.pop();
        if (state) {
          this._transform = state.transform;
          this._fillStyle = state.fillStyle;
          this._strokeStyle = state.strokeStyle;
        }
        return this;
      }
      /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
      save() {
        this._stateStack.push({
          transform: this._transform.clone(),
          fillStyle: { ...this._fillStyle },
          strokeStyle: { ...this._strokeStyle }
        });
        return this;
      }
      /**
       * Returns the current transformation matrix of the graphics context.
       * @returns The current transformation matrix.
       */
      getTransform() {
        return this._transform;
      }
      /**
       * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      resetTransform() {
        this._transform.identity();
        return this;
      }
      /**
       * Applies a rotation transformation to the graphics context around the current origin.
       * @param angle - The angle of rotation in radians.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      rotate(angle) {
        this._transform.rotate(angle);
        return this;
      }
      /**
       * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
       * @param x - The scale factor in the horizontal direction.
       * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      scale(x2, y2 = x2) {
        this._transform.scale(x2, y2);
        return this;
      }
      setTransform(a2, b3, c2, d2, dx, dy) {
        if (a2 instanceof Matrix) {
          this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
          return this;
        }
        this._transform.set(a2, b3, c2, d2, dx, dy);
        return this;
      }
      transform(a2, b3, c2, d2, dx, dy) {
        if (a2 instanceof Matrix) {
          this._transform.append(a2);
          return this;
        }
        tempMatrix4.set(a2, b3, c2, d2, dx, dy);
        this._transform.append(tempMatrix4);
        return this;
      }
      /**
       * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
       * @param x - The amount to translate in the horizontal direction.
       * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      translate(x2, y2 = x2) {
        this._transform.translate(x2, y2);
        return this;
      }
      /**
       * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
       * and optionally resetting transformations to the identity matrix.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      clear() {
        this._activePath.clear();
        this.instructions.length = 0;
        this.resetTransform();
        this.onUpdate();
        return this;
      }
      onUpdate() {
        if (this.dirty)
          return;
        this.emit("update", this, 16);
        this.dirty = true;
        this._boundsDirty = true;
      }
      /** The bounds of the graphic shape. */
      get bounds() {
        if (!this._boundsDirty)
          return this._bounds;
        const bounds = this._bounds;
        bounds.clear();
        for (let i3 = 0; i3 < this.instructions.length; i3++) {
          const instruction = this.instructions[i3];
          const action = instruction.action;
          if (action === "fill") {
            const data = instruction.data;
            bounds.addBounds(data.path.bounds);
          } else if (action === "texture") {
            const data = instruction.data;
            bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
          }
          if (action === "stroke") {
            const data = instruction.data;
            const alignment = data.style.alignment;
            const outerPadding = data.style.width * (1 - alignment);
            const _bounds = data.path.bounds;
            bounds.addFrame(
              _bounds.minX - outerPadding,
              _bounds.minY - outerPadding,
              _bounds.maxX + outerPadding,
              _bounds.maxY + outerPadding
            );
          }
        }
        return bounds;
      }
      /**
       * Check to see if a point is contained within this geometry.
       * @param point - Point to check if it's contained.
       * @returns {boolean} `true` if the point is contained within geometry.
       */
      containsPoint(point) {
        if (!this.bounds.containsPoint(point.x, point.y))
          return false;
        const instructions = this.instructions;
        let hasHit = false;
        for (let k2 = 0; k2 < instructions.length; k2++) {
          const instruction = instructions[k2];
          const data = instruction.data;
          const path2 = data.path;
          if (!instruction.action || !path2)
            continue;
          const style = data.style;
          const shapes = path2.shapePath.shapePrimitives;
          for (let i3 = 0; i3 < shapes.length; i3++) {
            const shape = shapes[i3].shape;
            if (!style || !shape)
              continue;
            const transform2 = shapes[i3].transform;
            const transformedPoint = transform2 ? transform2.applyInverse(point, tmpPoint) : point;
            if (instruction.action === "fill") {
              hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
            } else {
              const strokeStyle = style;
              hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);
            }
            const holes = data.hole;
            if (holes) {
              const holeShapes = holes.shapePath?.shapePrimitives;
              if (holeShapes) {
                for (let j2 = 0; j2 < holeShapes.length; j2++) {
                  if (holeShapes[j2].shape.contains(transformedPoint.x, transformedPoint.y)) {
                    hasHit = false;
                  }
                }
              }
            }
            if (hasHit) {
              return true;
            }
          }
        }
        return hasHit;
      }
      /**
       * Destroys the GraphicsData object.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
       * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
       */
      destroy(options = false) {
        this._stateStack.length = 0;
        this._transform = null;
        this.emit("destroy", this);
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          if (this._fillStyle.texture) {
            this._fillStyle.texture.destroy(destroyTextureSource);
          }
          if (this._strokeStyle.texture) {
            this._strokeStyle.texture.destroy(destroyTextureSource);
          }
        }
        this._fillStyle = null;
        this._strokeStyle = null;
        this.instructions = null;
        this._activePath = null;
        this._bounds = null;
        this._stateStack = null;
        this.customShader = null;
        this._transform = null;
      }
    };
    _GraphicsContext.defaultFillStyle = {
      /** The color to use for the fill. */
      color: 16777215,
      /** The alpha value to use for the fill. */
      alpha: 1,
      /** The texture to use for the fill. */
      texture: Texture.WHITE,
      /** The matrix to apply. */
      matrix: null,
      /** The fill pattern to use. */
      fill: null,
      /** Whether coordinates are 'global' or 'local' */
      textureSpace: "local"
    };
    _GraphicsContext.defaultStrokeStyle = {
      /** The width of the stroke. */
      width: 1,
      /** The color to use for the stroke. */
      color: 16777215,
      /** The alpha value to use for the stroke. */
      alpha: 1,
      /** The alignment of the stroke. */
      alignment: 0.5,
      /** The miter limit to use. */
      miterLimit: 10,
      /** The line cap style to use. */
      cap: "butt",
      /** The line join style to use. */
      join: "miter",
      /** The texture to use for the fill. */
      texture: Texture.WHITE,
      /** The matrix to apply. */
      matrix: null,
      /** The fill pattern to use. */
      fill: null,
      /** Whether coordinates are 'global' or 'local' */
      textureSpace: "local",
      /** If the stroke is a pixel line. */
      pixelLine: false
    };
    GraphicsContext = _GraphicsContext;
  }
});

// node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs
function generateTextStyleKey(style) {
  const key = [];
  let index = 0;
  for (let i3 = 0; i3 < valuesToIterateForKeys.length; i3++) {
    const prop = `_${valuesToIterateForKeys[i3]}`;
    key[index++] = style[prop];
  }
  index = addFillStyleKey(style._fill, key, index);
  index = addStokeStyleKey(style._stroke, key, index);
  index = addDropShadowKey(style.dropShadow, key, index);
  return key.join("-");
}
function addFillStyleKey(fillStyle, key, index) {
  if (!fillStyle)
    return index;
  key[index++] = fillStyle.color;
  key[index++] = fillStyle.alpha;
  key[index++] = fillStyle.fill?.styleKey;
  return index;
}
function addStokeStyleKey(strokeStyle, key, index) {
  if (!strokeStyle)
    return index;
  index = addFillStyleKey(strokeStyle, key, index);
  key[index++] = strokeStyle.width;
  key[index++] = strokeStyle.alignment;
  key[index++] = strokeStyle.cap;
  key[index++] = strokeStyle.join;
  key[index++] = strokeStyle.miterLimit;
  return index;
}
function addDropShadowKey(dropShadow, key, index) {
  if (!dropShadow)
    return index;
  key[index++] = dropShadow.alpha;
  key[index++] = dropShadow.angle;
  key[index++] = dropShadow.blur;
  key[index++] = dropShadow.distance;
  key[index++] = Color.shared.setValue(dropShadow.color).toNumber();
  return index;
}
var valuesToIterateForKeys;
var init_generateTextStyleKey = __esm({
  "node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs"() {
    init_define_AnParams();
    init_Color();
    valuesToIterateForKeys = [
      "align",
      "breakWords",
      "cssOverrides",
      "fontVariant",
      "fontWeight",
      "leading",
      "letterSpacing",
      "lineHeight",
      "padding",
      "textBaseline",
      "trim",
      "whiteSpace",
      "wordWrap",
      "wordWrapWidth",
      "fontFamily",
      "fontStyle",
      "fontSize"
    ];
  }
});

// node_modules/pixi.js/lib/scene/text/TextStyle.mjs
function convertV7Tov8Style(style) {
  const oldStyle = style;
  if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {
    const defaults = TextStyle.defaultDropShadow;
    style.dropShadow = {
      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,
      angle: oldStyle.dropShadowAngle ?? defaults.angle,
      blur: oldStyle.dropShadowBlur ?? defaults.blur,
      color: oldStyle.dropShadowColor ?? defaults.color,
      distance: oldStyle.dropShadowDistance ?? defaults.distance
    };
  }
  if (oldStyle.strokeThickness !== void 0) {
    deprecation(v8_0_0, "strokeThickness is now a part of stroke");
    const color = oldStyle.stroke;
    let obj = {};
    if (Color.isColorLike(color)) {
      obj.color = color;
    } else if (color instanceof FillGradient || color instanceof FillPattern) {
      obj.fill = color;
    } else if (Object.hasOwnProperty.call(color, "color") || Object.hasOwnProperty.call(color, "fill")) {
      obj = color;
    } else {
      throw new Error("Invalid stroke value.");
    }
    style.stroke = {
      ...obj,
      width: oldStyle.strokeThickness
    };
  }
  if (Array.isArray(oldStyle.fillGradientStops)) {
    deprecation(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
    let fontSize;
    if (style.fontSize == null) {
      style.fontSize = TextStyle.defaultTextStyle.fontSize;
    } else if (typeof style.fontSize === "string") {
      fontSize = parseInt(style.fontSize, 10);
    } else {
      fontSize = style.fontSize;
    }
    const gradientFill = new FillGradient({
      start: { x: 0, y: 0 },
      end: { x: 0, y: (fontSize || 0) * 1.7 }
    });
    const fills = oldStyle.fillGradientStops.map((color) => Color.shared.setValue(color).toNumber());
    fills.forEach((number, index) => {
      const ratio = index / (fills.length - 1);
      gradientFill.addColorStop(ratio, number);
    });
    style.fill = {
      fill: gradientFill
    };
  }
}
var _TextStyle, TextStyle;
var init_TextStyle = __esm({
  "node_modules/pixi.js/lib/scene/text/TextStyle.mjs"() {
    init_define_AnParams();
    init_eventemitter3();
    init_Color();
    init_deprecation();
    init_FillGradient();
    init_FillPattern();
    init_GraphicsContext();
    init_convertFillInputToFillStyle();
    init_generateTextStyleKey();
    _TextStyle = class _TextStyle2 extends eventemitter3_default {
      constructor(style = {}) {
        super();
        convertV7Tov8Style(style);
        const fullStyle = { ..._TextStyle2.defaultTextStyle, ...style };
        for (const key in fullStyle) {
          const thisKey = key;
          this[thisKey] = fullStyle[key];
        }
        this.update();
      }
      /**
       * Alignment for multiline text, does not affect single line text.
       * @member {'left'|'center'|'right'|'justify'}
       */
      get align() {
        return this._align;
      }
      set align(value) {
        this._align = value;
        this.update();
      }
      /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
      get breakWords() {
        return this._breakWords;
      }
      set breakWords(value) {
        this._breakWords = value;
        this.update();
      }
      /** Set a drop shadow for the text. */
      get dropShadow() {
        return this._dropShadow;
      }
      set dropShadow(value) {
        if (value !== null && typeof value === "object") {
          this._dropShadow = this._createProxy({ ..._TextStyle2.defaultDropShadow, ...value });
        } else {
          this._dropShadow = value ? this._createProxy({ ..._TextStyle2.defaultDropShadow }) : null;
        }
        this.update();
      }
      /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
      get fontFamily() {
        return this._fontFamily;
      }
      set fontFamily(value) {
        this._fontFamily = value;
        this.update();
      }
      /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
      get fontSize() {
        return this._fontSize;
      }
      set fontSize(value) {
        if (typeof value === "string") {
          this._fontSize = parseInt(value, 10);
        } else {
          this._fontSize = value;
        }
        this.update();
      }
      /**
       * The font style.
       * @member {'normal'|'italic'|'oblique'}
       */
      get fontStyle() {
        return this._fontStyle;
      }
      set fontStyle(value) {
        this._fontStyle = value.toLowerCase();
        this.update();
      }
      /**
       * The font variant.
       * @member {'normal'|'small-caps'}
       */
      get fontVariant() {
        return this._fontVariant;
      }
      set fontVariant(value) {
        this._fontVariant = value;
        this.update();
      }
      /**
       * The font weight.
       * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
       */
      get fontWeight() {
        return this._fontWeight;
      }
      set fontWeight(value) {
        this._fontWeight = value;
        this.update();
      }
      /** The space between lines. */
      get leading() {
        return this._leading;
      }
      set leading(value) {
        this._leading = value;
        this.update();
      }
      /** The amount of spacing between letters, default is 0. */
      get letterSpacing() {
        return this._letterSpacing;
      }
      set letterSpacing(value) {
        this._letterSpacing = value;
        this.update();
      }
      /** The line height, a number that represents the vertical space that a letter uses. */
      get lineHeight() {
        return this._lineHeight;
      }
      set lineHeight(value) {
        this._lineHeight = value;
        this.update();
      }
      /**
       * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
       * by adding padding to all sides of the text.
       */
      get padding() {
        return this._padding;
      }
      set padding(value) {
        this._padding = value;
        this.update();
      }
      /** Trim transparent borders. This is an expensive operation so only use this if you have to! */
      get trim() {
        return this._trim;
      }
      set trim(value) {
        this._trim = value;
        this.update();
      }
      /**
       * The baseline of the text that is rendered.
       * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
       */
      get textBaseline() {
        return this._textBaseline;
      }
      set textBaseline(value) {
        this._textBaseline = value;
        this.update();
      }
      /**
       * How newlines and spaces should be handled.
       * Default is 'pre' (preserve, preserve).
       *
       *  value       | New lines     |   Spaces
       *  ---         | ---           |   ---
       * 'normal'     | Collapse      |   Collapse
       * 'pre'        | Preserve      |   Preserve
       * 'pre-line'   | Preserve      |   Collapse
       * @member {'normal'|'pre'|'pre-line'}
       */
      get whiteSpace() {
        return this._whiteSpace;
      }
      set whiteSpace(value) {
        this._whiteSpace = value;
        this.update();
      }
      /** Indicates if word wrap should be used. */
      get wordWrap() {
        return this._wordWrap;
      }
      set wordWrap(value) {
        this._wordWrap = value;
        this.update();
      }
      /** The width at which text will wrap, it needs wordWrap to be set to true. */
      get wordWrapWidth() {
        return this._wordWrapWidth;
      }
      set wordWrapWidth(value) {
        this._wordWrapWidth = value;
        this.update();
      }
      /**
       * The fill style that will be used to color the text.
       * This can be:
       * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'
       * - A hex number like 0xff0000 for red
       * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }
       * - A FillGradient for gradient fills
       * - A FillPattern for pattern/texture fills
       *
       * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,
       * while gradients at any other angle are spread across the entire text body as a whole.
       * @example
       * // Vertical gradient applied per line
       * const verticalGradient = new FillGradient(0, 0, 0, 1)
       *     .addColorStop(0, 0xff0000)
       *     .addColorStop(1, 0x0000ff);
       *
       * const text = new Text({
       *     text: 'Line 1\nLine 2',
       *     style: { fill: verticalGradient }
       * });
       *
       * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.
       * @type {string|number|FillStyle|FillGradient|FillPattern}
       */
      get fill() {
        return this._originalFill;
      }
      set fill(value) {
        if (value === this._originalFill)
          return;
        this._originalFill = value;
        if (this._isFillStyle(value)) {
          this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () => {
            this._fill = toFillStyle(
              { ...this._originalFill },
              GraphicsContext.defaultFillStyle
            );
          });
        }
        this._fill = toFillStyle(
          value === 0 ? "black" : value,
          GraphicsContext.defaultFillStyle
        );
        this.update();
      }
      /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
      get stroke() {
        return this._originalStroke;
      }
      set stroke(value) {
        if (value === this._originalStroke)
          return;
        this._originalStroke = value;
        if (this._isFillStyle(value)) {
          this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () => {
            this._stroke = toStrokeStyle(
              { ...this._originalStroke },
              GraphicsContext.defaultStrokeStyle
            );
          });
        }
        this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);
        this.update();
      }
      _generateKey() {
        this._styleKey = generateTextStyleKey(this);
        return this._styleKey;
      }
      update() {
        this._styleKey = null;
        this.emit("update", this);
      }
      /** Resets all properties to the default values */
      reset() {
        const defaultStyle = _TextStyle2.defaultTextStyle;
        for (const key in defaultStyle) {
          this[key] = defaultStyle[key];
        }
      }
      get styleKey() {
        return this._styleKey || this._generateKey();
      }
      /**
       * Creates a new TextStyle object with the same values as this one.
       * @returns New cloned TextStyle object
       */
      clone() {
        return new _TextStyle2({
          align: this.align,
          breakWords: this.breakWords,
          dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
          fill: this._fill,
          fontFamily: this.fontFamily,
          fontSize: this.fontSize,
          fontStyle: this.fontStyle,
          fontVariant: this.fontVariant,
          fontWeight: this.fontWeight,
          leading: this.leading,
          letterSpacing: this.letterSpacing,
          lineHeight: this.lineHeight,
          padding: this.padding,
          stroke: this._stroke,
          textBaseline: this.textBaseline,
          whiteSpace: this.whiteSpace,
          wordWrap: this.wordWrap,
          wordWrapWidth: this.wordWrapWidth
        });
      }
      /**
       * Destroys this text style.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style
       */
      destroy(options = false) {
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          if (this._fill?.texture) {
            this._fill.texture.destroy(destroyTextureSource);
          }
          if (this._originalFill?.texture) {
            this._originalFill.texture.destroy(destroyTextureSource);
          }
          if (this._stroke?.texture) {
            this._stroke.texture.destroy(destroyTextureSource);
          }
          if (this._originalStroke?.texture) {
            this._originalStroke.texture.destroy(destroyTextureSource);
          }
        }
        this._fill = null;
        this._stroke = null;
        this.dropShadow = null;
        this._originalStroke = null;
        this._originalFill = null;
      }
      _createProxy(value, cb) {
        return new Proxy(value, {
          set: (target, property, newValue) => {
            target[property] = newValue;
            cb?.(property, newValue);
            this.update();
            return true;
          }
        });
      }
      _isFillStyle(value) {
        return (value ?? null) !== null && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern);
      }
    };
    _TextStyle.defaultDropShadow = {
      /** Set alpha for the drop shadow */
      alpha: 1,
      /** Set a angle of the drop shadow */
      angle: Math.PI / 6,
      /** Set a shadow blur radius */
      blur: 0,
      /** A fill style to be used on the  e.g., 'red', '#00FF00' */
      color: "black",
      /** Set a distance of the drop shadow */
      distance: 5
    };
    _TextStyle.defaultTextStyle = {
      /**
       * See {@link TextStyle.align}
       * @type {'left'|'center'|'right'|'justify'}
       */
      align: "left",
      /** See {@link TextStyle.breakWords} */
      breakWords: false,
      /** See {@link TextStyle.dropShadow} */
      dropShadow: null,
      /**
       * See {@link TextStyle.fill}
       * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
       */
      fill: "black",
      /**
       * See {@link TextStyle.fontFamily}
       * @type {string|string[]}
       */
      fontFamily: "Arial",
      /**
       * See {@link TextStyle.fontSize}
       * @type {number|string}
       */
      fontSize: 26,
      /**
       * See {@link TextStyle.fontStyle}
       * @type {'normal'|'italic'|'oblique'}
       */
      fontStyle: "normal",
      /**
       * See {@link TextStyle.fontVariant}
       * @type {'normal'|'small-caps'}
       */
      fontVariant: "normal",
      /**
       * See {@link TextStyle.fontWeight}
       * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
       */
      fontWeight: "normal",
      /** See {@link TextStyle.leading} */
      leading: 0,
      /** See {@link TextStyle.letterSpacing} */
      letterSpacing: 0,
      /** See {@link TextStyle.lineHeight} */
      lineHeight: 0,
      /** See {@link TextStyle.padding} */
      padding: 0,
      /**
       * See {@link TextStyle.stroke}
       * @type {string|number}
       */
      stroke: null,
      /**
       * See {@link TextStyle.textBaseline}
       * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
       */
      textBaseline: "alphabetic",
      /** See {@link TextStyle.trim} */
      trim: false,
      /**
       * See {@link TextStyle.whiteSpace}
       * @type {'normal'|'pre'|'pre-line'}
       */
      whiteSpace: "pre",
      /** See {@link TextStyle.wordWrap} */
      wordWrap: false,
      /** See {@link TextStyle.wordWrapWidth} */
      wordWrapWidth: 100
    };
    TextStyle = _TextStyle;
  }
});

// node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs
function getPo2TextureFromSource(image, width, height, resolution) {
  const bounds = tempBounds2;
  bounds.minX = 0;
  bounds.minY = 0;
  bounds.maxX = image.width / resolution | 0;
  bounds.maxY = image.height / resolution | 0;
  const texture = TexturePool.getOptimalTexture(
    bounds.width,
    bounds.height,
    resolution,
    false
  );
  texture.source.uploadMethodId = "image";
  texture.source.resource = image;
  texture.source.alphaMode = "premultiply-alpha-on-upload";
  texture.frame.width = width / resolution;
  texture.frame.height = height / resolution;
  texture.source.emit("update", texture.source);
  texture.updateUvs();
  return texture;
}
var tempBounds2;
var init_getPo2TextureFromSource = __esm({
  "node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs"() {
    init_define_AnParams();
    init_TexturePool();
    init_Bounds();
    tempBounds2 = new Bounds();
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs
function fontStringFromTextStyle(style) {
  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
  let fontFamilies = style.fontFamily;
  if (!Array.isArray(style.fontFamily)) {
    fontFamilies = style.fontFamily.split(",");
  }
  for (let i3 = fontFamilies.length - 1; i3 >= 0; i3--) {
    let fontFamily = fontFamilies[i3].trim();
    if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
      fontFamily = `"${fontFamily}"`;
    }
    fontFamilies[i3] = fontFamily;
  }
  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
}
var genericFontFamilies;
var init_fontStringFromTextStyle = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"() {
    "use strict";
    init_define_AnParams();
    genericFontFamilies = [
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui"
    ];
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs
var contextSettings, _CanvasTextMetrics, CanvasTextMetrics;
var init_CanvasTextMetrics = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_fontStringFromTextStyle();
    contextSettings = {
      // TextMetrics requires getImageData readback for measuring fonts.
      willReadFrequently: true
    };
    _CanvasTextMetrics = class _CanvasTextMetrics2 {
      /**
       * Checking that we can use modern canvas 2D API.
       *
       * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
       * @see TextMetrics.experimentalLetterSpacing
       * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
       * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
       */
      static get experimentalLetterSpacingSupported() {
        let result = _CanvasTextMetrics2._experimentalLetterSpacingSupported;
        if (result !== void 0) {
          const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;
          result = _CanvasTextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
        }
        return result;
      }
      /**
       * @param text - the text that was measured
       * @param style - the style that was measured
       * @param width - the measured width of the text
       * @param height - the measured height of the text
       * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
       * @param lineWidths - an array of the line widths for each line matched to `lines`
       * @param lineHeight - the measured line height for this style
       * @param maxLineWidth - the maximum line width for all measured lines
       * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
       */
      constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
      }
      /**
       * Measures the supplied string of text and returns a Rectangle.
       * @param text - The text to measure.
       * @param style - The text style to use for measuring
       * @param canvas - optional specification of the canvas to use for measuring.
       * @param wordWrap
       * @returns Measured width and height of the text.
       */
      static measureText(text = " ", style, canvas = _CanvasTextMetrics2._canvas, wordWrap = style.wordWrap) {
        const textKey = `${text}:${style.styleKey}`;
        if (_CanvasTextMetrics2._measurementCache[textKey])
          return _CanvasTextMetrics2._measurementCache[textKey];
        const font = fontStringFromTextStyle(style);
        const fontProperties = _CanvasTextMetrics2.measureFont(font);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = style.fontSize;
          fontProperties.ascent = style.fontSize;
        }
        const context2 = _CanvasTextMetrics2.__context;
        context2.font = font;
        const outputText = wordWrap ? _CanvasTextMetrics2._wordWrap(text, style, canvas) : text;
        const lines = outputText.split(/(?:\r\n|\r|\n)/);
        const lineWidths = new Array(lines.length);
        let maxLineWidth = 0;
        for (let i3 = 0; i3 < lines.length; i3++) {
          const lineWidth = _CanvasTextMetrics2._measureText(lines[i3], style.letterSpacing, context2);
          lineWidths[i3] = lineWidth;
          maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        const strokeWidth = style._stroke?.width || 0;
        let width = maxLineWidth + strokeWidth;
        if (style.dropShadow) {
          width += style.dropShadow.distance;
        }
        const lineHeight = style.lineHeight || fontProperties.fontSize;
        let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);
        if (style.dropShadow) {
          height += style.dropShadow.distance;
        }
        const measurements = new _CanvasTextMetrics2(
          text,
          style,
          width,
          height,
          lines,
          lineWidths,
          lineHeight + style.leading,
          maxLineWidth,
          fontProperties
        );
        return measurements;
      }
      static _measureText(text, letterSpacing, context2) {
        let useExperimentalLetterSpacing = false;
        if (_CanvasTextMetrics2.experimentalLetterSpacingSupported) {
          if (_CanvasTextMetrics2.experimentalLetterSpacing) {
            context2.letterSpacing = `${letterSpacing}px`;
            context2.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            context2.letterSpacing = "0px";
            context2.textLetterSpacing = "0px";
          }
        }
        const metrics = context2.measureText(text);
        let metricWidth = metrics.width;
        const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;
        const actualBoundingBoxRight = metrics.actualBoundingBoxRight;
        let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;
        if (metricWidth > 0) {
          if (useExperimentalLetterSpacing) {
            metricWidth -= letterSpacing;
            boundsWidth -= letterSpacing;
          } else {
            const val = (_CanvasTextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing;
            metricWidth += val;
            boundsWidth += val;
          }
        }
        return Math.max(metricWidth, boundsWidth);
      }
      /**
       * Applies newlines to a string to have it optimally fit into the horizontal
       * bounds set by the Text object's wordWrapWidth property.
       * @param text - String to apply word wrapping to
       * @param style - the style to use when wrapping
       * @param canvas - optional specification of the canvas to use for measuring.
       * @returns New string with new lines applied where required
       */
      static _wordWrap(text, style, canvas = _CanvasTextMetrics2._canvas) {
        const context2 = canvas.getContext("2d", contextSettings);
        let width = 0;
        let line = "";
        let lines = "";
        const cache = /* @__PURE__ */ Object.create(null);
        const { letterSpacing, whiteSpace } = style;
        const collapseSpaces = _CanvasTextMetrics2._collapseSpaces(whiteSpace);
        const collapseNewlines = _CanvasTextMetrics2._collapseNewlines(whiteSpace);
        let canPrependSpaces = !collapseSpaces;
        const wordWrapWidth = style.wordWrapWidth + letterSpacing;
        const tokens = _CanvasTextMetrics2._tokenize(text);
        for (let i3 = 0; i3 < tokens.length; i3++) {
          let token = tokens[i3];
          if (_CanvasTextMetrics2._isNewline(token)) {
            if (!collapseNewlines) {
              lines += _CanvasTextMetrics2._addLine(line);
              canPrependSpaces = !collapseSpaces;
              line = "";
              width = 0;
              continue;
            }
            token = " ";
          }
          if (collapseSpaces) {
            const currIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(token);
            const lastIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(line[line.length - 1]);
            if (currIsBreakingSpace && lastIsBreakingSpace) {
              continue;
            }
          }
          const tokenWidth = _CanvasTextMetrics2._getFromCache(token, letterSpacing, cache, context2);
          if (tokenWidth > wordWrapWidth) {
            if (line !== "") {
              lines += _CanvasTextMetrics2._addLine(line);
              line = "";
              width = 0;
            }
            if (_CanvasTextMetrics2.canBreakWords(token, style.breakWords)) {
              const characters = _CanvasTextMetrics2.wordWrapSplit(token);
              for (let j2 = 0; j2 < characters.length; j2++) {
                let char = characters[j2];
                let lastChar = char;
                let k2 = 1;
                while (characters[j2 + k2]) {
                  const nextChar = characters[j2 + k2];
                  if (!_CanvasTextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                    char += nextChar;
                  } else {
                    break;
                  }
                  lastChar = nextChar;
                  k2++;
                }
                j2 += k2 - 1;
                const characterWidth = _CanvasTextMetrics2._getFromCache(char, letterSpacing, cache, context2);
                if (characterWidth + width > wordWrapWidth) {
                  lines += _CanvasTextMetrics2._addLine(line);
                  canPrependSpaces = false;
                  line = "";
                  width = 0;
                }
                line += char;
                width += characterWidth;
              }
            } else {
              if (line.length > 0) {
                lines += _CanvasTextMetrics2._addLine(line);
                line = "";
                width = 0;
              }
              const isLastToken = i3 === tokens.length - 1;
              lines += _CanvasTextMetrics2._addLine(token, !isLastToken);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
          } else {
            if (tokenWidth + width > wordWrapWidth) {
              canPrependSpaces = false;
              lines += _CanvasTextMetrics2._addLine(line);
              line = "";
              width = 0;
            }
            if (line.length > 0 || !_CanvasTextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
              line += token;
              width += tokenWidth;
            }
          }
        }
        lines += _CanvasTextMetrics2._addLine(line, false);
        return lines;
      }
      /**
       * Convenience function for logging each line added during the wordWrap method.
       * @param line    - The line of text to add
       * @param newLine - Add new line character to end
       * @returns A formatted line
       */
      static _addLine(line, newLine = true) {
        line = _CanvasTextMetrics2._trimRight(line);
        line = newLine ? `${line}
` : line;
        return line;
      }
      /**
       * Gets & sets the widths of calculated characters in a cache object
       * @param key            - The key
       * @param letterSpacing  - The letter spacing
       * @param cache          - The cache
       * @param context        - The canvas context
       * @returns The from cache.
       */
      static _getFromCache(key, letterSpacing, cache, context2) {
        let width = cache[key];
        if (typeof width !== "number") {
          width = _CanvasTextMetrics2._measureText(key, letterSpacing, context2) + letterSpacing;
          cache[key] = width;
        }
        return width;
      }
      /**
       * Determines whether we should collapse breaking spaces.
       * @param whiteSpace - The TextStyle property whiteSpace
       * @returns Should collapse
       */
      static _collapseSpaces(whiteSpace) {
        return whiteSpace === "normal" || whiteSpace === "pre-line";
      }
      /**
       * Determines whether we should collapse newLine chars.
       * @param whiteSpace - The white space
       * @returns should collapse
       */
      static _collapseNewlines(whiteSpace) {
        return whiteSpace === "normal";
      }
      /**
       * Trims breaking whitespaces from string.
       * @param text - The text
       * @returns Trimmed string
       */
      static _trimRight(text) {
        if (typeof text !== "string") {
          return "";
        }
        for (let i3 = text.length - 1; i3 >= 0; i3--) {
          const char = text[i3];
          if (!_CanvasTextMetrics2.isBreakingSpace(char)) {
            break;
          }
          text = text.slice(0, -1);
        }
        return text;
      }
      /**
       * Determines if char is a newline.
       * @param char - The character
       * @returns True if newline, False otherwise.
       */
      static _isNewline(char) {
        if (typeof char !== "string") {
          return false;
        }
        return _CanvasTextMetrics2._newlines.includes(char.charCodeAt(0));
      }
      /**
       * Determines if char is a breaking whitespace.
       *
       * It allows one to determine whether char should be a breaking whitespace
       * For example certain characters in CJK langs or numbers.
       * It must return a boolean.
       * @param char - The character
       * @param [_nextChar] - The next character
       * @returns True if whitespace, False otherwise.
       */
      static isBreakingSpace(char, _nextChar) {
        if (typeof char !== "string") {
          return false;
        }
        return _CanvasTextMetrics2._breakingSpaces.includes(char.charCodeAt(0));
      }
      /**
       * Splits a string into words, breaking-spaces and newLine characters
       * @param text - The text
       * @returns A tokenized array
       */
      static _tokenize(text) {
        const tokens = [];
        let token = "";
        if (typeof text !== "string") {
          return tokens;
        }
        for (let i3 = 0; i3 < text.length; i3++) {
          const char = text[i3];
          const nextChar = text[i3 + 1];
          if (_CanvasTextMetrics2.isBreakingSpace(char, nextChar) || _CanvasTextMetrics2._isNewline(char)) {
            if (token !== "") {
              tokens.push(token);
              token = "";
            }
            tokens.push(char);
            continue;
          }
          token += char;
        }
        if (token !== "") {
          tokens.push(token);
        }
        return tokens;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It allows one to customise which words should break
       * Examples are if the token is CJK or numbers.
       * It must return a boolean.
       * @param _token - The token
       * @param breakWords - The style attr break words
       * @returns Whether to break word or not
       */
      static canBreakWords(_token, breakWords) {
        return breakWords;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It allows one to determine whether a pair of characters
       * should be broken by newlines
       * For example certain characters in CJK langs or numbers.
       * It must return a boolean.
       * @param _char - The character
       * @param _nextChar - The next character
       * @param _token - The token/word the characters are from
       * @param _index - The index in the token of the char
       * @param _breakWords - The style attr break words
       * @returns whether to break word or not
       */
      static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
        return true;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It is called when a token (usually a word) has to be split into separate pieces
       * in order to determine the point to break a word.
       * It must return an array of characters.
       * @param token - The token to split
       * @returns The characters of the token
       * @see CanvasTextMetrics.graphemeSegmenter
       */
      static wordWrapSplit(token) {
        return _CanvasTextMetrics2.graphemeSegmenter(token);
      }
      /**
       * Calculates the ascent, descent and fontSize of a given font-style
       * @param font - String representing the style of the font
       * @returns Font properties object
       */
      static measureFont(font) {
        if (_CanvasTextMetrics2._fonts[font]) {
          return _CanvasTextMetrics2._fonts[font];
        }
        const context2 = _CanvasTextMetrics2._context;
        context2.font = font;
        const metrics = context2.measureText(_CanvasTextMetrics2.METRICS_STRING + _CanvasTextMetrics2.BASELINE_SYMBOL);
        const properties = {
          ascent: metrics.actualBoundingBoxAscent,
          descent: metrics.actualBoundingBoxDescent,
          fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
        };
        _CanvasTextMetrics2._fonts[font] = properties;
        return properties;
      }
      /**
       * Clear font metrics in metrics cache.
       * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
       */
      static clearMetrics(font = "") {
        if (font) {
          delete _CanvasTextMetrics2._fonts[font];
        } else {
          _CanvasTextMetrics2._fonts = {};
        }
      }
      /**
       * Cached canvas element for measuring text
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      static get _canvas() {
        if (!_CanvasTextMetrics2.__canvas) {
          let canvas;
          try {
            const c2 = new OffscreenCanvas(0, 0);
            const context2 = c2.getContext("2d", contextSettings);
            if (context2?.measureText) {
              _CanvasTextMetrics2.__canvas = c2;
              return c2;
            }
            canvas = DOMAdapter.get().createCanvas();
          } catch (_cx) {
            canvas = DOMAdapter.get().createCanvas();
          }
          canvas.width = canvas.height = 10;
          _CanvasTextMetrics2.__canvas = canvas;
        }
        return _CanvasTextMetrics2.__canvas;
      }
      /**
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      static get _context() {
        if (!_CanvasTextMetrics2.__context) {
          _CanvasTextMetrics2.__context = _CanvasTextMetrics2._canvas.getContext("2d", contextSettings);
        }
        return _CanvasTextMetrics2.__context;
      }
    };
    _CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
    _CanvasTextMetrics.BASELINE_SYMBOL = "M";
    _CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
    _CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
    _CanvasTextMetrics.graphemeSegmenter = (() => {
      if (typeof Intl?.Segmenter === "function") {
        const segmenter = new Intl.Segmenter();
        return (s2) => [...segmenter.segment(s2)].map((x2) => x2.segment);
      }
      return (s2) => [...s2];
    })();
    _CanvasTextMetrics.experimentalLetterSpacing = false;
    _CanvasTextMetrics._fonts = {};
    _CanvasTextMetrics._newlines = [
      10,
      // line feed
      13
      // carriage return
    ];
    _CanvasTextMetrics._breakingSpaces = [
      9,
      // character tabulation
      32,
      // space
      8192,
      // en quad
      8193,
      // em quad
      8194,
      // en space
      8195,
      // em space
      8196,
      // three-per-em space
      8197,
      // four-per-em space
      8198,
      // six-per-em space
      8200,
      // punctuation space
      8201,
      // thin space
      8202,
      // hair space
      8287,
      // medium mathematical space
      12288
      // ideographic space
    ];
    _CanvasTextMetrics._measurementCache = {};
    CanvasTextMetrics = _CanvasTextMetrics;
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs
function getCanvasFillStyle(fillStyle, context2, textMetrics, padding = 0) {
  if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
    return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();
  } else if (!fillStyle.fill) {
    const pattern = context2.createPattern(fillStyle.texture.source.resource, "repeat");
    const tempMatrix8 = fillStyle.matrix.copyTo(Matrix.shared);
    tempMatrix8.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);
    pattern.setTransform(tempMatrix8);
    return pattern;
  } else if (fillStyle.fill instanceof FillPattern) {
    const fillPattern = fillStyle.fill;
    const pattern = context2.createPattern(fillPattern.texture.source.resource, "repeat");
    const tempMatrix8 = fillPattern.transform.copyTo(Matrix.shared);
    tempMatrix8.scale(
      fillPattern.texture.frame.width,
      fillPattern.texture.frame.height
    );
    pattern.setTransform(tempMatrix8);
    return pattern;
  } else if (fillStyle.fill instanceof FillGradient) {
    const fillGradient = fillStyle.fill;
    const isLinear = fillGradient.type === "linear";
    const isLocal = fillGradient.textureSpace === "local";
    let width = 1;
    let height = 1;
    if (isLocal && textMetrics) {
      width = textMetrics.width + padding;
      height = textMetrics.height + padding;
    }
    let gradient;
    let isNearlyVertical = false;
    if (isLinear) {
      const { start, end } = fillGradient;
      gradient = context2.createLinearGradient(
        start.x * width,
        start.y * height,
        end.x * width,
        end.y * height
      );
      isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);
    } else {
      const { center, innerRadius, outerCenter, outerRadius } = fillGradient;
      gradient = context2.createRadialGradient(
        center.x * width,
        center.y * height,
        innerRadius * width,
        outerCenter.x * width,
        outerCenter.y * height,
        outerRadius * width
      );
    }
    if (isNearlyVertical && isLocal && textMetrics) {
      const ratio = textMetrics.lineHeight / height;
      for (let i3 = 0; i3 < textMetrics.lines.length; i3++) {
        const start = (i3 * textMetrics.lineHeight + padding / 2) / height;
        fillGradient.colorStops.forEach((stop) => {
          const globalStop = start + stop.offset * ratio;
          gradient.addColorStop(
            // fix to 5 decimal places to avoid floating point precision issues
            Math.floor(globalStop * PRECISION) / PRECISION,
            Color.shared.setValue(stop.color).toHex()
          );
        });
      }
    } else {
      fillGradient.colorStops.forEach((stop) => {
        gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());
      });
    }
    return gradient;
  }
  warn("FillStyle not recognised", fillStyle);
  return "red";
}
var PRECISION;
var init_getCanvasFillStyle = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs"() {
    init_define_AnParams();
    init_Color();
    init_Matrix();
    init_Texture();
    init_warn();
    init_FillGradient();
    init_FillPattern();
    PRECISION = 1e5;
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs
var CanvasTextSystem;
var init_CanvasTextSystem = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs"() {
    init_define_AnParams();
    init_Color();
    init_Extensions();
    init_pow2();
    init_CanvasPool();
    init_TexturePool();
    init_getCanvasBoundingBox();
    init_deprecation();
    init_TextStyle();
    init_getPo2TextureFromSource();
    init_CanvasTextMetrics();
    init_fontStringFromTextStyle();
    init_getCanvasFillStyle();
    CanvasTextSystem = class {
      constructor(_renderer) {
        this._activeTextures = {};
        this._renderer = _renderer;
      }
      getTextureSize(text, resolution, style) {
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        width = Math.ceil(width - 1e-6);
        height = Math.ceil(height - 1e-6);
        width = nextPow2(width);
        height = nextPow2(height);
        return { width, height };
      }
      getTexture(options, resolution, style, _textKey) {
        if (typeof options === "string") {
          deprecation("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");
          options = {
            text: options,
            style,
            resolution
          };
        }
        if (!(options.style instanceof TextStyle)) {
          options.style = new TextStyle(options.style);
        }
        const { texture, canvasAndContext } = this.createTextureAndCanvas(
          options
        );
        this._renderer.texture.initSource(texture._source);
        CanvasPool.returnCanvasAndContext(canvasAndContext);
        return texture;
      }
      createTextureAndCanvas(options) {
        const { text, style } = options;
        const resolution = options.resolution ?? this._renderer.resolution;
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
        const { canvas } = canvasAndContext;
        this.renderTextToCanvas(text, style, resolution, canvasAndContext);
        const texture = getPo2TextureFromSource(canvas, width, height, resolution);
        if (style.trim) {
          const trimmed = getCanvasBoundingBox(canvas, resolution);
          texture.frame.copyFrom(trimmed);
          texture.updateUvs();
        }
        return { texture, canvasAndContext };
      }
      getManagedTexture(text) {
        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
        const textKey = text._getKey();
        if (this._activeTextures[textKey]) {
          this._increaseReferenceCount(textKey);
          return this._activeTextures[textKey].texture;
        }
        const { texture, canvasAndContext } = this.createTextureAndCanvas(text);
        this._activeTextures[textKey] = {
          canvasAndContext,
          texture,
          usageCount: 1
        };
        return texture;
      }
      _increaseReferenceCount(textKey) {
        this._activeTextures[textKey].usageCount++;
      }
      /**
       * Returns a texture that was created wit the above `getTexture` function.
       * Handy if you are done with a texture and want to return it to the pool.
       * @param texture - The texture to be returned.
       */
      returnTexture(texture) {
        const source9 = texture.source;
        source9.resource = null;
        source9.uploadMethodId = "unknown";
        source9.alphaMode = "no-premultiply-alpha";
        TexturePool.returnTexture(texture);
      }
      decreaseReferenceCount(textKey) {
        const activeTexture = this._activeTextures[textKey];
        activeTexture.usageCount--;
        if (activeTexture.usageCount === 0) {
          CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);
          this.returnTexture(activeTexture.texture);
          this._activeTextures[textKey] = null;
        }
      }
      getReferenceCount(textKey) {
        return this._activeTextures[textKey].usageCount;
      }
      /**
       * Renders text to its canvas, and updates its texture.
       *
       * By default this is used internally to ensure the texture is correct before rendering,
       * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,
       * and then shared across multiple Sprites.
       * @param text
       * @param style
       * @param resolution
       * @param canvasAndContext
       */
      renderTextToCanvas(text, style, resolution, canvasAndContext) {
        const { canvas, context: context2 } = canvasAndContext;
        const font = fontStringFromTextStyle(style);
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        const lines = measured.lines;
        const lineHeight = measured.lineHeight;
        const lineWidths = measured.lineWidths;
        const maxLineWidth = measured.maxLineWidth;
        const fontProperties = measured.fontProperties;
        const height = canvas.height;
        context2.resetTransform();
        context2.scale(resolution, resolution);
        context2.textBaseline = style.textBaseline;
        if (style._stroke?.width) {
          const strokeStyle = style._stroke;
          context2.lineWidth = strokeStyle.width;
          context2.miterLimit = strokeStyle.miterLimit;
          context2.lineJoin = strokeStyle.join;
          context2.lineCap = strokeStyle.cap;
        }
        context2.font = font;
        let linePositionX;
        let linePositionY;
        const passesCount = style.dropShadow ? 2 : 1;
        for (let i3 = 0; i3 < passesCount; ++i3) {
          const isShadowPass = style.dropShadow && i3 === 0;
          const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
          const dsOffsetShadow = dsOffsetText * resolution;
          if (isShadowPass) {
            context2.fillStyle = "black";
            context2.strokeStyle = "black";
            const shadowOptions = style.dropShadow;
            const dropShadowColor = shadowOptions.color;
            const dropShadowAlpha = shadowOptions.alpha;
            context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
            const dropShadowBlur = shadowOptions.blur * resolution;
            const dropShadowDistance = shadowOptions.distance * resolution;
            context2.shadowBlur = dropShadowBlur;
            context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
            context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
          } else {
            context2.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context2, measured) : null;
            if (style._stroke?.width) {
              const padding = style._stroke.width * style._stroke.alignment;
              context2.strokeStyle = getCanvasFillStyle(style._stroke, context2, measured, padding);
            }
            context2.shadowColor = "black";
          }
          let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
          if (lineHeight - fontProperties.fontSize < 0) {
            linePositionYShift = 0;
          }
          const strokeWidth = style._stroke?.width ?? 0;
          for (let i22 = 0; i22 < lines.length; i22++) {
            linePositionX = strokeWidth / 2;
            linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
            if (style.align === "right") {
              linePositionX += maxLineWidth - lineWidths[i22];
            } else if (style.align === "center") {
              linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
            }
            if (style._stroke?.width) {
              this._drawLetterSpacing(
                lines[i22],
                style,
                canvasAndContext,
                linePositionX + style.padding,
                linePositionY + style.padding - dsOffsetText,
                true
              );
            }
            if (style._fill !== void 0) {
              this._drawLetterSpacing(
                lines[i22],
                style,
                canvasAndContext,
                linePositionX + style.padding,
                linePositionY + style.padding - dsOffsetText
              );
            }
          }
        }
      }
      /**
       * Render the text with letter-spacing.
       * @param text - The text to draw
       * @param style
       * @param canvasAndContext
       * @param x - Horizontal position to draw the text
       * @param y - Vertical position to draw the text
       * @param isStroke - Is this drawing for the outside stroke of the
       *  text? If not, it's for the inside fill
       */
      _drawLetterSpacing(text, style, canvasAndContext, x2, y2, isStroke = false) {
        const { context: context2 } = canvasAndContext;
        const letterSpacing = style.letterSpacing;
        let useExperimentalLetterSpacing = false;
        if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
          if (CanvasTextMetrics.experimentalLetterSpacing) {
            context2.letterSpacing = `${letterSpacing}px`;
            context2.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            context2.letterSpacing = "0px";
            context2.textLetterSpacing = "0px";
          }
        }
        if (letterSpacing === 0 || useExperimentalLetterSpacing) {
          if (isStroke) {
            context2.strokeText(text, x2, y2);
          } else {
            context2.fillText(text, x2, y2);
          }
          return;
        }
        let currentPosition = x2;
        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);
        let previousWidth = context2.measureText(text).width;
        let currentWidth = 0;
        for (let i3 = 0; i3 < stringArray.length; ++i3) {
          const currentChar = stringArray[i3];
          if (isStroke) {
            context2.strokeText(currentChar, currentPosition, y2);
          } else {
            context2.fillText(currentChar, currentPosition, y2);
          }
          let textStr = "";
          for (let j2 = i3 + 1; j2 < stringArray.length; ++j2) {
            textStr += stringArray[j2];
          }
          currentWidth = context2.measureText(textStr).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
      }
      destroy() {
        this._activeTextures = null;
      }
    };
    CanvasTextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "canvasText"
    };
  }
});

// node_modules/pixi.js/lib/scene/text/init.mjs
var init_init10 = __esm({
  "node_modules/pixi.js/lib/scene/text/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_CanvasTextPipe();
    init_CanvasTextSystem();
    extensions.add(CanvasTextSystem);
    extensions.add(CanvasTextPipe);
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs
var Graphics;
var init_Graphics = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs"() {
    init_define_AnParams();
    init_deprecation();
    init_ViewContainer();
    init_GraphicsContext();
    Graphics = class _Graphics extends ViewContainer {
      /**
       * @param options - Options for the Graphics.
       */
      constructor(options) {
        if (options instanceof GraphicsContext) {
          options = { context: options };
        }
        const { context: context2, roundPixels, ...rest } = options || {};
        super({
          label: "Graphics",
          ...rest
        });
        this.renderPipeId = "graphics";
        if (!context2) {
          this._context = this._ownedContext = new GraphicsContext();
        } else {
          this._context = context2;
        }
        this._context.on("update", this.onViewUpdate, this);
        this.allowChildren = false;
        this.roundPixels = roundPixels ?? false;
      }
      set context(context2) {
        if (context2 === this._context)
          return;
        this._context.off("update", this.onViewUpdate, this);
        this._context = context2;
        this._context.on("update", this.onViewUpdate, this);
        this.onViewUpdate();
      }
      get context() {
        return this._context;
      }
      /**
       * The local bounds of the graphic.
       * @type {rendering.Bounds}
       */
      get bounds() {
        return this._context.bounds;
      }
      /**
       * Graphics objects do not need to update their bounds as the context handles this.
       * @private
       */
      updateBounds() {
      }
      /**
       * Checks if the object contains the given point.
       * @param point - The point to check
       */
      containsPoint(point) {
        return this._context.containsPoint(point);
      }
      /**
       * Destroys this graphics renderable and optionally its context.
       * @param options - Options parameter. A boolean will act as if all options
       *
       * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
       * then the context will still be destroyed.
       *
       * If you want to explicitly not destroy this context that this graphics created,
       * then you should pass destroy({ context: false })
       *
       * If the context was passed in as an argument to the constructor then it will not be destroyed
       * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context
       * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context
       * @param {boolean} [options.context=false] - Should destroy the context
       */
      destroy(options) {
        if (this._ownedContext && !options) {
          this._ownedContext.destroy(options);
        } else if (options === true || options?.context === true) {
          this._context.destroy(options);
        }
        this._ownedContext = null;
        this._context = null;
        super.destroy(options);
      }
      _callContextMethod(method, args) {
        this.context[method](...args);
        return this;
      }
      // --------------------------------------- GraphicsContext methods ---------------------------------------
      /**
       * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
       * pattern, or a more complex style defined by a FillStyle object.
       * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or
       * pattern object, or a FillStyle or ConvertedFillStyle object.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      setFillStyle(...args) {
        return this._callContextMethod("setFillStyle", args);
      }
      /**
       * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
       * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
       * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,
       * or a StrokeStyle or ConvertedStrokeStyle object.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      setStrokeStyle(...args) {
        return this._callContextMethod("setStrokeStyle", args);
      }
      fill(...args) {
        return this._callContextMethod("fill", args);
      }
      /**
       * Strokes the current path with the current stroke style. This method can take an optional
       * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.
       * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more
       * complex style object. If omitted, uses the current stroke style.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      stroke(...args) {
        return this._callContextMethod("stroke", args);
      }
      texture(...args) {
        return this._callContextMethod("texture", args);
      }
      /**
       * Resets the current path. Any previous path and its commands are discarded and a new path is
       * started. This is typically called before beginning a new shape or series of drawing commands.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      beginPath() {
        return this._callContextMethod("beginPath", []);
      }
      /**
       * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
       * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
       * fail to cut correctly!
       */
      cut() {
        return this._callContextMethod("cut", []);
      }
      arc(...args) {
        return this._callContextMethod("arc", args);
      }
      arcTo(...args) {
        return this._callContextMethod("arcTo", args);
      }
      arcToSvg(...args) {
        return this._callContextMethod("arcToSvg", args);
      }
      bezierCurveTo(...args) {
        return this._callContextMethod("bezierCurveTo", args);
      }
      /**
       * Closes the current path by drawing a straight line back to the start.
       * If the shape is already closed or there are no points in the path, this method does nothing.
       * @returns The instance of the current object for chaining.
       */
      closePath() {
        return this._callContextMethod("closePath", []);
      }
      ellipse(...args) {
        return this._callContextMethod("ellipse", args);
      }
      circle(...args) {
        return this._callContextMethod("circle", args);
      }
      path(...args) {
        return this._callContextMethod("path", args);
      }
      lineTo(...args) {
        return this._callContextMethod("lineTo", args);
      }
      moveTo(...args) {
        return this._callContextMethod("moveTo", args);
      }
      quadraticCurveTo(...args) {
        return this._callContextMethod("quadraticCurveTo", args);
      }
      rect(...args) {
        return this._callContextMethod("rect", args);
      }
      roundRect(...args) {
        return this._callContextMethod("roundRect", args);
      }
      poly(...args) {
        return this._callContextMethod("poly", args);
      }
      regularPoly(...args) {
        return this._callContextMethod("regularPoly", args);
      }
      roundPoly(...args) {
        return this._callContextMethod("roundPoly", args);
      }
      roundShape(...args) {
        return this._callContextMethod("roundShape", args);
      }
      filletRect(...args) {
        return this._callContextMethod("filletRect", args);
      }
      chamferRect(...args) {
        return this._callContextMethod("chamferRect", args);
      }
      star(...args) {
        return this._callContextMethod("star", args);
      }
      svg(...args) {
        return this._callContextMethod("svg", args);
      }
      restore(...args) {
        return this._callContextMethod("restore", args);
      }
      /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
      save() {
        return this._callContextMethod("save", []);
      }
      /**
       * Returns the current transformation matrix of the graphics context.
       * @returns The current transformation matrix.
       */
      getTransform() {
        return this.context.getTransform();
      }
      /**
       * Resets the current transformation matrix to the identity matrix, effectively removing
       * any transformations (rotation, scaling, translation) previously applied.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      resetTransform() {
        return this._callContextMethod("resetTransform", []);
      }
      rotateTransform(...args) {
        return this._callContextMethod("rotate", args);
      }
      scaleTransform(...args) {
        return this._callContextMethod("scale", args);
      }
      setTransform(...args) {
        return this._callContextMethod("setTransform", args);
      }
      transform(...args) {
        return this._callContextMethod("transform", args);
      }
      translateTransform(...args) {
        return this._callContextMethod("translate", args);
      }
      /**
       * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
       * and optionally resetting transformations to the identity matrix.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      clear() {
        return this._callContextMethod("clear", []);
      }
      /**
       * The fill style to use.
       * @type {ConvertedFillStyle}
       */
      get fillStyle() {
        return this._context.fillStyle;
      }
      set fillStyle(value) {
        this._context.fillStyle = value;
      }
      /**
       * The stroke style to use.
       * @type {ConvertedStrokeStyle}
       */
      get strokeStyle() {
        return this._context.strokeStyle;
      }
      set strokeStyle(value) {
        this._context.strokeStyle = value;
      }
      /**
       * Creates a new Graphics object.
       * Note that only the context of the object is cloned, not its transform (position,scale,etc)
       * @param deep - Whether to create a deep clone of the graphics object. If false, the context
       * will be shared between the two objects (default false). If true, the context will be
       * cloned (recommended if you need to modify the context in any way).
       * @returns - A clone of the graphics object
       */
      clone(deep = false) {
        if (deep) {
          return new _Graphics(this._context.clone());
        }
        this._ownedContext = null;
        const clone = new _Graphics(this._context);
        return clone;
      }
      // -------- v7 deprecations ---------
      /**
       * @param width
       * @param color
       * @param alpha
       * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
       */
      lineStyle(width, color, alpha) {
        deprecation(v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
        const strokeStyle = {};
        width && (strokeStyle.width = width);
        color && (strokeStyle.color = color);
        alpha && (strokeStyle.alpha = alpha);
        this.context.strokeStyle = strokeStyle;
        return this;
      }
      /**
       * @param color
       * @param alpha
       * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
       */
      beginFill(color, alpha) {
        deprecation(v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
        const fillStyle = {};
        if (color !== void 0)
          fillStyle.color = color;
        if (alpha !== void 0)
          fillStyle.alpha = alpha;
        this.context.fillStyle = fillStyle;
        return this;
      }
      /**
       * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
       */
      endFill() {
        deprecation(v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
        this.context.fill();
        const strokeStyle = this.context.strokeStyle;
        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {
          this.context.stroke();
        }
        return this;
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
       */
      drawCircle(...args) {
        deprecation(v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
        return this._callContextMethod("circle", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
       */
      drawEllipse(...args) {
        deprecation(v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
        return this._callContextMethod("ellipse", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
       */
      drawPolygon(...args) {
        deprecation(v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
        return this._callContextMethod("poly", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
       */
      drawRect(...args) {
        deprecation(v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
        return this._callContextMethod("rect", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
       */
      drawRoundedRect(...args) {
        deprecation(v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
        return this._callContextMethod("roundRect", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#star} instead
       */
      drawStar(...args) {
        deprecation(v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
        return this._callContextMethod("star", args);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs
var localUniformMSDFBit, localUniformMSDFBitGl;
var init_localUniformMSDFBit = __esm({
  "node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs"() {
    "use strict";
    init_define_AnParams();
    localUniformMSDFBit = {
      name: "local-uniform-msdf-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
        ),
        end: (
          /* wgsl */
          `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        )
      },
      fragment: {
        header: (
          /* wgsl */
          `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `
        ),
        main: (
          /* wgsl */
          ` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
        )
      }
    };
    localUniformMSDFBitGl = {
      name: "local-uniform-msdf-bit",
      vertex: {
        header: (
          /* glsl */
          `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
        ),
        main: (
          /* glsl */
          `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `
        ),
        end: (
          /* glsl */
          `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        )
      },
      fragment: {
        header: (
          /* glsl */
          `
            uniform float uDistance;
         `
        ),
        main: (
          /* glsl */
          ` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs
var mSDFBit, mSDFBitGl;
var init_mSDFBit = __esm({
  "node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs"() {
    "use strict";
    init_define_AnParams();
    mSDFBit = {
      name: "msdf-bit",
      fragment: {
        header: (
          /* wgsl */
          `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `
        )
      }
    };
    mSDFBitGl = {
      name: "msdf-bit",
      fragment: {
        header: (
          /* glsl */
          `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs
var gpuProgram, glProgram, SdfShader;
var init_SdfShader = __esm({
  "node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_maxRecommendedTextures();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_roundPixelsBit();
    init_getBatchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    init_localUniformMSDFBit();
    init_mSDFBit();
    SdfShader = class extends Shader {
      constructor() {
        const uniforms = new UniformGroup({
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uDistance: { value: 4, type: "f32" },
          uRound: { value: 0, type: "f32" }
        });
        const maxTextures2 = getMaxTexturesPerBatch();
        gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({
          name: "sdf-shader",
          bits: [
            colorBit,
            generateTextureBatchBit(maxTextures2),
            localUniformMSDFBit,
            mSDFBit,
            roundPixelsBit
          ]
        }));
        glProgram ?? (glProgram = compileHighShaderGlProgram({
          name: "sdf-shader",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(maxTextures2),
            localUniformMSDFBitGl,
            mSDFBitGl,
            roundPixelsBitGl
          ]
        }));
        super({
          glProgram,
          gpuProgram,
          resources: {
            localUniforms: uniforms,
            batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
          }
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs
var AbstractBitmapFont;
var init_AbstractBitmapFont = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs"() {
    init_define_AnParams();
    init_eventemitter3();
    init_deprecation();
    AbstractBitmapFont = class extends eventemitter3_default {
      constructor() {
        super(...arguments);
        this.chars = /* @__PURE__ */ Object.create(null);
        this.lineHeight = 0;
        this.fontFamily = "";
        this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
        this.baseLineOffset = 0;
        this.distanceField = { type: "none", range: 0 };
        this.pages = [];
        this.applyFillAsTint = true;
        this.baseMeasurementFontSize = 100;
        this.baseRenderedFontSize = 100;
      }
      /**
       * The name of the font face.
       * @deprecated since 8.0.0 Use `fontFamily` instead.
       */
      get font() {
        deprecation(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
        return this.fontFamily;
      }
      /**
       * The map of base page textures (i.e., sheets of glyphs).
       * @deprecated since 8.0.0 Use `pages` instead.
       */
      get pageTextures() {
        deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
        return this.pages;
      }
      /**
       * The size of the font face in pixels.
       * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
       */
      get size() {
        deprecation(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
        return this.fontMetrics.fontSize;
      }
      /**
       * The kind of distance field for this font or "none".
       * @deprecated since 8.0.0 Use `distanceField.type` instead.
       */
      get distanceFieldRange() {
        deprecation(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
        return this.distanceField.range;
      }
      /**
       * The range of the distance field in pixels.
       * @deprecated since 8.0.0 Use `distanceField.range` instead.
       */
      get distanceFieldType() {
        deprecation(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
        return this.distanceField.type;
      }
      destroy(destroyTextures = false) {
        this.emit("destroy", this);
        this.removeAllListeners();
        for (const i3 in this.chars) {
          this.chars[i3].texture?.destroy();
        }
        this.chars = null;
        if (destroyTextures) {
          this.pages.forEach((page) => page.texture.destroy(true));
          this.pages = null;
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs
function resolveCharacters(chars) {
  if (chars === "") {
    return [];
  }
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i3 = 0, j2 = chars.length; i3 < j2; i3++) {
    const item = chars[i3];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      if (item[0].length === 0 || item[1].length === 0) {
        throw new Error("[BitmapFont]: Invalid character delimiter.");
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
        result.push(String.fromCharCode(i22));
      }
    } else {
      result.push(...Array.from(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
var init_resolveCharacters = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs
var _DynamicBitmapFont, DynamicBitmapFont;
var init_DynamicBitmapFont = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs"() {
    init_define_AnParams();
    init_Color();
    init_Rectangle();
    init_CanvasPool();
    init_ImageSource();
    init_Texture();
    init_deprecation();
    init_CanvasTextMetrics();
    init_fontStringFromTextStyle();
    init_getCanvasFillStyle();
    init_TextStyle();
    init_AbstractBitmapFont();
    init_resolveCharacters();
    _DynamicBitmapFont = class _DynamicBitmapFont2 extends AbstractBitmapFont {
      /**
       * @param options - The options for the dynamic bitmap font.
       */
      constructor(options) {
        super();
        this.resolution = 1;
        this.pages = [];
        this._padding = 0;
        this._measureCache = /* @__PURE__ */ Object.create(null);
        this._currentChars = [];
        this._currentX = 0;
        this._currentY = 0;
        this._currentPageIndex = -1;
        this._skipKerning = false;
        const dynamicOptions = { ..._DynamicBitmapFont2.defaultOptions, ...options };
        this._textureSize = dynamicOptions.textureSize;
        this._mipmap = dynamicOptions.mipmap;
        const style = dynamicOptions.style.clone();
        if (dynamicOptions.overrideFill) {
          style._fill.color = 16777215;
          style._fill.alpha = 1;
          style._fill.texture = Texture.WHITE;
          style._fill.fill = null;
        }
        this.applyFillAsTint = dynamicOptions.overrideFill;
        const requestedFontSize = style.fontSize;
        style.fontSize = this.baseMeasurementFontSize;
        const font = fontStringFromTextStyle(style);
        if (dynamicOptions.overrideSize) {
          if (style._stroke) {
            style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;
          }
        } else {
          style.fontSize = this.baseRenderedFontSize = requestedFontSize;
        }
        this._style = style;
        this._skipKerning = dynamicOptions.skipKerning ?? false;
        this.resolution = dynamicOptions.resolution ?? 1;
        this._padding = dynamicOptions.padding ?? 4;
        this.fontMetrics = CanvasTextMetrics.measureFont(font);
        this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
      }
      ensureCharacters(chars) {
        const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self2) => self2.indexOf(char) === index);
        if (!charList.length)
          return;
        this._currentChars = [...this._currentChars, ...charList];
        let pageData;
        if (this._currentPageIndex === -1) {
          pageData = this._nextPage();
        } else {
          pageData = this.pages[this._currentPageIndex];
        }
        let { canvas, context: context2 } = pageData.canvasAndContext;
        let textureSource = pageData.texture.source;
        const style = this._style;
        let currentX = this._currentX;
        let currentY = this._currentY;
        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
        const padding = this._padding * fontScale;
        let maxCharHeight = 0;
        let skipTexture = false;
        const maxTextureWidth = canvas.width / this.resolution;
        const maxTextureHeight = canvas.height / this.resolution;
        for (let i3 = 0; i3 < charList.length; i3++) {
          const char = charList[i3];
          const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);
          metrics.lineHeight = metrics.height;
          const width = metrics.width * fontScale;
          const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
          const height = metrics.height * fontScale;
          const paddedWidth = textureGlyphWidth + padding * 2;
          const paddedHeight = height + padding * 2;
          skipTexture = false;
          if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
            skipTexture = true;
            maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));
          }
          if (currentX + paddedWidth > maxTextureWidth) {
            currentY += maxCharHeight;
            maxCharHeight = paddedHeight;
            currentX = 0;
            if (currentY + maxCharHeight > maxTextureHeight) {
              textureSource.update();
              const pageData2 = this._nextPage();
              canvas = pageData2.canvasAndContext.canvas;
              context2 = pageData2.canvasAndContext.context;
              textureSource = pageData2.texture.source;
              currentY = 0;
            }
          }
          const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
          this.chars[char] = {
            id: char.codePointAt(0),
            xOffset: -this._padding,
            yOffset: -this._padding,
            xAdvance,
            kerning: {}
          };
          if (skipTexture) {
            this._drawGlyph(
              context2,
              metrics,
              currentX + padding,
              currentY + padding,
              fontScale,
              style
            );
            const px = textureSource.width * fontScale;
            const py = textureSource.height * fontScale;
            const frame = new Rectangle(
              currentX / px * textureSource.width,
              currentY / py * textureSource.height,
              paddedWidth / px * textureSource.width,
              paddedHeight / py * textureSource.height
            );
            this.chars[char].texture = new Texture({
              source: textureSource,
              frame
            });
            currentX += Math.ceil(paddedWidth);
          }
        }
        textureSource.update();
        this._currentX = currentX;
        this._currentY = currentY;
        this._skipKerning && this._applyKerning(charList, context2);
      }
      /**
       * @deprecated since 8.0.0
       * The map of base page textures (i.e., sheets of glyphs).
       */
      get pageTextures() {
        deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
        return this.pages;
      }
      _applyKerning(newChars, context2) {
        const measureCache = this._measureCache;
        for (let i3 = 0; i3 < newChars.length; i3++) {
          const first = newChars[i3];
          for (let j2 = 0; j2 < this._currentChars.length; j2++) {
            const second = this._currentChars[j2];
            let c1 = measureCache[first];
            if (!c1)
              c1 = measureCache[first] = context2.measureText(first).width;
            let c2 = measureCache[second];
            if (!c2)
              c2 = measureCache[second] = context2.measureText(second).width;
            let total = context2.measureText(first + second).width;
            let amount = total - (c1 + c2);
            if (amount) {
              this.chars[first].kerning[second] = amount;
            }
            total = context2.measureText(first + second).width;
            amount = total - (c1 + c2);
            if (amount) {
              this.chars[second].kerning[first] = amount;
            }
          }
        }
      }
      _nextPage() {
        this._currentPageIndex++;
        const textureResolution = this.resolution;
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
          this._textureSize,
          this._textureSize,
          textureResolution
        );
        this._setupContext(canvasAndContext.context, this._style, textureResolution);
        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
        const texture = new Texture({
          source: new ImageSource({
            resource: canvasAndContext.canvas,
            resolution,
            alphaMode: "premultiply-alpha-on-upload",
            autoGenerateMipmaps: this._mipmap
          })
        });
        const pageData = {
          canvasAndContext,
          texture
        };
        this.pages[this._currentPageIndex] = pageData;
        return pageData;
      }
      // canvas style!
      _setupContext(context2, style, resolution) {
        style.fontSize = this.baseRenderedFontSize;
        context2.scale(resolution, resolution);
        context2.font = fontStringFromTextStyle(style);
        style.fontSize = this.baseMeasurementFontSize;
        context2.textBaseline = style.textBaseline;
        const stroke = style._stroke;
        const strokeThickness = stroke?.width ?? 0;
        if (stroke) {
          context2.lineWidth = strokeThickness;
          context2.lineJoin = stroke.join;
          context2.miterLimit = stroke.miterLimit;
          context2.strokeStyle = getCanvasFillStyle(stroke, context2);
        }
        if (style._fill) {
          context2.fillStyle = getCanvasFillStyle(style._fill, context2);
        }
        if (style.dropShadow) {
          const shadowOptions = style.dropShadow;
          const rgb = Color.shared.setValue(shadowOptions.color).toArray();
          const dropShadowBlur = shadowOptions.blur * resolution;
          const dropShadowDistance = shadowOptions.distance * resolution;
          context2.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
          context2.shadowBlur = dropShadowBlur;
          context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
          context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
        } else {
          context2.shadowColor = "black";
          context2.shadowBlur = 0;
          context2.shadowOffsetX = 0;
          context2.shadowOffsetY = 0;
        }
      }
      _drawGlyph(context2, metrics, x2, y2, fontScale, style) {
        const char = metrics.text;
        const fontProperties = metrics.fontProperties;
        const stroke = style._stroke;
        const strokeThickness = (stroke?.width ?? 0) * fontScale;
        const tx = x2 + strokeThickness / 2;
        const ty = y2 - strokeThickness / 2;
        const descent = fontProperties.descent * fontScale;
        const lineHeight = metrics.lineHeight * fontScale;
        if (style.stroke && strokeThickness) {
          context2.strokeText(char, tx, ty + lineHeight - descent);
        }
        if (style._fill) {
          context2.fillText(char, tx, ty + lineHeight - descent);
        }
      }
      destroy() {
        super.destroy();
        for (let i3 = 0; i3 < this.pages.length; i3++) {
          const { canvasAndContext, texture } = this.pages[i3];
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          texture.destroy(true);
        }
        this.pages = null;
      }
    };
    _DynamicBitmapFont.defaultOptions = {
      textureSize: 512,
      style: new TextStyle(),
      mipmap: true
    };
    DynamicBitmapFont = _DynamicBitmapFont;
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs
function getBitmapTextLayout(chars, style, font, trimEnd) {
  const layoutData = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: style.fontSize / font.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  layoutData.offsetY = font.baseLineOffset;
  let currentLine = layoutData.lines[0];
  let previousChar = null;
  let firstWord = true;
  const currentWord = {
    spaceWord: false,
    width: 0,
    start: 0,
    index: 0,
    // use index to not modify the array as we use it a lot!
    positions: [],
    chars: []
  };
  const nextWord = (word) => {
    const start = currentLine.width;
    for (let j2 = 0; j2 < currentWord.index; j2++) {
      const position = word.positions[j2];
      currentLine.chars.push(word.chars[j2]);
      currentLine.charPositions.push(position + start);
    }
    currentLine.width += word.width;
    firstWord = false;
    currentWord.width = 0;
    currentWord.index = 0;
    currentWord.chars.length = 0;
  };
  const nextLine = () => {
    let index = currentLine.chars.length - 1;
    if (trimEnd) {
      let lastChar = currentLine.chars[index];
      while (lastChar === " ") {
        currentLine.width -= font.chars[lastChar].xAdvance;
        lastChar = currentLine.chars[--index];
      }
    }
    layoutData.width = Math.max(layoutData.width, currentLine.width);
    currentLine = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    };
    firstWord = true;
    layoutData.lines.push(currentLine);
    layoutData.height += font.lineHeight;
  };
  const scale = font.baseMeasurementFontSize / style.fontSize;
  const adjustedLetterSpacing = style.letterSpacing * scale;
  const adjustedWordWrapWidth = style.wordWrapWidth * scale;
  for (let i3 = 0; i3 < chars.length + 1; i3++) {
    let char;
    const isEnd = i3 === chars.length;
    if (!isEnd) {
      char = chars[i3];
    }
    const charData = font.chars[char] || font.chars[" "];
    const isSpace = /(?:\s)/.test(char);
    const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
    if (isWordBreak) {
      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;
      if (addWordToNextLine) {
        nextLine();
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      } else {
        currentWord.start = currentLine.width;
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      }
      if (char === "\r" || char === "\n") {
        if (currentLine.width !== 0) {
          nextLine();
        }
      } else if (!isEnd) {
        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
        currentLine.width += spaceWidth;
        currentLine.spaceWidth = spaceWidth;
        currentLine.spacesIndex.push(currentLine.charPositions.length);
        currentLine.chars.push(char);
      }
    } else {
      const kerning = charData.kerning[previousChar] || 0;
      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
      currentWord.positions[currentWord.index++] = currentWord.width + kerning;
      currentWord.chars.push(char);
      currentWord.width += nextCharWidth;
    }
    previousChar = char;
  }
  nextLine();
  if (style.align === "center") {
    alignCenter(layoutData);
  } else if (style.align === "right") {
    alignRight(layoutData);
  } else if (style.align === "justify") {
    alignJustify(layoutData);
  }
  return layoutData;
}
function alignCenter(measurementData) {
  for (let i3 = 0; i3 < measurementData.lines.length; i3++) {
    const line = measurementData.lines[i3];
    const offset = measurementData.width / 2 - line.width / 2;
    for (let j2 = 0; j2 < line.charPositions.length; j2++) {
      line.charPositions[j2] += offset;
    }
  }
}
function alignRight(measurementData) {
  for (let i3 = 0; i3 < measurementData.lines.length; i3++) {
    const line = measurementData.lines[i3];
    const offset = measurementData.width - line.width;
    for (let j2 = 0; j2 < line.charPositions.length; j2++) {
      line.charPositions[j2] += offset;
    }
  }
}
function alignJustify(measurementData) {
  const width = measurementData.width;
  for (let i3 = 0; i3 < measurementData.lines.length; i3++) {
    const line = measurementData.lines[i3];
    let indy = 0;
    let spaceIndex = line.spacesIndex[indy++];
    let offset = 0;
    const totalSpaces = line.spacesIndex.length;
    const newSpaceWidth = (width - line.width) / totalSpaces;
    const spaceWidth = newSpaceWidth;
    for (let j2 = 0; j2 < line.charPositions.length; j2++) {
      if (j2 === spaceIndex) {
        spaceIndex = line.spacesIndex[indy++];
        offset += spaceWidth;
      }
      line.charPositions[j2] += offset;
    }
  }
}
var init_getBitmapTextLayout = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs
var fontCount, BitmapFontManagerClass, BitmapFontManager;
var init_BitmapFontManager = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs"() {
    init_define_AnParams();
    init_Cache();
    init_deprecation();
    init_warn();
    init_TextStyle();
    init_DynamicBitmapFont();
    init_getBitmapTextLayout();
    init_resolveCharacters();
    fontCount = 0;
    BitmapFontManagerClass = class {
      constructor() {
        this.ALPHA = [["a", "z"], ["A", "Z"], " "];
        this.NUMERIC = [["0", "9"]];
        this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
        this.ASCII = [[" ", "~"]];
        this.defaultOptions = {
          chars: this.ALPHANUMERIC,
          resolution: 1,
          padding: 4,
          skipKerning: false
        };
      }
      /**
       * Get a font for the specified text and style.
       * @param text - The text to get the font for
       * @param style - The style to use
       */
      getFont(text, style) {
        let fontFamilyKey = `${style.fontFamily}-bitmap`;
        let overrideFill = true;
        if (style._fill.fill && !style._stroke) {
          fontFamilyKey += style._fill.fill.styleKey;
          overrideFill = false;
        } else if (style._stroke || style.dropShadow) {
          let key = style.styleKey;
          key = key.substring(0, key.lastIndexOf("-"));
          fontFamilyKey = `${key}-bitmap`;
          overrideFill = false;
        }
        if (!Cache.has(fontFamilyKey)) {
          const fnt = new DynamicBitmapFont({
            style,
            overrideFill,
            overrideSize: true,
            ...this.defaultOptions
          });
          fontCount++;
          if (fontCount > 50) {
            warn("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``);
          }
          fnt.once("destroy", () => {
            fontCount--;
            Cache.remove(fontFamilyKey);
          });
          Cache.set(
            fontFamilyKey,
            fnt
          );
        }
        const dynamicFont = Cache.get(fontFamilyKey);
        dynamicFont.ensureCharacters?.(text);
        return dynamicFont;
      }
      /**
       * Get the layout of a text for the specified style.
       * @param text - The text to get the layout for
       * @param style - The style to use
       * @param trimEnd - Whether to ignore whitespaces at the end of each line
       */
      getLayout(text, style, trimEnd = true) {
        const bitmapFont = this.getFont(text, style);
        return getBitmapTextLayout([...text], style, bitmapFont, trimEnd);
      }
      /**
       * Measure the text using the specified style.
       * @param text - The text to measure
       * @param style - The style to use
       * @param trimEnd - Whether to ignore whitespaces at the end of each line
       */
      measureText(text, style, trimEnd = true) {
        return this.getLayout(text, style, trimEnd);
      }
      // eslint-disable-next-line max-len
      install(...args) {
        let options = args[0];
        if (typeof options === "string") {
          options = {
            name: options,
            style: args[1],
            chars: args[2]?.chars,
            resolution: args[2]?.resolution,
            padding: args[2]?.padding,
            skipKerning: args[2]?.skipKerning
          };
          deprecation(v8_0_0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");
        }
        const name = options?.name;
        if (!name) {
          throw new Error("[BitmapFontManager] Property `name` is required.");
        }
        options = { ...this.defaultOptions, ...options };
        const textStyle = options.style;
        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
        const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;
        const font = new DynamicBitmapFont({
          style,
          overrideFill,
          skipKerning: options.skipKerning,
          padding: options.padding,
          resolution: options.resolution,
          overrideSize: false
        });
        const flatChars = resolveCharacters(options.chars);
        font.ensureCharacters(flatChars.join(""));
        Cache.set(`${name}-bitmap`, font);
        font.once("destroy", () => Cache.remove(`${name}-bitmap`));
        return font;
      }
      /**
       * Uninstalls a bitmap font from the cache.
       * @param {string} name - The name of the bitmap font to uninstall.
       */
      uninstall(name) {
        const cacheKey = `${name}-bitmap`;
        const font = Cache.get(cacheKey);
        if (font) {
          font.destroy();
        }
      }
    };
    BitmapFontManager = new BitmapFontManagerClass();
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs
function syncWithProxy(container, proxy) {
  proxy.groupTransform = container.groupTransform;
  proxy.groupColorAlpha = container.groupColorAlpha;
  proxy.groupColor = container.groupColor;
  proxy.groupBlendMode = container.groupBlendMode;
  proxy.globalDisplayStatus = container.globalDisplayStatus;
  proxy.groupTransform = container.groupTransform;
  proxy.localDisplayStatus = container.localDisplayStatus;
  proxy.groupAlpha = container.groupAlpha;
  proxy._roundPixels = container._roundPixels;
}
var BitmapTextPipe;
var init_BitmapTextPipe = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs"() {
    init_define_AnParams();
    init_Cache();
    init_Extensions();
    init_PoolGroup();
    init_Graphics();
    init_SdfShader();
    init_BitmapFontManager();
    init_getBitmapTextLayout();
    BitmapTextPipe = class {
      constructor(renderer) {
        this._gpuBitmapText = {};
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_gpuBitmapText");
      }
      validateRenderable(bitmapText) {
        const graphicsRenderable = this._getGpuBitmapText(bitmapText);
        if (bitmapText._didTextUpdate) {
          bitmapText._didTextUpdate = false;
          this._updateContext(bitmapText, graphicsRenderable);
        }
        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
      }
      addRenderable(bitmapText, instructionSet) {
        const graphicsRenderable = this._getGpuBitmapText(bitmapText);
        syncWithProxy(bitmapText, graphicsRenderable);
        if (bitmapText._didTextUpdate) {
          bitmapText._didTextUpdate = false;
          this._updateContext(bitmapText, graphicsRenderable);
        }
        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
        if (graphicsRenderable.context.customShader) {
          this._updateDistanceField(bitmapText);
        }
      }
      destroyRenderable(bitmapText) {
        bitmapText.off("destroyed", this._destroyRenderableBound);
        this._destroyRenderableByUid(bitmapText.uid);
      }
      _destroyRenderableByUid(renderableUid) {
        const context2 = this._gpuBitmapText[renderableUid].context;
        if (context2.customShader) {
          BigPool.return(context2.customShader);
          context2.customShader = null;
        }
        BigPool.return(this._gpuBitmapText[renderableUid]);
        this._gpuBitmapText[renderableUid] = null;
      }
      updateRenderable(bitmapText) {
        const graphicsRenderable = this._getGpuBitmapText(bitmapText);
        syncWithProxy(bitmapText, graphicsRenderable);
        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
        if (graphicsRenderable.context.customShader) {
          this._updateDistanceField(bitmapText);
        }
      }
      _updateContext(bitmapText, proxyGraphics) {
        const { context: context2 } = proxyGraphics;
        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);
        context2.clear();
        if (bitmapFont.distanceField.type !== "none") {
          if (!context2.customShader) {
            context2.customShader = BigPool.get(SdfShader);
          }
        }
        const chars = Array.from(bitmapText.text);
        const style = bitmapText._style;
        let currentY = bitmapFont.baseLineOffset;
        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);
        let index = 0;
        const padding = style.padding;
        const scale = bitmapTextLayout.scale;
        let tx = bitmapTextLayout.width;
        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;
        if (style._stroke) {
          tx += style._stroke.width / scale;
          ty += style._stroke.width / scale;
        }
        context2.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);
        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;
        for (let i3 = 0; i3 < bitmapTextLayout.lines.length; i3++) {
          const line = bitmapTextLayout.lines[i3];
          for (let j2 = 0; j2 < line.charPositions.length; j2++) {
            const char = chars[index++];
            const charData = bitmapFont.chars[char];
            if (charData?.texture) {
              context2.texture(
                charData.texture,
                tint ? tint : "black",
                Math.round(line.charPositions[j2] + charData.xOffset),
                Math.round(currentY + charData.yOffset)
              );
            }
          }
          currentY += bitmapFont.lineHeight;
        }
      }
      _getGpuBitmapText(bitmapText) {
        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);
      }
      initGpuText(bitmapText) {
        const proxyRenderable = BigPool.get(Graphics);
        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;
        this._updateContext(bitmapText, proxyRenderable);
        bitmapText.on("destroyed", this._destroyRenderableBound);
        return this._gpuBitmapText[bitmapText.uid];
      }
      _updateDistanceField(bitmapText) {
        const context2 = this._getGpuBitmapText(bitmapText).context;
        const fontFamily = bitmapText._style.fontFamily;
        const dynamicFont = Cache.get(`${fontFamily}-bitmap`);
        const { a: a2, b: b3, c: c2, d: d2 } = bitmapText.groupTransform;
        const dx = Math.sqrt(a2 * a2 + b3 * b3);
        const dy = Math.sqrt(c2 * c2 + d2 * d2);
        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;
        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);
        context2.customShader.resources.localUniforms.uniforms.uDistance = distance;
      }
      destroy() {
        for (const uid3 in this._gpuBitmapText) {
          this._destroyRenderableByUid(uid3);
        }
        this._gpuBitmapText = null;
        this._renderer = null;
      }
    };
    BitmapTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "bitmapText"
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/init.mjs
var init_init11 = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BitmapTextPipe();
    extensions.add(BitmapTextPipe);
  }
});

// node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs
var HTMLTextPipe;
var init_HTMLTextPipe = __esm({
  "node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Texture();
    init_PoolGroup();
    init_BatchableSprite();
    init_updateTextBounds();
    HTMLTextPipe = class {
      constructor(renderer) {
        this._gpuText = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this._renderer = renderer;
        this._renderer.runners.resolutionChange.add(this);
        this._renderer.renderableGC.addManagedHash(this, "_gpuText");
      }
      resolutionChange() {
        for (const i3 in this._gpuText) {
          const gpuText = this._gpuText[i3];
          if (!gpuText)
            continue;
          const text = gpuText.batchableSprite.renderable;
          if (text._autoResolution) {
            text._resolution = this._renderer.resolution;
            text.onViewUpdate();
          }
        }
      }
      validateRenderable(htmlText) {
        const gpuText = this._getGpuText(htmlText);
        const newKey = htmlText._getKey();
        if (gpuText.textureNeedsUploading) {
          gpuText.textureNeedsUploading = false;
          return true;
        }
        if (gpuText.currentKey !== newKey) {
          return true;
        }
        return false;
      }
      addRenderable(htmlText, instructionSet) {
        const gpuText = this._getGpuText(htmlText);
        const batchableSprite = gpuText.batchableSprite;
        if (htmlText._didTextUpdate) {
          this._updateText(htmlText);
        }
        this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);
      }
      updateRenderable(htmlText) {
        const gpuText = this._getGpuText(htmlText);
        const batchableSprite = gpuText.batchableSprite;
        if (htmlText._didTextUpdate) {
          this._updateText(htmlText);
        }
        batchableSprite._batcher.updateElement(batchableSprite);
      }
      destroyRenderable(htmlText) {
        htmlText.off("destroyed", this._destroyRenderableBound);
        this._destroyRenderableById(htmlText.uid);
      }
      _destroyRenderableById(htmlTextUid) {
        const gpuText = this._gpuText[htmlTextUid];
        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
        BigPool.return(gpuText.batchableSprite);
        this._gpuText[htmlTextUid] = null;
      }
      _updateText(htmlText) {
        const newKey = htmlText._getKey();
        const gpuText = this._getGpuText(htmlText);
        const batchableSprite = gpuText.batchableSprite;
        if (gpuText.currentKey !== newKey) {
          this._updateGpuText(htmlText).catch((e2) => {
            console.error(e2);
          });
        }
        htmlText._didTextUpdate = false;
        updateTextBounds(batchableSprite, htmlText);
      }
      async _updateGpuText(htmlText) {
        htmlText._didTextUpdate = false;
        const gpuText = this._getGpuText(htmlText);
        if (gpuText.generatingTexture)
          return;
        const newKey = htmlText._getKey();
        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
        gpuText.generatingTexture = true;
        gpuText.currentKey = newKey;
        const resolution = htmlText.resolution ?? this._renderer.resolution;
        const texture = await this._renderer.htmlText.getManagedTexture(
          htmlText.text,
          resolution,
          htmlText._style,
          htmlText._getKey()
        );
        const batchableSprite = gpuText.batchableSprite;
        batchableSprite.texture = gpuText.texture = texture;
        gpuText.generatingTexture = false;
        gpuText.textureNeedsUploading = true;
        htmlText.onViewUpdate();
        updateTextBounds(batchableSprite, htmlText);
      }
      _getGpuText(htmlText) {
        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);
      }
      initGpuText(htmlText) {
        const gpuTextData = {
          texture: Texture.EMPTY,
          currentKey: "--",
          batchableSprite: BigPool.get(BatchableSprite),
          textureNeedsUploading: false,
          generatingTexture: false
        };
        const batchableSprite = gpuTextData.batchableSprite;
        batchableSprite.renderable = htmlText;
        batchableSprite.transform = htmlText.groupTransform;
        batchableSprite.texture = Texture.EMPTY;
        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
        batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;
        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
        this._gpuText[htmlText.uid] = gpuTextData;
        htmlText.on("destroyed", this._destroyRenderableBound);
        return gpuTextData;
      }
      destroy() {
        for (const i3 in this._gpuText) {
          this._destroyRenderableById(i3);
        }
        this._gpuText = null;
        this._renderer = null;
      }
    };
    HTMLTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "htmlText"
    };
  }
});

// node_modules/pixi.js/lib/utils/browser/isSafari.mjs
function isSafari() {
  const { userAgent } = DOMAdapter.get().getNavigator();
  return /^((?!chrome|android).)*safari/i.test(userAgent);
}
var init_isSafari = __esm({
  "node_modules/pixi.js/lib/utils/browser/isSafari.mjs"() {
    init_define_AnParams();
    init_adapter();
  }
});

// node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs
var nssvg, nsxhtml, HTMLTextRenderData;
var init_HTMLTextRenderData = __esm({
  "node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs"() {
    "use strict";
    init_define_AnParams();
    nssvg = "http://www.w3.org/2000/svg";
    nsxhtml = "http://www.w3.org/1999/xhtml";
    HTMLTextRenderData = class {
      constructor() {
        this.svgRoot = document.createElementNS(nssvg, "svg");
        this.foreignObject = document.createElementNS(nssvg, "foreignObject");
        this.domElement = document.createElementNS(nsxhtml, "div");
        this.styleElement = document.createElementNS(nsxhtml, "style");
        this.image = new Image();
        const { foreignObject, svgRoot, styleElement, domElement } = this;
        foreignObject.setAttribute("width", "10000");
        foreignObject.setAttribute("height", "10000");
        foreignObject.style.overflow = "hidden";
        svgRoot.appendChild(foreignObject);
        foreignObject.appendChild(styleElement);
        foreignObject.appendChild(domElement);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs
function textStyleToCSS(style) {
  const stroke = style._stroke;
  const fill = style._fill;
  const cssStyleString = [
    `color: ${Color.shared.setValue(fill.color).toHex()}`,
    `font-size: ${style.fontSize}px`,
    `font-family: ${style.fontFamily}`,
    `font-weight: ${style.fontWeight}`,
    `font-style: ${style.fontStyle}`,
    `font-variant: ${style.fontVariant}`,
    `letter-spacing: ${style.letterSpacing}px`,
    `text-align: ${style.align}`,
    `padding: ${style.padding}px`,
    `white-space: ${style.whiteSpace === "pre" && style.wordWrap ? "pre-wrap" : style.whiteSpace}`,
    ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],
    ...style.wordWrap ? [
      `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,
      `max-width: ${style.wordWrapWidth}px`
    ] : [],
    ...stroke ? [strokeToCSS(stroke)] : [],
    ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],
    ...style.cssOverrides
  ].join(";");
  const cssStyles = [`div { ${cssStyleString} }`];
  tagStyleToCSS(style.tagStyles, cssStyles);
  return cssStyles.join(" ");
}
function dropShadowToCSS(dropShadowStyle) {
  const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();
  const x2 = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);
  const y2 = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);
  const position = `${x2}px ${y2}px`;
  if (dropShadowStyle.blur > 0) {
    return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;
  }
  return `text-shadow: ${position} ${color}`;
}
function strokeToCSS(stroke) {
  return [
    `-webkit-text-stroke-width: ${stroke.width}px`,
    `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
    `text-stroke-width: ${stroke.width}px`,
    `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
    "paint-order: stroke"
  ].join(";");
}
function tagStyleToCSS(tagStyles, out2) {
  for (const i3 in tagStyles) {
    const tagStyle = tagStyles[i3];
    const cssTagStyle = [];
    for (const j2 in tagStyle) {
      if (transform[j2]) {
        cssTagStyle.push(transform[j2](tagStyle[j2]));
      } else if (templates[j2]) {
        cssTagStyle.push(templates[j2].replace("{{VALUE}}", tagStyle[j2]));
      }
    }
    out2.push(`${i3} { ${cssTagStyle.join(";")} }`);
  }
}
var templates, transform;
var init_textStyleToCSS = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs"() {
    init_define_AnParams();
    init_Color();
    templates = {
      fontSize: `font-size: {{VALUE}}px`,
      fontFamily: `font-family: {{VALUE}}`,
      fontWeight: `font-weight: {{VALUE}}`,
      fontStyle: `font-style: {{VALUE}}`,
      fontVariant: `font-variant: {{VALUE}}`,
      letterSpacing: `letter-spacing: {{VALUE}}px`,
      align: `text-align: {{VALUE}}`,
      padding: `padding: {{VALUE}}px`,
      whiteSpace: `white-space: {{VALUE}}`,
      lineHeight: `line-height: {{VALUE}}px`,
      wordWrapWidth: `max-width: {{VALUE}}px`
    };
    transform = {
      fill: (value) => `color: ${Color.shared.setValue(value).toHex()}`,
      breakWords: (value) => `word-wrap: ${value ? "break-all" : "break-word"}`,
      stroke: strokeToCSS,
      dropShadow: dropShadowToCSS
    };
  }
});

// node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.mjs
var HTMLTextStyle;
var init_HTMLTextStyle = __esm({
  "node_modules/pixi.js/lib/scene/text-html/HTMLTextStyle.mjs"() {
    init_define_AnParams();
    init_warn();
    init_TextStyle();
    init_generateTextStyleKey();
    init_textStyleToCSS();
    HTMLTextStyle = class _HTMLTextStyle extends TextStyle {
      constructor(options = {}) {
        super(options);
        this._cssOverrides = [];
        this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);
        this.tagStyles = options.tagStyles ?? {};
      }
      /** List of style overrides that will be applied to the HTML text. */
      set cssOverrides(value) {
        this._cssOverrides = value instanceof Array ? value : [value];
        this.update();
      }
      get cssOverrides() {
        return this._cssOverrides;
      }
      _generateKey() {
        this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join("-");
        return this._styleKey;
      }
      update() {
        this._cssStyle = null;
        super.update();
      }
      /**
       * Creates a new HTMLTextStyle object with the same values as this one.
       * @returns New cloned HTMLTextStyle object
       */
      clone() {
        return new _HTMLTextStyle({
          align: this.align,
          breakWords: this.breakWords,
          dropShadow: this.dropShadow ? { ...this.dropShadow } : null,
          fill: this._fill,
          fontFamily: this.fontFamily,
          fontSize: this.fontSize,
          fontStyle: this.fontStyle,
          fontVariant: this.fontVariant,
          fontWeight: this.fontWeight,
          letterSpacing: this.letterSpacing,
          lineHeight: this.lineHeight,
          padding: this.padding,
          stroke: this._stroke,
          whiteSpace: this.whiteSpace,
          wordWrap: this.wordWrap,
          wordWrapWidth: this.wordWrapWidth,
          cssOverrides: this.cssOverrides
        });
      }
      get cssStyle() {
        if (!this._cssStyle) {
          this._cssStyle = textStyleToCSS(this);
        }
        return this._cssStyle;
      }
      /**
       * Add a style override, this can be any CSS property
       * it will override any built-in style. This is the
       * property and the value as a string (e.g., `color: red`).
       * This will override any other internal style.
       * @param {string} value - CSS style(s) to add.
       * @example
       * style.addOverride('background-color: red');
       */
      addOverride(...value) {
        const toAdd = value.filter((v2) => !this.cssOverrides.includes(v2));
        if (toAdd.length > 0) {
          this.cssOverrides.push(...toAdd);
          this.update();
        }
      }
      /**
       * Remove any overrides that match the value.
       * @param {string} value - CSS style to remove.
       * @example
       * style.removeOverride('background-color: red');
       */
      removeOverride(...value) {
        const toRemove = value.filter((v2) => this.cssOverrides.includes(v2));
        if (toRemove.length > 0) {
          this.cssOverrides = this.cssOverrides.filter((v2) => !toRemove.includes(v2));
          this.update();
        }
      }
      set fill(value) {
        if (typeof value !== "string" && typeof value !== "number") {
          warn("[HTMLTextStyle] only color fill is not supported by HTMLText");
        }
        super.fill = value;
      }
      set stroke(value) {
        if (value && typeof value !== "string" && typeof value !== "number") {
          warn("[HTMLTextStyle] only color stroke is not supported by HTMLText");
        }
        super.stroke = value;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs
function extractFontFamilies(text, style) {
  const fontFamily = style.fontFamily;
  const fontFamilies = [];
  const dedupe = {};
  const regex = /font-family:([^;"\s]+)/g;
  const matches = text.match(regex);
  function addFontFamily(fontFamily2) {
    if (!dedupe[fontFamily2]) {
      fontFamilies.push(fontFamily2);
      dedupe[fontFamily2] = true;
    }
  }
  if (Array.isArray(fontFamily)) {
    for (let i3 = 0; i3 < fontFamily.length; i3++) {
      addFontFamily(fontFamily[i3]);
    }
  } else {
    addFontFamily(fontFamily);
  }
  if (matches) {
    matches.forEach((match) => {
      const fontFamily2 = match.split(":")[1].trim();
      addFontFamily(fontFamily2);
    });
  }
  for (const i3 in style.tagStyles) {
    const fontFamily2 = style.tagStyles[i3].fontFamily;
    addFontFamily(fontFamily2);
  }
  return fontFamilies;
}
var init_extractFontFamilies = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs
async function loadFontAsBase64(url) {
  const response = await DOMAdapter.get().fetch(url);
  const blob = await response.blob();
  const reader = new FileReader();
  const dataSrc = await new Promise((resolve, reject) => {
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
  return dataSrc;
}
var init_loadFontAsBase64 = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs"() {
    init_define_AnParams();
    init_adapter();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs
async function loadFontCSS(style, url) {
  const dataSrc = await loadFontAsBase64(url);
  return `@font-face {
        font-family: "${style.fontFamily}";
        src: url('${dataSrc}');
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
    }`;
}
var init_loadFontCSS = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs"() {
    init_define_AnParams();
    init_loadFontAsBase64();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs
async function getFontCss(fontFamilies, style, defaultOptions) {
  const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily, i3) => {
    if (!FontStylePromiseCache.has(fontFamily)) {
      const { url } = Cache.get(`${fontFamily}-and-url`);
      if (i3 === 0) {
        FontStylePromiseCache.set(fontFamily, loadFontCSS({
          fontWeight: style.fontWeight,
          fontStyle: style.fontStyle,
          fontFamily
        }, url));
      } else {
        FontStylePromiseCache.set(fontFamily, loadFontCSS({
          fontWeight: defaultOptions.fontWeight,
          fontStyle: defaultOptions.fontStyle,
          fontFamily
        }, url));
      }
    }
    return FontStylePromiseCache.get(fontFamily);
  });
  return (await Promise.all(fontPromises)).join("\n");
}
var FontStylePromiseCache;
var init_getFontCss = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs"() {
    init_define_AnParams();
    init_Cache();
    init_loadFontCSS();
    FontStylePromiseCache = /* @__PURE__ */ new Map();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs
function getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {
  const { domElement, styleElement, svgRoot } = htmlTextData;
  domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;
  domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);
  styleElement.textContent = fontCSS;
  const { width, height } = htmlTextData.image;
  svgRoot.setAttribute("width", width.toString());
  svgRoot.setAttribute("height", height.toString());
  return new XMLSerializer().serializeToString(svgRoot);
}
var init_getSVGUrl = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs
function getTemporaryCanvasFromImage(image, resolution) {
  const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
    image.width,
    image.height,
    resolution
  );
  const { context: context2 } = canvasAndContext;
  context2.clearRect(0, 0, image.width, image.height);
  context2.drawImage(image, 0, 0);
  return canvasAndContext;
}
var init_getTemporaryCanvasFromImage = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs"() {
    init_define_AnParams();
    init_CanvasPool();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs
function loadSVGImage(image, url, delay2) {
  return new Promise(async (resolve) => {
    if (delay2) {
      await new Promise((resolve2) => setTimeout(resolve2, 100));
    }
    image.onload = () => {
      resolve();
    };
    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;
    image.crossOrigin = "anonymous";
  });
}
var init_loadSVGImage = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs
function measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {
  htmlTextRenderData || (htmlTextRenderData = tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData()));
  const { domElement, styleElement, svgRoot } = htmlTextRenderData;
  domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;
  domElement.setAttribute("style", "transform-origin: top left; display: inline-block");
  if (fontStyleCSS) {
    styleElement.textContent = fontStyleCSS;
  }
  document.body.appendChild(svgRoot);
  const contentBounds = domElement.getBoundingClientRect();
  svgRoot.remove();
  const doublePadding = style.padding * 2;
  return {
    width: contentBounds.width - doublePadding,
    height: contentBounds.height - doublePadding
  };
}
var tempHTMLTextRenderData;
var init_measureHtmlText = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs"() {
    init_define_AnParams();
    init_HTMLTextRenderData();
  }
});

// node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs
var HTMLTextSystem;
var init_HTMLTextSystem = __esm({
  "node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_CanvasPool();
    init_TexturePool();
    init_types2();
    init_isSafari();
    init_warn();
    init_PoolGroup();
    init_getPo2TextureFromSource();
    init_HTMLTextRenderData();
    init_HTMLTextStyle();
    init_extractFontFamilies();
    init_getFontCss();
    init_getSVGUrl();
    init_getTemporaryCanvasFromImage();
    init_loadSVGImage();
    init_measureHtmlText();
    HTMLTextSystem = class {
      constructor(renderer) {
        this._activeTextures = {};
        this._renderer = renderer;
        this._createCanvas = renderer.type === RendererType.WEBGPU;
      }
      getTexture(options) {
        return this._buildTexturePromise(
          options.text,
          options.resolution,
          options.style
        );
      }
      getManagedTexture(text, resolution, style, textKey) {
        if (this._activeTextures[textKey]) {
          this._increaseReferenceCount(textKey);
          return this._activeTextures[textKey].promise;
        }
        const promise2 = this._buildTexturePromise(text, resolution, style).then((texture) => {
          this._activeTextures[textKey].texture = texture;
          return texture;
        });
        this._activeTextures[textKey] = {
          texture: null,
          promise: promise2,
          usageCount: 1
        };
        return promise2;
      }
      async _buildTexturePromise(text, resolution, style) {
        const htmlTextData = BigPool.get(HTMLTextRenderData);
        const fontFamilies = extractFontFamilies(text, style);
        const fontCSS = await getFontCss(
          fontFamilies,
          style,
          HTMLTextStyle.defaultTextStyle
        );
        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);
        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        const image = htmlTextData.image;
        const uvSafeOffset = 2;
        image.width = (width | 0) + uvSafeOffset;
        image.height = (height | 0) + uvSafeOffset;
        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);
        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);
        const resource = image;
        let canvasAndContext;
        if (this._createCanvas) {
          canvasAndContext = getTemporaryCanvasFromImage(image, resolution);
        }
        const texture = getPo2TextureFromSource(
          canvasAndContext ? canvasAndContext.canvas : resource,
          image.width - uvSafeOffset,
          image.height - uvSafeOffset,
          resolution
        );
        if (this._createCanvas) {
          this._renderer.texture.initSource(texture.source);
          CanvasPool.returnCanvasAndContext(canvasAndContext);
        }
        BigPool.return(htmlTextData);
        return texture;
      }
      _increaseReferenceCount(textKey) {
        this._activeTextures[textKey].usageCount++;
      }
      decreaseReferenceCount(textKey) {
        const activeTexture = this._activeTextures[textKey];
        if (!activeTexture)
          return;
        activeTexture.usageCount--;
        if (activeTexture.usageCount === 0) {
          if (activeTexture.texture) {
            this._cleanUp(activeTexture);
          } else {
            activeTexture.promise.then((texture) => {
              activeTexture.texture = texture;
              this._cleanUp(activeTexture);
            }).catch(() => {
              warn("HTMLTextSystem: Failed to clean texture");
            });
          }
          this._activeTextures[textKey] = null;
        }
      }
      _cleanUp(activeTexture) {
        TexturePool.returnTexture(activeTexture.texture);
        activeTexture.texture.source.resource = null;
        activeTexture.texture.source.uploadMethodId = "unknown";
      }
      getReferenceCount(textKey) {
        return this._activeTextures[textKey].usageCount;
      }
      destroy() {
        this._activeTextures = null;
      }
    };
    HTMLTextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "htmlText"
    };
    HTMLTextSystem.defaultFontOptions = {
      fontFamily: "Arial",
      fontStyle: "normal",
      fontWeight: "normal"
    };
  }
});

// node_modules/pixi.js/lib/scene/text-html/init.mjs
var init_init12 = __esm({
  "node_modules/pixi.js/lib/scene/text-html/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_HTMLTextPipe();
    init_HTMLTextSystem();
    extensions.add(HTMLTextSystem);
    extensions.add(HTMLTextPipe);
  }
});

// node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs
var _MeshGeometry, MeshGeometry;
var init_MeshGeometry = __esm({
  "node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs"() {
    init_define_AnParams();
    init_Buffer();
    init_const4();
    init_Geometry();
    init_deprecation();
    _MeshGeometry = class _MeshGeometry2 extends Geometry {
      constructor(...args) {
        let options = args[0] ?? {};
        if (options instanceof Float32Array) {
          deprecation(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
          options = {
            positions: options,
            uvs: args[1],
            indices: args[2]
          };
        }
        options = { ..._MeshGeometry2.defaultOptions, ...options };
        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        let uvs = options.uvs;
        if (!uvs) {
          if (options.positions) {
            uvs = new Float32Array(positions.length);
          } else {
            uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
          }
        }
        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
        const shrinkToFit = options.shrinkBuffersToFit;
        const positionBuffer = new Buffer2({
          data: positions,
          label: "attribute-mesh-positions",
          shrinkToFit,
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const uvBuffer = new Buffer2({
          data: uvs,
          label: "attribute-mesh-uvs",
          shrinkToFit,
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const indexBuffer = new Buffer2({
          data: indices,
          label: "index-mesh-buffer",
          shrinkToFit,
          usage: BufferUsage.INDEX | BufferUsage.COPY_DST
        });
        super({
          attributes: {
            aPosition: {
              buffer: positionBuffer,
              format: "float32x2",
              stride: 2 * 4,
              offset: 0
            },
            aUV: {
              buffer: uvBuffer,
              format: "float32x2",
              stride: 2 * 4,
              offset: 0
            }
          },
          indexBuffer,
          topology: options.topology
        });
        this.batchMode = "auto";
      }
      /** The positions of the mesh. */
      get positions() {
        return this.attributes.aPosition.buffer.data;
      }
      /**
       * Set the positions of the mesh.
       * When setting the positions, its important that the uvs array is at least as long as the positions array.
       * otherwise the geometry will not be valid.
       * @param {Float32Array} value - The positions of the mesh.
       */
      set positions(value) {
        this.attributes.aPosition.buffer.data = value;
      }
      /** The UVs of the mesh. */
      get uvs() {
        return this.attributes.aUV.buffer.data;
      }
      /**
       * Set the UVs of the mesh.
       * Its important that the uvs array you set is at least as long as the positions array.
       * otherwise the geometry will not be valid.
       * @param {Float32Array} value - The UVs of the mesh.
       */
      set uvs(value) {
        this.attributes.aUV.buffer.data = value;
      }
      /** The indices of the mesh. */
      get indices() {
        return this.indexBuffer.data;
      }
      set indices(value) {
        this.indexBuffer.data = value;
      }
    };
    _MeshGeometry.defaultOptions = {
      topology: "triangle-list",
      shrinkBuffersToFit: false
    };
    MeshGeometry = _MeshGeometry;
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs
var localUniformBit, localUniformBitGroup2, localUniformBitGl;
var init_localUniformBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"() {
    "use strict";
    init_define_AnParams();
    localUniformBit = {
      name: "local-uniform-bit",
      vertex: {
        header: (
          /* wgsl */
          `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
        ),
        end: (
          /* wgsl */
          `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        )
      }
    };
    localUniformBitGroup2 = {
      ...localUniformBit,
      vertex: {
        ...localUniformBit.vertex,
        // replace the group!
        header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
      }
    };
    localUniformBitGl = {
      name: "local-uniform-bit",
      vertex: {
        header: (
          /* glsl */
          `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
        ),
        main: (
          /* glsl */
          `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
        ),
        end: (
          /* glsl */
          `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs
var tilingBit, tilingBitGl;
var init_tilingBit = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs"() {
    "use strict";
    init_define_AnParams();
    tilingBit = {
      name: "tiling-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
        ),
        main: (
          /* wgsl */
          `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
        )
      },
      fragment: {
        header: (
          /* wgsl */
          `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
        ),
        main: (
          /* wgsl */
          `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
        )
      }
    };
    tilingBitGl = {
      name: "tiling-bit",
      vertex: {
        header: (
          /* glsl */
          `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `
        ),
        main: (
          /* glsl */
          `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
        )
      },
      fragment: {
        header: (
          /* glsl */
          `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `
        ),
        main: (
          /* glsl */
          `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs
var gpuProgram2, glProgram2, TilingSpriteShader;
var init_TilingSpriteShader = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_Shader();
    init_UniformGroup();
    init_Texture();
    init_tilingBit();
    TilingSpriteShader = class extends Shader {
      constructor() {
        gpuProgram2 ?? (gpuProgram2 = compileHighShaderGpuProgram({
          name: "tiling-sprite-shader",
          bits: [
            localUniformBit,
            tilingBit,
            roundPixelsBit
          ]
        }));
        glProgram2 ?? (glProgram2 = compileHighShaderGlProgram({
          name: "tiling-sprite-shader",
          bits: [
            localUniformBitGl,
            tilingBitGl,
            roundPixelsBitGl
          ]
        }));
        const tilingUniforms = new UniformGroup({
          uMapCoord: { value: new Matrix(), type: "mat3x3<f32>" },
          uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
          uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
          uTextureTransform: { value: new Matrix(), type: "mat3x3<f32>" },
          uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }
        });
        super({
          glProgram: glProgram2,
          gpuProgram: gpuProgram2,
          resources: {
            localUniforms: new UniformGroup({
              uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
              uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
              uRound: { value: 0, type: "f32" }
            }),
            tilingUniforms,
            uTexture: Texture.EMPTY.source,
            uSampler: Texture.EMPTY.source.style
          }
        });
      }
      updateUniforms(width, height, matrix, anchorX, anchorY, texture) {
        const tilingUniforms = this.resources.tilingUniforms;
        const textureWidth = texture.width;
        const textureHeight = texture.height;
        const textureMatrix = texture.textureMatrix;
        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
        uTextureTransform.set(
          matrix.a * textureWidth / width,
          matrix.b * textureWidth / height,
          matrix.c * textureHeight / width,
          matrix.d * textureHeight / height,
          matrix.tx / width,
          matrix.ty / height
        );
        uTextureTransform.invert();
        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
        tilingUniforms.uniforms.uSizeAnchor[0] = width;
        tilingUniforms.uniforms.uSizeAnchor[1] = height;
        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;
        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;
        if (texture) {
          this.resources.uTexture = texture.source;
          this.resources.uSampler = texture.source.style;
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs
var QuadGeometry;
var init_QuadGeometry = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs"() {
    init_define_AnParams();
    init_MeshGeometry();
    QuadGeometry = class extends MeshGeometry {
      constructor() {
        super({
          positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          indices: new Uint32Array([0, 1, 2, 0, 2, 3])
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs
function setPositions(tilingSprite, positions) {
  const anchorX = tilingSprite.anchor.x;
  const anchorY = tilingSprite.anchor.y;
  positions[0] = -anchorX * tilingSprite.width;
  positions[1] = -anchorY * tilingSprite.height;
  positions[2] = (1 - anchorX) * tilingSprite.width;
  positions[3] = -anchorY * tilingSprite.height;
  positions[4] = (1 - anchorX) * tilingSprite.width;
  positions[5] = (1 - anchorY) * tilingSprite.height;
  positions[6] = -anchorX * tilingSprite.width;
  positions[7] = (1 - anchorY) * tilingSprite.height;
}
var init_setPositions = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs
function applyMatrix(array, stride, offset, matrix) {
  let index = 0;
  const size = array.length / (stride || 2);
  const a2 = matrix.a;
  const b3 = matrix.b;
  const c2 = matrix.c;
  const d2 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  offset *= stride;
  while (index < size) {
    const x2 = array[offset];
    const y2 = array[offset + 1];
    array[offset] = a2 * x2 + c2 * y2 + tx;
    array[offset + 1] = b3 * x2 + d2 * y2 + ty;
    offset += stride;
    index++;
  }
}
var init_applyMatrix = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs
function setUvs(tilingSprite, uvs) {
  const texture = tilingSprite.texture;
  const width = texture.frame.width;
  const height = texture.frame.height;
  let anchorX = 0;
  let anchorY = 0;
  if (tilingSprite.applyAnchorToTexture) {
    anchorX = tilingSprite.anchor.x;
    anchorY = tilingSprite.anchor.y;
  }
  uvs[0] = uvs[6] = -anchorX;
  uvs[2] = uvs[4] = 1 - anchorX;
  uvs[1] = uvs[3] = -anchorY;
  uvs[5] = uvs[7] = 1 - anchorY;
  const textureMatrix = Matrix.shared;
  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);
  textureMatrix.tx /= tilingSprite.width;
  textureMatrix.ty /= tilingSprite.height;
  textureMatrix.invert();
  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);
  applyMatrix(uvs, 2, 0, textureMatrix);
}
var init_setUvs = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_applyMatrix();
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs
var sharedQuad, TilingSpritePipe;
var init_TilingSpritePipe = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_getAdjustedBlendModeBlend();
    init_State();
    init_types2();
    init_colorToUniform();
    init_BatchableMesh();
    init_MeshGeometry();
    init_TilingSpriteShader();
    init_QuadGeometry();
    init_setPositions();
    init_setUvs();
    sharedQuad = new QuadGeometry();
    TilingSpritePipe = class {
      constructor(renderer) {
        this._state = State.default2d;
        this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_tilingSpriteDataHash");
      }
      validateRenderable(renderable) {
        const tilingSpriteData = this._getTilingSpriteData(renderable);
        const couldBatch = tilingSpriteData.canBatch;
        this._updateCanBatch(renderable);
        const canBatch = tilingSpriteData.canBatch;
        if (canBatch && canBatch === couldBatch) {
          const { batchableMesh } = tilingSpriteData;
          return !batchableMesh._batcher.checkAndUpdateTexture(
            batchableMesh,
            renderable.texture
          );
        }
        return couldBatch !== canBatch;
      }
      addRenderable(tilingSprite, instructionSet) {
        const batcher = this._renderer.renderPipes.batch;
        this._updateCanBatch(tilingSprite);
        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
        const { geometry, canBatch } = tilingSpriteData;
        if (canBatch) {
          tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());
          const batchableMesh = tilingSpriteData.batchableMesh;
          if (tilingSprite.didViewUpdate) {
            this._updateBatchableMesh(tilingSprite);
            batchableMesh.geometry = geometry;
            batchableMesh.renderable = tilingSprite;
            batchableMesh.transform = tilingSprite.groupTransform;
            batchableMesh.setTexture(tilingSprite._texture);
          }
          batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;
          batcher.addToBatch(batchableMesh, instructionSet);
        } else {
          batcher.break(instructionSet);
          tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());
          this.updateRenderable(tilingSprite);
          instructionSet.add(tilingSprite);
        }
      }
      execute(tilingSprite) {
        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];
        shader.groups[0] = this._renderer.globalUniforms.bindGroup;
        const localUniforms = shader.resources.localUniforms.uniforms;
        localUniforms.uTransformMatrix = tilingSprite.groupTransform;
        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;
        color32BitToUniform(
          tilingSprite.groupColorAlpha,
          localUniforms.uColor,
          0
        );
        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);
        this._renderer.encoder.draw({
          geometry: sharedQuad,
          shader,
          state: this._state
        });
      }
      updateRenderable(tilingSprite) {
        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
        const { canBatch } = tilingSpriteData;
        if (canBatch) {
          const { batchableMesh } = tilingSpriteData;
          if (tilingSprite.didViewUpdate)
            this._updateBatchableMesh(tilingSprite);
          batchableMesh._batcher.updateElement(batchableMesh);
        } else if (tilingSprite.didViewUpdate) {
          const { shader } = tilingSpriteData;
          shader.updateUniforms(
            tilingSprite.width,
            tilingSprite.height,
            tilingSprite._tileTransform.matrix,
            tilingSprite.anchor.x,
            tilingSprite.anchor.y,
            tilingSprite.texture
          );
        }
      }
      destroyRenderable(tilingSprite) {
        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
        tilingSpriteData.batchableMesh = null;
        tilingSpriteData.shader?.destroy();
        this._tilingSpriteDataHash[tilingSprite.uid] = null;
        tilingSprite.off("destroyed", this._destroyRenderableBound);
      }
      _getTilingSpriteData(renderable) {
        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);
      }
      _initTilingSpriteData(tilingSprite) {
        const geometry = new MeshGeometry({
          indices: sharedQuad.indices,
          positions: sharedQuad.positions.slice(),
          uvs: sharedQuad.uvs.slice()
        });
        this._tilingSpriteDataHash[tilingSprite.uid] = {
          canBatch: true,
          renderable: tilingSprite,
          geometry
        };
        tilingSprite.on("destroyed", this._destroyRenderableBound);
        return this._tilingSpriteDataHash[tilingSprite.uid];
      }
      _updateBatchableMesh(tilingSprite) {
        const renderableData = this._getTilingSpriteData(tilingSprite);
        const { geometry } = renderableData;
        const style = tilingSprite.texture.source.style;
        if (style.addressMode !== "repeat") {
          style.addressMode = "repeat";
          style.update();
        }
        setUvs(tilingSprite, geometry.uvs);
        setPositions(tilingSprite, geometry.positions);
      }
      destroy() {
        for (const i3 in this._tilingSpriteDataHash) {
          this.destroyRenderable(this._tilingSpriteDataHash[i3].renderable);
        }
        this._tilingSpriteDataHash = null;
        this._renderer = null;
      }
      _updateCanBatch(tilingSprite) {
        const renderableData = this._getTilingSpriteData(tilingSprite);
        const texture = tilingSprite.texture;
        let _nonPowOf2wrapping = true;
        if (this._renderer.type === RendererType.WEBGL) {
          _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;
        }
        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);
        return renderableData.canBatch;
      }
    };
    TilingSpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "tilingSprite"
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs
var init_init13 = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_TilingSpritePipe();
    extensions.add(TilingSpritePipe);
  }
});

// node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs
var _PlaneGeometry, PlaneGeometry;
var init_PlaneGeometry = __esm({
  "node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs"() {
    init_define_AnParams();
    init_deprecation();
    init_MeshGeometry();
    _PlaneGeometry = class _PlaneGeometry2 extends MeshGeometry {
      constructor(...args) {
        super({});
        let options = args[0] ?? {};
        if (typeof options === "number") {
          deprecation(v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
          options = {
            width: options,
            height: args[1],
            verticesX: args[2],
            verticesY: args[3]
          };
        }
        this.build(options);
      }
      /**
       * Refreshes plane coordinates
       * @param options - Options to be applied to plane geometry
       */
      build(options) {
        options = { ..._PlaneGeometry2.defaultOptions, ...options };
        this.verticesX = this.verticesX ?? options.verticesX;
        this.verticesY = this.verticesY ?? options.verticesY;
        this.width = this.width ?? options.width;
        this.height = this.height ?? options.height;
        const total = this.verticesX * this.verticesY;
        const verts = [];
        const uvs = [];
        const indices = [];
        const verticesX = this.verticesX - 1;
        const verticesY = this.verticesY - 1;
        const sizeX = this.width / verticesX;
        const sizeY = this.height / verticesY;
        for (let i3 = 0; i3 < total; i3++) {
          const x2 = i3 % this.verticesX;
          const y2 = i3 / this.verticesX | 0;
          verts.push(x2 * sizeX, y2 * sizeY);
          uvs.push(x2 / verticesX, y2 / verticesY);
        }
        const totalSub = verticesX * verticesY;
        for (let i3 = 0; i3 < totalSub; i3++) {
          const xpos = i3 % verticesX;
          const ypos = i3 / verticesX | 0;
          const value = ypos * this.verticesX + xpos;
          const value2 = ypos * this.verticesX + xpos + 1;
          const value3 = (ypos + 1) * this.verticesX + xpos;
          const value4 = (ypos + 1) * this.verticesX + xpos + 1;
          indices.push(
            value,
            value2,
            value3,
            value2,
            value4,
            value3
          );
        }
        this.buffers[0].data = new Float32Array(verts);
        this.buffers[1].data = new Float32Array(uvs);
        this.indexBuffer.data = new Uint32Array(indices);
        this.buffers[0].update();
        this.buffers[1].update();
        this.indexBuffer.update();
      }
    };
    _PlaneGeometry.defaultOptions = {
      width: 100,
      height: 100,
      verticesX: 10,
      verticesY: 10
    };
    PlaneGeometry = _PlaneGeometry;
  }
});

// node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs
var _NineSliceGeometry, NineSliceGeometry;
var init_NineSliceGeometry = __esm({
  "node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs"() {
    init_define_AnParams();
    init_PlaneGeometry();
    _NineSliceGeometry = class _NineSliceGeometry2 extends PlaneGeometry {
      constructor(options = {}) {
        options = { ..._NineSliceGeometry2.defaultOptions, ...options };
        super({
          width: options.width,
          height: options.height,
          verticesX: 4,
          verticesY: 4
        });
        this.update(options);
      }
      /**
       * Updates the NineSliceGeometry with the options.
       * @param options - The options of the NineSliceGeometry.
       */
      update(options) {
        this.width = options.width ?? this.width;
        this.height = options.height ?? this.height;
        this._originalWidth = options.originalWidth ?? this._originalWidth;
        this._originalHeight = options.originalHeight ?? this._originalHeight;
        this._leftWidth = options.leftWidth ?? this._leftWidth;
        this._rightWidth = options.rightWidth ?? this._rightWidth;
        this._topHeight = options.topHeight ?? this._topHeight;
        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
        this._anchorX = options.anchor?.x;
        this._anchorY = options.anchor?.y;
        this.updateUvs();
        this.updatePositions();
      }
      /** Updates the positions of the vertices. */
      updatePositions() {
        const p2 = this.positions;
        const {
          width,
          height,
          _leftWidth,
          _rightWidth,
          _topHeight,
          _bottomHeight,
          _anchorX,
          _anchorY
        } = this;
        const w2 = _leftWidth + _rightWidth;
        const scaleW = width > w2 ? 1 : width / w2;
        const h2 = _topHeight + _bottomHeight;
        const scaleH = height > h2 ? 1 : height / h2;
        const scale = Math.min(scaleW, scaleH);
        const anchorOffsetX = _anchorX * width;
        const anchorOffsetY = _anchorY * height;
        p2[0] = p2[8] = p2[16] = p2[24] = -anchorOffsetX;
        p2[2] = p2[10] = p2[18] = p2[26] = _leftWidth * scale - anchorOffsetX;
        p2[4] = p2[12] = p2[20] = p2[28] = width - _rightWidth * scale - anchorOffsetX;
        p2[6] = p2[14] = p2[22] = p2[30] = width - anchorOffsetX;
        p2[1] = p2[3] = p2[5] = p2[7] = -anchorOffsetY;
        p2[9] = p2[11] = p2[13] = p2[15] = _topHeight * scale - anchorOffsetY;
        p2[17] = p2[19] = p2[21] = p2[23] = height - _bottomHeight * scale - anchorOffsetY;
        p2[25] = p2[27] = p2[29] = p2[31] = height - anchorOffsetY;
        this.getBuffer("aPosition").update();
      }
      /** Updates the UVs of the vertices. */
      updateUvs() {
        const uvs = this.uvs;
        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
        const _uvw = 1 / this._originalWidth;
        const _uvh = 1 / this._originalHeight;
        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
        this.getBuffer("aUV").update();
      }
    };
    _NineSliceGeometry.defaultOptions = {
      /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
      width: 100,
      /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
      height: 100,
      /** The width of the left column. */
      leftWidth: 10,
      /** The height of the top row. */
      topHeight: 10,
      /** The width of the right column. */
      rightWidth: 10,
      /** The height of the bottom row. */
      bottomHeight: 10,
      /** The original width of the texture */
      originalWidth: 100,
      /** The original height of the texture */
      originalHeight: 100
    };
    NineSliceGeometry = _NineSliceGeometry;
  }
});

// node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs
var NineSliceSpritePipe;
var init_NineSliceSpritePipe = __esm({
  "node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_PoolGroup();
    init_BatchableMesh();
    init_NineSliceGeometry();
    NineSliceSpritePipe = class {
      constructor(renderer) {
        this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
      }
      addRenderable(sprite, instructionSet) {
        const gpuSprite = this._getGpuSprite(sprite);
        if (sprite.didViewUpdate)
          this._updateBatchableSprite(sprite, gpuSprite);
        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
      }
      updateRenderable(sprite) {
        const gpuSprite = this._gpuSpriteHash[sprite.uid];
        if (sprite.didViewUpdate)
          this._updateBatchableSprite(sprite, gpuSprite);
        gpuSprite._batcher.updateElement(gpuSprite);
      }
      validateRenderable(sprite) {
        const gpuSprite = this._getGpuSprite(sprite);
        return !gpuSprite._batcher.checkAndUpdateTexture(
          gpuSprite,
          sprite._texture
        );
      }
      destroyRenderable(sprite) {
        const batchableMesh = this._gpuSpriteHash[sprite.uid];
        BigPool.return(batchableMesh.geometry);
        BigPool.return(batchableMesh);
        this._gpuSpriteHash[sprite.uid] = null;
        sprite.off("destroyed", this._destroyRenderableBound);
      }
      _updateBatchableSprite(sprite, batchableSprite) {
        batchableSprite.geometry.update(sprite);
        batchableSprite.setTexture(sprite._texture);
      }
      _getGpuSprite(sprite) {
        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
      }
      _initGPUSprite(sprite) {
        const batchableMesh = BigPool.get(BatchableMesh);
        batchableMesh.geometry = BigPool.get(NineSliceGeometry);
        batchableMesh.renderable = sprite;
        batchableMesh.transform = sprite.groupTransform;
        batchableMesh.texture = sprite._texture;
        batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
        this._gpuSpriteHash[sprite.uid] = batchableMesh;
        if (!sprite.didViewUpdate) {
          this._updateBatchableSprite(sprite, batchableMesh);
        }
        sprite.on("destroyed", this._destroyRenderableBound);
        return batchableMesh;
      }
      destroy() {
        for (const i3 in this._gpuSpriteHash) {
          const batchableMesh = this._gpuSpriteHash[i3];
          batchableMesh.geometry.destroy();
        }
        this._gpuSpriteHash = null;
        this._renderer = null;
      }
    };
    NineSliceSpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "nineSliceSprite"
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs
var init_init14 = __esm({
  "node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_NineSliceSpritePipe();
    extensions.add(NineSliceSpritePipe);
  }
});

// node_modules/pixi.js/lib/filters/FilterPipe.mjs
var FilterPipe;
var init_FilterPipe = __esm({
  "node_modules/pixi.js/lib/filters/FilterPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    FilterPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      push(filterEffect, container, instructionSet) {
        const renderPipes3 = this._renderer.renderPipes;
        renderPipes3.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "filter",
          canBundle: false,
          action: "pushFilter",
          container,
          filterEffect
        });
      }
      pop(_filterEffect, _container, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "filter",
          action: "popFilter",
          canBundle: false
        });
      }
      execute(instruction) {
        if (instruction.action === "pushFilter") {
          this._renderer.filter.push(instruction);
        } else if (instruction.action === "popFilter") {
          this._renderer.filter.pop();
        }
      }
      destroy() {
        this._renderer = null;
      }
    };
    FilterPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "filter"
    };
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs
function getGlobalRenderableBounds(renderables, bounds) {
  bounds.clear();
  const tempMatrix8 = bounds.matrix;
  for (let i3 = 0; i3 < renderables.length; i3++) {
    const renderable = renderables[i3];
    if (renderable.globalDisplayStatus < 7) {
      continue;
    }
    bounds.matrix = renderable.worldTransform;
    bounds.addBounds(renderable.bounds);
  }
  bounds.matrix = tempMatrix8;
  return bounds;
}
var init_getRenderableBounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/filters/FilterSystem.mjs
var quadGeometry, FilterSystem;
var init_FilterSystem = __esm({
  "node_modules/pixi.js/lib/filters/FilterSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Matrix();
    init_Point();
    init_BindGroup();
    init_Geometry();
    init_UniformGroup();
    init_Texture();
    init_TexturePool();
    init_types2();
    init_Bounds();
    init_getRenderableBounds();
    init_warn();
    quadGeometry = new Geometry({
      attributes: {
        aPosition: {
          buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          format: "float32x2",
          stride: 2 * 4,
          offset: 0
        }
      },
      indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
    });
    FilterSystem = class {
      constructor(renderer) {
        this._filterStackIndex = 0;
        this._filterStack = [];
        this._filterGlobalUniforms = new UniformGroup({
          uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
          uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
          uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
          uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
        });
        this._globalFilterBindGroup = new BindGroup({});
        this.renderer = renderer;
      }
      /**
       * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.
       * @readonly
       */
      get activeBackTexture() {
        return this._activeFilterData?.backTexture;
      }
      push(instruction) {
        const renderer = this.renderer;
        const filters = instruction.filterEffect.filters;
        if (!this._filterStack[this._filterStackIndex]) {
          this._filterStack[this._filterStackIndex] = this._getFilterData();
        }
        const filterData = this._filterStack[this._filterStackIndex];
        this._filterStackIndex++;
        if (filters.length === 0) {
          filterData.skip = true;
          return;
        }
        const bounds = filterData.bounds;
        if (instruction.renderables) {
          getGlobalRenderableBounds(instruction.renderables, bounds);
        } else if (instruction.filterEffect.filterArea) {
          bounds.clear();
          bounds.addRect(instruction.filterEffect.filterArea);
          bounds.applyMatrix(instruction.container.worldTransform);
        } else {
          instruction.container.getFastGlobalBounds(true, bounds);
        }
        if (instruction.container) {
          const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;
          const filterFrameTransform = renderGroup.cacheToLocalTransform;
          if (filterFrameTransform) {
            bounds.applyMatrix(filterFrameTransform);
          }
        }
        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
        let resolution = Infinity;
        let padding = 0;
        let antialias = true;
        let blendRequired = false;
        let enabled = false;
        let clipToViewport = true;
        for (let i3 = 0; i3 < filters.length; i3++) {
          const filter = filters[i3];
          resolution = Math.min(resolution, filter.resolution === "inherit" ? colorTextureSource._resolution : filter.resolution);
          padding += filter.padding;
          if (filter.antialias === "off") {
            antialias = false;
          } else if (filter.antialias === "inherit") {
            antialias && (antialias = colorTextureSource.antialias);
          }
          if (!filter.clipToViewport) {
            clipToViewport = false;
          }
          const isCompatible = !!(filter.compatibleRenderers & renderer.type);
          if (!isCompatible) {
            enabled = false;
            break;
          }
          if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
            warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
            enabled = false;
            break;
          }
          enabled = filter.enabled || enabled;
          blendRequired || (blendRequired = filter.blendRequired);
        }
        if (!enabled) {
          filterData.skip = true;
          return;
        }
        if (clipToViewport) {
          const viewPort = renderer.renderTarget.rootViewPort;
          const rootResolution = renderer.renderTarget.renderTarget.resolution;
          bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);
        }
        bounds.scale(resolution).ceil().scale(1 / resolution).pad(padding | 0);
        if (!bounds.isPositive) {
          filterData.skip = true;
          return;
        }
        filterData.skip = false;
        filterData.bounds = bounds;
        filterData.blendRequired = blendRequired;
        filterData.container = instruction.container;
        filterData.filterEffect = instruction.filterEffect;
        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;
        filterData.inputTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          resolution,
          antialias
        );
        renderer.renderTarget.bind(filterData.inputTexture, true);
        renderer.globalUniforms.push({
          offset: bounds
        });
      }
      pop() {
        const renderer = this.renderer;
        this._filterStackIndex--;
        const filterData = this._filterStack[this._filterStackIndex];
        if (filterData.skip) {
          return;
        }
        this._activeFilterData = filterData;
        const inputTexture = filterData.inputTexture;
        const bounds = filterData.bounds;
        let backTexture = Texture.EMPTY;
        renderer.renderTarget.finishRenderPass();
        if (filterData.blendRequired) {
          const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;
          const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);
          backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);
        }
        filterData.backTexture = backTexture;
        const filters = filterData.filterEffect.filters;
        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
        this._globalFilterBindGroup.setResource(backTexture.source, 3);
        renderer.globalUniforms.pop();
        if (filters.length === 1) {
          filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);
          TexturePool.returnTexture(inputTexture);
        } else {
          let flip = filterData.inputTexture;
          let flop = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            flip.source._resolution,
            false
          );
          let i3 = 0;
          for (i3 = 0; i3 < filters.length - 1; ++i3) {
            const filter = filters[i3];
            filter.apply(this, flip, flop, true);
            const t2 = flip;
            flip = flop;
            flop = t2;
          }
          filters[i3].apply(this, flip, filterData.previousRenderSurface, false);
          TexturePool.returnTexture(flip);
          TexturePool.returnTexture(flop);
        }
        if (filterData.blendRequired) {
          TexturePool.returnTexture(backTexture);
        }
      }
      getBackTexture(lastRenderSurface, bounds, previousBounds) {
        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
        const backTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          backgroundResolution,
          false
        );
        let x2 = bounds.minX;
        let y2 = bounds.minY;
        if (previousBounds) {
          x2 -= previousBounds.minX;
          y2 -= previousBounds.minY;
        }
        x2 = Math.floor(x2 * backgroundResolution);
        y2 = Math.floor(y2 * backgroundResolution);
        const width = Math.ceil(bounds.width * backgroundResolution);
        const height = Math.ceil(bounds.height * backgroundResolution);
        this.renderer.renderTarget.copyToTexture(
          lastRenderSurface,
          backTexture,
          { x: x2, y: y2 },
          { width, height },
          { x: 0, y: 0 }
        );
        return backTexture;
      }
      applyFilter(filter, input, output, clear) {
        const renderer = this.renderer;
        const filterData = this._filterStack[this._filterStackIndex];
        const bounds = filterData.bounds;
        const offset = Point.shared;
        const previousRenderSurface = filterData.previousRenderSurface;
        const isFinalTarget = previousRenderSurface === output;
        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
        let currentIndex = this._filterStackIndex - 1;
        while (currentIndex > 0 && this._filterStack[currentIndex].skip) {
          --currentIndex;
        }
        if (currentIndex > 0) {
          resolution = this._filterStack[currentIndex].inputTexture.source._resolution;
        }
        const filterUniforms = this._filterGlobalUniforms;
        const uniforms = filterUniforms.uniforms;
        const outputFrame = uniforms.uOutputFrame;
        const inputSize = uniforms.uInputSize;
        const inputPixel = uniforms.uInputPixel;
        const inputClamp = uniforms.uInputClamp;
        const globalFrame = uniforms.uGlobalFrame;
        const outputTexture = uniforms.uOutputTexture;
        if (isFinalTarget) {
          let lastIndex = this._filterStackIndex;
          while (lastIndex > 0) {
            lastIndex--;
            const filterData2 = this._filterStack[this._filterStackIndex - 1];
            if (!filterData2.skip) {
              offset.x = filterData2.bounds.minX;
              offset.y = filterData2.bounds.minY;
              break;
            }
          }
          outputFrame[0] = bounds.minX - offset.x;
          outputFrame[1] = bounds.minY - offset.y;
        } else {
          outputFrame[0] = 0;
          outputFrame[1] = 0;
        }
        outputFrame[2] = input.frame.width;
        outputFrame[3] = input.frame.height;
        inputSize[0] = input.source.width;
        inputSize[1] = input.source.height;
        inputSize[2] = 1 / inputSize[0];
        inputSize[3] = 1 / inputSize[1];
        inputPixel[0] = input.source.pixelWidth;
        inputPixel[1] = input.source.pixelHeight;
        inputPixel[2] = 1 / inputPixel[0];
        inputPixel[3] = 1 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
        inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
        globalFrame[0] = offset.x * resolution;
        globalFrame[1] = offset.y * resolution;
        globalFrame[2] = rootTexture.source.width * resolution;
        globalFrame[3] = rootTexture.source.height * resolution;
        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);
        renderer.renderTarget.bind(output, !!clear);
        if (output instanceof Texture) {
          outputTexture[0] = output.frame.width;
          outputTexture[1] = output.frame.height;
        } else {
          outputTexture[0] = renderTarget.width;
          outputTexture[1] = renderTarget.height;
        }
        outputTexture[2] = renderTarget.isRoot ? -1 : 1;
        filterUniforms.update();
        if (renderer.renderPipes.uniformBatch) {
          const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);
          this._globalFilterBindGroup.setResource(batchUniforms, 0);
        } else {
          this._globalFilterBindGroup.setResource(filterUniforms, 0);
        }
        this._globalFilterBindGroup.setResource(input.source, 1);
        this._globalFilterBindGroup.setResource(input.source.style, 2);
        filter.groups[0] = this._globalFilterBindGroup;
        renderer.encoder.draw({
          geometry: quadGeometry,
          shader: filter,
          state: filter._state,
          topology: "triangle-list"
        });
        if (renderer.type === RendererType.WEBGL) {
          renderer.renderTarget.finishRenderPass();
        }
      }
      _getFilterData() {
        return {
          skip: false,
          inputTexture: null,
          bounds: new Bounds(),
          container: null,
          filterEffect: null,
          blendRequired: false,
          previousRenderSurface: null
        };
      }
      /**
       * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
       *
       * Use `outputMatrix * vTextureCoord` in the shader.
       * @param outputMatrix - The matrix to output to.
       * @param {Sprite} sprite - The sprite to map to.
       * @returns The mapped matrix.
       */
      calculateSpriteMatrix(outputMatrix, sprite) {
        const data = this._activeFilterData;
        const mappedMatrix = outputMatrix.set(
          data.inputTexture._source.width,
          0,
          0,
          data.inputTexture._source.height,
          data.bounds.minX,
          data.bounds.minY
        );
        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;
        if (renderGroup && renderGroup.cacheToLocalTransform) {
          worldTransform.prepend(renderGroup.cacheToLocalTransform);
        }
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(
          1 / sprite.texture.frame.width,
          1 / sprite.texture.frame.height
        );
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
      }
    };
    FilterSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "filter"
    };
  }
});

// node_modules/pixi.js/lib/filters/init.mjs
var init_init15 = __esm({
  "node_modules/pixi.js/lib/filters/init.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_FilterPipe();
    init_FilterSystem();
    extensions.add(FilterSystem);
    extensions.add(FilterPipe);
  }
});

// node_modules/pixi.js/lib/environment-browser/browserAll.mjs
var browserAll_exports = {};
var init_browserAll = __esm({
  "node_modules/pixi.js/lib/environment-browser/browserAll.mjs"() {
    init_define_AnParams();
    init_init();
    init_init2();
    init_init3();
    init_init4();
    init_init5();
    init_init6();
    init_init7();
    init_init8();
    init_init9();
    init_init10();
    init_init11();
    init_init12();
    init_init13();
    init_init14();
    init_init15();
  }
});

// node_modules/pixi.js/lib/environment-browser/browserExt.mjs
var browserExt;
var init_browserExt = __esm({
  "node_modules/pixi.js/lib/environment-browser/browserExt.mjs"() {
    init_define_AnParams();
    init_Extensions();
    browserExt = {
      extension: {
        type: ExtensionType.Environment,
        name: "browser",
        priority: -1
      },
      test: () => true,
      load: async () => {
        await Promise.resolve().then(() => (init_browserAll(), browserAll_exports));
      }
    };
  }
});

// node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs
var webworkerAll_exports = {};
var init_webworkerAll = __esm({
  "node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs"() {
    init_define_AnParams();
    init_init2();
    init_init5();
    init_init6();
    init_init7();
    init_init8();
    init_init9();
    init_init10();
    init_init11();
    init_init12();
    init_init13();
    init_init14();
    init_init15();
  }
});

// node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs
var webworkerExt;
var init_webworkerExt = __esm({
  "node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs"() {
    init_define_AnParams();
    init_Extensions();
    webworkerExt = {
      extension: {
        type: ExtensionType.Environment,
        name: "webworker",
        priority: 0
      },
      test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,
      load: async () => {
        await Promise.resolve().then(() => (init_webworkerAll(), webworkerAll_exports));
      }
    };
  }
});

// node_modules/pixi.js/lib/filters/Filter.mjs
var _Filter, Filter;
var init_Filter = __esm({
  "node_modules/pixi.js/lib/filters/Filter.mjs"() {
    init_define_AnParams();
    init_GlProgram();
    init_GpuProgram();
    init_Shader();
    init_State();
    _Filter = class _Filter2 extends Shader {
      /**
       * @param options - The optional parameters of this filter.
       */
      constructor(options) {
        options = { ..._Filter2.defaultOptions, ...options };
        super(options);
        this.enabled = true;
        this._state = State.for2d();
        this.blendMode = options.blendMode;
        this.padding = options.padding;
        if (typeof options.antialias === "boolean") {
          this.antialias = options.antialias ? "on" : "off";
        } else {
          this.antialias = options.antialias;
        }
        this.resolution = options.resolution;
        this.blendRequired = options.blendRequired;
        this.clipToViewport = options.clipToViewport;
        this.addResource("uTexture", 0, 1);
      }
      /**
       * Applies the filter
       * @param filterManager - The renderer to retrieve the filter from
       * @param input - The input render target.
       * @param output - The target to output to.
       * @param clearMode - Should the output be cleared before rendering to it
       */
      apply(filterManager, input, output, clearMode) {
        filterManager.applyFilter(this, input, output, clearMode);
      }
      /**
       * Get the blend mode of the filter.
       * @default "normal"
       */
      get blendMode() {
        return this._state.blendMode;
      }
      /** Sets the blend mode of the filter. */
      set blendMode(value) {
        this._state.blendMode = value;
      }
      /**
       * A short hand function to create a filter based of a vertex and fragment shader src.
       * @param options
       * @returns A shiny new PixiJS filter!
       */
      static from(options) {
        const { gpu, gl, ...rest } = options;
        let gpuProgram3;
        let glProgram3;
        if (gpu) {
          gpuProgram3 = GpuProgram.from(gpu);
        }
        if (gl) {
          glProgram3 = GlProgram.from(gl);
        }
        return new _Filter2({
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          ...rest
        });
      }
    };
    _Filter.defaultOptions = {
      blendMode: "normal",
      resolution: 1,
      padding: 0,
      antialias: "off",
      blendRequired: false,
      clipToViewport: true
    };
    Filter = _Filter;
  }
});

// node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.mjs
var blendTemplateFrag;
var init_blend_template_frag = __esm({
  "node_modules/pixi.js/lib/filters/blend-modes/blend-template.frag.mjs"() {
    init_define_AnParams();
    blendTemplateFrag = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uBlend;\n\nuniform sampler2D uTexture;\nuniform sampler2D uBackTexture;\n\n{FUNCTIONS}\n\nvoid main()\n{ \n    vec4 back = texture(uBackTexture, vTextureCoord);\n    vec4 front = texture(uTexture, vTextureCoord);\n    float blendedAlpha = front.a + back.a * (1.0 - front.a);\n    \n    {MAIN}\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.mjs
var blendTemplateVert;
var init_blend_template_vert = __esm({
  "node_modules/pixi.js/lib/filters/blend-modes/blend-template.vert.mjs"() {
    init_define_AnParams();
    blendTemplateVert = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 backgroundUv;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.mjs
var blendTemplate;
var init_blend_template_wgsl = __esm({
  "node_modules/pixi.js/lib/filters/blend-modes/blend-template.wgsl.mjs"() {
    init_define_AnParams();
    blendTemplate = "\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct BlendUniforms {\n  uBlend:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n@group(0) @binding(3) var uBackTexture: texture_2d<f32>;\n\n@group(1) @binding(0) var<uniform> blendUniforms : BlendUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n{FUNCTIONS}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>\n) -> @location(0) vec4<f32> {\n\n\n   var back =  textureSample(uBackTexture, uSampler, uv);\n   var front = textureSample(uTexture, uSampler, uv);\n   var blendedAlpha = front.a + back.a * (1.0 - front.a);\n   \n   var out = vec4<f32>(0.0,0.0,0.0,0.0);\n\n   {MAIN}\n\n   return out;\n}";
  }
});

// node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs
function compileBlendModeShader(options) {
  const { source: source9, functions, main } = options;
  return source9.replace("{FUNCTIONS}", functions).replace("{MAIN}", main);
}
var BlendModeFilter;
var init_BlendModeFilter = __esm({
  "node_modules/pixi.js/lib/filters/blend-modes/BlendModeFilter.mjs"() {
    init_define_AnParams();
    init_GlProgram();
    init_GpuProgram();
    init_UniformGroup();
    init_Texture();
    init_Filter();
    init_blend_template_frag();
    init_blend_template_vert();
    init_blend_template_wgsl();
    BlendModeFilter = class extends Filter {
      constructor(options) {
        const gpuOptions = options.gpu;
        const gpuSource = compileBlendModeShader({ source: blendTemplate, ...gpuOptions });
        const gpuProgram3 = GpuProgram.from({
          vertex: {
            source: gpuSource,
            entryPoint: "mainVertex"
          },
          fragment: {
            source: gpuSource,
            entryPoint: "mainFragment"
          }
        });
        const glOptions = options.gl;
        const glSource = compileBlendModeShader({ source: blendTemplateFrag, ...glOptions });
        const glProgram3 = GlProgram.from({
          vertex: blendTemplateVert,
          fragment: glSource
        });
        const uniformGroup = new UniformGroup({
          uBlend: {
            value: 1,
            type: "f32"
          }
        });
        super({
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          blendRequired: true,
          resources: {
            blendUniforms: uniformGroup,
            uBackTexture: Texture.EMPTY
          }
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs
var hslgl;
var init_GLhls = __esm({
  "node_modules/pixi.js/lib/filters/blend-modes/hls/GLhls.mjs"() {
    "use strict";
    init_define_AnParams();
    hslgl = `
	float getLuminosity(vec3 c) {
		return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;
	}

	vec3 setLuminosity(vec3 c, float lum) {
		float modLum = lum - getLuminosity(c);
		vec3 color = c.rgb + vec3(modLum);

		// clip back into legal range
		modLum = getLuminosity(color);
		vec3 modLumVec = vec3(modLum);

		float cMin = min(color.r, min(color.g, color.b));
		float cMax = max(color.r, max(color.g, color.b));

		if(cMin < 0.0) {
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0) {
			color = mix(modLumVec, color, (1.0 - modLum) / (cMax - modLum));
		}

		return color;
	}

	float getSaturation(vec3 c) {
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	vec3 setSaturationMinMidMax(vec3 cSorted, float s) {
		vec3 colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x) {
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else {
			colorSorted.y = 0.0;
			colorSorted.z = 0.0;
		}

		colorSorted.x = 0.0;

		return colorSorted;
	}

	vec3 setSaturation(vec3 c, float s) {
		vec3 color = c;

		if(color.r <= color.g && color.r <= color.b) {
			if(color.g <= color.b) {
				color = setSaturationMinMidMax(color.rgb, s).rgb;
			}
			else {
				color = setSaturationMinMidMax(color.rbg, s).rbg;
			}
		}
		else if(color.g <= color.r && color.g <= color.b) {
			if(color.r <= color.b) {
				color = setSaturationMinMidMax(color.grb, s).grb;
			}
			else {
				color = setSaturationMinMidMax(color.gbr, s).gbr;
			}
		}
		else {
			// Using bgr for both fixes part of hue
			if(color.r <= color.g) {
				color = setSaturationMinMidMax(color.brg, s).brg;
			}
			else {
				color = setSaturationMinMidMax(color.bgr, s).bgr;
			}
		}

		return color;
	}
    `;
  }
});

// node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs
var hslgpu;
var init_GPUhls = __esm({
  "node_modules/pixi.js/lib/filters/blend-modes/hls/GPUhls.mjs"() {
    "use strict";
    init_define_AnParams();
    hslgpu = `
	fn getLuminosity(c: vec3<f32>) -> f32
	{
		return 0.3*c.r + 0.59*c.g + 0.11*c.b;
	}

	fn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32>
	{
		var modLum: f32 = lum - getLuminosity(c);
		var color: vec3<f32> = c.rgb + modLum;

		// clip back into legal range
		modLum = getLuminosity(color);
		let modLumVec = vec3<f32>(modLum);

		let cMin: f32 = min(color.r, min(color.g, color.b));
		let cMax: f32 = max(color.r, max(color.g, color.b));

		if(cMin < 0.0)
		{
			color = mix(modLumVec, color, modLum / (modLum - cMin));
		}

		if(cMax > 1.0)
		{
			color = mix(modLumVec, color, (1 - modLum) / (cMax - modLum));
		}

		return color;
	}

	fn getSaturation(c: vec3<f32>) -> f32
	{
		return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));
	}

	fn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32>
	{
		var colorSorted = cSorted;

		if(colorSorted.z > colorSorted.x)
		{
			colorSorted.y = (((colorSorted.y - colorSorted.x) * s) / (colorSorted.z - colorSorted.x));
			colorSorted.z = s;
		}
		else
		{
			colorSorted.y = 0;
			colorSorted.z = 0;
		}

		colorSorted.x = 0;

		return colorSorted;
	}

	fn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32>
	{
		var color = c;

		if (color.r <= color.g && color.r <= color.b)
		{
			if (color.g <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rgb, s)).rgb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.rbg, s)).rbg;
			}
		}
		else if (color.g <= color.r && color.g <= color.b)
		{
			if (color.r <= color.b)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.grb, s)).grb;
			}
			else
			{
				color = vec3<f32>(setSaturationMinMidMax(color.gbr, s)).gbr;
			}
		}
		else
		{
			// Using bgr for both fixes part of hue
			if (color.r <= color.g)
			{
				color = vec3<f32>(setSaturationMinMidMax(color.brg, s)).brg;
			}
			else
			{
				color  = vec3<f32>(setSaturationMinMidMax(color.bgr, s)).bgr;
			}
		}

		return color;
	}
	`;
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.mjs
var ColorBlend;
var init_ColorBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/ColorBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    init_GLhls();
    init_GPUhls();
    ColorBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                ${hslgl}

                vec3 blendColor(vec3 base, vec3 blend,  float opacity)
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                finalColor = vec4(blendColor(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                ${hslgpu}

                fn blendColorOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (setLuminosity(blend, getLuminosity(base)) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendColorOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
          }
        });
      }
    };
    ColorBlend.extension = {
      name: "color",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.mjs
var ColorBurnBlend;
var init_ColorBurnBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/ColorBurnBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    ColorBurnBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0 - ((1.0 - base) / blend)), 0.0);
                }

                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                finalColor = vec4(blendColorBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
          },
          gpu: {
            functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorBurn(base.r, blend.r),
                        colorBurn(base.g, blend.g),
                        colorBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
          }
        });
      }
    };
    ColorBurnBlend.extension = {
      name: "color-burn",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.mjs
var ColorDodgeBlend;
var init_ColorDodgeBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/ColorDodgeBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    ColorDodgeBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float colorDodge(float base, float blend)
                {
                    return base / (1.0 - blend);
                }

                vec3 blendColorDodge(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                finalColor = vec4(blendColorDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return base / (1.0 - blend);
                }

                fn blendColorDodge(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        colorDodge(base.r, blend.r),
                        colorDodge(base.g, blend.g),
                        colorDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                    out = vec4<f32>(blendColorDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
          }
        });
      }
    };
    ColorDodgeBlend.extension = {
      name: "color-dodge",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.mjs
var DarkenBlend;
var init_DarkenBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/DarkenBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    DarkenBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 blendDarken(vec3 base, vec3 blend, float opacity)
                {
                    return (min(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                finalColor = vec4(blendDarken(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                fn blendDarken(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (min(blend,base) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendDarken(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
          }
        });
      }
    };
    DarkenBlend.extension = {
      name: "darken",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.mjs
var DifferenceBlend;
var init_DifferenceBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/DifferenceBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    DifferenceBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 blendDifference(vec3 base, vec3 blend,  float opacity)
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                finalColor = vec4(blendDifference(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
          },
          gpu: {
            functions: `
                fn blendDifference(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (abs(blend - base) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendDifference(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
          }
        });
      }
    };
    DifferenceBlend.extension = {
      name: "difference",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.mjs
var DivideBlend;
var init_DivideBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/DivideBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    DivideBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float divide(float base, float blend)
                {
                    return (blend > 0.0) ? clamp(base / blend, 0.0, 1.0) : 1.0;
                }

                vec3 blendDivide(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                finalColor = vec4(blendDivide(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                fn divide(base: f32, blend: f32) -> f32
                {
                    return select(1.0, clamp(base / blend, 0.0, 1.0), blend > 0.0);
                }

                fn blendDivide(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        divide(base.r, blend.r),
                        divide(base.g, blend.g),
                        divide(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendDivide(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
          }
        });
      }
    };
    DivideBlend.extension = {
      name: "divide",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.mjs
var ExclusionBlend;
var init_ExclusionBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/ExclusionBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    ExclusionBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 exclusion(vec3 base, vec3 blend)
                {
                    return base + blend - 2.0 * base * blend;
                }

                vec3 blendExclusion(vec3 base, vec3 blend, float opacity)
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                finalColor = vec4(blendExclusion(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                fn exclusion(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return base+blend-2.0*base*blend;
                }

                fn blendExclusion(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (exclusion(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendExclusion(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
          }
        });
      }
    };
    ExclusionBlend.extension = {
      name: "exclusion",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.mjs
var HardLightBlend;
var init_HardLightBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/HardLightBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    HardLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float hardLight(float base, float blend)
                {
                    return (blend < 0.5) ? 2.0 * base * blend : 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);
                }

                vec3 blendHardLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                finalColor = vec4(blendHardLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
          },
          gpu: {
            functions: `
                fn hardLight(base: f32, blend: f32) -> f32
                {
                    return select(1.0 - 2.0 * (1.0 - base) * (1.0 - blend), 2.0 * base * blend, blend < 0.5);
                }

                fn blendHardLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        hardLight(base.r, blend.r),
                        hardLight(base.g, blend.g),
                        hardLight(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendHardLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
          }
        });
      }
    };
    HardLightBlend.extension = {
      name: "hard-light",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.mjs
var HardMixBlend;
var init_HardMixBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/HardMixBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    HardMixBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float hardMix(float base, float blend)
                {
                    return (base + blend >= 1.0) ? 1.0 : 0.0;
                }

                vec3 blendHardMix(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blended = vec3(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                finalColor = vec4(blendHardMix(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
          },
          gpu: {
            functions: `
                fn hardMix(base: f32, blend: f32) -> f32
                {
                    return select(0.0, 1.0, base + blend >= 1.0);
                }

                fn blendHardMix(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        hardMix(base.r, blend.r),
                        hardMix(base.g, blend.g),
                        hardMix(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendHardMix(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
          }
        });
      }
    };
    HardMixBlend.extension = {
      name: "hard-mix",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.mjs
var LightenBlend;
var init_LightenBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/LightenBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    LightenBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 blendLighten(vec3 base, vec3 blend, float opacity)
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                finalColor = vec4(blendLighten(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                fn blendLighten(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    return (max(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendLighten(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
          }
        });
      }
    };
    LightenBlend.extension = {
      name: "lighten",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.mjs
var LinearBurnBlend;
var init_LinearBurnBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/LinearBurnBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    LinearBurnBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float linearBurn(float base, float blend)
                {
                    return max(0.0, base + blend - 1.0);
                }

                vec3 blendLinearBurn(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                finalColor = vec4(blendLinearBurn(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn blendLinearBurn(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearBurn(base.r, blend.r),
                        linearBurn(base.g, blend.g),
                        linearBurn(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendLinearBurn(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
          }
        });
      }
    };
    LinearBurnBlend.extension = {
      name: "linear-burn",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.mjs
var LinearDodgeBlend;
var init_LinearDodgeBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/LinearDodgeBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    LinearDodgeBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                vec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                finalColor = vec4(blendLinearDodge(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1, base + blend);
                }

                fn blendLinearDodge(base:vec3<f32>, blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearDodge(base.r, blend.r),
                        linearDodge(base.g, blend.g),
                        linearDodge(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendLinearDodge(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
          }
        });
      }
    };
    LinearDodgeBlend.extension = {
      name: "linear-dodge",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.mjs
var LinearLightBlend;
var init_LinearLightBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/LinearLightBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    LinearLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float linearBurn(float base, float blend) {
                    return max(0.0, base + blend - 1.0);
                }

                float linearDodge(float base, float blend) {
                    return min(1.0, base + blend);
                }

                float linearLight(float base, float blend) {
                    return (blend <= 0.5) ? linearBurn(base,2.0*blend) : linearBurn(base,2.0*(blend-0.5));
                }

                vec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {
                    vec3 blended = vec3(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                finalColor = vec4(blendLinearLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                fn linearBurn(base: f32, blend: f32) -> f32
                {
                    return max(0.0, base + blend - 1.0);
                }

                fn linearDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base + blend);
                }

                fn linearLight(base: f32, blend: f32) -> f32
                {
                    return select(linearBurn(base,2.0*(blend-0.5)), linearBurn(base,2.0*blend), blend <= 0.5);
                }

                fn blendLinearLightOpacity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        linearLight(base.r, blend.r),
                        linearLight(base.g, blend.g),
                        linearLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendLinearLightOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
          }
        });
      }
    };
    LinearLightBlend.extension = {
      name: "linear-light",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.mjs
var LuminosityBlend;
var init_LuminosityBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/LuminosityBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    init_GLhls();
    init_GPUhls();
    LuminosityBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                ${hslgl}

                vec3 blendLuminosity(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendLuminosity = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                finalColor = vec4(blendLuminosity(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                ${hslgpu}

                fn blendLuminosity(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendLuminosity: vec3<f32> = setLuminosity(base, getLuminosity(blend));
                    return (blendLuminosity * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendLuminosity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
          }
        });
      }
    };
    LuminosityBlend.extension = {
      name: "luminosity",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.mjs
var NegationBlend;
var init_NegationBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/NegationBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    NegationBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                vec3 negation(vec3 base, vec3 blend)
                {
                    return 1.0-abs(1.0-base-blend);
                }

                vec3 blendNegation(vec3 base, vec3 blend, float opacity)
                {
                    return (negation(base, blend) * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                finalColor = vec4(blendNegation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                fn blendNegation(base: vec3<f32>, blend: vec3<f32>) -> vec3<f32>
                {
                    return 1.0-abs(1.0-base-blend);
                }

                fn blendNegationOpacity(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    return (blendNegation(base, blend) * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendNegationOpacity(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
          }
        });
      }
    };
    NegationBlend.extension = {
      name: "negation",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.mjs
var OverlayBlend;
var init_OverlayBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/OverlayBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    OverlayBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float overlay(float base, float blend)
                {
                    return (base < 0.5) ? (2.0*base*blend) : (1.0-2.0*(1.0-base)*(1.0-blend));
                }

                vec3 blendOverlay(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );
   
                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                finalColor = vec4(blendOverlay(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                fn overlay(base: f32, blend: f32) -> f32
                {
                    return select((1.0-2.0*(1.0-base)*(1.0-blend)), (2.0*base*blend), base < 0.5);
                }

                fn blendOverlay(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        overlay(base.r, blend.r),
                        overlay(base.g, blend.g),
                        overlay(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendOverlay(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
          }
        });
      }
    };
    OverlayBlend.extension = {
      name: "overlay",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.mjs
var PinLightBlend;
var init_PinLightBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/PinLightBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    PinLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float pinLight(float base, float blend)
                {
                    return (blend <= 0.5) ? min(base, 2.0 * blend) : max(base, 2.0 * (blend - 0.5));
                }

                vec3 blendPinLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                finalColor = vec4(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                fn pinLight(base: f32, blend: f32) -> f32
                {
                    return select(max(base,2.0*(blend-0.5)), min(base,2.0*blend), blend <= 0.5);
                }

                fn blendPinLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        pinLight(base.r, blend.r),
                        pinLight(base.g, blend.g),
                        pinLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendPinLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
          }
        });
      }
    };
    PinLightBlend.extension = {
      name: "pin-light",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.mjs
var SaturationBlend;
var init_SaturationBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/SaturationBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    init_GLhls();
    init_GPUhls();
    SaturationBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                ${hslgl}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                finalColor = vec4(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
            `
          },
          gpu: {
            functions: `
                ${hslgpu}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                out = vec4<f32>(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
            `
          }
        });
      }
    };
    SaturationBlend.extension = {
      name: "saturation",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.mjs
var SoftLightBlend;
var init_SoftLightBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/SoftLightBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    SoftLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float softLight(float base, float blend)
                {
                    return (blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend));
                }

                vec3 blendSoftLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                finalColor = vec4(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                fn softLight(base: f32, blend: f32) -> f32
                {
                    return select(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), blend < 0.5);
                }

                fn blendSoftLight(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        softLight(base.r, blend.r),
                        softLight(base.g, blend.g),
                        softLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendSoftLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
          }
        });
      }
    };
    SoftLightBlend.extension = {
      name: "soft-light",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.mjs
var SubtractBlend;
var init_SubtractBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/SubtractBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    SubtractBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float subtract(float base, float blend)
                {
                    return max(0.0, base - blend);
                }

                vec3 blendSubtract(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                finalColor = vec4(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;
                `
          },
          gpu: {
            functions: `
                fn subtract(base: f32, blend: f32) -> f32
                {
                    return max(0, base - blend);
                }

                fn blendSubtract(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blended = vec3<f32>(
                        subtract(base.r, blend.r),
                        subtract(base.g, blend.g),
                        subtract(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendSubtract(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
          }
        });
      }
    };
    SubtractBlend.extension = {
      name: "subtract",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.mjs
var VividLightBlend;
var init_VividLightBlend = __esm({
  "node_modules/pixi.js/lib/advanced-blend-modes/VividLightBlend.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_BlendModeFilter();
    VividLightBlend = class extends BlendModeFilter {
      constructor() {
        super({
          gl: {
            functions: `
                float colorBurn(float base, float blend)
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                float colorDodge(float base, float blend)
                {
                    return min(1.0, base / (1.0-blend));
                }

                float vividLight(float base, float blend)
                {
                    return (blend < 0.5) ? colorBurn(base,(2.0*blend)) : colorDodge(base,(2.0*(blend-0.5)));
                }

                vec3 blendVividLight(vec3 base, vec3 blend, float opacity)
                {
                    vec3 blended = vec3(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
            `,
            main: `
                finalColor = vec4(blendVividLight(back.rgb, front.rgb,front.a), blendedAlpha) * uBlend;
            `
          },
          gpu: {
            functions: `
                fn colorBurn(base:f32, blend:f32) -> f32
                {
                    return max((1.0-((1.0-base)/blend)),0.0);
                }

                fn colorDodge(base: f32, blend: f32) -> f32
                {
                    return min(1.0, base / (1.0-blend));
                }

                fn vividLight(base: f32, blend: f32) -> f32
                {
                    return select(colorDodge(base,(2.0*(blend-0.5))), colorBurn(base,(2.0*blend)), blend<0.5);
                }

                fn blendVividLight(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>
                {
                    let blended: vec3<f32> = vec3<f32>(
                        vividLight(base.r, blend.r),
                        vividLight(base.g, blend.g),
                        vividLight(base.b, blend.b)
                    );

                    return (blended * opacity + base * (1.0 - opacity));
                }
                `,
            main: `
                out = vec4<f32>(blendVividLight(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;
                `
          }
        });
      }
    };
    VividLightBlend.extension = {
      name: "vivid-light",
      type: ExtensionType.BlendMode
    };
  }
});

// node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs
async function loadEnvironmentExtensions(skip) {
  if (skip)
    return;
  for (let i3 = 0; i3 < environments.length; i3++) {
    const env = environments[i3];
    if (env.value.test()) {
      await env.value.load();
      return;
    }
  }
}
async function autoDetectEnvironment(add) {
  return loadEnvironmentExtensions(!add);
}
var environments;
var init_autoDetectEnvironment = __esm({
  "node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs"() {
    init_define_AnParams();
    init_Extensions();
    environments = [];
    extensions.handleByNamedList(ExtensionType.Environment, environments);
  }
});

// node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (_e) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var unsafeEval;
var init_unsafeEvalSupported = __esm({
  "node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs
var CLEAR;
var init_const7 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs"() {
    "use strict";
    init_define_AnParams();
    CLEAR = /* @__PURE__ */ ((CLEAR2) => {
      CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
      CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
      CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
      CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
      CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
      CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
      CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
      CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
      return CLEAR2;
    })(CLEAR || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs
var SystemRunner;
var init_SystemRunner = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs"() {
    "use strict";
    init_define_AnParams();
    SystemRunner = class {
      /**
       * @param name - The function name that will be executed on the listeners added to this Runner.
       */
      constructor(name) {
        this.items = [];
        this._name = name;
      }
      /* jsdoc/check-param-names */
      /**
       * Dispatch/Broadcast Runner to all listeners added to the queue.
       * @param {...any} params - (optional) parameters to pass to each listener
       */
      /* jsdoc/check-param-names */
      emit(a0, a1, a2, a3, a4, a5, a6, a7) {
        const { name, items } = this;
        for (let i3 = 0, len = items.length; i3 < len; i3++) {
          items[i3][name](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        return this;
      }
      /**
       * Add a listener to the Runner
       *
       * Runners do not need to have scope or functions passed to them.
       * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
       * as the name provided to the Runner when it was created.
       *
       * Eg A listener passed to this Runner will require a 'complete' function.
       *
       * ```
       * import { Runner } from 'pixi.js';
       *
       * const complete = new Runner('complete');
       * ```
       *
       * The scope used will be the object itself.
       * @param {any} item - The object that will be listening.
       */
      add(item) {
        if (item[this._name]) {
          this.remove(item);
          this.items.push(item);
        }
        return this;
      }
      /**
       * Remove a single listener from the dispatch queue.
       * @param {any} item - The listener that you would like to remove.
       */
      remove(item) {
        const index = this.items.indexOf(item);
        if (index !== -1) {
          this.items.splice(index, 1);
        }
        return this;
      }
      /**
       * Check to see if the listener is already in the Runner
       * @param {any} item - The listener that you would like to check.
       */
      contains(item) {
        return this.items.indexOf(item) !== -1;
      }
      /** Remove all listeners from the Runner */
      removeAll() {
        this.items.length = 0;
        return this;
      }
      /** Remove all references, don't use after this. */
      destroy() {
        this.removeAll();
        this.items = null;
        this._name = null;
      }
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get empty() {
        return this.items.length === 0;
      }
      /**
       * The name of the runner.
       * @readonly
       */
      get name() {
        return this._name;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
var defaultRunners, _AbstractRenderer, AbstractRenderer;
var init_AbstractRenderer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs"() {
    init_define_AnParams();
    init_Color();
    init_autoDetectEnvironment();
    init_Container();
    init_unsafeEvalSupported();
    init_deprecation();
    init_const7();
    init_SystemRunner();
    init_eventemitter3();
    defaultRunners = [
      "init",
      "destroy",
      "contextChange",
      "resolutionChange",
      "resetState",
      "renderEnd",
      "renderStart",
      "render",
      "update",
      "postrender",
      "prerender"
    ];
    _AbstractRenderer = class _AbstractRenderer2 extends eventemitter3_default {
      /**
       * Set up a system with a collection of SystemClasses and runners.
       * Systems are attached dynamically to this class when added.
       * @param config - the config for the system manager
       */
      constructor(config2) {
        super();
        this.runners = /* @__PURE__ */ Object.create(null);
        this.renderPipes = /* @__PURE__ */ Object.create(null);
        this._initOptions = {};
        this._systemsHash = /* @__PURE__ */ Object.create(null);
        this.type = config2.type;
        this.name = config2.name;
        this.config = config2;
        const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];
        this._addRunners(...combinedRunners);
        this._unsafeEvalCheck();
      }
      /**
       * Initialize the renderer.
       * @param options - The options to use to create the renderer.
       */
      async init(options = {}) {
        const skip = options.skipExtensionImports === true ? true : options.manageImports === false;
        await loadEnvironmentExtensions(skip);
        this._addSystems(this.config.systems);
        this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
        for (const systemName in this._systemsHash) {
          const system = this._systemsHash[systemName];
          const defaultSystemOptions = system.constructor.defaultOptions;
          options = { ...defaultSystemOptions, ...options };
        }
        options = { ..._AbstractRenderer2.defaultOptions, ...options };
        this._roundPixels = options.roundPixels ? 1 : 0;
        for (let i3 = 0; i3 < this.runners.init.items.length; i3++) {
          await this.runners.init.items[i3].init(options);
        }
        this._initOptions = options;
      }
      render(args, deprecated) {
        let options = args;
        if (options instanceof Container) {
          options = { container: options };
          if (deprecated) {
            deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
            options.target = deprecated.renderTexture;
          }
        }
        options.target || (options.target = this.view.renderTarget);
        if (options.target === this.view.renderTarget) {
          this._lastObjectRendered = options.container;
          options.clearColor ?? (options.clearColor = this.background.colorRgba);
          options.clear ?? (options.clear = this.background.clearBeforeRender);
        }
        if (options.clearColor) {
          const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
          options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();
        }
        if (!options.transform) {
          options.container.updateLocalTransform();
          options.transform = options.container.localTransform;
        }
        options.container.enableRenderGroup();
        this.runners.prerender.emit(options);
        this.runners.renderStart.emit(options);
        this.runners.render.emit(options);
        this.runners.renderEnd.emit(options);
        this.runners.postrender.emit(options);
      }
      /**
       * Resizes the WebGL view to the specified width and height.
       * @param desiredScreenWidth - The desired width of the screen.
       * @param desiredScreenHeight - The desired height of the screen.
       * @param resolution - The resolution / device pixel ratio of the renderer.
       */
      resize(desiredScreenWidth, desiredScreenHeight, resolution) {
        const previousResolution = this.view.resolution;
        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
        this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);
        if (resolution !== void 0 && resolution !== previousResolution) {
          this.runners.resolutionChange.emit(resolution);
        }
      }
      clear(options = {}) {
        const renderer = this;
        options.target || (options.target = renderer.renderTarget.renderTarget);
        options.clearColor || (options.clearColor = this.background.colorRgba);
        options.clear ?? (options.clear = CLEAR.ALL);
        const { clear, clearColor, target } = options;
        Color.shared.setValue(clearColor ?? this.background.colorRgba);
        renderer.renderTarget.clear(target, clear, Color.shared.toArray());
      }
      /** The resolution / device pixel ratio of the renderer. */
      get resolution() {
        return this.view.resolution;
      }
      set resolution(value) {
        this.view.resolution = value;
        this.runners.resolutionChange.emit(value);
      }
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       * @member {number}
       * @readonly
       * @default 800
       */
      get width() {
        return this.view.texture.frame.width;
      }
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       * @default 600
       */
      get height() {
        return this.view.texture.frame.height;
      }
      // NOTE: this was `view` in v7
      /**
       * The canvas element that everything is drawn to.
       * @type {environment.ICanvas}
       */
      get canvas() {
        return this.view.canvas;
      }
      /**
       * the last object rendered by the renderer. Useful for other plugins like interaction managers
       * @readonly
       */
      get lastObjectRendered() {
        return this._lastObjectRendered;
      }
      /**
       * Flag if we are rendering to the screen vs renderTexture
       * @readonly
       * @default true
       */
      get renderingToScreen() {
        const renderer = this;
        return renderer.renderTarget.renderingToScreen;
      }
      /**
       * Measurements of the screen. (0, 0, screenWidth, screenHeight).
       *
       * Its safe to use as filterArea or hitArea for the whole stage.
       */
      get screen() {
        return this.view.screen;
      }
      /**
       * Create a bunch of runners based of a collection of ids
       * @param runnerIds - the runner ids to add
       */
      _addRunners(...runnerIds) {
        runnerIds.forEach((runnerId) => {
          this.runners[runnerId] = new SystemRunner(runnerId);
        });
      }
      _addSystems(systems3) {
        let i3;
        for (i3 in systems3) {
          const val = systems3[i3];
          this._addSystem(val.value, val.name);
        }
      }
      /**
       * Add a new system to the renderer.
       * @param ClassRef - Class reference
       * @param name - Property name for system, if not specified
       *        will use a static `name` property on the class itself. This
       *        name will be assigned as s property on the Renderer so make
       *        sure it doesn't collide with properties on Renderer.
       * @returns Return instance of renderer
       */
      _addSystem(ClassRef, name) {
        const system = new ClassRef(this);
        if (this[name]) {
          throw new Error(`Whoops! The name "${name}" is already in use`);
        }
        this[name] = system;
        this._systemsHash[name] = system;
        for (const i3 in this.runners) {
          this.runners[i3].add(system);
        }
        return this;
      }
      _addPipes(pipes, pipeAdaptors) {
        const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
          acc[adaptor.name] = adaptor.value;
          return acc;
        }, {});
        pipes.forEach((pipe) => {
          const PipeClass = pipe.value;
          const name = pipe.name;
          const Adaptor = adaptors[name];
          this.renderPipes[name] = new PipeClass(
            this,
            Adaptor ? new Adaptor() : null
          );
        });
      }
      destroy(options = false) {
        this.runners.destroy.items.reverse();
        this.runners.destroy.emit(options);
        Object.values(this.runners).forEach((runner) => {
          runner.destroy();
        });
        this._systemsHash = null;
        this.renderPipes = null;
      }
      /**
       * Generate a texture from a container.
       * @param options - options or container target to use when generating the texture
       * @returns a texture
       */
      generateTexture(options) {
        return this.textureGenerator.generateTexture(options);
      }
      /**
       * Whether the renderer will round coordinates to whole pixels when rendering.
       * Can be overridden on a per scene item basis.
       */
      get roundPixels() {
        return !!this._roundPixels;
      }
      /**
       * Overridable function by `pixi.js/unsafe-eval` to silence
       * throwing an error if platform doesn't support unsafe-evals.
       * @private
       * @ignore
       */
      _unsafeEvalCheck() {
        if (!unsafeEvalSupported()) {
          throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
        }
      }
      /**
       * Resets the rendering state of the renderer.
       * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state
       * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi
       * render will reset all internal caches and ensure it executes correctly.
       *
       * This is particularly useful when combining PixiJS with other rendering engines like Three.js:
       * ```js
       * // Reset Three.js state
       * threeRenderer.resetState();
       *
       * // Render a Three.js scene
       * threeRenderer.render(threeScene, threeCamera);
       *
       * // Reset PixiJS state since Three.js modified the WebGL context
       * pixiRenderer.resetState();
       *
       * // Now render Pixi content
       * pixiRenderer.render(pixiScene);
       * ```
       */
      resetState() {
        this.runners.resetState.emit();
      }
    };
    _AbstractRenderer.defaultOptions = {
      /**
       * Default resolution / device pixel ratio of the renderer.
       * @default 1
       */
      resolution: 1,
      /**
       * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
       * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
       * performance issues when using WebGL.
       *
       * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
       * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
       * driver version blacklisted by the
       * browser.
       *
       * If your application requires high performance rendering, you may wish to set this to false.
       * We recommend one of two options if you decide to set this flag to false:
       *
       * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
       *    not supported.
       *
       * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
       *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
       *    device & browser combination does not support high performance WebGL.
       *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
       * @default false
       */
      failIfMajorPerformanceCaveat: false,
      /**
       * Should round pixels be forced when rendering?
       * @default false
       */
      roundPixels: false
    };
    AbstractRenderer = _AbstractRenderer;
  }
});

// node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs
function isWebGLSupported(failIfMajorPerformanceCaveat) {
  if (_isWebGLSupported !== void 0)
    return _isWebGLSupported;
  _isWebGLSupported = (() => {
    const contextOptions = {
      stencil: true,
      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    };
    try {
      if (!DOMAdapter.get().getWebGLRenderingContext()) {
        return false;
      }
      const canvas = DOMAdapter.get().createCanvas();
      let gl = canvas.getContext("webgl", contextOptions);
      const success = !!gl?.getContextAttributes()?.stencil;
      if (gl) {
        const loseContext = gl.getExtension("WEBGL_lose_context");
        if (loseContext) {
          loseContext.loseContext();
        }
      }
      gl = null;
      return success;
    } catch (_e) {
      return false;
    }
  })();
  return _isWebGLSupported;
}
var _isWebGLSupported;
var init_isWebGLSupported = __esm({
  "node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_AbstractRenderer();
  }
});

// node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs
async function isWebGPUSupported(options = {}) {
  if (_isWebGPUSupported !== void 0)
    return _isWebGPUSupported;
  _isWebGPUSupported = await (async () => {
    const gpu = DOMAdapter.get().getNavigator().gpu;
    if (!gpu) {
      return false;
    }
    try {
      const adapter = await gpu.requestAdapter(options);
      await adapter.requestDevice();
      return true;
    } catch (_e) {
      return false;
    }
  })();
  return _isWebGPUSupported;
}
var _isWebGPUSupported;
var init_isWebGPUSupported = __esm({
  "node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs"() {
    init_define_AnParams();
    init_adapter();
  }
});

// node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs
var GpuGraphicsAdaptor;
var init_GpuGraphicsAdaptor = __esm({
  "node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Matrix();
    init_maxRecommendedTextures();
    init_getTextureBatchBindGroup();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_localUniformBit();
    init_roundPixelsBit();
    init_Shader();
    init_UniformGroup();
    GpuGraphicsAdaptor = class {
      init() {
        const localUniforms = new UniformGroup({
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uRound: { value: 0, type: "f32" }
        });
        const gpuProgram3 = compileHighShaderGpuProgram({
          name: "graphics",
          bits: [
            colorBit,
            generateTextureBatchBit(getMaxTexturesPerBatch()),
            localUniformBitGroup2,
            roundPixelsBit
          ]
        });
        this.shader = new Shader({
          gpuProgram: gpuProgram3,
          resources: {
            // added on the fly!
            localUniforms
          }
        });
      }
      execute(graphicsPipe, renderable) {
        const context2 = renderable.context;
        const shader = context2.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        const {
          batcher,
          instructions
        } = contextSystem.getContextRenderData(context2);
        const encoder = renderer.encoder;
        encoder.setGeometry(batcher.geometry, shader.gpuProgram);
        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
        const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
        const batches = instructions.instructions;
        let topology = null;
        for (let i3 = 0; i3 < instructions.instructionSize; i3++) {
          const batch = batches[i3];
          if (batch.topology !== topology) {
            topology = batch.topology;
            encoder.setPipelineFromGeometryProgramAndState(
              batcher.geometry,
              shader.gpuProgram,
              graphicsPipe.state,
              batch.topology
            );
          }
          shader.groups[1] = batch.bindGroup;
          if (!batch.gpuBindGroup) {
            const textureBatch = batch.textures;
            batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
            batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
              batch.bindGroup,
              shader.gpuProgram,
              1
            );
          }
          encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
          encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
        }
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GpuGraphicsAdaptor.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "graphics"
    };
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs
var textureBit, textureBitGl;
var init_textureBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs"() {
    "use strict";
    init_define_AnParams();
    textureBit = {
      name: "texture-bit",
      vertex: {
        header: (
          /* wgsl */
          `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `
        ),
        main: (
          /* wgsl */
          `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        )
      },
      fragment: {
        header: (
          /* wgsl */
          `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `
        ),
        main: (
          /* wgsl */
          `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
        )
      }
    };
    textureBitGl = {
      name: "texture-bit",
      vertex: {
        header: (
          /* glsl */
          `
            uniform mat3 uTextureMatrix;
        `
        ),
        main: (
          /* glsl */
          `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        )
      },
      fragment: {
        header: (
          /* glsl */
          `
        uniform sampler2D uTexture;

         
        `
        ),
        main: (
          /* glsl */
          `
            outColor = texture(uTexture, vUV);
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs
var GpuMeshAdapter;
var init_GpuMeshAdapter = __esm({
  "node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Matrix();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_textureBit();
    init_Shader();
    init_Texture();
    init_warn();
    GpuMeshAdapter = class {
      init() {
        const gpuProgram3 = compileHighShaderGpuProgram({
          name: "mesh",
          bits: [
            localUniformBit,
            textureBit,
            roundPixelsBit
          ]
        });
        this._shader = new Shader({
          gpuProgram: gpuProgram3,
          resources: {
            uTexture: Texture.EMPTY._source,
            uSampler: Texture.EMPTY._source.style,
            textureUniforms: {
              uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
            }
          }
        });
      }
      execute(meshPipe, mesh) {
        const renderer = meshPipe.renderer;
        let shader = mesh._shader;
        if (!shader) {
          shader = this._shader;
          shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);
        } else if (!shader.gpuProgram) {
          warn("Mesh shader has no gpuProgram", mesh.shader);
          return;
        }
        const gpuProgram3 = shader.gpuProgram;
        if (gpuProgram3.autoAssignGlobalUniforms) {
          shader.groups[0] = renderer.globalUniforms.bindGroup;
        }
        if (gpuProgram3.autoAssignLocalUniforms) {
          const localUniforms = meshPipe.localUniforms;
          shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
        }
        renderer.encoder.draw({
          geometry: mesh._geometry,
          shader,
          state: mesh.state
        });
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GpuMeshAdapter.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "mesh"
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
var tempState, GpuBatchAdaptor;
var init_GpuBatchAdaptor = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_State();
    init_getTextureBatchBindGroup();
    tempState = State.for2d();
    GpuBatchAdaptor = class {
      start(batchPipe, geometry, shader) {
        const renderer = batchPipe.renderer;
        const encoder = renderer.encoder;
        const program = shader.gpuProgram;
        this._shader = shader;
        this._geometry = geometry;
        encoder.setGeometry(geometry, program);
        tempState.blendMode = "normal";
        renderer.pipeline.getPipeline(
          geometry,
          program,
          tempState
        );
        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
        encoder.resetBindGroup(1);
        encoder.setBindGroup(0, globalUniformsBindGroup, program);
      }
      execute(batchPipe, batch) {
        const program = this._shader.gpuProgram;
        const renderer = batchPipe.renderer;
        const encoder = renderer.encoder;
        if (!batch.bindGroup) {
          const textureBatch = batch.textures;
          batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
        }
        tempState.blendMode = batch.blendMode;
        const gpuBindGroup = renderer.bindGroup.getBindGroup(
          batch.bindGroup,
          program,
          1
        );
        const pipeline = renderer.pipeline.getPipeline(
          this._geometry,
          program,
          tempState,
          batch.topology
        );
        batch.bindGroup._touch(renderer.textureGC.count);
        encoder.setPipeline(pipeline);
        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
      }
    };
    GpuBatchAdaptor.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "batch"
    };
  }
});

// node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs
var CustomRenderPipe;
var init_CustomRenderPipe = __esm({
  "node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    CustomRenderPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      updateRenderable() {
      }
      destroyRenderable() {
      }
      validateRenderable() {
        return false;
      }
      addRenderable(container, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add(container);
      }
      execute(container) {
        if (!container.isRenderable)
          return;
        container.render(this._renderer);
      }
      destroy() {
        this._renderer = null;
      }
    };
    CustomRenderPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "customRender"
    };
  }
});

// node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs
function executeInstructions(renderGroup, renderer) {
  const instructionSet = renderGroup.instructionSet;
  const instructions = instructionSet.instructions;
  for (let i3 = 0; i3 < instructionSet.instructionSize; i3++) {
    const instruction = instructions[i3];
    renderer[instruction.renderPipeId].execute(instruction);
  }
}
var init_executeInstructions = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs
var tempMatrix5, RenderGroupPipe;
var init_RenderGroupPipe = __esm({
  "node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Matrix();
    init_PoolGroup();
    init_BatchableSprite();
    init_executeInstructions();
    tempMatrix5 = new Matrix();
    RenderGroupPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      addRenderGroup(renderGroup, instructionSet) {
        if (renderGroup.isCachedAsTexture) {
          this._addRenderableCacheAsTexture(renderGroup, instructionSet);
        } else {
          this._addRenderableDirect(renderGroup, instructionSet);
        }
      }
      execute(renderGroup) {
        if (!renderGroup.isRenderable)
          return;
        if (renderGroup.isCachedAsTexture) {
          this._executeCacheAsTexture(renderGroup);
        } else {
          this._executeDirect(renderGroup);
        }
      }
      destroy() {
        this._renderer = null;
      }
      _addRenderableDirect(renderGroup, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        if (renderGroup._batchableRenderGroup) {
          BigPool.return(renderGroup._batchableRenderGroup);
          renderGroup._batchableRenderGroup = null;
        }
        instructionSet.add(renderGroup);
      }
      _addRenderableCacheAsTexture(renderGroup, instructionSet) {
        const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = BigPool.get(BatchableSprite));
        batchableRenderGroup.renderable = renderGroup.root;
        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;
        batchableRenderGroup.texture = renderGroup.texture;
        batchableRenderGroup.bounds = renderGroup._textureBounds;
        instructionSet.add(renderGroup);
        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);
      }
      _executeCacheAsTexture(renderGroup) {
        if (renderGroup.textureNeedsUpdate) {
          renderGroup.textureNeedsUpdate = false;
          const worldTransformMatrix = tempMatrix5.identity().translate(
            -renderGroup._textureBounds.x,
            -renderGroup._textureBounds.y
          );
          this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);
          this._renderer.globalUniforms.push({
            worldTransformMatrix,
            worldColor: 4294967295
          });
          executeInstructions(renderGroup, this._renderer.renderPipes);
          this._renderer.renderTarget.finishRenderPass();
          this._renderer.renderTarget.pop();
          this._renderer.globalUniforms.pop();
        }
        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);
        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();
      }
      _executeDirect(renderGroup) {
        this._renderer.globalUniforms.push({
          worldTransformMatrix: renderGroup.inverseParentTextureTransform,
          worldColor: renderGroup.worldColorAlpha
        });
        executeInstructions(renderGroup, this._renderer.renderPipes);
        this._renderer.globalUniforms.pop();
      }
    };
    RenderGroupPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "renderGroup"
    };
  }
});

// node_modules/pixi.js/lib/scene/container/utils/clearList.mjs
function clearList(list, index) {
  index || (index = 0);
  for (let j2 = index; j2 < list.length; j2++) {
    if (list[j2]) {
      list[j2] = null;
    } else {
      break;
    }
  }
}
var init_clearList = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/clearList.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs
function updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {
  updateRenderGroupTransform(renderGroup);
  const childrenToUpdate = renderGroup.childrenToUpdate;
  const updateTick = renderGroup.updateTick++;
  for (const j2 in childrenToUpdate) {
    const renderGroupDepth = Number(j2);
    const childrenAtDepth = childrenToUpdate[j2];
    const list = childrenAtDepth.list;
    const index = childrenAtDepth.index;
    for (let i3 = 0; i3 < index; i3++) {
      const child = list[i3];
      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {
        updateTransformAndChildren(child, updateTick, 0);
      }
    }
    clearList(list, index);
    childrenAtDepth.index = 0;
  }
  if (updateChildRenderGroups) {
    for (let i3 = 0; i3 < renderGroup.renderGroupChildren.length; i3++) {
      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i3], updateChildRenderGroups);
    }
  }
}
function updateRenderGroupTransform(renderGroup) {
  const root = renderGroup.root;
  let worldAlpha;
  if (renderGroup.renderGroupParent) {
    const renderGroupParent = renderGroup.renderGroupParent;
    renderGroup.worldTransform.appendFrom(
      root.relativeGroupTransform,
      renderGroupParent.worldTransform
    );
    renderGroup.worldColor = multiplyColors(
      root.groupColor,
      renderGroupParent.worldColor
    );
    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;
  } else {
    renderGroup.worldTransform.copyFrom(root.localTransform);
    renderGroup.worldColor = root.localColor;
    worldAlpha = root.localAlpha;
  }
  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
  renderGroup.worldAlpha = worldAlpha;
  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);
}
function updateTransformAndChildren(container, updateTick, updateFlags) {
  if (updateTick === container.updateTick)
    return;
  container.updateTick = updateTick;
  container.didChange = false;
  const localTransform = container.localTransform;
  container.updateLocalTransform();
  const parent2 = container.parent;
  if (parent2 && !parent2.renderGroup) {
    updateFlags |= container._updateFlags;
    container.relativeGroupTransform.appendFrom(
      localTransform,
      parent2.relativeGroupTransform
    );
    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
      updateColorBlendVisibility(container, parent2, updateFlags);
    }
  } else {
    updateFlags = container._updateFlags;
    container.relativeGroupTransform.copyFrom(localTransform);
    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
      updateColorBlendVisibility(container, tempContainer, updateFlags);
    }
  }
  if (!container.renderGroup) {
    const children = container.children;
    const length = children.length;
    for (let i3 = 0; i3 < length; i3++) {
      updateTransformAndChildren(children[i3], updateTick, updateFlags);
    }
    const renderGroup = container.parentRenderGroup;
    const renderable = container;
    if (renderable.renderPipeId && !renderGroup.structureDidChange) {
      renderGroup.updateRenderable(renderable);
    }
  }
}
function updateColorBlendVisibility(container, parent2, updateFlags) {
  if (updateFlags & UPDATE_COLOR) {
    container.groupColor = multiplyColors(
      container.localColor,
      parent2.groupColor
    );
    let groupAlpha = container.localAlpha * parent2.groupAlpha;
    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;
    container.groupAlpha = groupAlpha;
    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);
  }
  if (updateFlags & UPDATE_BLEND) {
    container.groupBlendMode = container.localBlendMode === "inherit" ? parent2.groupBlendMode : container.localBlendMode;
  }
  if (updateFlags & UPDATE_VISIBLE) {
    container.globalDisplayStatus = container.localDisplayStatus & parent2.globalDisplayStatus;
  }
  container._updateFlags = 0;
}
var tempContainer, UPDATE_BLEND_COLOR_VISIBLE;
var init_updateRenderGroupTransforms = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs"() {
    init_define_AnParams();
    init_Container();
    init_clearList();
    init_multiplyColors();
    tempContainer = new Container();
    UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;
  }
});

// node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs
function validateRenderables(renderGroup, renderPipes3) {
  const { list, index } = renderGroup.childrenRenderablesToUpdate;
  let rebuildRequired = false;
  for (let i3 = 0; i3 < index; i3++) {
    const container = list[i3];
    const renderable = container;
    const pipe = renderPipes3[renderable.renderPipeId];
    rebuildRequired = pipe.validateRenderable(container);
    if (rebuildRequired) {
      break;
    }
  }
  renderGroup.structureDidChange = rebuildRequired;
  return rebuildRequired;
}
var init_validateRenderables = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs
var tempMatrix6, RenderGroupSystem;
var init_RenderGroupSystem = __esm({
  "node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Matrix();
    init_TexturePool();
    init_Bounds();
    init_clearList();
    init_executeInstructions();
    init_updateRenderGroupTransforms();
    init_validateRenderables();
    tempMatrix6 = new Matrix();
    RenderGroupSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      render({ container, transform: transform2 }) {
        const parent2 = container.parent;
        const renderGroupParent = container.renderGroup.renderGroupParent;
        container.parent = null;
        container.renderGroup.renderGroupParent = null;
        const renderer = this._renderer;
        let originalLocalTransform = tempMatrix6;
        if (transform2) {
          originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);
          container.renderGroup.localTransform.copyFrom(transform2);
        }
        const renderPipes3 = renderer.renderPipes;
        this._updateCachedRenderGroups(container.renderGroup, null);
        this._updateRenderGroups(container.renderGroup);
        renderer.globalUniforms.start({
          worldTransformMatrix: transform2 ? container.renderGroup.localTransform : container.renderGroup.worldTransform,
          worldColor: container.renderGroup.worldColorAlpha
        });
        executeInstructions(container.renderGroup, renderPipes3);
        if (renderPipes3.uniformBatch) {
          renderPipes3.uniformBatch.renderEnd();
        }
        if (transform2) {
          container.renderGroup.localTransform.copyFrom(originalLocalTransform);
        }
        container.parent = parent2;
        container.renderGroup.renderGroupParent = renderGroupParent;
      }
      destroy() {
        this._renderer = null;
      }
      _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {
        if (renderGroup.isCachedAsTexture) {
          if (!renderGroup.updateCacheTexture)
            return;
          closestCacheAsTexture = renderGroup;
        }
        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;
        for (let i3 = renderGroup.renderGroupChildren.length - 1; i3 >= 0; i3--) {
          this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i3], closestCacheAsTexture);
        }
        renderGroup.invalidateMatrices();
        if (renderGroup.isCachedAsTexture) {
          if (renderGroup.textureNeedsUpdate) {
            const bounds = renderGroup.root.getLocalBounds();
            bounds.ceil();
            const lastTexture = renderGroup.texture;
            if (renderGroup.texture) {
              TexturePool.returnTexture(renderGroup.texture);
            }
            const renderer = this._renderer;
            const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;
            const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;
            renderGroup.texture = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              resolution,
              antialias
            );
            renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds());
            renderGroup._textureBounds.copyFrom(bounds);
            if (lastTexture !== renderGroup.texture) {
              if (renderGroup.renderGroupParent) {
                renderGroup.renderGroupParent.structureDidChange = true;
              }
            }
          }
        } else if (renderGroup.texture) {
          TexturePool.returnTexture(renderGroup.texture);
          renderGroup.texture = null;
        }
      }
      _updateRenderGroups(renderGroup) {
        const renderer = this._renderer;
        const renderPipes3 = renderer.renderPipes;
        renderGroup.runOnRender(renderer);
        renderGroup.instructionSet.renderPipes = renderPipes3;
        if (!renderGroup.structureDidChange) {
          validateRenderables(renderGroup, renderPipes3);
        } else {
          clearList(renderGroup.childrenRenderablesToUpdate.list, 0);
        }
        updateRenderGroupTransforms(renderGroup);
        if (renderGroup.structureDidChange) {
          renderGroup.structureDidChange = false;
          this._buildInstructions(renderGroup, renderer);
        } else {
          this._updateRenderables(renderGroup);
        }
        renderGroup.childrenRenderablesToUpdate.index = 0;
        renderer.renderPipes.batch.upload(renderGroup.instructionSet);
        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate)
          return;
        for (let i3 = 0; i3 < renderGroup.renderGroupChildren.length; i3++) {
          this._updateRenderGroups(renderGroup.renderGroupChildren[i3]);
        }
      }
      _updateRenderables(renderGroup) {
        const { list, index } = renderGroup.childrenRenderablesToUpdate;
        for (let i3 = 0; i3 < index; i3++) {
          const container = list[i3];
          if (container.didViewUpdate) {
            renderGroup.updateRenderable(container);
          }
        }
        clearList(list, index);
      }
      _buildInstructions(renderGroup, rendererOrPipes) {
        const root = renderGroup.root;
        const instructionSet = renderGroup.instructionSet;
        instructionSet.reset();
        const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
        const renderPipes3 = renderer.renderPipes;
        renderPipes3.batch.buildStart(instructionSet);
        renderPipes3.blendMode.buildStart();
        renderPipes3.colorMask.buildStart();
        if (root.sortableChildren) {
          root.sortChildren();
        }
        root.collectRenderablesWithEffects(instructionSet, renderer, null);
        renderPipes3.batch.buildEnd(instructionSet);
        renderPipes3.blendMode.buildEnd(instructionSet);
      }
    };
    RenderGroupSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "renderGroup"
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs
var SpritePipe;
var init_SpritePipe = __esm({
  "node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_PoolGroup();
    init_BatchableSprite();
    SpritePipe = class {
      constructor(renderer) {
        this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
      }
      addRenderable(sprite, instructionSet) {
        const gpuSprite = this._getGpuSprite(sprite);
        if (sprite.didViewUpdate)
          this._updateBatchableSprite(sprite, gpuSprite);
        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
      }
      updateRenderable(sprite) {
        const gpuSprite = this._gpuSpriteHash[sprite.uid];
        if (sprite.didViewUpdate)
          this._updateBatchableSprite(sprite, gpuSprite);
        gpuSprite._batcher.updateElement(gpuSprite);
      }
      validateRenderable(sprite) {
        const gpuSprite = this._getGpuSprite(sprite);
        return !gpuSprite._batcher.checkAndUpdateTexture(
          gpuSprite,
          sprite._texture
        );
      }
      destroyRenderable(sprite) {
        const batchableSprite = this._gpuSpriteHash[sprite.uid];
        BigPool.return(batchableSprite);
        this._gpuSpriteHash[sprite.uid] = null;
        sprite.off("destroyed", this._destroyRenderableBound);
      }
      _updateBatchableSprite(sprite, batchableSprite) {
        batchableSprite.bounds = sprite.visualBounds;
        batchableSprite.texture = sprite._texture;
      }
      _getGpuSprite(sprite) {
        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
      }
      _initGPUSprite(sprite) {
        const batchableSprite = BigPool.get(BatchableSprite);
        batchableSprite.renderable = sprite;
        batchableSprite.transform = sprite.groupTransform;
        batchableSprite.texture = sprite._texture;
        batchableSprite.bounds = sprite.visualBounds;
        batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
        this._gpuSpriteHash[sprite.uid] = batchableSprite;
        sprite.on("destroyed", this._destroyRenderableBound);
        return batchableSprite;
      }
      destroy() {
        for (const i3 in this._gpuSpriteHash) {
          BigPool.return(this._gpuSpriteHash[i3]);
        }
        this._gpuSpriteHash = null;
        this._renderer = null;
      }
    };
    SpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "sprite"
    };
  }
});

// node_modules/pixi.js/lib/utils/const.mjs
var DATA_URI, VERSION;
var init_const8 = __esm({
  "node_modules/pixi.js/lib/utils/const.mjs"() {
    init_define_AnParams();
    init_eventemitter3();
    DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
    VERSION = "8.9.1";
  }
});

// node_modules/pixi.js/lib/utils/global/globalHooks.mjs
var ApplicationInitHook, RendererInitHook;
var init_globalHooks = __esm({
  "node_modules/pixi.js/lib/utils/global/globalHooks.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_const8();
    ApplicationInitHook = class {
      static init() {
        globalThis.__PIXI_APP_INIT__?.(this, VERSION);
      }
      static destroy() {
      }
    };
    ApplicationInitHook.extension = ExtensionType.Application;
    RendererInitHook = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      init() {
        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);
      }
      destroy() {
        this._renderer = null;
      }
    };
    RendererInitHook.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "initHook",
      priority: -10
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs
var _BatcherPipe, BatcherPipe;
var init_BatcherPipe = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_State();
    init_DefaultBatcher();
    _BatcherPipe = class _BatcherPipe2 {
      constructor(renderer, adaptor) {
        this.state = State.for2d();
        this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);
        this._activeBatches = /* @__PURE__ */ Object.create(null);
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init?.(this);
      }
      static getBatcher(name) {
        return new this._availableBatchers[name]();
      }
      buildStart(instructionSet) {
        let batchers = this._batchersByInstructionSet[instructionSet.uid];
        if (!batchers) {
          batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);
          batchers.default || (batchers.default = new DefaultBatcher());
        }
        this._activeBatches = batchers;
        this._activeBatch = this._activeBatches.default;
        for (const i3 in this._activeBatches) {
          this._activeBatches[i3].begin();
        }
      }
      addToBatch(batchableObject, instructionSet) {
        if (this._activeBatch.name !== batchableObject.batcherName) {
          this._activeBatch.break(instructionSet);
          let batch = this._activeBatches[batchableObject.batcherName];
          if (!batch) {
            batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe2.getBatcher(batchableObject.batcherName);
            batch.begin();
          }
          this._activeBatch = batch;
        }
        this._activeBatch.add(batchableObject);
      }
      break(instructionSet) {
        this._activeBatch.break(instructionSet);
      }
      buildEnd(instructionSet) {
        this._activeBatch.break(instructionSet);
        const batches = this._activeBatches;
        for (const i3 in batches) {
          const batch = batches[i3];
          const geometry = batch.geometry;
          geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);
          geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);
        }
      }
      upload(instructionSet) {
        const batchers = this._batchersByInstructionSet[instructionSet.uid];
        for (const i3 in batchers) {
          const batcher = batchers[i3];
          const geometry = batcher.geometry;
          if (batcher.dirty) {
            batcher.dirty = false;
            geometry.buffers[0].update(batcher.attributeSize * 4);
          }
        }
      }
      execute(batch) {
        if (batch.action === "startBatch") {
          const batcher = batch.batcher;
          const geometry = batcher.geometry;
          const shader = batcher.shader;
          this._adaptor.start(this, geometry, shader);
        }
        this._adaptor.execute(this, batch);
      }
      destroy() {
        this.state = null;
        this.renderer = null;
        this._adaptor = null;
        for (const i3 in this._activeBatches) {
          this._activeBatches[i3].destroy();
        }
        this._activeBatches = null;
      }
    };
    _BatcherPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "batch"
    };
    _BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);
    BatcherPipe = _BatcherPipe;
    extensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);
    extensions.add(DefaultBatcher);
  }
});

// node_modules/pixi.js/lib/filters/mask/mask.frag.mjs
var fragment2;
var init_mask_frag = __esm({
  "node_modules/pixi.js/lib/filters/mask/mask.frag.mjs"() {
    init_define_AnParams();
    fragment2 = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\nuniform float uInverse;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha;\n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    float a = alphaMul * masky.r * npmAlpha * clip;\n\n    if (uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    finalColor = original * a;\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/mask/mask.vert.mjs
var vertex2;
var init_mask_vert = __esm({
  "node_modules/pixi.js/lib/filters/mask/mask.vert.mjs"() {
    init_define_AnParams();
    vertex2 = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs
var source;
var init_mask_wgsl = __esm({
  "node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs"() {
    init_define_AnParams();
    source = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n    var uAlpha = filterUniforms.uAlpha;\n\n    var clip = step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    return source * a;\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs
var MaskFilter;
var init_MaskFilter = __esm({
  "node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_GlProgram();
    init_GpuProgram();
    init_UniformGroup();
    init_TextureMatrix();
    init_Filter();
    init_mask_frag();
    init_mask_vert();
    init_mask_wgsl();
    MaskFilter = class extends Filter {
      constructor(options) {
        const { sprite, ...rest } = options;
        const textureMatrix = new TextureMatrix(sprite.texture);
        const filterUniforms = new UniformGroup({
          uFilterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
          uAlpha: { value: 1, type: "f32" },
          uInverse: { value: options.inverse ? 1 : 0, type: "f32" }
        });
        const gpuProgram3 = GpuProgram.from({
          vertex: {
            source,
            entryPoint: "mainVertex"
          },
          fragment: {
            source,
            entryPoint: "mainFragment"
          }
        });
        const glProgram3 = GlProgram.from({
          vertex: vertex2,
          fragment: fragment2,
          name: "mask-filter"
        });
        super({
          ...rest,
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          resources: {
            filterUniforms,
            uMaskTexture: sprite.texture.source
          }
        });
        this.sprite = sprite;
        this._textureMatrix = textureMatrix;
      }
      set inverse(value) {
        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;
      }
      get inverse() {
        return this.resources.filterUniforms.uniforms.uInverse === 1;
      }
      apply(filterManager, input, output, clearMode) {
        this._textureMatrix.texture = this.sprite.texture;
        filterManager.calculateSpriteMatrix(
          this.resources.filterUniforms.uniforms.uFilterMatrix,
          this.sprite
        ).prepend(this._textureMatrix.mapCoord);
        this.resources.uMaskTexture = this.sprite.texture.source;
        filterManager.applyFilter(this, input, output, clearMode);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs
var tempBounds3, AlphaMaskEffect, AlphaMaskPipe;
var init_AlphaMaskPipe = __esm({
  "node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_FilterEffect();
    init_MaskFilter();
    init_Bounds();
    init_getGlobalBounds();
    init_Sprite();
    init_PoolGroup();
    init_Texture();
    init_TexturePool();
    init_types2();
    tempBounds3 = new Bounds();
    AlphaMaskEffect = class extends FilterEffect {
      constructor() {
        super();
        this.filters = [new MaskFilter({
          sprite: new Sprite(Texture.EMPTY),
          inverse: false,
          resolution: "inherit",
          antialias: "inherit"
        })];
      }
      get sprite() {
        return this.filters[0].sprite;
      }
      set sprite(value) {
        this.filters[0].sprite = value;
      }
      get inverse() {
        return this.filters[0].inverse;
      }
      set inverse(value) {
        this.filters[0].inverse = value;
      }
    };
    AlphaMaskPipe = class {
      constructor(renderer) {
        this._activeMaskStage = [];
        this._renderer = renderer;
      }
      push(mask, maskedContainer, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "alphaMask",
          action: "pushMaskBegin",
          mask,
          inverse: maskedContainer._maskOptions.inverse,
          canBundle: false,
          maskedContainer
        });
        mask.inverse = maskedContainer._maskOptions.inverse;
        if (mask.renderMaskToTexture) {
          const maskContainer = mask.mask;
          maskContainer.includeInBuild = true;
          maskContainer.collectRenderables(
            instructionSet,
            renderer,
            null
          );
          maskContainer.includeInBuild = false;
        }
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "alphaMask",
          action: "pushMaskEnd",
          mask,
          maskedContainer,
          inverse: maskedContainer._maskOptions.inverse,
          canBundle: false
        });
      }
      pop(mask, _maskedContainer, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "alphaMask",
          action: "popMaskEnd",
          mask,
          inverse: _maskedContainer._maskOptions.inverse,
          canBundle: false
        });
      }
      execute(instruction) {
        const renderer = this._renderer;
        const renderMask = instruction.mask.renderMaskToTexture;
        if (instruction.action === "pushMaskBegin") {
          const filterEffect = BigPool.get(AlphaMaskEffect);
          filterEffect.inverse = instruction.inverse;
          if (renderMask) {
            instruction.mask.mask.measurable = true;
            const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds3);
            instruction.mask.mask.measurable = false;
            bounds.ceil();
            const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
            const filterTexture = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              colorTextureSource._resolution,
              colorTextureSource.antialias
            );
            renderer.renderTarget.push(filterTexture, true);
            renderer.globalUniforms.push({
              offset: bounds,
              worldColor: 4294967295
            });
            const sprite = filterEffect.sprite;
            sprite.texture = filterTexture;
            sprite.worldTransform.tx = bounds.minX;
            sprite.worldTransform.ty = bounds.minY;
            this._activeMaskStage.push({
              filterEffect,
              maskedContainer: instruction.maskedContainer,
              filterTexture
            });
          } else {
            filterEffect.sprite = instruction.mask.mask;
            this._activeMaskStage.push({
              filterEffect,
              maskedContainer: instruction.maskedContainer
            });
          }
        } else if (instruction.action === "pushMaskEnd") {
          const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
          if (renderMask) {
            if (renderer.type === RendererType.WEBGL) {
              renderer.renderTarget.finishRenderPass();
            }
            renderer.renderTarget.pop();
            renderer.globalUniforms.pop();
          }
          renderer.filter.push({
            renderPipeId: "filter",
            action: "pushFilter",
            container: maskData.maskedContainer,
            filterEffect: maskData.filterEffect,
            canBundle: false
          });
        } else if (instruction.action === "popMaskEnd") {
          renderer.filter.pop();
          const maskData = this._activeMaskStage.pop();
          if (renderMask) {
            TexturePool.returnTexture(maskData.filterTexture);
          }
          BigPool.return(maskData.filterEffect);
        }
      }
      destroy() {
        this._renderer = null;
        this._activeMaskStage = null;
      }
    };
    AlphaMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "alphaMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs
var ColorMaskPipe;
var init_ColorMaskPipe = __esm({
  "node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    ColorMaskPipe = class {
      constructor(renderer) {
        this._colorStack = [];
        this._colorStackIndex = 0;
        this._currentColor = 0;
        this._renderer = renderer;
      }
      buildStart() {
        this._colorStack[0] = 15;
        this._colorStackIndex = 1;
        this._currentColor = 15;
      }
      push(mask, _container, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        const colorStack = this._colorStack;
        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
        const currentColor = this._colorStack[this._colorStackIndex];
        if (currentColor !== this._currentColor) {
          this._currentColor = currentColor;
          instructionSet.add({
            renderPipeId: "colorMask",
            colorMask: currentColor,
            canBundle: false
          });
        }
        this._colorStackIndex++;
      }
      pop(_mask, _container, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        const colorStack = this._colorStack;
        this._colorStackIndex--;
        const currentColor = colorStack[this._colorStackIndex - 1];
        if (currentColor !== this._currentColor) {
          this._currentColor = currentColor;
          instructionSet.add({
            renderPipeId: "colorMask",
            colorMask: currentColor,
            canBundle: false
          });
        }
      }
      execute(instruction) {
        const renderer = this._renderer;
        renderer.colorMask.setMask(instruction.colorMask);
      }
      destroy() {
        this._colorStack = null;
      }
    };
    ColorMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "colorMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs
var StencilMaskPipe;
var init_StencilMaskPipe = __esm({
  "node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_const7();
    init_const3();
    StencilMaskPipe = class {
      constructor(renderer) {
        this._maskStackHash = {};
        this._maskHash = /* @__PURE__ */ new WeakMap();
        this._renderer = renderer;
      }
      push(mask, _container, instructionSet) {
        var _a2;
        const effect = mask;
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
        instructionSet.add({
          renderPipeId: "stencilMask",
          action: "pushMaskBegin",
          mask,
          inverse: _container._maskOptions.inverse,
          canBundle: false
        });
        const maskContainer = effect.mask;
        maskContainer.includeInBuild = true;
        if (!this._maskHash.has(effect)) {
          this._maskHash.set(effect, {
            instructionsStart: 0,
            instructionsLength: 0
          });
        }
        const maskData = this._maskHash.get(effect);
        maskData.instructionsStart = instructionSet.instructionSize;
        maskContainer.collectRenderables(
          instructionSet,
          renderer,
          null
        );
        maskContainer.includeInBuild = false;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "stencilMask",
          action: "pushMaskEnd",
          mask,
          inverse: _container._maskOptions.inverse,
          canBundle: false
        });
        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
        maskData.instructionsLength = instructionsLength;
        const renderTargetUid = renderer.renderTarget.renderTarget.uid;
        (_a2 = this._maskStackHash)[renderTargetUid] ?? (_a2[renderTargetUid] = 0);
      }
      pop(mask, _container, instructionSet) {
        const effect = mask;
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
        instructionSet.add({
          renderPipeId: "stencilMask",
          action: "popMaskBegin",
          inverse: _container._maskOptions.inverse,
          canBundle: false
        });
        const maskData = this._maskHash.get(mask);
        for (let i3 = 0; i3 < maskData.instructionsLength; i3++) {
          instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
        }
        instructionSet.add({
          renderPipeId: "stencilMask",
          action: "popMaskEnd",
          canBundle: false
        });
      }
      execute(instruction) {
        var _a2;
        const renderer = this._renderer;
        const renderTargetUid = renderer.renderTarget.renderTarget.uid;
        let maskStackIndex = (_a2 = this._maskStackHash)[renderTargetUid] ?? (_a2[renderTargetUid] = 0);
        if (instruction.action === "pushMaskBegin") {
          renderer.renderTarget.ensureDepthStencil();
          renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
          maskStackIndex++;
          renderer.colorMask.setMask(0);
        } else if (instruction.action === "pushMaskEnd") {
          if (instruction.inverse) {
            renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
          } else {
            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
          }
          renderer.colorMask.setMask(15);
        } else if (instruction.action === "popMaskBegin") {
          renderer.colorMask.setMask(0);
          if (maskStackIndex !== 0) {
            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
          } else {
            renderer.renderTarget.clear(null, CLEAR.STENCIL);
            renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
          }
          maskStackIndex--;
        } else if (instruction.action === "popMaskEnd") {
          if (instruction.inverse) {
            renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
          } else {
            renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
          }
          renderer.colorMask.setMask(15);
        }
        this._maskStackHash[renderTargetUid] = maskStackIndex;
      }
      destroy() {
        this._renderer = null;
        this._maskStackHash = null;
        this._maskHash = null;
      }
    };
    StencilMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "stencilMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
var _BackgroundSystem, BackgroundSystem;
var init_BackgroundSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs"() {
    init_define_AnParams();
    init_Color();
    init_Extensions();
    _BackgroundSystem = class _BackgroundSystem2 {
      constructor() {
        this.clearBeforeRender = true;
        this._backgroundColor = new Color(0);
        this.color = this._backgroundColor;
        this.alpha = 1;
      }
      /**
       * initiates the background system
       * @param options - the options for the background colors
       */
      init(options) {
        options = { ..._BackgroundSystem2.defaultOptions, ...options };
        this.clearBeforeRender = options.clearBeforeRender;
        this.color = options.background || options.backgroundColor || this._backgroundColor;
        this.alpha = options.backgroundAlpha;
        this._backgroundColor.setAlpha(options.backgroundAlpha);
      }
      /** The background color to fill if not transparent */
      get color() {
        return this._backgroundColor;
      }
      set color(value) {
        this._backgroundColor.setValue(value);
      }
      /** The background color alpha. Setting this to 0 will make the canvas transparent. */
      get alpha() {
        return this._backgroundColor.alpha;
      }
      set alpha(value) {
        this._backgroundColor.setAlpha(value);
      }
      /** The background color as an [R, G, B, A] array. */
      get colorRgba() {
        return this._backgroundColor.toArray();
      }
      /**
       * destroys the background system
       * @internal
       * @ignore
       */
      destroy() {
      }
    };
    _BackgroundSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "background",
      priority: 0
    };
    _BackgroundSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.backgroundAlpha}
       * @default 1
       */
      backgroundAlpha: 1,
      /**
       * {@link WebGLOptions.backgroundColor}
       * @default 0x000000
       */
      backgroundColor: 0,
      /**
       * {@link WebGLOptions.clearBeforeRender}
       * @default true
       */
      clearBeforeRender: true
    };
    BackgroundSystem = _BackgroundSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs
var BLEND_MODE_FILTERS, BlendModePipe;
var init_BlendModePipe = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_FilterEffect();
    init_warn();
    BLEND_MODE_FILTERS = {};
    extensions.handle(ExtensionType.BlendMode, (value) => {
      if (!value.name) {
        throw new Error("BlendMode extension must have a name property");
      }
      BLEND_MODE_FILTERS[value.name] = value.ref;
    }, (value) => {
      delete BLEND_MODE_FILTERS[value.name];
    });
    BlendModePipe = class {
      constructor(renderer) {
        this._isAdvanced = false;
        this._filterHash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        this._renderer.runners.prerender.add(this);
      }
      prerender() {
        this._activeBlendMode = "normal";
        this._isAdvanced = false;
      }
      /**
       * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.
       * @param renderable - The renderable we are adding to the instruction set
       * @param blendMode - The blend mode of the renderable
       * @param instructionSet - The instruction set we are adding to
       */
      setBlendMode(renderable, blendMode, instructionSet) {
        if (this._activeBlendMode === blendMode) {
          if (this._isAdvanced)
            this._renderableList.push(renderable);
          return;
        }
        this._activeBlendMode = blendMode;
        if (this._isAdvanced) {
          this._endAdvancedBlendMode(instructionSet);
        }
        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
        if (this._isAdvanced) {
          this._beginAdvancedBlendMode(instructionSet);
          this._renderableList.push(renderable);
        }
      }
      _beginAdvancedBlendMode(instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        const blendMode = this._activeBlendMode;
        if (!BLEND_MODE_FILTERS[blendMode]) {
          warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
          return;
        }
        let filterEffect = this._filterHash[blendMode];
        if (!filterEffect) {
          filterEffect = this._filterHash[blendMode] = new FilterEffect();
          filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];
        }
        const instruction = {
          renderPipeId: "filter",
          action: "pushFilter",
          renderables: [],
          filterEffect,
          canBundle: false
        };
        this._renderableList = instruction.renderables;
        instructionSet.add(instruction);
      }
      _endAdvancedBlendMode(instructionSet) {
        this._renderableList = null;
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "filter",
          action: "popFilter",
          canBundle: false
        });
      }
      /**
       * called when the instruction build process is starting this will reset internally to the default blend mode
       * @internal
       * @ignore
       */
      buildStart() {
        this._isAdvanced = false;
      }
      /**
       * called when the instruction build process is finished, ensuring that if there is an advanced blend mode
       * active, we add the final render instructions added to the instruction set
       * @param instructionSet - The instruction set we are adding to
       * @internal
       * @ignore
       */
      buildEnd(instructionSet) {
        if (this._isAdvanced) {
          this._endAdvancedBlendMode(instructionSet);
        }
      }
      /**
       * @internal
       * @ignore
       */
      destroy() {
        this._renderer = null;
        this._renderableList = null;
        for (const i3 in this._filterHash) {
          this._filterHash[i3].destroy();
        }
        this._filterHash = null;
      }
    };
    BlendModePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "blendMode"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs
var imageTypes, _ExtractSystem, ExtractSystem;
var init_ExtractSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Container();
    init_Texture();
    imageTypes = {
      png: "image/png",
      jpg: "image/jpeg",
      webp: "image/webp"
    };
    _ExtractSystem = class _ExtractSystem2 {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._renderer = renderer;
      }
      _normalizeOptions(options, defaults = {}) {
        if (options instanceof Container || options instanceof Texture) {
          return {
            target: options,
            ...defaults
          };
        }
        return {
          ...defaults,
          ...options
        };
      }
      /**
       * Will return a HTML Image of the target
       * @param options - The options for creating the image, or the target to extract
       * @returns - HTML Image of the target
       */
      async image(options) {
        const image = new Image();
        image.src = await this.base64(options);
        return image;
      }
      /**
       * Will return a base64 encoded string of this target. It works by calling
       * `Extract.canvas` and then running toDataURL on that.
       * @param options - The options for creating the image, or the target to extract
       */
      async base64(options) {
        options = this._normalizeOptions(
          options,
          _ExtractSystem2.defaultImageOptions
        );
        const { format, quality } = options;
        const canvas = this.canvas(options);
        if (canvas.toBlob !== void 0) {
          return new Promise((resolve, reject) => {
            canvas.toBlob((blob) => {
              if (!blob) {
                reject(new Error("ICanvas.toBlob failed!"));
                return;
              }
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(blob);
            }, imageTypes[format], quality);
          });
        }
        if (canvas.toDataURL !== void 0) {
          return canvas.toDataURL(imageTypes[format], quality);
        }
        if (canvas.convertToBlob !== void 0) {
          const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }
        throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
      }
      /**
       * Creates a Canvas element, renders this target to it and then returns it.
       * @param options - The options for creating the canvas, or the target to extract
       * @returns - A Canvas element with the texture rendered on.
       */
      canvas(options) {
        options = this._normalizeOptions(options);
        const target = options.target;
        const renderer = this._renderer;
        if (target instanceof Texture) {
          return renderer.texture.generateCanvas(target);
        }
        const texture = renderer.textureGenerator.generateTexture(options);
        const canvas = renderer.texture.generateCanvas(texture);
        texture.destroy(true);
        return canvas;
      }
      /**
       * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
       * order, with integer values between 0 and 255 (included).
       * @param options - The options for extracting the image, or the target to extract
       * @returns - One-dimensional array containing the pixel data of the entire texture
       */
      pixels(options) {
        options = this._normalizeOptions(options);
        const target = options.target;
        const renderer = this._renderer;
        const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
        const pixelInfo = renderer.texture.getPixels(texture);
        if (target instanceof Container) {
          texture.destroy(true);
        }
        return pixelInfo;
      }
      /**
       * Will return a texture of the target
       * @param options - The options for creating the texture, or the target to extract
       * @returns - A texture of the target
       */
      texture(options) {
        options = this._normalizeOptions(options);
        if (options.target instanceof Texture)
          return options.target;
        return this._renderer.textureGenerator.generateTexture(options);
      }
      /**
       * Will extract a HTMLImage of the target and download it
       * @param options - The options for downloading and extracting the image, or the target to extract
       */
      download(options) {
        options = this._normalizeOptions(options);
        const canvas = this.canvas(options);
        const link = document.createElement("a");
        link.download = options.filename ?? "image.png";
        link.href = canvas.toDataURL("image/png");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      /**
       * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.
       * @param options - The options for logging the image, or the target to log
       */
      log(options) {
        const width = options.width ?? 200;
        options = this._normalizeOptions(options);
        const canvas = this.canvas(options);
        const base64 = canvas.toDataURL();
        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);
        const style = [
          "font-size: 1px;",
          `padding: ${width}px ${300}px;`,
          `background: url(${base64}) no-repeat;`,
          "background-size: contain;"
        ].join(" ");
        console.log("%c ", style);
      }
      destroy() {
        this._renderer = null;
      }
    };
    _ExtractSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "extract"
    };
    _ExtractSystem.defaultImageOptions = {
      /** The format of the image. */
      format: "png",
      /** The quality of the image. */
      quality: 1
    };
    ExtractSystem = _ExtractSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs
var RenderTexture;
var init_RenderTexture = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs"() {
    init_define_AnParams();
    init_TextureSource();
    init_Texture();
    RenderTexture = class _RenderTexture extends Texture {
      static create(options) {
        return new _RenderTexture({
          source: new TextureSource(options)
        });
      }
      /**
       * Resizes the render texture.
       * @param width - The new width of the render texture.
       * @param height - The new height of the render texture.
       * @param resolution - The new resolution of the render texture.
       * @returns This texture.
       */
      resize(width, height, resolution) {
        this.source.resize(width, height, resolution);
        return this;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs
var tempRect4, tempBounds4, noColor, GenerateTextureSystem;
var init_GenerateTextureSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs"() {
    init_define_AnParams();
    init_Color();
    init_Extensions();
    init_Matrix();
    init_Rectangle();
    init_Bounds();
    init_getLocalBounds();
    init_Container();
    init_RenderTexture();
    tempRect4 = new Rectangle();
    tempBounds4 = new Bounds();
    noColor = [0, 0, 0, 0];
    GenerateTextureSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      /**
       * A Useful function that returns a texture of the display object that can then be used to create sprites
       * This can be quite useful if your container is complicated and needs to be reused multiple times.
       * @param {GenerateTextureOptions | Container} options - Generate texture options.
       * @param {Container} [options.container] - If not given, the renderer's resolution is used.
       * @param {Rectangle} options.region - The region of the container, that shall be rendered,
       * @param {number} [options.resolution] - The resolution of the texture being generated.
       *        if no region is specified, defaults to the local bounds of the container.
       * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.
       * @returns a shiny new texture of the container passed in
       */
      generateTexture(options) {
        if (options instanceof Container) {
          options = {
            target: options,
            frame: void 0,
            textureSourceOptions: {},
            resolution: void 0
          };
        }
        const resolution = options.resolution || this._renderer.resolution;
        const antialias = options.antialias || this._renderer.view.antialias;
        const container = options.target;
        let clearColor = options.clearColor;
        if (clearColor) {
          const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
          clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();
        } else {
          clearColor = noColor;
        }
        const region = options.frame?.copyTo(tempRect4) || getLocalBounds(container, tempBounds4).rectangle;
        region.width = Math.max(region.width, 1 / resolution) | 0;
        region.height = Math.max(region.height, 1 / resolution) | 0;
        const target = RenderTexture.create({
          ...options.textureSourceOptions,
          width: region.width,
          height: region.height,
          resolution,
          antialias
        });
        const transform2 = Matrix.shared.translate(-region.x, -region.y);
        this._renderer.render({
          container,
          transform: transform2,
          target,
          clearColor
        });
        target.source.updateMipmaps();
        return target;
      }
      destroy() {
        this._renderer = null;
      }
    };
    GenerateTextureSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "textureGenerator"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
var GlobalUniformSystem;
var init_GlobalUniformSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Matrix();
    init_Point();
    init_colorToUniform();
    init_BindGroup();
    init_types2();
    init_UniformGroup();
    GlobalUniformSystem = class {
      constructor(renderer) {
        this._stackIndex = 0;
        this._globalUniformDataStack = [];
        this._uniformsPool = [];
        this._activeUniforms = [];
        this._bindGroupPool = [];
        this._activeBindGroups = [];
        this._renderer = renderer;
      }
      reset() {
        this._stackIndex = 0;
        for (let i3 = 0; i3 < this._activeUniforms.length; i3++) {
          this._uniformsPool.push(this._activeUniforms[i3]);
        }
        for (let i3 = 0; i3 < this._activeBindGroups.length; i3++) {
          this._bindGroupPool.push(this._activeBindGroups[i3]);
        }
        this._activeUniforms.length = 0;
        this._activeBindGroups.length = 0;
      }
      start(options) {
        this.reset();
        this.push(options);
      }
      bind({
        size,
        projectionMatrix,
        worldTransformMatrix,
        worldColor,
        offset
      }) {
        const renderTarget = this._renderer.renderTarget.renderTarget;
        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
          projectionData: renderTarget,
          worldTransformMatrix: new Matrix(),
          worldColor: 4294967295,
          offset: new Point()
        };
        const globalUniformData = {
          projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,
          resolution: size || renderTarget.size,
          worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
          worldColor: worldColor || currentGlobalUniformData.worldColor,
          offset: offset || currentGlobalUniformData.offset,
          bindGroup: null
        };
        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
        this._activeUniforms.push(uniformGroup);
        const uniforms = uniformGroup.uniforms;
        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;
        uniforms.uResolution = globalUniformData.resolution;
        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;
        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;
        color32BitToUniform(
          globalUniformData.worldColor,
          uniforms.uWorldColorAlpha,
          0
        );
        uniformGroup.update();
        let bindGroup;
        if (this._renderer.renderPipes.uniformBatch) {
          bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
        } else {
          bindGroup = this._bindGroupPool.pop() || new BindGroup();
          this._activeBindGroups.push(bindGroup);
          bindGroup.setResource(uniformGroup, 0);
        }
        globalUniformData.bindGroup = bindGroup;
        this._currentGlobalUniformData = globalUniformData;
      }
      push(options) {
        this.bind(options);
        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
      }
      pop() {
        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
        if (this._renderer.type === RendererType.WEBGL) {
          this._currentGlobalUniformData.bindGroup.resources[0].update();
        }
      }
      get bindGroup() {
        return this._currentGlobalUniformData.bindGroup;
      }
      get globalUniformData() {
        return this._currentGlobalUniformData;
      }
      get uniformGroup() {
        return this._currentGlobalUniformData.bindGroup.resources[0];
      }
      _createUniforms() {
        const globalUniforms = new UniformGroup({
          uProjectionMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uWorldTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
          uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
          uResolution: { value: [0, 0], type: "vec2<f32>" }
        }, {
          isStatic: true
        });
        return globalUniforms;
      }
      destroy() {
        this._renderer = null;
      }
    };
    GlobalUniformSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "globalUniforms"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs
var uid2, SchedulerSystem;
var init_SchedulerSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Ticker();
    uid2 = 1;
    SchedulerSystem = class {
      constructor() {
        this._tasks = [];
        this._offset = 0;
      }
      /** Initializes the scheduler system and starts the ticker. */
      init() {
        Ticker.system.add(this._update, this);
      }
      /**
       * Schedules a repeating task.
       * @param func - The function to execute.
       * @param duration - The interval duration in milliseconds.
       * @param useOffset - this will spread out tasks so that they do not all run at the same time
       * @returns The unique identifier for the scheduled task.
       */
      repeat(func, duration, useOffset = true) {
        const id = uid2++;
        let offset = 0;
        if (useOffset) {
          this._offset += 1e3;
          offset = this._offset;
        }
        this._tasks.push({
          func,
          duration,
          start: performance.now(),
          offset,
          last: performance.now(),
          repeat: true,
          id
        });
        return id;
      }
      /**
       * Cancels a scheduled task.
       * @param id - The unique identifier of the task to cancel.
       */
      cancel(id) {
        for (let i3 = 0; i3 < this._tasks.length; i3++) {
          if (this._tasks[i3].id === id) {
            this._tasks.splice(i3, 1);
            return;
          }
        }
      }
      /**
       * Updates and executes the scheduled tasks.
       * @private
       */
      _update() {
        const now = performance.now();
        for (let i3 = 0; i3 < this._tasks.length; i3++) {
          const task = this._tasks[i3];
          if (now - task.offset - task.last >= task.duration) {
            const elapsed = now - task.start;
            task.func(elapsed);
            task.last = now;
          }
        }
      }
      /**
       * Destroys the scheduler system and removes all tasks.
       * @internal
       * @ignore
       */
      destroy() {
        Ticker.system.remove(this._update, this);
        this._tasks.length = 0;
      }
    };
    SchedulerSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "scheduler",
      priority: 0
    };
  }
});

// node_modules/pixi.js/lib/utils/sayHello.mjs
function sayHello(type) {
  if (saidHello) {
    return;
  }
  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
    const args = [
      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/

`,
      "background: #E72264; padding:5px 0;",
      "background: #6CA2EA; padding:5px 0;",
      "background: #B5D33D; padding:5px 0;",
      "background: #FED23F; padding:5px 0;",
      "color: #FFFFFF; background: #E72264; padding:5px 0;",
      "color: #E72264; background: #FFFFFF; padding:5px 0;"
    ];
    globalThis.console.log(...args);
  } else if (globalThis.console) {
    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);
  }
  saidHello = true;
}
var saidHello;
var init_sayHello = __esm({
  "node_modules/pixi.js/lib/utils/sayHello.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_const8();
    saidHello = false;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs
var HelloSystem;
var init_HelloSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_sayHello();
    init_types2();
    HelloSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      /**
       * It all starts here! This initiates every system, passing in the options for any system by name.
       * @param options - the config for the renderer and all its systems
       */
      init(options) {
        if (options.hello) {
          let name = this._renderer.name;
          if (this._renderer.type === RendererType.WEBGL) {
            name += ` ${this._renderer.context.webGLVersion}`;
          }
          sayHello(name);
        }
      }
    };
    HelloSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "hello",
      priority: -2
    };
    HelloSystem.defaultOptions = {
      /** {@link WebGLOptions.hello} */
      hello: false
    };
  }
});

// node_modules/pixi.js/lib/utils/data/clean.mjs
function cleanHash(hash) {
  let clean = false;
  for (const i3 in hash) {
    if (hash[i3] == void 0) {
      clean = true;
      break;
    }
  }
  if (!clean)
    return hash;
  const cleanHash2 = /* @__PURE__ */ Object.create(null);
  for (const i3 in hash) {
    const value = hash[i3];
    if (value) {
      cleanHash2[i3] = value;
    }
  }
  return cleanHash2;
}
function cleanArray(arr) {
  let offset = 0;
  for (let i3 = 0; i3 < arr.length; i3++) {
    if (arr[i3] == void 0) {
      offset++;
    } else {
      arr[i3 - offset] = arr[i3];
    }
  }
  arr.length -= offset;
  return arr;
}
var init_clean = __esm({
  "node_modules/pixi.js/lib/utils/data/clean.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs
var renderableGCTick, _RenderableGCSystem, RenderableGCSystem;
var init_RenderableGCSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_clean();
    renderableGCTick = 0;
    _RenderableGCSystem = class _RenderableGCSystem2 {
      /**
       * Creates a new RenderableGCSystem instance.
       * @param renderer - The renderer this garbage collection system works for
       */
      constructor(renderer) {
        this._managedRenderables = [];
        this._managedHashes = [];
        this._managedArrays = [];
        this._renderer = renderer;
      }
      /**
       * Initializes the garbage collection system with the provided options.
       * @param options - Configuration options for the renderer
       */
      init(options) {
        options = { ..._RenderableGCSystem2.defaultOptions, ...options };
        this.maxUnusedTime = options.renderableGCMaxUnusedTime;
        this._frequency = options.renderableGCFrequency;
        this.enabled = options.renderableGCActive;
      }
      /**
       * Gets whether the garbage collection system is currently enabled.
       * @returns True if GC is enabled, false otherwise
       */
      get enabled() {
        return !!this._handler;
      }
      /**
       * Enables or disables the garbage collection system.
       * When enabled, schedules periodic cleanup of resources.
       * When disabled, cancels all scheduled cleanups.
       */
      set enabled(value) {
        if (this.enabled === value)
          return;
        if (value) {
          this._handler = this._renderer.scheduler.repeat(
            () => this.run(),
            this._frequency,
            false
          );
          this._hashHandler = this._renderer.scheduler.repeat(
            () => {
              for (const hash of this._managedHashes) {
                hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);
              }
            },
            this._frequency
          );
          this._arrayHandler = this._renderer.scheduler.repeat(
            () => {
              for (const array of this._managedArrays) {
                cleanArray(array.context[array.hash]);
              }
            },
            this._frequency
          );
        } else {
          this._renderer.scheduler.cancel(this._handler);
          this._renderer.scheduler.cancel(this._hashHandler);
          this._renderer.scheduler.cancel(this._arrayHandler);
        }
      }
      /**
       * Adds a hash table to be managed by the garbage collector.
       * @param context - The object containing the hash table
       * @param hash - The property name of the hash table
       */
      addManagedHash(context2, hash) {
        this._managedHashes.push({ context: context2, hash });
      }
      /**
       * Adds an array to be managed by the garbage collector.
       * @param context - The object containing the array
       * @param hash - The property name of the array
       */
      addManagedArray(context2, hash) {
        this._managedArrays.push({ context: context2, hash });
      }
      /**
       * Updates the GC timestamp and tracking before rendering.
       * @param options - The render options
       * @param options.container - The container to render
       */
      prerender({
        container
      }) {
        this._now = performance.now();
        container.renderGroup.gcTick = renderableGCTick++;
        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);
      }
      /**
       * Starts tracking a renderable for garbage collection.
       * @param renderable - The renderable to track
       */
      addRenderable(renderable) {
        if (!this.enabled)
          return;
        if (renderable._lastUsed === -1) {
          this._managedRenderables.push(renderable);
          renderable.once("destroyed", this._removeRenderable, this);
        }
        renderable._lastUsed = this._now;
      }
      /**
       * Performs garbage collection by cleaning up unused renderables.
       * Removes renderables that haven't been used for longer than maxUnusedTime.
       */
      run() {
        const now = this._now;
        const managedRenderables = this._managedRenderables;
        const renderPipes3 = this._renderer.renderPipes;
        let offset = 0;
        for (let i3 = 0; i3 < managedRenderables.length; i3++) {
          const renderable = managedRenderables[i3];
          if (renderable === null) {
            offset++;
            continue;
          }
          const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
          const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;
          if ((renderGroup?.gcTick ?? 0) === currentTick) {
            renderable._lastUsed = now;
          }
          if (now - renderable._lastUsed > this.maxUnusedTime) {
            if (!renderable.destroyed) {
              const rp = renderPipes3;
              if (renderGroup)
                renderGroup.structureDidChange = true;
              rp[renderable.renderPipeId].destroyRenderable(renderable);
            }
            renderable._lastUsed = -1;
            offset++;
            renderable.off("destroyed", this._removeRenderable, this);
          } else {
            managedRenderables[i3 - offset] = renderable;
          }
        }
        managedRenderables.length -= offset;
      }
      /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */
      destroy() {
        this.enabled = false;
        this._renderer = null;
        this._managedRenderables.length = 0;
        this._managedHashes.length = 0;
        this._managedArrays.length = 0;
      }
      /**
       * Removes a renderable from being tracked when it's destroyed.
       * @param renderable - The renderable to stop tracking
       */
      _removeRenderable(renderable) {
        const index = this._managedRenderables.indexOf(renderable);
        if (index >= 0) {
          renderable.off("destroyed", this._removeRenderable, this);
          this._managedRenderables[index] = null;
        }
      }
      /**
       * Updates the GC tick counter for a render group and its children.
       * @param renderGroup - The render group to update
       * @param gcTick - The new tick value
       */
      _updateInstructionGCTick(renderGroup, gcTick) {
        renderGroup.instructionSet.gcTick = gcTick;
        for (const child of renderGroup.renderGroupChildren) {
          this._updateInstructionGCTick(child, gcTick);
        }
      }
    };
    _RenderableGCSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "renderableGC",
      priority: 0
    };
    _RenderableGCSystem.defaultOptions = {
      /** Enable/disable the garbage collector */
      renderableGCActive: true,
      /** Time in ms before an unused resource is collected (default 1 minute) */
      renderableGCMaxUnusedTime: 6e4,
      /** How often to run garbage collection in ms (default 30 seconds) */
      renderableGCFrequency: 3e4
    };
    RenderableGCSystem = _RenderableGCSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs
var _TextureGCSystem, TextureGCSystem;
var init_TextureGCSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    _TextureGCSystem = class _TextureGCSystem2 {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._renderer = renderer;
        this.count = 0;
        this.checkCount = 0;
      }
      init(options) {
        options = { ..._TextureGCSystem2.defaultOptions, ...options };
        this.checkCountMax = options.textureGCCheckCountMax;
        this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;
        this.active = options.textureGCActive;
      }
      /**
       * Checks to see when the last time a texture was used.
       * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
       */
      postrender() {
        if (!this._renderer.renderingToScreen) {
          return;
        }
        this.count++;
        if (!this.active)
          return;
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
          this.checkCount = 0;
          this.run();
        }
      }
      /**
       * Checks to see when the last time a texture was used.
       * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
       */
      run() {
        const managedTextures = this._renderer.texture.managedTextures;
        for (let i3 = 0; i3 < managedTextures.length; i3++) {
          const texture = managedTextures[i3];
          if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {
            texture._touched = -1;
            texture.unload();
          }
        }
      }
      destroy() {
        this._renderer = null;
      }
    };
    _TextureGCSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "textureGC"
    };
    _TextureGCSystem.defaultOptions = {
      /**
       * If set to true, this will enable the garbage collector on the GPU.
       * @default true
       */
      textureGCActive: true,
      /**
       * @deprecated since 8.3.0
       * @see {@link TextureGCSystem.textureGCMaxIdle}
       */
      textureGCAMaxIdle: null,
      /**
       * The maximum idle frames before a texture is destroyed by garbage collection.
       * @default 60 * 60
       */
      textureGCMaxIdle: 60 * 60,
      /**
       * Frames between two garbage collections.
       * @default 600
       */
      textureGCCheckCountMax: 600
    };
    TextureGCSystem = _TextureGCSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
var _RenderTarget, RenderTarget;
var init_RenderTarget = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs"() {
    init_define_AnParams();
    init_uid();
    init_TextureSource();
    init_Texture();
    _RenderTarget = class _RenderTarget2 {
      /**
       * @param [descriptor] - Options for creating a render target.
       */
      constructor(descriptor = {}) {
        this.uid = uid("renderTarget");
        this.colorTextures = [];
        this.dirtyId = 0;
        this.isRoot = false;
        this._size = new Float32Array(2);
        this._managedColorTextures = false;
        descriptor = { ..._RenderTarget2.defaultOptions, ...descriptor };
        this.stencil = descriptor.stencil;
        this.depth = descriptor.depth;
        this.isRoot = descriptor.isRoot;
        if (typeof descriptor.colorTextures === "number") {
          this._managedColorTextures = true;
          for (let i3 = 0; i3 < descriptor.colorTextures; i3++) {
            this.colorTextures.push(
              new TextureSource({
                width: descriptor.width,
                height: descriptor.height,
                resolution: descriptor.resolution,
                antialias: descriptor.antialias
              })
            );
          }
        } else {
          this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];
          const colorSource = this.colorTexture.source;
          this.resize(colorSource.width, colorSource.height, colorSource._resolution);
        }
        this.colorTexture.source.on("resize", this.onSourceResize, this);
        if (descriptor.depthStencilTexture || this.stencil) {
          if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {
            this.depthStencilTexture = descriptor.depthStencilTexture.source;
          } else {
            this.ensureDepthStencilTexture();
          }
        }
      }
      get size() {
        const _size = this._size;
        _size[0] = this.pixelWidth;
        _size[1] = this.pixelHeight;
        return _size;
      }
      get width() {
        return this.colorTexture.source.width;
      }
      get height() {
        return this.colorTexture.source.height;
      }
      get pixelWidth() {
        return this.colorTexture.source.pixelWidth;
      }
      get pixelHeight() {
        return this.colorTexture.source.pixelHeight;
      }
      get resolution() {
        return this.colorTexture.source._resolution;
      }
      get colorTexture() {
        return this.colorTextures[0];
      }
      onSourceResize(source9) {
        this.resize(source9.width, source9.height, source9._resolution, true);
      }
      /**
       * This will ensure a depthStencil texture is created for this render target.
       * Most likely called by the mask system to make sure we have stencil buffer added.
       * @internal
       * @ignore
       */
      ensureDepthStencilTexture() {
        if (!this.depthStencilTexture) {
          this.depthStencilTexture = new TextureSource({
            width: this.width,
            height: this.height,
            resolution: this.resolution,
            format: "depth24plus-stencil8",
            autoGenerateMipmaps: false,
            antialias: false,
            mipLevelCount: 1
            // sampleCount: handled by the render target system..
          });
        }
      }
      resize(width, height, resolution = this.resolution, skipColorTexture = false) {
        this.dirtyId++;
        this.colorTextures.forEach((colorTexture, i3) => {
          if (skipColorTexture && i3 === 0)
            return;
          colorTexture.source.resize(width, height, resolution);
        });
        if (this.depthStencilTexture) {
          this.depthStencilTexture.source.resize(width, height, resolution);
        }
      }
      destroy() {
        this.colorTexture.source.off("resize", this.onSourceResize, this);
        if (this._managedColorTextures) {
          this.colorTextures.forEach((texture) => {
            texture.destroy();
          });
        }
        if (this.depthStencilTexture) {
          this.depthStencilTexture.destroy();
          delete this.depthStencilTexture;
        }
      }
    };
    _RenderTarget.defaultOptions = {
      /** the width of the RenderTarget */
      width: 0,
      /** the height of the RenderTarget */
      height: 0,
      /** the resolution of the RenderTarget */
      resolution: 1,
      /** an array of textures, or a number indicating how many color textures there should be */
      colorTextures: 1,
      /** should this render target have a stencil buffer? */
      stencil: false,
      /** should this render target have a depth buffer? */
      depth: false,
      /** should this render target be antialiased? */
      antialias: false,
      // save on perf by default!
      /** is this a root element, true if this is gl context owners render target */
      isRoot: false
    };
    RenderTarget = _RenderTarget;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
function getCanvasTexture(canvas, options) {
  if (!canvasCache.has(canvas)) {
    const texture = new Texture({
      source: new CanvasSource({
        resource: canvas,
        ...options
      })
    });
    const onDestroy = () => {
      if (canvasCache.get(canvas) === texture) {
        canvasCache.delete(canvas);
      }
    };
    texture.once("destroy", onDestroy);
    texture.source.once("destroy", onDestroy);
    canvasCache.set(canvas, texture);
  }
  return canvasCache.get(canvas);
}
function hasCachedCanvasTexture(canvas) {
  return canvasCache.has(canvas);
}
var canvasCache;
var init_getCanvasTexture = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"() {
    init_define_AnParams();
    init_CanvasSource();
    init_Texture();
    canvasCache = /* @__PURE__ */ new Map();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs
var _ViewSystem, ViewSystem;
var init_ViewSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_Extensions();
    init_Rectangle();
    init_deprecation();
    init_RenderTarget();
    init_getCanvasTexture();
    _ViewSystem = class _ViewSystem2 {
      /**
       * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
       * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.
       * @member {boolean}
       */
      get autoDensity() {
        return this.texture.source.autoDensity;
      }
      set autoDensity(value) {
        this.texture.source.autoDensity = value;
      }
      /** The resolution / device pixel ratio of the renderer. */
      get resolution() {
        return this.texture.source._resolution;
      }
      set resolution(value) {
        this.texture.source.resize(
          this.texture.source.width,
          this.texture.source.height,
          value
        );
      }
      /**
       * initiates the view system
       * @param options - the options for the view
       */
      init(options) {
        options = {
          ..._ViewSystem2.defaultOptions,
          ...options
        };
        if (options.view) {
          deprecation(v8_0_0, "ViewSystem.view has been renamed to ViewSystem.canvas");
          options.canvas = options.view;
        }
        this.screen = new Rectangle(0, 0, options.width, options.height);
        this.canvas = options.canvas || DOMAdapter.get().createCanvas();
        this.antialias = !!options.antialias;
        this.texture = getCanvasTexture(this.canvas, options);
        this.renderTarget = new RenderTarget({
          colorTextures: [this.texture],
          depth: !!options.depth,
          isRoot: true
        });
        this.texture.source.transparent = options.backgroundAlpha < 1;
        this.resolution = options.resolution;
      }
      /**
       * Resizes the screen and canvas to the specified dimensions.
       * @param desiredScreenWidth - The new width of the screen.
       * @param desiredScreenHeight - The new height of the screen.
       * @param resolution
       */
      resize(desiredScreenWidth, desiredScreenHeight, resolution) {
        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
        this.screen.width = this.texture.frame.width;
        this.screen.height = this.texture.frame.height;
      }
      /**
       * Destroys this System and optionally removes the canvas from the dom.
       * @param {options | false} options - The options for destroying the view, or "false".
       * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.
       */
      destroy(options = false) {
        const removeView = typeof options === "boolean" ? options : !!options?.removeView;
        if (removeView && this.canvas.parentNode) {
          this.canvas.parentNode.removeChild(this.canvas);
        }
      }
    };
    _ViewSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "view",
      priority: 0
    };
    _ViewSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.width}
       * @default 800
       */
      width: 800,
      /**
       * {@link WebGLOptions.height}
       * @default 600
       */
      height: 600,
      /**
       * {@link WebGLOptions.autoDensity}
       * @default false
       */
      autoDensity: false,
      /**
       * {@link WebGLOptions.antialias}
       * @default false
       */
      antialias: false
    };
    ViewSystem = _ViewSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs
var SharedSystems, SharedRenderPipes;
var init_SharedSystems = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"() {
    init_define_AnParams();
    init_CustomRenderPipe();
    init_RenderGroupPipe();
    init_RenderGroupSystem();
    init_SpritePipe();
    init_globalHooks();
    init_BatcherPipe();
    init_AlphaMaskPipe();
    init_ColorMaskPipe();
    init_StencilMaskPipe();
    init_BackgroundSystem();
    init_BlendModePipe();
    init_ExtractSystem();
    init_GenerateTextureSystem();
    init_GlobalUniformSystem();
    init_SchedulerSystem();
    init_HelloSystem();
    init_RenderableGCSystem();
    init_TextureGCSystem();
    init_ViewSystem();
    SharedSystems = [
      BackgroundSystem,
      GlobalUniformSystem,
      HelloSystem,
      ViewSystem,
      RenderGroupSystem,
      TextureGCSystem,
      GenerateTextureSystem,
      ExtractSystem,
      RendererInitHook,
      RenderableGCSystem,
      SchedulerSystem
    ];
    SharedRenderPipes = [
      BlendModePipe,
      BatcherPipe,
      SpritePipe,
      RenderGroupPipe,
      AlphaMaskPipe,
      StencilMaskPipe,
      ColorMaskPipe,
      CustomRenderPipe
    ];
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs
var BindGroupSystem;
var init_BindGroupSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    BindGroupSystem = class {
      constructor(renderer) {
        this._hash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_hash");
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      getBindGroup(bindGroup, program, groupIndex) {
        bindGroup._updateKey();
        const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);
        return gpuBindGroup;
      }
      _createBindGroup(group, program, groupIndex) {
        const device = this._gpu.device;
        const groupLayout = program.layout[groupIndex];
        const entries = [];
        const renderer = this._renderer;
        for (const j2 in groupLayout) {
          const resource = group.resources[j2] ?? group.resources[groupLayout[j2]];
          let gpuResource;
          if (resource._resourceType === "uniformGroup") {
            const uniformGroup = resource;
            renderer.ubo.updateUniformGroup(uniformGroup);
            const buffer = uniformGroup.buffer;
            gpuResource = {
              buffer: renderer.buffer.getGPUBuffer(buffer),
              offset: 0,
              size: buffer.descriptor.size
            };
          } else if (resource._resourceType === "buffer") {
            const buffer = resource;
            gpuResource = {
              buffer: renderer.buffer.getGPUBuffer(buffer),
              offset: 0,
              size: buffer.descriptor.size
            };
          } else if (resource._resourceType === "bufferResource") {
            const bufferResource = resource;
            gpuResource = {
              buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),
              offset: bufferResource.offset,
              size: bufferResource.size
            };
          } else if (resource._resourceType === "textureSampler") {
            const sampler = resource;
            gpuResource = renderer.texture.getGpuSampler(sampler);
          } else if (resource._resourceType === "textureSource") {
            const texture = resource;
            gpuResource = renderer.texture.getGpuSource(texture).createView({});
          }
          entries.push({
            binding: groupLayout[j2],
            resource: gpuResource
          });
        }
        const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];
        const gpuBindGroup = device.createBindGroup({
          layout,
          entries
        });
        this._hash[group._key] = gpuBindGroup;
        return gpuBindGroup;
      }
      destroy() {
        for (const key of Object.keys(this._hash)) {
          this._hash[key] = null;
        }
        this._hash = null;
        this._renderer = null;
      }
    };
    BindGroupSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "bindGroup"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
var GpuBufferSystem;
var init_GpuBufferSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_fastCopy();
    GpuBufferSystem = class {
      constructor(renderer) {
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        this._managedBuffers = [];
        renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      getGPUBuffer(buffer) {
        return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
      }
      updateBuffer(buffer) {
        const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
        const data = buffer.data;
        if (buffer._updateID && data) {
          buffer._updateID = 0;
          this._gpu.device.queue.writeBuffer(
            gpuBuffer,
            0,
            data.buffer,
            0,
            // round to the nearest 4 bytes
            (buffer._updateSize || data.byteLength) + 3 & ~3
          );
        }
        return gpuBuffer;
      }
      /** dispose all WebGL resources of all managed buffers */
      destroyAll() {
        for (const id in this._gpuBuffers) {
          this._gpuBuffers[id].destroy();
        }
        this._gpuBuffers = {};
      }
      createGPUBuffer(buffer) {
        if (!this._gpuBuffers[buffer.uid]) {
          buffer.on("update", this.updateBuffer, this);
          buffer.on("change", this.onBufferChange, this);
          buffer.on("destroy", this.onBufferDestroy, this);
          this._managedBuffers.push(buffer);
        }
        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
        buffer._updateID = 0;
        if (buffer.data) {
          fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());
          gpuBuffer.unmap();
        }
        this._gpuBuffers[buffer.uid] = gpuBuffer;
        return gpuBuffer;
      }
      onBufferChange(buffer) {
        const gpuBuffer = this._gpuBuffers[buffer.uid];
        gpuBuffer.destroy();
        buffer._updateID = 0;
        this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);
      }
      /**
       * Disposes buffer
       * @param buffer - buffer with data
       */
      onBufferDestroy(buffer) {
        this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);
        this._destroyBuffer(buffer);
      }
      destroy() {
        this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));
        this._managedBuffers = null;
        this._gpuBuffers = null;
      }
      _destroyBuffer(buffer) {
        const gpuBuffer = this._gpuBuffers[buffer.uid];
        gpuBuffer.destroy();
        buffer.off("update", this.updateBuffer, this);
        buffer.off("change", this.onBufferChange, this);
        buffer.off("destroy", this.onBufferDestroy, this);
        this._gpuBuffers[buffer.uid] = null;
      }
    };
    GpuBufferSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "buffer"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
var GpuColorMaskSystem;
var init_GpuColorMaskSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    GpuColorMaskSystem = class {
      constructor(renderer) {
        this._colorMaskCache = 15;
        this._renderer = renderer;
      }
      setMask(colorMask) {
        if (this._colorMaskCache === colorMask)
          return;
        this._colorMaskCache = colorMask;
        this._renderer.pipeline.setColorMask(colorMask);
      }
      destroy() {
        this._renderer = null;
        this._colorMaskCache = null;
      }
    };
    GpuColorMaskSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "colorMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
var GpuDeviceSystem;
var init_GpuDeviceSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_Extensions();
    GpuDeviceSystem = class {
      /**
       * @param {WebGPURenderer} renderer - The renderer this System works for.
       */
      constructor(renderer) {
        this._renderer = renderer;
      }
      async init(options) {
        if (this._initPromise)
          return this._initPromise;
        this._initPromise = this._createDeviceAndAdaptor(options).then((gpu) => {
          this.gpu = gpu;
          this._renderer.runners.contextChange.emit(this.gpu);
        });
        return this._initPromise;
      }
      /**
       * Handle the context change event
       * @param gpu
       */
      contextChange(gpu) {
        this._renderer.gpu = gpu;
      }
      /**
       * Helper class to create a WebGL Context
       * @param {object} options - An options object that gets passed in to the canvas element containing the
       *    context attributes
       * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
       * @returns {WebGLRenderingContext} the WebGL context
       */
      async _createDeviceAndAdaptor(options) {
        const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({
          powerPreference: options.powerPreference,
          forceFallbackAdapter: options.forceFallbackAdapter
        });
        const requiredFeatures = [
          "texture-compression-bc",
          "texture-compression-astc",
          "texture-compression-etc2"
        ].filter((feature) => adapter.features.has(feature));
        const device = await adapter.requestDevice({
          requiredFeatures
        });
        return { adapter, device };
      }
      destroy() {
        this.gpu = null;
        this._renderer = null;
      }
    };
    GpuDeviceSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "device"
    };
    GpuDeviceSystem.defaultOptions = {
      /**
       * {@link WebGPUOptions.powerPreference}
       * @default default
       */
      powerPreference: void 0,
      /**
       * Force the use of the fallback adapter
       * @default false
       */
      forceFallbackAdapter: false
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
var GpuEncoderSystem;
var init_GpuEncoderSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    GpuEncoderSystem = class {
      constructor(renderer) {
        this._boundBindGroup = /* @__PURE__ */ Object.create(null);
        this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      renderStart() {
        this.commandFinished = new Promise((resolve) => {
          this._resolveCommandFinished = resolve;
        });
        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
      }
      beginRenderPass(gpuRenderTarget) {
        this.endRenderPass();
        this._clearCache();
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
      }
      endRenderPass() {
        if (this.renderPassEncoder) {
          this.renderPassEncoder.end();
        }
        this.renderPassEncoder = null;
      }
      setViewport(viewport) {
        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
      }
      setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
        this.setPipeline(pipeline);
      }
      setPipeline(pipeline) {
        if (this._boundPipeline === pipeline)
          return;
        this._boundPipeline = pipeline;
        this.renderPassEncoder.setPipeline(pipeline);
      }
      _setVertexBuffer(index, buffer) {
        if (this._boundVertexBuffer[index] === buffer)
          return;
        this._boundVertexBuffer[index] = buffer;
        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));
      }
      _setIndexBuffer(buffer) {
        if (this._boundIndexBuffer === buffer)
          return;
        this._boundIndexBuffer = buffer;
        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);
      }
      resetBindGroup(index) {
        this._boundBindGroup[index] = null;
      }
      setBindGroup(index, bindGroup, program) {
        if (this._boundBindGroup[index] === bindGroup)
          return;
        this._boundBindGroup[index] = bindGroup;
        bindGroup._touch(this._renderer.textureGC.count);
        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);
        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
      }
      setGeometry(geometry, program) {
        const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);
        for (const i3 in buffersToBind) {
          this._setVertexBuffer(i3, geometry.attributes[buffersToBind[i3]].buffer);
        }
        if (geometry.indexBuffer) {
          this._setIndexBuffer(geometry.indexBuffer);
        }
      }
      _setShaderBindGroups(shader, skipSync) {
        for (const i3 in shader.groups) {
          const bindGroup = shader.groups[i3];
          if (!skipSync) {
            this._syncBindGroup(bindGroup);
          }
          this.setBindGroup(i3, bindGroup, shader.gpuProgram);
        }
      }
      _syncBindGroup(bindGroup) {
        for (const j2 in bindGroup.resources) {
          const resource = bindGroup.resources[j2];
          if (resource.isUniformGroup) {
            this._renderer.ubo.updateUniformGroup(resource);
          }
        }
      }
      draw(options) {
        const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;
        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
        this.setGeometry(geometry, shader.gpuProgram);
        this._setShaderBindGroups(shader, skipSync);
        if (geometry.indexBuffer) {
          this.renderPassEncoder.drawIndexed(
            size || geometry.indexBuffer.data.length,
            instanceCount ?? geometry.instanceCount,
            start || 0
          );
        } else {
          this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);
        }
      }
      finishRenderPass() {
        if (this.renderPassEncoder) {
          this.renderPassEncoder.end();
          this.renderPassEncoder = null;
        }
      }
      postrender() {
        this.finishRenderPass();
        this._gpu.device.queue.submit([this.commandEncoder.finish()]);
        this._resolveCommandFinished();
        this.commandEncoder = null;
      }
      // restores a render pass if finishRenderPass was called
      // not optimised as really used for debugging!
      // used when we want to stop drawing and log a texture..
      restoreRenderPass() {
        const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(
          this._renderer.renderTarget.renderTarget,
          false,
          [0, 0, 0, 1]
        );
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
        const boundPipeline = this._boundPipeline;
        const boundVertexBuffer = { ...this._boundVertexBuffer };
        const boundIndexBuffer = this._boundIndexBuffer;
        const boundBindGroup = { ...this._boundBindGroup };
        this._clearCache();
        const viewport = this._renderer.renderTarget.viewport;
        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
        this.setPipeline(boundPipeline);
        for (const i3 in boundVertexBuffer) {
          this._setVertexBuffer(i3, boundVertexBuffer[i3]);
        }
        for (const i3 in boundBindGroup) {
          this.setBindGroup(i3, boundBindGroup[i3], null);
        }
        this._setIndexBuffer(boundIndexBuffer);
      }
      _clearCache() {
        for (let i3 = 0; i3 < 16; i3++) {
          this._boundBindGroup[i3] = null;
          this._boundVertexBuffer[i3] = null;
        }
        this._boundIndexBuffer = null;
        this._boundPipeline = null;
      }
      destroy() {
        this._renderer = null;
        this._gpu = null;
        this._boundBindGroup = null;
        this._boundVertexBuffer = null;
        this._boundIndexBuffer = null;
        this._boundPipeline = null;
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
    };
    GpuEncoderSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "encoder",
      priority: 1
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
var GpuStencilSystem;
var init_GpuStencilSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_const3();
    GpuStencilSystem = class {
      constructor(renderer) {
        this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      onRenderTargetChange(renderTarget) {
        let stencilState = this._renderTargetStencilState[renderTarget.uid];
        if (!stencilState) {
          stencilState = this._renderTargetStencilState[renderTarget.uid] = {
            stencilMode: STENCIL_MODES.DISABLED,
            stencilReference: 0
          };
        }
        this._activeRenderTarget = renderTarget;
        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
      }
      setStencilMode(stencilMode, stencilReference) {
        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
        stencilState.stencilMode = stencilMode;
        stencilState.stencilReference = stencilReference;
        const renderer = this._renderer;
        renderer.pipeline.setStencilMode(stencilMode);
        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
      }
      destroy() {
        this._renderer.renderTarget.onRenderTargetChange.remove(this);
        this._renderer = null;
        this._activeRenderTarget = null;
        this._renderTargetStencilState = null;
      }
    };
    GpuStencilSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "stencil"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs
var UboSystem;
var init_UboSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs"() {
    init_define_AnParams();
    init_unsafeEvalSupported();
    init_Buffer();
    init_const4();
    UboSystem = class {
      constructor(adaptor) {
        this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
        this._adaptor = adaptor;
        this._systemCheck();
      }
      /**
       * Overridable function by `pixi.js/unsafe-eval` to silence
       * throwing an error if platform doesn't support unsafe-evals.
       * @private
       */
      _systemCheck() {
        if (!unsafeEvalSupported()) {
          throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
        }
      }
      ensureUniformGroup(uniformGroup) {
        const uniformData = this.getUniformGroupData(uniformGroup);
        uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
          data: new Float32Array(uniformData.layout.size / 4),
          usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
        }));
      }
      getUniformGroupData(uniformGroup) {
        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
      }
      _initUniformGroup(uniformGroup) {
        const uniformGroupSignature = uniformGroup._signature;
        let uniformData = this._syncFunctionHash[uniformGroupSignature];
        if (!uniformData) {
          const elements = Object.keys(uniformGroup.uniformStructures).map((i3) => uniformGroup.uniformStructures[i3]);
          const layout = this._adaptor.createUboElements(elements);
          const syncFunction = this._generateUboSync(layout.uboElements);
          uniformData = this._syncFunctionHash[uniformGroupSignature] = {
            layout,
            syncFunction
          };
        }
        return this._syncFunctionHash[uniformGroupSignature];
      }
      _generateUboSync(uboElements) {
        return this._adaptor.generateUboSync(uboElements);
      }
      syncUniformGroup(uniformGroup, data, offset) {
        const uniformGroupData = this.getUniformGroupData(uniformGroup);
        uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
          data: new Float32Array(uniformGroupData.layout.size / 4),
          usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
        }));
        let dataInt32 = null;
        if (!data) {
          data = uniformGroup.buffer.data;
          dataInt32 = uniformGroup.buffer.dataInt32;
        }
        offset || (offset = 0);
        uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);
        return true;
      }
      updateUniformGroup(uniformGroup) {
        if (uniformGroup.isStatic && !uniformGroup._dirtyId)
          return false;
        uniformGroup._dirtyId = 0;
        const synced = this.syncUniformGroup(uniformGroup);
        uniformGroup.buffer.update();
        return synced;
      }
      destroy() {
        this._syncFunctionHash = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs
function createUboElementsWGSL(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  let offset = 0;
  for (let i3 = 0; i3 < uboElements.length; i3++) {
    const uboElement = uboElements[i3];
    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;
    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;
    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {
      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size = Math.max(size, align) * uboElement.data.size;
    }
    offset = Math.ceil(offset / align) * align;
    uboElement.size = size;
    uboElement.offset = offset;
    offset += size;
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
var WGSL_ALIGN_SIZE_DATA;
var init_createUboElementsWGSL = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs"() {
    "use strict";
    init_define_AnParams();
    WGSL_ALIGN_SIZE_DATA = {
      i32: { align: 4, size: 4 },
      u32: { align: 4, size: 4 },
      f32: { align: 4, size: 4 },
      f16: { align: 2, size: 2 },
      "vec2<i32>": { align: 8, size: 8 },
      "vec2<u32>": { align: 8, size: 8 },
      "vec2<f32>": { align: 8, size: 8 },
      "vec2<f16>": { align: 4, size: 4 },
      "vec3<i32>": { align: 16, size: 12 },
      "vec3<u32>": { align: 16, size: 12 },
      "vec3<f32>": { align: 16, size: 12 },
      "vec3<f16>": { align: 8, size: 6 },
      "vec4<i32>": { align: 16, size: 16 },
      "vec4<u32>": { align: 16, size: 16 },
      "vec4<f32>": { align: 16, size: 16 },
      "vec4<f16>": { align: 8, size: 8 },
      "mat2x2<f32>": { align: 8, size: 16 },
      "mat2x2<f16>": { align: 4, size: 8 },
      "mat3x2<f32>": { align: 8, size: 24 },
      "mat3x2<f16>": { align: 4, size: 12 },
      "mat4x2<f32>": { align: 8, size: 32 },
      "mat4x2<f16>": { align: 4, size: 16 },
      "mat2x3<f32>": { align: 16, size: 32 },
      "mat2x3<f16>": { align: 8, size: 16 },
      "mat3x3<f32>": { align: 16, size: 48 },
      "mat3x3<f16>": { align: 8, size: 24 },
      "mat4x3<f32>": { align: 16, size: 64 },
      "mat4x3<f16>": { align: 8, size: 32 },
      "mat2x4<f32>": { align: 16, size: 32 },
      "mat2x4<f16>": { align: 8, size: 16 },
      "mat3x4<f32>": { align: 16, size: 48 },
      "mat3x4<f16>": { align: 8, size: 24 },
      "mat4x4<f32>": { align: 16, size: 64 },
      "mat4x4<f16>": { align: 8, size: 32 }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs
var uniformParsers;
var init_uniformParsers = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs"() {
    "use strict";
    init_define_AnParams();
    uniformParsers = [
      // uploading pixi matrix object to mat3
      {
        type: "mat3x3<f32>",
        test: (data) => {
          const value = data.value;
          return value.a !== void 0;
        },
        ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
        uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
      },
      // uploading a pixi rectangle as a vec4
      {
        type: "vec4<f32>",
        test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
      },
      // uploading a pixi point as a vec2
      {
        type: "vec2<f32>",
        test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
      },
      // uploading a pixi color as a vec4
      {
        type: "vec4<f32>",
        test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
      },
      // uploading a pixi color as a vec3
      {
        type: "vec3<f32>",
        test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
      }
    ];
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs
function createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {
  const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
  let prev = 0;
  for (let i3 = 0; i3 < uboElements.length; i3++) {
    const uboElement = uboElements[i3];
    const name = uboElement.data.name;
    let parsed = false;
    let offset = 0;
    for (let j2 = 0; j2 < uniformParsers.length; j2++) {
      const uniformParser = uniformParsers[j2];
      if (uniformParser.test(uboElement.data)) {
        offset = uboElement.offset / 4;
        funcFragments.push(
          `name = "${name}";`,
          `offset += ${offset - prev};`,
          uniformParsers[j2][parserCode] || uniformParsers[j2].ubo
        );
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        offset = uboElement.offset / 4;
        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));
      } else {
        const template = singleSettersMap[uboElement.data.type];
        offset = uboElement.offset / 4;
        funcFragments.push(
          /* wgsl */
          `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
        );
      }
    }
    prev = offset;
  }
  const fragmentSrc = funcFragments.join("\n");
  return new Function(
    "uv",
    "data",
    "dataInt32",
    "offset",
    fragmentSrc
  );
}
var init_createUboSyncFunction = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs"() {
    init_define_AnParams();
    init_uniformParsers();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs
function loopMatrix(col, row) {
  const total = col * row;
  return `
        for (let i = 0; i < ${total}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `;
}
var uboSyncFunctionsSTD40, uboSyncFunctionsWGSL;
var init_uboSyncFunctions = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs"() {
    "use strict";
    init_define_AnParams();
    uboSyncFunctionsSTD40 = {
      f32: `
        data[offset] = v;`,
      i32: `
        dataInt32[offset] = v;`,
      "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
      "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
      "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
      "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
      "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
      "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
      "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
      "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
      "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
      "mat3x2<f32>": loopMatrix(3, 2),
      "mat4x2<f32>": loopMatrix(4, 2),
      "mat2x3<f32>": loopMatrix(2, 3),
      "mat4x3<f32>": loopMatrix(4, 3),
      "mat2x4<f32>": loopMatrix(2, 4),
      "mat3x4<f32>": loopMatrix(3, 4)
    };
    uboSyncFunctionsWGSL = {
      ...uboSyncFunctionsSTD40,
      "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs
function generateArraySyncWGSL(uboElement, offsetToAdd) {
  const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];
  const remainder = (align - size) / 4;
  const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
  return `
         v = uv.${uboElement.data.name};
         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)
         {
             for(var j = 0; j < ${size / 4}; j++)
             {
                 ${data}[arrayOffset++] = v[t++];
             }
             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
         }
     `;
}
var init_generateArraySyncWGSL = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs"() {
    init_define_AnParams();
    init_createUboElementsWGSL();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs
function createUboSyncFunctionWGSL(uboElements) {
  return createUboSyncFunction(
    uboElements,
    "uboWgsl",
    generateArraySyncWGSL,
    uboSyncFunctionsWGSL
  );
}
var init_createUboSyncFunctionWGSL = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs"() {
    init_define_AnParams();
    init_createUboSyncFunction();
    init_uboSyncFunctions();
    init_generateArraySyncWGSL();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs
var GpuUboSystem;
var init_GpuUboSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_UboSystem();
    init_createUboElementsWGSL();
    init_createUboSyncFunctionWGSL();
    GpuUboSystem = class extends UboSystem {
      constructor() {
        super({
          createUboElements: createUboElementsWGSL,
          generateUboSync: createUboSyncFunctionWGSL
        });
      }
    };
    GpuUboSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "ubo"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs
var BufferResource;
var init_BufferResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs"() {
    init_define_AnParams();
    init_eventemitter3();
    init_uid();
    BufferResource = class extends eventemitter3_default {
      /**
       * Create a new Buffer Resource.
       * @param options - The options for the buffer resource
       * @param options.buffer - The underlying buffer that this resource is using
       * @param options.offset - The offset of the buffer this resource is using.
       * If not provided, then it will use the offset of the buffer.
       * @param options.size - The size of the buffer this resource is using.
       * If not provided, then it will use the size of the buffer.
       */
      constructor({ buffer, offset, size }) {
        super();
        this.uid = uid("buffer");
        this._resourceType = "bufferResource";
        this._touched = 0;
        this._resourceId = uid("resource");
        this._bufferResource = true;
        this.destroyed = false;
        this.buffer = buffer;
        this.offset = offset | 0;
        this.size = size;
        this.buffer.on("change", this.onBufferChange, this);
      }
      onBufferChange() {
        this._resourceId = uid("resource");
        this.emit("change", this);
      }
      /**
       * Destroys this resource. Make sure the underlying buffer is not used anywhere else
       * if you want to destroy it as well, or code will explode
       * @param destroyBuffer - Should the underlying buffer be destroyed as well?
       */
      destroy(destroyBuffer = false) {
        this.destroyed = true;
        if (destroyBuffer) {
          this.buffer.destroy();
        }
        this.emit("change", this);
        this.buffer = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs
var UboBatch;
var init_UboBatch = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs"() {
    "use strict";
    init_define_AnParams();
    UboBatch = class {
      constructor({ minUniformOffsetAlignment: minUniformOffsetAlignment2 }) {
        this._minUniformOffsetAlignment = 256;
        this.byteIndex = 0;
        this._minUniformOffsetAlignment = minUniformOffsetAlignment2;
        this.data = new Float32Array(65535);
      }
      clear() {
        this.byteIndex = 0;
      }
      addEmptyGroup(size) {
        if (size > this._minUniformOffsetAlignment / 4) {
          throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);
        }
        const start = this.byteIndex;
        let newSize = start + size * 4;
        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
        if (newSize > this.data.length * 4) {
          throw new Error("UniformBufferBatch: ubo batch got too big");
        }
        this.byteIndex = newSize;
        return start;
      }
      addGroup(array) {
        const offset = this.addEmptyGroup(array.length);
        for (let i3 = 0; i3 < array.length; i3++) {
          this.data[offset / 4 + i3] = array[i3];
        }
        return offset;
      }
      destroy() {
        this.data = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
var minUniformOffsetAlignment, GpuUniformBatchPipe;
var init_GpuUniformBatchPipe = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Buffer();
    init_BufferResource();
    init_const4();
    init_UboBatch();
    init_BindGroup();
    minUniformOffsetAlignment = 128;
    GpuUniformBatchPipe = class {
      constructor(renderer) {
        this._bindGroupHash = /* @__PURE__ */ Object.create(null);
        this._buffers = [];
        this._bindGroups = [];
        this._bufferResources = [];
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
        this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });
        const totalBuffers = 256 / minUniformOffsetAlignment;
        for (let i3 = 0; i3 < totalBuffers; i3++) {
          let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
          if (i3 === 0)
            usage |= BufferUsage.COPY_SRC;
          this._buffers.push(new Buffer2({
            data: this._batchBuffer.data,
            usage
          }));
        }
      }
      renderEnd() {
        this._uploadBindGroups();
        this._resetBindGroups();
      }
      _resetBindGroups() {
        for (const i3 in this._bindGroupHash) {
          this._bindGroupHash[i3] = null;
        }
        this._batchBuffer.clear();
      }
      // just works for single bind groups for now
      getUniformBindGroup(group, duplicate) {
        if (!duplicate && this._bindGroupHash[group.uid]) {
          return this._bindGroupHash[group.uid];
        }
        this._renderer.ubo.ensureUniformGroup(group);
        const data = group.buffer.data;
        const offset = this._batchBuffer.addEmptyGroup(data.length);
        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
        return this._bindGroupHash[group.uid];
      }
      getUboResource(group) {
        this._renderer.ubo.updateUniformGroup(group);
        const data = group.buffer.data;
        const offset = this._batchBuffer.addGroup(data);
        return this._getBufferResource(offset / minUniformOffsetAlignment);
      }
      getArrayBindGroup(data) {
        const offset = this._batchBuffer.addGroup(data);
        return this._getBindGroup(offset / minUniformOffsetAlignment);
      }
      getArrayBufferResource(data) {
        const offset = this._batchBuffer.addGroup(data);
        const index = offset / minUniformOffsetAlignment;
        return this._getBufferResource(index);
      }
      _getBufferResource(index) {
        if (!this._bufferResources[index]) {
          const buffer = this._buffers[index % 2];
          this._bufferResources[index] = new BufferResource({
            buffer,
            offset: (index / 2 | 0) * 256,
            size: minUniformOffsetAlignment
          });
        }
        return this._bufferResources[index];
      }
      _getBindGroup(index) {
        if (!this._bindGroups[index]) {
          const bindGroup = new BindGroup({
            0: this._getBufferResource(index)
          });
          this._bindGroups[index] = bindGroup;
        }
        return this._bindGroups[index];
      }
      _uploadBindGroups() {
        const bufferSystem = this._renderer.buffer;
        const firstBuffer = this._buffers[0];
        firstBuffer.update(this._batchBuffer.byteIndex);
        bufferSystem.updateBuffer(firstBuffer);
        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
        for (let i3 = 1; i3 < this._buffers.length; i3++) {
          const buffer = this._buffers[i3];
          commandEncoder.copyBufferToBuffer(
            bufferSystem.getGPUBuffer(firstBuffer),
            minUniformOffsetAlignment,
            bufferSystem.getGPUBuffer(buffer),
            0,
            this._batchBuffer.byteIndex
          );
        }
        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
      }
      destroy() {
        for (let i3 = 0; i3 < this._bindGroups.length; i3++) {
          this._bindGroups[i3].destroy();
        }
        this._bindGroups = null;
        this._bindGroupHash = null;
        for (let i3 = 0; i3 < this._buffers.length; i3++) {
          this._buffers[i3].destroy();
        }
        this._buffers = null;
        for (let i3 = 0; i3 < this._bufferResources.length; i3++) {
          this._bufferResources[i3].destroy();
        }
        this._bufferResources = null;
        this._batchBuffer.destroy();
        this._bindGroupHash = null;
        this._renderer = null;
      }
    };
    GpuUniformBatchPipe.extension = {
      type: [
        ExtensionType.WebGPUPipes
      ],
      name: "uniformBatch"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs
function ensureAttributes(geometry, extractedData) {
  for (const i3 in geometry.attributes) {
    const attribute = geometry.attributes[i3];
    const attributeData = extractedData[i3];
    if (attributeData) {
      attribute.format ?? (attribute.format = attributeData.format);
      attribute.offset ?? (attribute.offset = attributeData.offset);
      attribute.instance ?? (attribute.instance = attributeData.instance);
    } else {
      warn(`Attribute ${i3} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
    }
  }
  ensureStartAndStride(geometry);
}
function ensureStartAndStride(geometry) {
  const { buffers, attributes } = geometry;
  const tempStride = {};
  const tempStart = {};
  for (const j2 in buffers) {
    const buffer = buffers[j2];
    tempStride[buffer.uid] = 0;
    tempStart[buffer.uid] = 0;
  }
  for (const j2 in attributes) {
    const attribute = attributes[j2];
    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
  }
  for (const j2 in attributes) {
    const attribute = attributes[j2];
    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);
    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);
    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
  }
}
var init_ensureAttributes = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs"() {
    init_define_AnParams();
    init_warn();
    init_getAttributeInfoFromFormat();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
var GpuStencilModesToPixi;
var init_GpuStencilModesToPixi = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs"() {
    init_define_AnParams();
    init_const3();
    GpuStencilModesToPixi = [];
    GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
    GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
      stencilWriteMask: 0,
      stencilReadMask: 0
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
      stencilFront: {
        compare: "equal",
        passOp: "increment-clamp"
      },
      stencilBack: {
        compare: "equal",
        passOp: "increment-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
      stencilFront: {
        compare: "equal",
        passOp: "decrement-clamp"
      },
      stencilBack: {
        compare: "equal",
        passOp: "decrement-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
      stencilWriteMask: 0,
      stencilFront: {
        compare: "equal",
        passOp: "keep"
      },
      stencilBack: {
        compare: "equal",
        passOp: "keep"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {
      stencilWriteMask: 0,
      stencilFront: {
        compare: "not-equal",
        passOp: "replace"
      },
      stencilBack: {
        compare: "not-equal",
        passOp: "replace"
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
function getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {
  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;
}
function getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {
  return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;
}
var topologyStringToId, PipelineSystem;
var init_PipelineSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_warn();
    init_ensureAttributes();
    init_const3();
    init_createIdFromString();
    init_GpuStencilModesToPixi();
    topologyStringToId = {
      "point-list": 0,
      "line-list": 1,
      "line-strip": 2,
      "triangle-list": 3,
      "triangle-strip": 4
    };
    PipelineSystem = class {
      constructor(renderer) {
        this._moduleCache = /* @__PURE__ */ Object.create(null);
        this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
        this._bindingNamesCache = /* @__PURE__ */ Object.create(null);
        this._pipeCache = /* @__PURE__ */ Object.create(null);
        this._pipeStateCaches = /* @__PURE__ */ Object.create(null);
        this._colorMask = 15;
        this._multisampleCount = 1;
        this._renderer = renderer;
      }
      contextChange(gpu) {
        this._gpu = gpu;
        this.setStencilMode(STENCIL_MODES.DISABLED);
        this._updatePipeHash();
      }
      setMultisampleCount(multisampleCount) {
        if (this._multisampleCount === multisampleCount)
          return;
        this._multisampleCount = multisampleCount;
        this._updatePipeHash();
      }
      setRenderTarget(renderTarget) {
        this._multisampleCount = renderTarget.msaaSamples;
        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;
        this._updatePipeHash();
      }
      setColorMask(colorMask) {
        if (this._colorMask === colorMask)
          return;
        this._colorMask = colorMask;
        this._updatePipeHash();
      }
      setStencilMode(stencilMode) {
        if (this._stencilMode === stencilMode)
          return;
        this._stencilMode = stencilMode;
        this._stencilState = GpuStencilModesToPixi[stencilMode];
        this._updatePipeHash();
      }
      setPipeline(geometry, program, state, passEncoder) {
        const pipeline = this.getPipeline(geometry, program, state);
        passEncoder.setPipeline(pipeline);
      }
      getPipeline(geometry, program, state, topology) {
        if (!geometry._layoutKey) {
          ensureAttributes(geometry, program.attributeData);
          this._generateBufferKey(geometry);
        }
        topology || (topology = geometry.topology);
        const key = getGraphicsStateKey(
          geometry._layoutKey,
          program._layoutKey,
          state.data,
          state._blendModeId,
          topologyStringToId[topology]
        );
        if (this._pipeCache[key])
          return this._pipeCache[key];
        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);
        return this._pipeCache[key];
      }
      _createPipeline(geometry, program, state, topology) {
        const device = this._gpu.device;
        const buffers = this._createVertexBufferLayouts(geometry, program);
        const blendModes = this._renderer.state.getColorTargets(state);
        blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
        const layout = this._renderer.shader.getProgramData(program).pipeline;
        const descriptor = {
          // TODO later check if its helpful to create..
          // layout,
          vertex: {
            module: this._getModule(program.vertex.source),
            entryPoint: program.vertex.entryPoint,
            // geometry..
            buffers
          },
          fragment: {
            module: this._getModule(program.fragment.source),
            entryPoint: program.fragment.entryPoint,
            targets: blendModes
          },
          primitive: {
            topology,
            cullMode: state.cullMode
          },
          layout,
          multisample: {
            count: this._multisampleCount
          },
          // depthStencil,
          label: `PIXI Pipeline`
        };
        if (this._depthStencilAttachment) {
          descriptor.depthStencil = {
            ...this._stencilState,
            format: "depth24plus-stencil8",
            depthWriteEnabled: state.depthTest,
            depthCompare: state.depthTest ? "less" : "always"
          };
        }
        const pipeline = device.createRenderPipeline(descriptor);
        return pipeline;
      }
      _getModule(code) {
        return this._moduleCache[code] || this._createModule(code);
      }
      _createModule(code) {
        const device = this._gpu.device;
        this._moduleCache[code] = device.createShaderModule({
          code
        });
        return this._moduleCache[code];
      }
      _generateBufferKey(geometry) {
        const keyGen = [];
        let index = 0;
        const attributeKeys = Object.keys(geometry.attributes).sort();
        for (let i3 = 0; i3 < attributeKeys.length; i3++) {
          const attribute = geometry.attributes[attributeKeys[i3]];
          keyGen[index++] = attribute.offset;
          keyGen[index++] = attribute.format;
          keyGen[index++] = attribute.stride;
          keyGen[index++] = attribute.instance;
        }
        const stringKey = keyGen.join("|");
        geometry._layoutKey = createIdFromString(stringKey, "geometry");
        return geometry._layoutKey;
      }
      _generateAttributeLocationsKey(program) {
        const keyGen = [];
        let index = 0;
        const attributeKeys = Object.keys(program.attributeData).sort();
        for (let i3 = 0; i3 < attributeKeys.length; i3++) {
          const attribute = program.attributeData[attributeKeys[i3]];
          keyGen[index++] = attribute.location;
        }
        const stringKey = keyGen.join("|");
        program._attributeLocationsKey = createIdFromString(stringKey, "programAttributes");
        return program._attributeLocationsKey;
      }
      /**
       * Returns a hash of buffer names mapped to bind locations.
       * This is used to bind the correct buffer to the correct location in the shader.
       * @param geometry - The geometry where to get the buffer names
       * @param program - The program where to get the buffer names
       * @returns An object of buffer names mapped to the bind location.
       */
      getBufferNamesToBind(geometry, program) {
        const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
        if (this._bindingNamesCache[key])
          return this._bindingNamesCache[key];
        const data = this._createVertexBufferLayouts(geometry, program);
        const bufferNamesToBind = /* @__PURE__ */ Object.create(null);
        const attributeData = program.attributeData;
        for (let i3 = 0; i3 < data.length; i3++) {
          const attributes = Object.values(data[i3].attributes);
          const shaderLocation = attributes[0].shaderLocation;
          for (const j2 in attributeData) {
            if (attributeData[j2].location === shaderLocation) {
              bufferNamesToBind[i3] = j2;
              break;
            }
          }
        }
        this._bindingNamesCache[key] = bufferNamesToBind;
        return bufferNamesToBind;
      }
      _createVertexBufferLayouts(geometry, program) {
        if (!program._attributeLocationsKey)
          this._generateAttributeLocationsKey(program);
        const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
        if (this._bufferLayoutsCache[key]) {
          return this._bufferLayoutsCache[key];
        }
        const vertexBuffersLayout = [];
        geometry.buffers.forEach((buffer) => {
          const bufferEntry = {
            arrayStride: 0,
            stepMode: "vertex",
            attributes: []
          };
          const bufferEntryAttributes = bufferEntry.attributes;
          for (const i3 in program.attributeData) {
            const attribute = geometry.attributes[i3];
            if ((attribute.divisor ?? 1) !== 1) {
              warn(`Attribute ${i3} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);
            }
            if (attribute.buffer === buffer) {
              bufferEntry.arrayStride = attribute.stride;
              bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";
              bufferEntryAttributes.push({
                shaderLocation: program.attributeData[i3].location,
                offset: attribute.offset,
                format: attribute.format
              });
            }
          }
          if (bufferEntryAttributes.length) {
            vertexBuffersLayout.push(bufferEntry);
          }
        });
        this._bufferLayoutsCache[key] = vertexBuffersLayout;
        return vertexBuffersLayout;
      }
      _updatePipeHash() {
        const key = getGlobalStateKey(
          this._stencilMode,
          this._multisampleCount,
          this._colorMask,
          this._depthStencilAttachment
        );
        if (!this._pipeStateCaches[key]) {
          this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);
        }
        this._pipeCache = this._pipeStateCaches[key];
      }
      destroy() {
        this._renderer = null;
        this._bufferLayoutsCache = null;
      }
    };
    PipelineSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "pipeline"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
function calculateProjection(pm, x2, y2, width, height, flipY) {
  const sign = flipY ? 1 : -1;
  pm.identity();
  pm.a = 1 / width * 2;
  pm.d = sign * (1 / height * 2);
  pm.tx = -1 - x2 * pm.a;
  pm.ty = -sign - y2 * pm.d;
  return pm;
}
var init_calculateProjection = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
function isRenderingToScreen(renderTarget) {
  const resource = renderTarget.colorTexture.source.resource;
  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);
}
var init_isRenderingToScreen = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs
var RenderTargetSystem;
var init_RenderTargetSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_Rectangle();
    init_const7();
    init_calculateProjection();
    init_SystemRunner();
    init_CanvasSource();
    init_TextureSource();
    init_Texture();
    init_getCanvasTexture();
    init_isRenderingToScreen();
    init_RenderTarget();
    RenderTargetSystem = class {
      constructor(renderer) {
        this.rootViewPort = new Rectangle();
        this.viewport = new Rectangle();
        this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
        this.projectionMatrix = new Matrix();
        this.defaultClearColor = [0, 0, 0, 0];
        this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        this._renderTargetStack = [];
        this._renderer = renderer;
        renderer.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
      }
      /** called when dev wants to finish a render pass */
      finishRenderPass() {
        this.adaptor.finishRenderPass(this.renderTarget);
      }
      /**
       * called when the renderer starts to render a scene.
       * @param options
       * @param options.target - the render target to render to
       * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
       * @param options.clearColor - the color to clear to
       * @param options.frame - the frame to render to
       */
      renderStart({
        target,
        clear,
        clearColor,
        frame
      }) {
        this._renderTargetStack.length = 0;
        this.push(
          target,
          clear,
          clearColor,
          frame
        );
        this.rootViewPort.copyFrom(this.viewport);
        this.rootRenderTarget = this.renderTarget;
        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
        this.adaptor.prerender?.(this.rootRenderTarget);
      }
      postrender() {
        this.adaptor.postrender?.(this.rootRenderTarget);
      }
      /**
       * Binding a render surface! This is the main function of the render target system.
       * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.
       * Once bound all draw calls will be rendered to the render surface.
       *
       * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.
       * @param renderSurface - the render surface to bind
       * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
       * @param clearColor - the color to clear to
       * @param frame - the frame to render to
       * @returns the render target that was bound
       */
      bind(renderSurface, clear = true, clearColor, frame) {
        const renderTarget = this.getRenderTarget(renderSurface);
        const didChange = this.renderTarget !== renderTarget;
        this.renderTarget = renderTarget;
        this.renderSurface = renderSurface;
        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
        if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
          this.adaptor.resizeGpuRenderTarget(renderTarget);
          gpuRenderTarget.width = renderTarget.pixelWidth;
          gpuRenderTarget.height = renderTarget.pixelHeight;
        }
        const source9 = renderTarget.colorTexture;
        const viewport = this.viewport;
        const pixelWidth = source9.pixelWidth;
        const pixelHeight = source9.pixelHeight;
        if (!frame && renderSurface instanceof Texture) {
          frame = renderSurface.frame;
        }
        if (frame) {
          const resolution = source9._resolution;
          viewport.x = frame.x * resolution + 0.5 | 0;
          viewport.y = frame.y * resolution + 0.5 | 0;
          viewport.width = frame.width * resolution + 0.5 | 0;
          viewport.height = frame.height * resolution + 0.5 | 0;
        } else {
          viewport.x = 0;
          viewport.y = 0;
          viewport.width = pixelWidth;
          viewport.height = pixelHeight;
        }
        calculateProjection(
          this.projectionMatrix,
          0,
          0,
          viewport.width / source9.resolution,
          viewport.height / source9.resolution,
          !renderTarget.isRoot
        );
        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);
        if (didChange) {
          this.onRenderTargetChange.emit(renderTarget);
        }
        return renderTarget;
      }
      clear(target, clear = CLEAR.ALL, clearColor) {
        if (!clear)
          return;
        if (target) {
          target = this.getRenderTarget(target);
        }
        this.adaptor.clear(
          target || this.renderTarget,
          clear,
          clearColor,
          this.viewport
        );
      }
      contextChange() {
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Push a render surface to the renderer. This will bind the render surface to the renderer,
       * @param renderSurface - the render surface to push
       * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
       * @param clearColor - the color to clear to
       * @param frame - the frame to use when rendering to the render surface
       */
      push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {
        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);
        this._renderTargetStack.push({
          renderTarget,
          frame
        });
        return renderTarget;
      }
      /** Pops the current render target from the renderer and restores the previous render target. */
      pop() {
        this._renderTargetStack.pop();
        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];
        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);
      }
      /**
       * Gets the render target from the provide render surface. Eg if its a texture,
       * it will return the render target for the texture.
       * If its a render target, it will return the same render target.
       * @param renderSurface - the render surface to get the render target for
       * @returns the render target for the render surface
       */
      getRenderTarget(renderSurface) {
        if (renderSurface.isTexture) {
          renderSurface = renderSurface.source;
        }
        return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
      }
      /**
       * Copies a render surface to another texture.
       *
       * NOTE:
       * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer
       *
       * The following is not valid:
       * @example
       * const canvas = document.createElement('canvas')
       * canvas.width = 200;
       * canvas.height = 200;
       *
       * const ctx = canvas2.getContext('2d')!
       * ctx.fillStyle = 'red'
       * ctx.fillRect(0, 0, 200, 200);
       *
       * const texture = RenderTexture.create({
       *   width: 200,
       *   height: 200,
       * })
       * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);
       *
       * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});
       *
       * The best way to copy a canvas is to create a texture from it. Then render with that.
       *
       * Parsing in a RenderTarget canvas context (with a 2d context)
       * @param sourceRenderSurfaceTexture - the render surface to copy from
       * @param destinationTexture - the texture to copy to
       * @param originSrc - the origin of the copy
       * @param originSrc.x - the x origin of the copy
       * @param originSrc.y - the y origin of the copy
       * @param size - the size of the copy
       * @param size.width - the width of the copy
       * @param size.height - the height of the copy
       * @param originDest - the destination origin (top left to paste from!)
       * @param originDest.x - the x origin of the paste
       * @param originDest.y - the y origin of the paste
       */
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
        if (originSrc.x < 0) {
          size.width += originSrc.x;
          originDest.x -= originSrc.x;
          originSrc.x = 0;
        }
        if (originSrc.y < 0) {
          size.height += originSrc.y;
          originDest.y -= originSrc.y;
          originSrc.y = 0;
        }
        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;
        size.width = Math.min(size.width, pixelWidth - originSrc.x);
        size.height = Math.min(size.height, pixelHeight - originSrc.y);
        return this.adaptor.copyToTexture(
          sourceRenderSurfaceTexture,
          destinationTexture,
          originSrc,
          size,
          originDest
        );
      }
      /**
       * ensures that we have a depth stencil buffer available to render to
       * This is used by the mask system to make sure we have a stencil buffer.
       */
      ensureDepthStencil() {
        if (!this.renderTarget.stencil) {
          this.renderTarget.stencil = true;
          this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);
        }
      }
      /** nukes the render target system */
      destroy() {
        this._renderer = null;
        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {
          if (renderTarget !== key) {
            renderTarget.destroy();
          }
        });
        this._renderSurfaceToRenderTargetHash.clear();
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
      }
      _initRenderTarget(renderSurface) {
        let renderTarget = null;
        if (CanvasSource.test(renderSurface)) {
          renderSurface = getCanvasTexture(renderSurface).source;
        }
        if (renderSurface instanceof RenderTarget) {
          renderTarget = renderSurface;
        } else if (renderSurface instanceof TextureSource) {
          renderTarget = new RenderTarget({
            colorTextures: [renderSurface]
          });
          if (CanvasSource.test(renderSurface.source.resource)) {
            renderTarget.isRoot = true;
          }
          renderSurface.once("destroy", () => {
            renderTarget.destroy();
            this._renderSurfaceToRenderTargetHash.delete(renderSurface);
            const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];
            if (gpuRenderTarget) {
              this._gpuRenderTargetHash[renderTarget.uid] = null;
              this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);
            }
          });
        }
        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
        return renderTarget;
      }
      getGpuRenderTarget(renderTarget) {
        return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));
      }
      resetState() {
        this.renderTarget = null;
        this.renderSurface = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
var GpuRenderTarget;
var init_GpuRenderTarget = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs"() {
    "use strict";
    init_define_AnParams();
    GpuRenderTarget = class {
      constructor() {
        this.contexts = [];
        this.msaaTextures = [];
        this.msaaSamples = 1;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs
var GpuRenderTargetAdaptor;
var init_GpuRenderTargetAdaptor = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs"() {
    init_define_AnParams();
    init_const7();
    init_CanvasSource();
    init_TextureSource();
    init_GpuRenderTarget();
    GpuRenderTargetAdaptor = class {
      init(renderer, renderTargetSystem) {
        this._renderer = renderer;
        this._renderTargetSystem = renderTargetSystem;
      }
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
        const renderer = this._renderer;
        const baseGpuTexture = this._getGpuColorTexture(
          sourceRenderSurfaceTexture
        );
        const backGpuTexture = renderer.texture.getGpuSource(
          destinationTexture.source
        );
        renderer.encoder.commandEncoder.copyTextureToTexture(
          {
            texture: baseGpuTexture,
            origin: originSrc
          },
          {
            texture: backGpuTexture,
            origin: originDest
          },
          size
        );
        return destinationTexture;
      }
      startRenderPass(renderTarget, clear = true, clearColor, viewport) {
        const renderTargetSystem = this._renderTargetSystem;
        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
        gpuRenderTarget.descriptor = descriptor;
        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);
        this._renderer.encoder.beginRenderPass(gpuRenderTarget);
        this._renderer.encoder.setViewport(viewport);
      }
      finishRenderPass() {
        this._renderer.encoder.endRenderPass();
      }
      /**
       * returns the gpu texture for the first color texture in the render target
       * mainly used by the filter manager to get copy the texture for blending
       * @param renderTarget
       * @returns a gpu texture
       */
      _getGpuColorTexture(renderTarget) {
        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
        if (gpuRenderTarget.contexts[0]) {
          return gpuRenderTarget.contexts[0].getCurrentTexture();
        }
        return this._renderer.texture.getGpuSource(
          renderTarget.colorTextures[0].source
        );
      }
      getDescriptor(renderTarget, clear, clearValue) {
        if (typeof clear === "boolean") {
          clear = clear ? CLEAR.ALL : CLEAR.NONE;
        }
        const renderTargetSystem = this._renderTargetSystem;
        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        const colorAttachments = renderTarget.colorTextures.map(
          (texture, i3) => {
            const context2 = gpuRenderTarget.contexts[i3];
            let view;
            let resolveTarget;
            if (context2) {
              const currentTexture = context2.getCurrentTexture();
              const canvasTextureView = currentTexture.createView();
              view = canvasTextureView;
            } else {
              view = this._renderer.texture.getGpuSource(texture).createView({
                mipLevelCount: 1
              });
            }
            if (gpuRenderTarget.msaaTextures[i3]) {
              resolveTarget = view;
              view = this._renderer.texture.getTextureView(
                gpuRenderTarget.msaaTextures[i3]
              );
            }
            const loadOp = clear & CLEAR.COLOR ? "clear" : "load";
            clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);
            return {
              view,
              resolveTarget,
              clearValue,
              storeOp: "store",
              loadOp
            };
          }
        );
        let depthStencilAttachment;
        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {
          renderTarget.ensureDepthStencilTexture();
          renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;
        }
        if (renderTarget.depthStencilTexture) {
          const stencilLoadOp = clear & CLEAR.STENCIL ? "clear" : "load";
          const depthLoadOp = clear & CLEAR.DEPTH ? "clear" : "load";
          depthStencilAttachment = {
            view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),
            stencilStoreOp: "store",
            stencilLoadOp,
            depthClearValue: 1,
            depthLoadOp,
            depthStoreOp: "store"
          };
        }
        const descriptor = {
          colorAttachments,
          depthStencilAttachment
        };
        return descriptor;
      }
      clear(renderTarget, clear = true, clearColor, viewport) {
        if (!clear)
          return;
        const { gpu, encoder } = this._renderer;
        const device = gpu.device;
        const standAlone = encoder.commandEncoder === null;
        if (standAlone) {
          const commandEncoder = device.createCommandEncoder();
          const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);
          const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
          passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
          passEncoder.end();
          const gpuCommands = commandEncoder.finish();
          device.queue.submit([gpuCommands]);
        } else {
          this.startRenderPass(renderTarget, clear, clearColor, viewport);
        }
      }
      initGpuRenderTarget(renderTarget) {
        renderTarget.isRoot = true;
        const gpuRenderTarget = new GpuRenderTarget();
        renderTarget.colorTextures.forEach((colorTexture, i3) => {
          if (CanvasSource.test(colorTexture.resource)) {
            const context2 = colorTexture.resource.getContext(
              "webgpu"
            );
            const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
            try {
              context2.configure({
                device: this._renderer.gpu.device,
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                format: "bgra8unorm",
                alphaMode
              });
            } catch (e2) {
              console.error(e2);
            }
            gpuRenderTarget.contexts[i3] = context2;
          }
          gpuRenderTarget.msaa = colorTexture.source.antialias;
          if (colorTexture.source.antialias) {
            const msaaTexture = new TextureSource({
              width: 0,
              height: 0,
              sampleCount: 4
            });
            gpuRenderTarget.msaaTextures[i3] = msaaTexture;
          }
        });
        if (gpuRenderTarget.msaa) {
          gpuRenderTarget.msaaSamples = 4;
          if (renderTarget.depthStencilTexture) {
            renderTarget.depthStencilTexture.source.sampleCount = 4;
          }
        }
        return gpuRenderTarget;
      }
      destroyGpuRenderTarget(gpuRenderTarget) {
        gpuRenderTarget.contexts.forEach((context2) => {
          context2.unconfigure();
        });
        gpuRenderTarget.msaaTextures.forEach((texture) => {
          texture.destroy();
        });
        gpuRenderTarget.msaaTextures.length = 0;
        gpuRenderTarget.contexts.length = 0;
      }
      ensureDepthStencilTexture(renderTarget) {
        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {
          renderTarget.depthStencilTexture.source.sampleCount = 4;
        }
      }
      resizeGpuRenderTarget(renderTarget) {
        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
        gpuRenderTarget.width = renderTarget.width;
        gpuRenderTarget.height = renderTarget.height;
        if (gpuRenderTarget.msaa) {
          renderTarget.colorTextures.forEach((colorTexture, i3) => {
            const msaaTexture = gpuRenderTarget.msaaTextures[i3];
            msaaTexture?.resize(
              colorTexture.source.width,
              colorTexture.source.height,
              colorTexture.source._resolution
            );
          });
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
var GpuRenderTargetSystem;
var init_GpuRenderTargetSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_RenderTargetSystem();
    init_GpuRenderTargetAdaptor();
    GpuRenderTargetSystem = class extends RenderTargetSystem {
      constructor(renderer) {
        super(renderer);
        this.adaptor = new GpuRenderTargetAdaptor();
        this.adaptor.init(renderer, this);
      }
    };
    GpuRenderTargetSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "renderTarget"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
var GpuShaderSystem;
var init_GpuShaderSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    GpuShaderSystem = class {
      constructor() {
        this._gpuProgramData = /* @__PURE__ */ Object.create(null);
      }
      contextChange(gpu) {
        this._gpu = gpu;
        this.maxTextures = gpu.device.limits.maxSampledTexturesPerShaderStage;
      }
      getProgramData(program) {
        return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);
      }
      _createGPUProgramData(program) {
        const device = this._gpu.device;
        const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
        const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
        this._gpuProgramData[program._layoutKey] = {
          bindGroups,
          pipeline: device.createPipelineLayout(pipelineLayoutDesc)
        };
        return this._gpuProgramData[program._layoutKey];
      }
      destroy() {
        this._gpu = null;
        this._gpuProgramData = null;
      }
    };
    GpuShaderSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "shader"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
var GpuBlendModesToPixi;
var init_GpuBlendModesToPixi = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs"() {
    "use strict";
    init_define_AnParams();
    GpuBlendModesToPixi = {};
    GpuBlendModesToPixi.normal = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.add = {
      alpha: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.multiply = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "dst",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.screen = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.overlay = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.none = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "zero",
        dstFactor: "zero",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["normal-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["add-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["screen-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.erase = {
      alpha: {
        srcFactor: "zero",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "zero",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.min = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "min"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "min"
      }
    };
    GpuBlendModesToPixi.max = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "max"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "max"
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
var GpuStateSystem;
var init_GpuStateSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_State();
    init_GpuBlendModesToPixi();
    GpuStateSystem = class {
      constructor() {
        this.defaultState = new State();
        this.defaultState.blend = true;
      }
      contextChange(gpu) {
        this.gpu = gpu;
      }
      /**
       * Gets the blend mode data for the current state
       * @param state - The state to get the blend mode from
       */
      getColorTargets(state) {
        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
        return [
          {
            format: "bgra8unorm",
            writeMask: 0,
            blend
          }
        ];
      }
      destroy() {
        this.gpu = null;
      }
    };
    GpuStateSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "state"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
var gpuUploadBufferImageResource;
var init_gpuUploadBufferImageResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs"() {
    "use strict";
    init_define_AnParams();
    gpuUploadBufferImageResource = {
      type: "image",
      upload(source9, gpuTexture, gpu) {
        const resource = source9.resource;
        const total = (source9.pixelWidth | 0) * (source9.pixelHeight | 0);
        const bytesPerPixel = resource.byteLength / total;
        gpu.device.queue.writeTexture(
          { texture: gpuTexture },
          resource,
          {
            offset: 0,
            rowsPerImage: source9.pixelHeight,
            bytesPerRow: source9.pixelHeight * bytesPerPixel
          },
          {
            width: source9.pixelWidth,
            height: source9.pixelHeight,
            depthOrArrayLayers: 1
          }
        );
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs
var blockDataMap, defaultBlockData, gpuUploadCompressedTextureResource;
var init_gpuUploadCompressedTextureResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs"() {
    "use strict";
    init_define_AnParams();
    blockDataMap = {
      "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
      "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
      "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }
    };
    defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
    gpuUploadCompressedTextureResource = {
      type: "compressed",
      upload(source9, gpuTexture, gpu) {
        let mipWidth = source9.pixelWidth;
        let mipHeight = source9.pixelHeight;
        const blockData = blockDataMap[source9.format] || defaultBlockData;
        for (let i3 = 0; i3 < source9.resource.length; i3++) {
          const levelBuffer = source9.resource[i3];
          const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;
          gpu.device.queue.writeTexture(
            {
              texture: gpuTexture,
              mipLevel: i3
            },
            levelBuffer,
            {
              offset: 0,
              bytesPerRow
            },
            {
              width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,
              height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,
              depthOrArrayLayers: 1
            }
          );
          mipWidth = Math.max(mipWidth >> 1, 1);
          mipHeight = Math.max(mipHeight >> 1, 1);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
var gpuUploadImageResource;
var init_gpuUploadImageSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs"() {
    "use strict";
    init_define_AnParams();
    gpuUploadImageResource = {
      type: "image",
      upload(source9, gpuTexture, gpu) {
        const resource = source9.resource;
        if (!resource)
          return;
        const width = Math.min(gpuTexture.width, source9.resourceWidth || source9.pixelWidth);
        const height = Math.min(gpuTexture.height, source9.resourceHeight || source9.pixelHeight);
        const premultipliedAlpha = source9.alphaMode === "premultiply-alpha-on-upload";
        gpu.device.queue.copyExternalImageToTexture(
          { source: resource },
          { texture: gpuTexture, premultipliedAlpha },
          {
            width,
            height
          }
        );
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs
var gpuUploadVideoResource;
var init_gpuUploadVideoSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs"() {
    init_define_AnParams();
    init_gpuUploadImageSource();
    gpuUploadVideoResource = {
      type: "video",
      upload(source9, gpuTexture, gpu) {
        gpuUploadImageResource.upload(source9, gpuTexture, gpu);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
var GpuMipmapGenerator;
var init_GpuMipmapGenerator = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs"() {
    "use strict";
    init_define_AnParams();
    GpuMipmapGenerator = class {
      constructor(device) {
        this.device = device;
        this.sampler = device.createSampler({ minFilter: "linear" });
        this.pipelines = {};
      }
      _getMipmapPipeline(format) {
        let pipeline = this.pipelines[format];
        if (!pipeline) {
          if (!this.mipmapShaderModule) {
            this.mipmapShaderModule = this.device.createShaderModule({
              code: (
                /* wgsl */
                `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
              )
            });
          }
          pipeline = this.device.createRenderPipeline({
            layout: "auto",
            vertex: {
              module: this.mipmapShaderModule,
              entryPoint: "vertexMain"
            },
            fragment: {
              module: this.mipmapShaderModule,
              entryPoint: "fragmentMain",
              targets: [{ format }]
            }
          });
          this.pipelines[format] = pipeline;
        }
        return pipeline;
      }
      /**
       * Generates mipmaps for the given GPUTexture from the data in level 0.
       * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
       * @returns {module:External.GPUTexture} - The originally passed texture
       */
      generateMipmap(texture) {
        const pipeline = this._getMipmapPipeline(texture.format);
        if (texture.dimension === "3d" || texture.dimension === "1d") {
          throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
        }
        let mipTexture = texture;
        const arrayLayerCount = texture.depthOrArrayLayers || 1;
        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
        if (!renderToSource) {
          const mipTextureDescriptor = {
            size: {
              width: Math.ceil(texture.width / 2),
              height: Math.ceil(texture.height / 2),
              depthOrArrayLayers: arrayLayerCount
            },
            format: texture.format,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
            mipLevelCount: texture.mipLevelCount - 1
          };
          mipTexture = this.device.createTexture(mipTextureDescriptor);
        }
        const commandEncoder = this.device.createCommandEncoder({});
        const bindGroupLayout = pipeline.getBindGroupLayout(0);
        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
          let srcView = texture.createView({
            baseMipLevel: 0,
            mipLevelCount: 1,
            dimension: "2d",
            baseArrayLayer: arrayLayer,
            arrayLayerCount: 1
          });
          let dstMipLevel = renderToSource ? 1 : 0;
          for (let i3 = 1; i3 < texture.mipLevelCount; ++i3) {
            const dstView = mipTexture.createView({
              baseMipLevel: dstMipLevel++,
              mipLevelCount: 1,
              dimension: "2d",
              baseArrayLayer: arrayLayer,
              arrayLayerCount: 1
            });
            const passEncoder = commandEncoder.beginRenderPass({
              colorAttachments: [{
                view: dstView,
                storeOp: "store",
                loadOp: "clear",
                clearValue: { r: 0, g: 0, b: 0, a: 0 }
              }]
            });
            const bindGroup = this.device.createBindGroup({
              layout: bindGroupLayout,
              entries: [{
                binding: 0,
                resource: this.sampler
              }, {
                binding: 1,
                resource: srcView
              }]
            });
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, bindGroup);
            passEncoder.draw(3, 1, 0, 0);
            passEncoder.end();
            srcView = dstView;
          }
        }
        if (!renderToSource) {
          const mipLevelSize = {
            width: Math.ceil(texture.width / 2),
            height: Math.ceil(texture.height / 2),
            depthOrArrayLayers: arrayLayerCount
          };
          for (let i3 = 1; i3 < texture.mipLevelCount; ++i3) {
            commandEncoder.copyTextureToTexture({
              texture: mipTexture,
              mipLevel: i3 - 1
            }, {
              texture,
              mipLevel: i3
            }, mipLevelSize);
            mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
            mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
          }
        }
        this.device.queue.submit([commandEncoder.finish()]);
        if (!renderToSource) {
          mipTexture.destroy();
        }
        return texture;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
var GpuTextureSystem;
var init_GpuTextureSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_Extensions();
    init_UniformGroup();
    init_CanvasPool();
    init_BindGroup();
    init_gpuUploadBufferImageResource();
    init_gpuUploadCompressedTextureResource();
    init_gpuUploadImageSource();
    init_gpuUploadVideoSource();
    init_GpuMipmapGenerator();
    GpuTextureSystem = class {
      constructor(renderer) {
        this.managedTextures = [];
        this._gpuSources = /* @__PURE__ */ Object.create(null);
        this._gpuSamplers = /* @__PURE__ */ Object.create(null);
        this._bindGroupHash = /* @__PURE__ */ Object.create(null);
        this._textureViewHash = /* @__PURE__ */ Object.create(null);
        this._uploads = {
          image: gpuUploadImageResource,
          buffer: gpuUploadBufferImageResource,
          video: gpuUploadVideoResource,
          compressed: gpuUploadCompressedTextureResource
        };
        this._renderer = renderer;
        renderer.renderableGC.addManagedHash(this, "_gpuSources");
        renderer.renderableGC.addManagedHash(this, "_gpuSamplers");
        renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
        renderer.renderableGC.addManagedHash(this, "_textureViewHash");
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      initSource(source9) {
        if (source9.autoGenerateMipmaps) {
          const biggestDimension = Math.max(source9.pixelWidth, source9.pixelHeight);
          source9.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
        }
        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
        if (source9.uploadMethodId !== "compressed") {
          usage |= GPUTextureUsage.RENDER_ATTACHMENT;
          usage |= GPUTextureUsage.COPY_SRC;
        }
        const blockData = blockDataMap[source9.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
        const width = Math.ceil(source9.pixelWidth / blockData.blockWidth) * blockData.blockWidth;
        const height = Math.ceil(source9.pixelHeight / blockData.blockHeight) * blockData.blockHeight;
        const textureDescriptor = {
          label: source9.label,
          size: { width, height },
          format: source9.format,
          sampleCount: source9.sampleCount,
          mipLevelCount: source9.mipLevelCount,
          dimension: source9.dimension,
          usage
        };
        const gpuTexture = this._gpu.device.createTexture(textureDescriptor);
        this._gpuSources[source9.uid] = gpuTexture;
        if (!this.managedTextures.includes(source9)) {
          source9.on("update", this.onSourceUpdate, this);
          source9.on("resize", this.onSourceResize, this);
          source9.on("destroy", this.onSourceDestroy, this);
          source9.on("unload", this.onSourceUnload, this);
          source9.on("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.push(source9);
        }
        this.onSourceUpdate(source9);
        return gpuTexture;
      }
      onSourceUpdate(source9) {
        const gpuTexture = this.getGpuSource(source9);
        if (!gpuTexture)
          return;
        if (this._uploads[source9.uploadMethodId]) {
          this._uploads[source9.uploadMethodId].upload(source9, gpuTexture, this._gpu);
        }
        if (source9.autoGenerateMipmaps && source9.mipLevelCount > 1) {
          this.onUpdateMipmaps(source9);
        }
      }
      onSourceUnload(source9) {
        const gpuTexture = this._gpuSources[source9.uid];
        if (gpuTexture) {
          this._gpuSources[source9.uid] = null;
          gpuTexture.destroy();
        }
      }
      onUpdateMipmaps(source9) {
        if (!this._mipmapGenerator) {
          this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
        }
        const gpuTexture = this.getGpuSource(source9);
        this._mipmapGenerator.generateMipmap(gpuTexture);
      }
      onSourceDestroy(source9) {
        source9.off("update", this.onSourceUpdate, this);
        source9.off("unload", this.onSourceUnload, this);
        source9.off("destroy", this.onSourceDestroy, this);
        source9.off("resize", this.onSourceResize, this);
        source9.off("updateMipmaps", this.onUpdateMipmaps, this);
        this.managedTextures.splice(this.managedTextures.indexOf(source9), 1);
        this.onSourceUnload(source9);
      }
      onSourceResize(source9) {
        const gpuTexture = this._gpuSources[source9.uid];
        if (!gpuTexture) {
          this.initSource(source9);
        } else if (gpuTexture.width !== source9.pixelWidth || gpuTexture.height !== source9.pixelHeight) {
          this._textureViewHash[source9.uid] = null;
          this._bindGroupHash[source9.uid] = null;
          this.onSourceUnload(source9);
          this.initSource(source9);
        }
      }
      _initSampler(sampler) {
        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);
        return this._gpuSamplers[sampler._resourceId];
      }
      getGpuSampler(sampler) {
        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);
      }
      getGpuSource(source9) {
        return this._gpuSources[source9.uid] || this.initSource(source9);
      }
      /**
       * this returns s bind group for a specific texture, the bind group contains
       * - the texture source
       * - the texture style
       * - the texture matrix
       * This is cached so the bind group should only be created once per texture
       * @param texture - the texture you want the bindgroup for
       * @returns the bind group for the texture
       */
      getTextureBindGroup(texture) {
        return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);
      }
      _createTextureBindGroup(texture) {
        const source9 = texture.source;
        this._bindGroupHash[texture.uid] = new BindGroup({
          0: source9,
          1: source9.style,
          2: new UniformGroup({
            uTextureMatrix: { type: "mat3x3<f32>", value: texture.textureMatrix.mapCoord }
          })
        });
        return this._bindGroupHash[texture.uid];
      }
      getTextureView(texture) {
        const source9 = texture.source;
        return this._textureViewHash[source9.uid] ?? this._createTextureView(source9);
      }
      _createTextureView(texture) {
        this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
        return this._textureViewHash[texture.uid];
      }
      generateCanvas(texture) {
        const renderer = this._renderer;
        const commandEncoder = renderer.gpu.device.createCommandEncoder();
        const canvas = DOMAdapter.get().createCanvas();
        canvas.width = texture.source.pixelWidth;
        canvas.height = texture.source.pixelHeight;
        const context2 = canvas.getContext("webgpu");
        context2.configure({
          device: renderer.gpu.device,
          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
          format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),
          alphaMode: "premultiplied"
        });
        commandEncoder.copyTextureToTexture({
          texture: renderer.texture.getGpuSource(texture.source),
          origin: {
            x: 0,
            y: 0
          }
        }, {
          texture: context2.getCurrentTexture()
        }, {
          width: canvas.width,
          height: canvas.height
        });
        renderer.gpu.device.queue.submit([commandEncoder.finish()]);
        return canvas;
      }
      getPixels(texture) {
        const webGPUCanvas = this.generateCanvas(texture);
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
        const context2 = canvasAndContext.context;
        context2.drawImage(webGPUCanvas, 0, 0);
        const { width, height } = webGPUCanvas;
        const imageData = context2.getImageData(0, 0, width, height);
        const pixels = new Uint8ClampedArray(imageData.data.buffer);
        CanvasPool.returnCanvasAndContext(canvasAndContext);
        return { pixels, width, height };
      }
      destroy() {
        this.managedTextures.slice().forEach((source9) => this.onSourceDestroy(source9));
        this.managedTextures = null;
        for (const k2 of Object.keys(this._bindGroupHash)) {
          const key = Number(k2);
          const bindGroup = this._bindGroupHash[key];
          bindGroup?.destroy();
          this._bindGroupHash[key] = null;
        }
        this._gpu = null;
        this._mipmapGenerator = null;
        this._gpuSources = null;
        this._bindGroupHash = null;
        this._textureViewHash = null;
        this._gpuSamplers = null;
      }
    };
    GpuTextureSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "texture"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs
var WebGPURenderer_exports = {};
__export(WebGPURenderer_exports, {
  WebGPURenderer: () => WebGPURenderer
});
var DefaultWebGPUSystems, DefaultWebGPUPipes, DefaultWebGPUAdapters, systems, renderPipes, renderPipeAdaptors, WebGPURenderer;
var init_WebGPURenderer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_GpuGraphicsAdaptor();
    init_GpuMeshAdapter();
    init_GpuBatchAdaptor();
    init_AbstractRenderer();
    init_SharedSystems();
    init_types2();
    init_BindGroupSystem();
    init_GpuBufferSystem();
    init_GpuColorMaskSystem();
    init_GpuDeviceSystem();
    init_GpuEncoderSystem();
    init_GpuStencilSystem();
    init_GpuUboSystem();
    init_GpuUniformBatchPipe();
    init_PipelineSystem();
    init_GpuRenderTargetSystem();
    init_GpuShaderSystem();
    init_GpuStateSystem();
    init_GpuTextureSystem();
    DefaultWebGPUSystems = [
      ...SharedSystems,
      GpuUboSystem,
      GpuEncoderSystem,
      GpuDeviceSystem,
      GpuBufferSystem,
      GpuTextureSystem,
      GpuRenderTargetSystem,
      GpuShaderSystem,
      GpuStateSystem,
      PipelineSystem,
      GpuColorMaskSystem,
      GpuStencilSystem,
      BindGroupSystem
    ];
    DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];
    DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
    systems = [];
    renderPipes = [];
    renderPipeAdaptors = [];
    extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
    extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
    extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
    extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
    WebGPURenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          name: "webgpu",
          type: RendererType.WEBGPU,
          systems,
          renderPipes,
          renderPipeAdaptors
        };
        super(systemConfig);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs
var GlGraphicsAdaptor;
var init_GlGraphicsAdaptor = __esm({
  "node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Matrix();
    init_maxRecommendedTextures();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_localUniformBit();
    init_roundPixelsBit();
    init_getBatchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    GlGraphicsAdaptor = class {
      init() {
        const uniforms = new UniformGroup({
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uRound: { value: 0, type: "f32" }
        });
        const maxTextures2 = getMaxTexturesPerBatch();
        const glProgram3 = compileHighShaderGlProgram({
          name: "graphics",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(maxTextures2),
            localUniformBitGl,
            roundPixelsBitGl
          ]
        });
        this.shader = new Shader({
          glProgram: glProgram3,
          resources: {
            localUniforms: uniforms,
            batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
          }
        });
      }
      execute(graphicsPipe, renderable) {
        const context2 = renderable.context;
        const shader = context2.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        const {
          batcher,
          instructions
        } = contextSystem.getContextRenderData(context2);
        shader.groups[0] = renderer.globalUniforms.bindGroup;
        renderer.state.set(graphicsPipe.state);
        renderer.shader.bind(shader);
        renderer.geometry.bind(batcher.geometry, shader.glProgram);
        const batches = instructions.instructions;
        for (let i3 = 0; i3 < instructions.instructionSize; i3++) {
          const batch = batches[i3];
          if (batch.size) {
            for (let j2 = 0; j2 < batch.textures.count; j2++) {
              renderer.texture.bind(batch.textures.textures[j2], j2);
            }
            renderer.geometry.draw(batch.topology, batch.size, batch.start);
          }
        }
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GlGraphicsAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "graphics"
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs
var GlMeshAdaptor;
var init_GlMeshAdaptor = __esm({
  "node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Matrix();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_textureBit();
    init_Shader();
    init_Texture();
    init_warn();
    GlMeshAdaptor = class {
      init() {
        const glProgram3 = compileHighShaderGlProgram({
          name: "mesh",
          bits: [
            localUniformBitGl,
            textureBitGl,
            roundPixelsBitGl
          ]
        });
        this._shader = new Shader({
          glProgram: glProgram3,
          resources: {
            uTexture: Texture.EMPTY.source,
            textureUniforms: {
              uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
            }
          }
        });
      }
      execute(meshPipe, mesh) {
        const renderer = meshPipe.renderer;
        let shader = mesh._shader;
        if (!shader) {
          shader = this._shader;
          const texture = mesh.texture;
          const source9 = texture.source;
          shader.resources.uTexture = source9;
          shader.resources.uSampler = source9.style;
          shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;
        } else if (!shader.glProgram) {
          warn("Mesh shader has no glProgram", mesh.shader);
          return;
        }
        shader.groups[100] = renderer.globalUniforms.bindGroup;
        shader.groups[101] = meshPipe.localUniformsBindGroup;
        renderer.encoder.draw({
          geometry: mesh._geometry,
          shader,
          state: mesh.state
        });
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GlMeshAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "mesh"
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
var GlBatchAdaptor;
var init_GlBatchAdaptor = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_State();
    GlBatchAdaptor = class {
      constructor() {
        this._tempState = State.for2d();
        this._didUploadHash = {};
      }
      init(batcherPipe) {
        batcherPipe.renderer.runners.contextChange.add(this);
      }
      contextChange() {
        this._didUploadHash = {};
      }
      start(batchPipe, geometry, shader) {
        const renderer = batchPipe.renderer;
        const didUpload = this._didUploadHash[shader.uid];
        renderer.shader.bind(shader, didUpload);
        if (!didUpload) {
          this._didUploadHash[shader.uid] = true;
        }
        renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);
        renderer.geometry.bind(geometry, shader.glProgram);
      }
      execute(batchPipe, batch) {
        const renderer = batchPipe.renderer;
        this._tempState.blendMode = batch.blendMode;
        renderer.state.set(this._tempState);
        const textures = batch.textures.textures;
        for (let i3 = 0; i3 < batch.textures.count; i3++) {
          renderer.texture.bind(textures[i3], i3);
        }
        renderer.geometry.draw(batch.topology, batch.size, batch.start);
      }
    };
    GlBatchAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "batch"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs
var BUFFER_TYPE;
var init_const9 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs"() {
    "use strict";
    init_define_AnParams();
    BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
      BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
      BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
      BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
      return BUFFER_TYPE2;
    })(BUFFER_TYPE || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
var GlBuffer;
var init_GlBuffer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs"() {
    "use strict";
    init_define_AnParams();
    GlBuffer = class {
      constructor(buffer, type) {
        this._lastBindBaseLocation = -1;
        this._lastBindCallId = -1;
        this.buffer = buffer || null;
        this.updateID = -1;
        this.byteLength = -1;
        this.type = type;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
var GlBufferSystem;
var init_GlBufferSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_const4();
    init_const9();
    init_GlBuffer();
    GlBufferSystem = class {
      /**
       * @param {Renderer} renderer - The renderer this System works for.
       */
      constructor(renderer) {
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        this._boundBufferBases = /* @__PURE__ */ Object.create(null);
        this._minBaseLocation = 0;
        this._nextBindBaseIndex = this._minBaseLocation;
        this._bindCallId = 0;
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
      }
      /**
       * @ignore
       */
      destroy() {
        this._renderer = null;
        this._gl = null;
        this._gpuBuffers = null;
        this._boundBufferBases = null;
      }
      /** Sets up the renderer context and necessary buffers. */
      contextChange() {
        const gl = this._gl = this._renderer.gl;
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
      }
      getGlBuffer(buffer) {
        return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
      }
      /**
       * This binds specified buffer. On first run, it will create the webGL buffers for the context too
       * @param buffer - the buffer to bind to the renderer
       */
      bind(buffer) {
        const { _gl: gl } = this;
        const glBuffer = this.getGlBuffer(buffer);
        gl.bindBuffer(glBuffer.type, glBuffer.buffer);
      }
      /**
       * Binds an uniform buffer to at the given index.
       *
       * A cache is used so a buffer will not be bound again if already bound.
       * @param glBuffer - the buffer to bind
       * @param index - the base index to bind it to.
       */
      bindBufferBase(glBuffer, index) {
        const { _gl: gl } = this;
        if (this._boundBufferBases[index] !== glBuffer) {
          this._boundBufferBases[index] = glBuffer;
          glBuffer._lastBindBaseLocation = index;
          gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
        }
      }
      nextBindBase(hasTransformFeedback) {
        this._bindCallId++;
        this._minBaseLocation = 0;
        if (hasTransformFeedback) {
          this._boundBufferBases[0] = null;
          this._minBaseLocation = 1;
          if (this._nextBindBaseIndex < 1) {
            this._nextBindBaseIndex = 1;
          }
        }
      }
      freeLocationForBufferBase(glBuffer) {
        let freeIndex = this.getLastBindBaseLocation(glBuffer);
        if (freeIndex >= this._minBaseLocation) {
          glBuffer._lastBindCallId = this._bindCallId;
          return freeIndex;
        }
        let loop = 0;
        let nextIndex = this._nextBindBaseIndex;
        while (loop < 2) {
          if (nextIndex >= this._maxBindings) {
            nextIndex = this._minBaseLocation;
            loop++;
          }
          const curBuf = this._boundBufferBases[nextIndex];
          if (curBuf && curBuf._lastBindCallId === this._bindCallId) {
            nextIndex++;
            continue;
          }
          break;
        }
        freeIndex = nextIndex;
        this._nextBindBaseIndex = nextIndex + 1;
        if (loop >= 2) {
          return -1;
        }
        glBuffer._lastBindCallId = this._bindCallId;
        this._boundBufferBases[freeIndex] = null;
        return freeIndex;
      }
      getLastBindBaseLocation(glBuffer) {
        const index = glBuffer._lastBindBaseLocation;
        if (this._boundBufferBases[index] === glBuffer) {
          return index;
        }
        return -1;
      }
      /**
       * Binds a buffer whilst also binding its range.
       * This will make the buffer start from the offset supplied rather than 0 when it is read.
       * @param glBuffer - the buffer to bind
       * @param index - the base index to bind at, defaults to 0
       * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
       * @param size - the size to bind at (this is blocks of 256).
       */
      bindBufferRange(glBuffer, index, offset, size) {
        const { _gl: gl } = this;
        offset || (offset = 0);
        index || (index = 0);
        this._boundBufferBases[index] = null;
        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);
      }
      /**
       * Will ensure the data in the buffer is uploaded to the GPU.
       * @param {Buffer} buffer - the buffer to update
       */
      updateBuffer(buffer) {
        const { _gl: gl } = this;
        const glBuffer = this.getGlBuffer(buffer);
        if (buffer._updateID === glBuffer.updateID) {
          return glBuffer;
        }
        glBuffer.updateID = buffer._updateID;
        gl.bindBuffer(glBuffer.type, glBuffer.buffer);
        const data = buffer.data;
        const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
        if (data) {
          if (glBuffer.byteLength >= data.byteLength) {
            gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);
          } else {
            glBuffer.byteLength = data.byteLength;
            gl.bufferData(glBuffer.type, data, drawType);
          }
        } else {
          glBuffer.byteLength = buffer.descriptor.size;
          gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);
        }
        return glBuffer;
      }
      /** dispose all WebGL resources of all managed buffers */
      destroyAll() {
        const gl = this._gl;
        for (const id in this._gpuBuffers) {
          gl.deleteBuffer(this._gpuBuffers[id].buffer);
        }
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Disposes buffer
       * @param {Buffer} buffer - buffer with data
       * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
       */
      onBufferDestroy(buffer, contextLost) {
        const glBuffer = this._gpuBuffers[buffer.uid];
        const gl = this._gl;
        if (!contextLost) {
          gl.deleteBuffer(glBuffer.buffer);
        }
        this._gpuBuffers[buffer.uid] = null;
      }
      /**
       * creates and attaches a GLBuffer object tied to the current context.
       * @param buffer
       * @protected
       */
      createGLBuffer(buffer) {
        const { _gl: gl } = this;
        let type = BUFFER_TYPE.ARRAY_BUFFER;
        if (buffer.descriptor.usage & BufferUsage.INDEX) {
          type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
          type = BUFFER_TYPE.UNIFORM_BUFFER;
        }
        const glBuffer = new GlBuffer(gl.createBuffer(), type);
        this._gpuBuffers[buffer.uid] = glBuffer;
        buffer.on("destroy", this.onBufferDestroy, this);
        return glBuffer;
      }
      resetState() {
        this._boundBufferBases = /* @__PURE__ */ Object.create(null);
      }
    };
    GlBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "buffer"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs
var _GlContextSystem, GlContextSystem;
var init_GlContextSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_Extensions();
    init_warn();
    _GlContextSystem = class _GlContextSystem2 {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this.supports = {
          /** Support for 32-bit indices buffer. */
          uint32Indices: true,
          /** Support for UniformBufferObjects */
          uniformBufferObject: true,
          /** Support for VertexArrayObjects */
          vertexArrayObject: true,
          /** Support for SRGB texture format */
          srgbTextures: true,
          /** Support for wrapping modes if a texture is non-power of two */
          nonPowOf2wrapping: true,
          /** Support for MSAA (antialiasing of dynamic textures) */
          msaa: true,
          /** Support for mipmaps if a texture is non-power of two */
          nonPowOf2mipmaps: true
        };
        this._renderer = renderer;
        this.extensions = /* @__PURE__ */ Object.create(null);
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
      }
      /**
       * `true` if the context is lost
       * @readonly
       */
      get isLost() {
        return !this.gl || this.gl.isContextLost();
      }
      /**
       * Handles the context change event.
       * @param {WebGLRenderingContext} gl - New WebGL context.
       */
      contextChange(gl) {
        this.gl = gl;
        this._renderer.gl = gl;
      }
      init(options) {
        options = { ..._GlContextSystem2.defaultOptions, ...options };
        let multiView = this.multiView = options.multiView;
        if (options.context && multiView) {
          warn("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.");
          multiView = false;
        }
        if (multiView) {
          this.canvas = DOMAdapter.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);
        } else {
          this.canvas = this._renderer.view.canvas;
        }
        if (options.context) {
          this.initFromContext(options.context);
        } else {
          const alpha = this._renderer.background.alpha < 1;
          const premultipliedAlpha = options.premultipliedAlpha ?? true;
          const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
          this.createContext(options.preferWebGLVersion, {
            alpha,
            premultipliedAlpha,
            antialias,
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer,
            powerPreference: options.powerPreference ?? "default"
          });
        }
      }
      ensureCanvasSize(targetCanvas) {
        if (!this.multiView) {
          if (targetCanvas !== this.canvas) {
            warn("multiView is disabled, but targetCanvas is not the main canvas");
          }
          return;
        }
        const { canvas } = this;
        if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height) {
          canvas.width = Math.max(targetCanvas.width, targetCanvas.width);
          canvas.height = Math.max(targetCanvas.height, targetCanvas.height);
        }
      }
      /**
       * Initializes the context.
       * @protected
       * @param {WebGLRenderingContext} gl - WebGL context
       */
      initFromContext(gl) {
        this.gl = gl;
        this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;
        this.getExtensions();
        this.validateContext(gl);
        this._renderer.runners.contextChange.emit(gl);
        const element = this._renderer.view.canvas;
        element.addEventListener("webglcontextlost", this.handleContextLost, false);
        element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
      }
      /**
       * Initialize from context options
       * @protected
       * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
       * @param preferWebGLVersion
       * @param {object} options - context attributes
       */
      createContext(preferWebGLVersion, options) {
        let gl;
        const canvas = this.canvas;
        if (preferWebGLVersion === 2) {
          gl = canvas.getContext("webgl2", options);
        }
        if (!gl) {
          gl = canvas.getContext("webgl", options);
          if (!gl) {
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
          }
        }
        this.gl = gl;
        this.initFromContext(this.gl);
      }
      /** Auto-populate the {@link GlContextSystem.extensions extensions}. */
      getExtensions() {
        const { gl } = this;
        const common = {
          anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          // eslint-disable-line camelcase
          etc: gl.getExtension("WEBGL_compressed_texture_etc"),
          etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: gl.getExtension("WEBGL_compressed_texture_atc"),
          astc: gl.getExtension("WEBGL_compressed_texture_astc"),
          bptc: gl.getExtension("EXT_texture_compression_bptc"),
          rgtc: gl.getExtension("EXT_texture_compression_rgtc"),
          loseContext: gl.getExtension("WEBGL_lose_context")
        };
        if (this.webGLVersion === 1) {
          this.extensions = {
            ...common,
            drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
            depthTexture: gl.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
            // Floats and half-floats
            floatTexture: gl.getExtension("OES_texture_float"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            textureHalfFloat: gl.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),
            vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),
            srgb: gl.getExtension("EXT_sRGB")
          };
        } else {
          this.extensions = {
            ...common,
            colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
          };
          const provokeExt = gl.getExtension("WEBGL_provoking_vertex");
          if (provokeExt) {
            provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);
          }
        }
      }
      /**
       * Handles a lost webgl context
       * @param {WebGLContextEvent} event - The context lost event.
       */
      handleContextLost(event) {
        event.preventDefault();
        if (this._contextLossForced) {
          this._contextLossForced = false;
          setTimeout(() => {
            if (this.gl.isContextLost()) {
              this.extensions.loseContext?.restoreContext();
            }
          }, 0);
        }
      }
      /** Handles a restored webgl context. */
      handleContextRestored() {
        this.getExtensions();
        this._renderer.runners.contextChange.emit(this.gl);
      }
      destroy() {
        const element = this._renderer.view.canvas;
        this._renderer = null;
        element.removeEventListener("webglcontextlost", this.handleContextLost);
        element.removeEventListener("webglcontextrestored", this.handleContextRestored);
        this.gl.useProgram(null);
        this.extensions.loseContext?.loseContext();
      }
      /**
       * this function can be called to force a webGL context loss
       * this will release all resources on the GPU.
       * Useful if you need to put Pixi to sleep, and save some GPU memory
       *
       * As soon as render is called - all resources will be created again.
       */
      forceContextLoss() {
        this.extensions.loseContext?.loseContext();
        this._contextLossForced = true;
      }
      /**
       * Validate context.
       * @param {WebGLRenderingContext} gl - Render context.
       */
      validateContext(gl) {
        const attributes = gl.getContextAttributes();
        if (attributes && !attributes.stencil) {
          warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        }
        const supports = this.supports;
        const isWebGl2 = this.webGLVersion === 2;
        const extensions2 = this.extensions;
        supports.uint32Indices = isWebGl2 || !!extensions2.uint32ElementIndex;
        supports.uniformBufferObject = isWebGl2;
        supports.vertexArrayObject = isWebGl2 || !!extensions2.vertexArrayObject;
        supports.srgbTextures = isWebGl2 || !!extensions2.srgb;
        supports.nonPowOf2wrapping = isWebGl2;
        supports.nonPowOf2mipmaps = isWebGl2;
        supports.msaa = isWebGl2;
        if (!supports.uint32Indices) {
          warn("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
        }
      }
    };
    _GlContextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "context"
    };
    _GlContextSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.context}
       * @default null
       */
      context: null,
      /**
       * {@link WebGLOptions.premultipliedAlpha}
       * @default true
       */
      premultipliedAlpha: true,
      /**
       * {@link WebGLOptions.preserveDrawingBuffer}
       * @default false
       */
      preserveDrawingBuffer: false,
      /**
       * {@link WebGLOptions.powerPreference}
       * @default default
       */
      powerPreference: void 0,
      /**
       * {@link WebGLOptions.webGLVersion}
       * @default 2
       */
      preferWebGLVersion: 2,
      /**
       * {@link WebGLOptions.multiView}
       * @default false
       */
      multiView: false
    };
    GlContextSystem = _GlContextSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs
var GL_FORMATS, GL_TARGETS, GL_WRAP_MODES, GL_TYPES;
var init_const10 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs"() {
    "use strict";
    init_define_AnParams();
    GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
      GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
      GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
      GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
      GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
      GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
      GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
      GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
      GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
      return GL_FORMATS2;
    })(GL_FORMATS || {});
    GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
      GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      return GL_TARGETS2;
    })(GL_TARGETS || {});
    GL_WRAP_MODES = /* @__PURE__ */ ((GL_WRAP_MODES2) => {
      GL_WRAP_MODES2[GL_WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
      GL_WRAP_MODES2[GL_WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
      GL_WRAP_MODES2[GL_WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
      return GL_WRAP_MODES2;
    })(GL_WRAP_MODES || {});
    GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
      GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
      GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
      GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
      GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
      GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
      GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
      GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
      return GL_TYPES2;
    })(GL_TYPES || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs
function getGlTypeFromFormat(format) {
  return infoMap[format] ?? infoMap.float32;
}
var infoMap;
var init_getGlTypeFromFormat = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs"() {
    init_define_AnParams();
    init_const10();
    infoMap = {
      uint8x2: GL_TYPES.UNSIGNED_BYTE,
      uint8x4: GL_TYPES.UNSIGNED_BYTE,
      sint8x2: GL_TYPES.BYTE,
      sint8x4: GL_TYPES.BYTE,
      unorm8x2: GL_TYPES.UNSIGNED_BYTE,
      unorm8x4: GL_TYPES.UNSIGNED_BYTE,
      snorm8x2: GL_TYPES.BYTE,
      snorm8x4: GL_TYPES.BYTE,
      uint16x2: GL_TYPES.UNSIGNED_SHORT,
      uint16x4: GL_TYPES.UNSIGNED_SHORT,
      sint16x2: GL_TYPES.SHORT,
      sint16x4: GL_TYPES.SHORT,
      unorm16x2: GL_TYPES.UNSIGNED_SHORT,
      unorm16x4: GL_TYPES.UNSIGNED_SHORT,
      snorm16x2: GL_TYPES.SHORT,
      snorm16x4: GL_TYPES.SHORT,
      float16x2: GL_TYPES.HALF_FLOAT,
      float16x4: GL_TYPES.HALF_FLOAT,
      float32: GL_TYPES.FLOAT,
      float32x2: GL_TYPES.FLOAT,
      float32x3: GL_TYPES.FLOAT,
      float32x4: GL_TYPES.FLOAT,
      uint32: GL_TYPES.UNSIGNED_INT,
      uint32x2: GL_TYPES.UNSIGNED_INT,
      uint32x3: GL_TYPES.UNSIGNED_INT,
      uint32x4: GL_TYPES.UNSIGNED_INT,
      sint32: GL_TYPES.INT,
      sint32x2: GL_TYPES.INT,
      sint32x3: GL_TYPES.INT,
      sint32x4: GL_TYPES.INT
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
var topologyToGlMap, GlGeometrySystem;
var init_GlGeometrySystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_getAttributeInfoFromFormat();
    init_ensureAttributes();
    init_getGlTypeFromFormat();
    topologyToGlMap = {
      "point-list": 0,
      "line-list": 1,
      "line-strip": 3,
      "triangle-list": 4,
      "triangle-strip": 5
    };
    GlGeometrySystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        this._activeGeometry = null;
        this._activeVao = null;
        this.hasVao = true;
        this.hasInstance = true;
        this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
      }
      /** Sets up the renderer context and necessary buffers. */
      contextChange() {
        const gl = this.gl = this._renderer.gl;
        if (!this._renderer.context.supports.vertexArrayObject) {
          throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
        }
        const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
        if (nativeVaoExtension) {
          gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
          gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
          gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
        }
        const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
        if (nativeInstancedExtension) {
          gl.drawArraysInstanced = (a2, b3, c2, d2) => {
            nativeInstancedExtension.drawArraysInstancedANGLE(a2, b3, c2, d2);
          };
          gl.drawElementsInstanced = (a2, b3, c2, d2, e2) => {
            nativeInstancedExtension.drawElementsInstancedANGLE(a2, b3, c2, d2, e2);
          };
          gl.vertexAttribDivisor = (a2, b3) => nativeInstancedExtension.vertexAttribDivisorANGLE(a2, b3);
        }
        this._activeGeometry = null;
        this._activeVao = null;
        this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Binds geometry so that is can be drawn. Creating a Vao if required
       * @param geometry - Instance of geometry to bind.
       * @param program - Instance of program to use vao for.
       */
      bind(geometry, program) {
        const gl = this.gl;
        this._activeGeometry = geometry;
        const vao = this.getVao(geometry, program);
        if (this._activeVao !== vao) {
          this._activeVao = vao;
          gl.bindVertexArray(vao);
        }
        this.updateBuffers();
      }
      /** Reset and unbind any active VAO and geometry. */
      resetState() {
        this.unbind();
      }
      /** Update buffers of the currently bound geometry. */
      updateBuffers() {
        const geometry = this._activeGeometry;
        const bufferSystem = this._renderer.buffer;
        for (let i3 = 0; i3 < geometry.buffers.length; i3++) {
          const buffer = geometry.buffers[i3];
          bufferSystem.updateBuffer(buffer);
        }
      }
      /**
       * Check compatibility between a geometry and a program
       * @param geometry - Geometry instance.
       * @param program - Program instance.
       */
      checkCompatibility(geometry, program) {
        const geometryAttributes = geometry.attributes;
        const shaderAttributes = program._attributeData;
        for (const j2 in shaderAttributes) {
          if (!geometryAttributes[j2]) {
            throw new Error(`shader and geometry incompatible, geometry missing the "${j2}" attribute`);
          }
        }
      }
      /**
       * Takes a geometry and program and generates a unique signature for them.
       * @param geometry - To get signature from.
       * @param program - To test geometry against.
       * @returns - Unique signature of the geometry and program
       */
      getSignature(geometry, program) {
        const attribs = geometry.attributes;
        const shaderAttributes = program._attributeData;
        const strings = ["g", geometry.uid];
        for (const i3 in attribs) {
          if (shaderAttributes[i3]) {
            strings.push(i3, shaderAttributes[i3].location);
          }
        }
        return strings.join("-");
      }
      getVao(geometry, program) {
        return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);
      }
      /**
       * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
       * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
       * attribute locations.
       * @param geometry - Instance of geometry to to generate Vao for.
       * @param program
       * @param _incRefCount - Increment refCount of all geometry buffers.
       */
      initGeometryVao(geometry, program, _incRefCount = true) {
        const gl = this._renderer.gl;
        const bufferSystem = this._renderer.buffer;
        this._renderer.shader._getProgramData(program);
        this.checkCompatibility(geometry, program);
        const signature = this.getSignature(geometry, program);
        if (!this._geometryVaoHash[geometry.uid]) {
          this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);
          geometry.on("destroy", this.onGeometryDestroy, this);
        }
        const vaoObjectHash = this._geometryVaoHash[geometry.uid];
        let vao = vaoObjectHash[signature];
        if (vao) {
          vaoObjectHash[program._key] = vao;
          return vao;
        }
        ensureAttributes(geometry, program._attributeData);
        const buffers = geometry.buffers;
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        for (let i3 = 0; i3 < buffers.length; i3++) {
          const buffer = buffers[i3];
          bufferSystem.bind(buffer);
        }
        this.activateVao(geometry, program);
        vaoObjectHash[program._key] = vao;
        vaoObjectHash[signature] = vao;
        gl.bindVertexArray(null);
        return vao;
      }
      /**
       * Disposes geometry.
       * @param geometry - Geometry with buffers. Only VAO will be disposed
       * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
       */
      onGeometryDestroy(geometry, contextLost) {
        const vaoObjectHash = this._geometryVaoHash[geometry.uid];
        const gl = this.gl;
        if (vaoObjectHash) {
          if (contextLost) {
            for (const i3 in vaoObjectHash) {
              if (this._activeVao !== vaoObjectHash[i3]) {
                this.unbind();
              }
              gl.deleteVertexArray(vaoObjectHash[i3]);
            }
          }
          this._geometryVaoHash[geometry.uid] = null;
        }
      }
      /**
       * Dispose all WebGL resources of all managed geometries.
       * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
       */
      destroyAll(contextLost = false) {
        const gl = this.gl;
        for (const i3 in this._geometryVaoHash) {
          if (contextLost) {
            for (const j2 in this._geometryVaoHash[i3]) {
              const vaoObjectHash = this._geometryVaoHash[i3];
              if (this._activeVao !== vaoObjectHash) {
                this.unbind();
              }
              gl.deleteVertexArray(vaoObjectHash[j2]);
            }
          }
          this._geometryVaoHash[i3] = null;
        }
      }
      /**
       * Activate vertex array object.
       * @param geometry - Geometry instance.
       * @param program - Shader program instance.
       */
      activateVao(geometry, program) {
        const gl = this._renderer.gl;
        const bufferSystem = this._renderer.buffer;
        const attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          bufferSystem.bind(geometry.indexBuffer);
        }
        let lastBuffer = null;
        for (const j2 in attributes) {
          const attribute = attributes[j2];
          const buffer = attribute.buffer;
          const glBuffer = bufferSystem.getGlBuffer(buffer);
          const programAttrib = program._attributeData[j2];
          if (programAttrib) {
            if (lastBuffer !== glBuffer) {
              bufferSystem.bind(buffer);
              lastBuffer = glBuffer;
            }
            const location2 = programAttrib.location;
            gl.enableVertexAttribArray(location2);
            const attributeInfo = getAttributeInfoFromFormat(attribute.format);
            const type = getGlTypeFromFormat(attribute.format);
            if (programAttrib.format?.substring(1, 4) === "int") {
              gl.vertexAttribIPointer(
                location2,
                attributeInfo.size,
                type,
                attribute.stride,
                attribute.offset
              );
            } else {
              gl.vertexAttribPointer(
                location2,
                attributeInfo.size,
                type,
                attributeInfo.normalised,
                attribute.stride,
                attribute.offset
              );
            }
            if (attribute.instance) {
              if (this.hasInstance) {
                const divisor = attribute.divisor ?? 1;
                gl.vertexAttribDivisor(location2, divisor);
              } else {
                throw new Error("geometry error, GPU Instancing is not supported on this device");
              }
            }
          }
        }
      }
      /**
       * Draws the currently bound geometry.
       * @param topology - The type primitive to render.
       * @param size - The number of elements to be rendered. If not specified, all vertices after the
       *  starting vertex will be drawn.
       * @param start - The starting vertex in the geometry to start drawing from. If not specified,
       *  drawing will start from the first vertex.
       * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
       *  all instances will be drawn.
       */
      draw(topology, size, start, instanceCount) {
        const { gl } = this._renderer;
        const geometry = this._activeGeometry;
        const glTopology = topologyToGlMap[topology || geometry.topology];
        instanceCount ?? (instanceCount = geometry.instanceCount);
        if (geometry.indexBuffer) {
          const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          if (instanceCount > 1) {
            gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);
          } else {
            gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
          }
        } else if (instanceCount > 1) {
          gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);
        } else {
          gl.drawArrays(glTopology, start || 0, size || geometry.getSize());
        }
        return this;
      }
      /** Unbind/reset everything. */
      unbind() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
      }
      destroy() {
        this._renderer = null;
        this.gl = null;
        this._activeVao = null;
        this._activeGeometry = null;
      }
    };
    GlGeometrySystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "geometry"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
var bigTriangleGeometry, _GlBackBufferSystem, GlBackBufferSystem;
var init_GlBackBufferSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_warn();
    init_Geometry();
    init_Shader();
    init_State();
    init_TextureSource();
    init_Texture();
    init_GlProgram();
    bigTriangleGeometry = new Geometry({
      attributes: {
        aPosition: [
          -1,
          -1,
          // Bottom left corner
          3,
          -1,
          // Bottom right corner, extending beyond right edge
          -1,
          3
          // Top left corner, extending beyond top edge
        ]
      }
    });
    _GlBackBufferSystem = class _GlBackBufferSystem2 {
      constructor(renderer) {
        this.useBackBuffer = false;
        this._useBackBufferThisRender = false;
        this._renderer = renderer;
      }
      init(options = {}) {
        const { useBackBuffer, antialias } = { ..._GlBackBufferSystem2.defaultOptions, ...options };
        this.useBackBuffer = useBackBuffer;
        this._antialias = antialias;
        if (!this._renderer.context.supports.msaa) {
          warn("antialiasing, is not supported on when using the back buffer");
          this._antialias = false;
        }
        this._state = State.for2d();
        const bigTriangleProgram = new GlProgram({
          vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
          fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
          name: "big-triangle"
        });
        this._bigTriangleShader = new Shader({
          glProgram: bigTriangleProgram,
          resources: {
            uTexture: Texture.WHITE.source
          }
        });
      }
      /**
       * This is called before the RenderTargetSystem is started. This is where
       * we replace the target with the back buffer if required.
       * @param options - The options for this render.
       */
      renderStart(options) {
        const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);
        this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;
        if (this._useBackBufferThisRender) {
          const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);
          this._targetTexture = renderTarget2.colorTexture;
          options.target = this._getBackBufferTexture(renderTarget2.colorTexture);
        }
      }
      renderEnd() {
        this._presentBackBuffer();
      }
      _presentBackBuffer() {
        const renderer = this._renderer;
        renderer.renderTarget.finishRenderPass();
        if (!this._useBackBufferThisRender)
          return;
        renderer.renderTarget.bind(this._targetTexture, false);
        this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
        renderer.encoder.draw({
          geometry: bigTriangleGeometry,
          shader: this._bigTriangleShader,
          state: this._state
        });
      }
      _getBackBufferTexture(targetSourceTexture) {
        this._backBufferTexture = this._backBufferTexture || new Texture({
          source: new TextureSource({
            width: targetSourceTexture.width,
            height: targetSourceTexture.height,
            resolution: targetSourceTexture._resolution,
            antialias: this._antialias
          })
        });
        this._backBufferTexture.source.resize(
          targetSourceTexture.width,
          targetSourceTexture.height,
          targetSourceTexture._resolution
        );
        return this._backBufferTexture;
      }
      /** destroys the back buffer */
      destroy() {
        if (this._backBufferTexture) {
          this._backBufferTexture.destroy();
          this._backBufferTexture = null;
        }
      }
    };
    _GlBackBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "backBuffer",
      priority: 1
    };
    _GlBackBufferSystem.defaultOptions = {
      /** if true will use the back buffer where required */
      useBackBuffer: false
    };
    GlBackBufferSystem = _GlBackBufferSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
var GlColorMaskSystem;
var init_GlColorMaskSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    GlColorMaskSystem = class {
      constructor(renderer) {
        this._colorMaskCache = 15;
        this._renderer = renderer;
      }
      setMask(colorMask) {
        if (this._colorMaskCache === colorMask)
          return;
        this._colorMaskCache = colorMask;
        this._renderer.gl.colorMask(
          !!(colorMask & 8),
          !!(colorMask & 4),
          !!(colorMask & 2),
          !!(colorMask & 1)
        );
      }
    };
    GlColorMaskSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "colorMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs
var GlEncoderSystem;
var init_GlEncoderSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    GlEncoderSystem = class {
      constructor(renderer) {
        this.commandFinished = Promise.resolve();
        this._renderer = renderer;
      }
      setGeometry(geometry, shader) {
        this._renderer.geometry.bind(geometry, shader.glProgram);
      }
      finishRenderPass() {
      }
      draw(options) {
        const renderer = this._renderer;
        const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;
        renderer.shader.bind(shader, skipSync);
        renderer.geometry.bind(geometry, renderer.shader._activeProgram);
        if (state) {
          renderer.state.set(state);
        }
        renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);
      }
      destroy() {
        this._renderer = null;
      }
    };
    GlEncoderSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "encoder"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs
var GlStencilSystem;
var init_GlStencilSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_GpuStencilModesToPixi();
    init_const3();
    GlStencilSystem = class {
      constructor(renderer) {
        this._stencilCache = {
          enabled: false,
          stencilReference: 0,
          stencilMode: STENCIL_MODES.NONE
        };
        this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      contextChange(gl) {
        this._gl = gl;
        this._comparisonFuncMapping = {
          always: gl.ALWAYS,
          never: gl.NEVER,
          equal: gl.EQUAL,
          "not-equal": gl.NOTEQUAL,
          less: gl.LESS,
          "less-equal": gl.LEQUAL,
          greater: gl.GREATER,
          "greater-equal": gl.GEQUAL
        };
        this._stencilOpsMapping = {
          keep: gl.KEEP,
          zero: gl.ZERO,
          replace: gl.REPLACE,
          invert: gl.INVERT,
          "increment-clamp": gl.INCR,
          "decrement-clamp": gl.DECR,
          "increment-wrap": gl.INCR_WRAP,
          "decrement-wrap": gl.DECR_WRAP
        };
        this.resetState();
      }
      onRenderTargetChange(renderTarget) {
        if (this._activeRenderTarget === renderTarget)
          return;
        this._activeRenderTarget = renderTarget;
        let stencilState = this._renderTargetStencilState[renderTarget.uid];
        if (!stencilState) {
          stencilState = this._renderTargetStencilState[renderTarget.uid] = {
            stencilMode: STENCIL_MODES.DISABLED,
            stencilReference: 0
          };
        }
        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
      }
      resetState() {
        this._stencilCache.enabled = false;
        this._stencilCache.stencilMode = STENCIL_MODES.NONE;
        this._stencilCache.stencilReference = 0;
      }
      setStencilMode(stencilMode, stencilReference) {
        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
        const gl = this._gl;
        const mode = GpuStencilModesToPixi[stencilMode];
        const _stencilCache = this._stencilCache;
        stencilState.stencilMode = stencilMode;
        stencilState.stencilReference = stencilReference;
        if (stencilMode === STENCIL_MODES.DISABLED) {
          if (this._stencilCache.enabled) {
            this._stencilCache.enabled = false;
            gl.disable(gl.STENCIL_TEST);
          }
          return;
        }
        if (!this._stencilCache.enabled) {
          this._stencilCache.enabled = true;
          gl.enable(gl.STENCIL_TEST);
        }
        if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
          _stencilCache.stencilMode = stencilMode;
          _stencilCache.stencilReference = stencilReference;
          gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
          gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
        }
      }
    };
    GlStencilSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "stencil"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs
function createUboElementsSTD40(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  const chunkSize = 16;
  let size = 0;
  let offset = 0;
  for (let i3 = 0; i3 < uboElements.length; i3++) {
    const uboElement = uboElements[i3];
    size = WGSL_TO_STD40_SIZE[uboElement.data.type];
    if (!size) {
      throw new Error(`Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size = Math.max(size, chunkSize) * uboElement.data.size;
    }
    const boundary = size === 12 ? 16 : size;
    uboElement.size = size;
    const curOffset = offset % chunkSize;
    if (curOffset > 0 && chunkSize - curOffset < boundary) {
      offset += (chunkSize - curOffset) % 16;
    } else {
      offset += (size - curOffset % size) % size;
    }
    uboElement.offset = offset;
    offset += size;
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
var WGSL_TO_STD40_SIZE;
var init_createUboElementsSTD40 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs"() {
    "use strict";
    init_define_AnParams();
    WGSL_TO_STD40_SIZE = {
      f32: 4,
      i32: 4,
      "vec2<f32>": 8,
      "vec3<f32>": 12,
      "vec4<f32>": 16,
      "vec2<i32>": 8,
      "vec3<i32>": 12,
      "vec4<i32>": 16,
      "mat2x2<f32>": 16 * 2,
      "mat3x3<f32>": 16 * 3,
      "mat4x4<f32>": 16 * 4
      // TODO - not essential for now but support these in the future
      // int:      4,
      // ivec2:    8,
      // ivec3:    12,
      // ivec4:    16,
      // uint:     4,
      // uvec2:    8,
      // uvec3:    12,
      // uvec4:    16,
      // bool:     4,
      // bvec2:    8,
      // bvec3:    12,
      // bvec4:    16,
      // mat2:     16 * 2,
      // mat3:     16 * 3,
      // mat4:     16 * 4,
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs
function generateArraySyncSTD40(uboElement, offsetToAdd) {
  const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
  const elementSize = uboElement.data.value.length / uboElement.data.size;
  const remainder = (4 - elementSize % 4) % 4;
  const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
  return `
        v = uv.${uboElement.data.name};
        offset += ${offsetToAdd};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
        {
            for(var j = 0; j < ${elementSize}; j++)
            {
                ${data}[arrayOffset++] = v[t++];
            }
            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
        }
    `;
}
var init_generateArraySyncSTD40 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs"() {
    init_define_AnParams();
    init_createUboElementsSTD40();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs
function createUboSyncFunctionSTD40(uboElements) {
  return createUboSyncFunction(
    uboElements,
    "uboStd40",
    generateArraySyncSTD40,
    uboSyncFunctionsSTD40
  );
}
var init_createUboSyncSTD40 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs"() {
    init_define_AnParams();
    init_createUboSyncFunction();
    init_uboSyncFunctions();
    init_generateArraySyncSTD40();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs
var GlUboSystem;
var init_GlUboSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_UboSystem();
    init_createUboElementsSTD40();
    init_createUboSyncSTD40();
    GlUboSystem = class extends UboSystem {
      constructor() {
        super({
          createUboElements: createUboElementsSTD40,
          generateUboSync: createUboSyncFunctionSTD40
        });
      }
    };
    GlUboSystem.extension = {
      type: [ExtensionType.WebGLSystem],
      name: "ubo"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs
var GlRenderTarget;
var init_GlRenderTarget = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs"() {
    "use strict";
    init_define_AnParams();
    GlRenderTarget = class {
      constructor() {
        this.width = -1;
        this.height = -1;
        this.msaa = false;
        this.msaaRenderBuffer = [];
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs
var GlRenderTargetAdaptor;
var init_GlRenderTargetAdaptor = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs"() {
    init_define_AnParams();
    init_Rectangle();
    init_warn();
    init_CanvasSource();
    init_const7();
    init_GlRenderTarget();
    GlRenderTargetAdaptor = class {
      constructor() {
        this._clearColorCache = [0, 0, 0, 0];
        this._viewPortCache = new Rectangle();
      }
      init(renderer, renderTargetSystem) {
        this._renderer = renderer;
        this._renderTargetSystem = renderTargetSystem;
        renderer.runners.contextChange.add(this);
      }
      contextChange() {
        this._clearColorCache = [0, 0, 0, 0];
        this._viewPortCache = new Rectangle();
      }
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
        const renderTargetSystem = this._renderTargetSystem;
        const renderer = this._renderer;
        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
        const gl = renderer.gl;
        this.finishRenderPass(sourceRenderSurfaceTexture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
        renderer.texture.bind(destinationTexture, 0);
        gl.copyTexSubImage2D(
          gl.TEXTURE_2D,
          0,
          originDest.x,
          originDest.y,
          originSrc.x,
          originSrc.y,
          size.width,
          size.height
        );
        return destinationTexture;
      }
      startRenderPass(renderTarget, clear = true, clearColor, viewport) {
        const renderTargetSystem = this._renderTargetSystem;
        const source9 = renderTarget.colorTexture;
        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        let viewPortY = viewport.y;
        if (renderTarget.isRoot) {
          viewPortY = source9.pixelHeight - viewport.height;
        }
        renderTarget.colorTextures.forEach((texture) => {
          this._renderer.texture.unbind(texture);
        });
        const gl = this._renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
        const viewPortCache = this._viewPortCache;
        if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
          viewPortCache.x = viewport.x;
          viewPortCache.y = viewPortY;
          viewPortCache.width = viewport.width;
          viewPortCache.height = viewport.height;
          gl.viewport(
            viewport.x,
            viewPortY,
            viewport.width,
            viewport.height
          );
        }
        if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {
          this._initStencil(gpuRenderTarget);
        }
        this.clear(renderTarget, clear, clearColor);
      }
      finishRenderPass(renderTarget) {
        const renderTargetSystem = this._renderTargetSystem;
        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        if (!glRenderTarget.msaa)
          return;
        const gl = this._renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
        gl.blitFramebuffer(
          0,
          0,
          glRenderTarget.width,
          glRenderTarget.height,
          0,
          0,
          glRenderTarget.width,
          glRenderTarget.height,
          gl.COLOR_BUFFER_BIT,
          gl.NEAREST
        );
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
      }
      initGpuRenderTarget(renderTarget) {
        const renderer = this._renderer;
        const gl = renderer.gl;
        const glRenderTarget = new GlRenderTarget();
        const colorTexture = renderTarget.colorTexture;
        if (CanvasSource.test(colorTexture.resource)) {
          this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);
          glRenderTarget.framebuffer = null;
          return glRenderTarget;
        }
        this._initColor(renderTarget, glRenderTarget);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return glRenderTarget;
      }
      destroyGpuRenderTarget(gpuRenderTarget) {
        const gl = this._renderer.gl;
        if (gpuRenderTarget.framebuffer) {
          gl.deleteFramebuffer(gpuRenderTarget.framebuffer);
          gpuRenderTarget.framebuffer = null;
        }
        if (gpuRenderTarget.resolveTargetFramebuffer) {
          gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);
          gpuRenderTarget.resolveTargetFramebuffer = null;
        }
        if (gpuRenderTarget.depthStencilRenderBuffer) {
          gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);
          gpuRenderTarget.depthStencilRenderBuffer = null;
        }
        gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {
          gl.deleteRenderbuffer(renderBuffer);
        });
        gpuRenderTarget.msaaRenderBuffer = null;
      }
      clear(_renderTarget, clear, clearColor) {
        if (!clear)
          return;
        const renderTargetSystem = this._renderTargetSystem;
        if (typeof clear === "boolean") {
          clear = clear ? CLEAR.ALL : CLEAR.NONE;
        }
        const gl = this._renderer.gl;
        if (clear & CLEAR.COLOR) {
          clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);
          const clearColorCache = this._clearColorCache;
          const clearColorArray = clearColor;
          if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
            clearColorCache[0] = clearColorArray[0];
            clearColorCache[1] = clearColorArray[1];
            clearColorCache[2] = clearColorArray[2];
            clearColorCache[3] = clearColorArray[3];
            gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
          }
        }
        gl.clear(clear);
      }
      resizeGpuRenderTarget(renderTarget) {
        if (renderTarget.isRoot)
          return;
        const renderTargetSystem = this._renderTargetSystem;
        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        this._resizeColor(renderTarget, glRenderTarget);
        if (renderTarget.stencil || renderTarget.depth) {
          this._resizeStencil(glRenderTarget);
        }
      }
      _initColor(renderTarget, glRenderTarget) {
        const renderer = this._renderer;
        const gl = renderer.gl;
        const resolveTargetFramebuffer = gl.createFramebuffer();
        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
        renderTarget.colorTextures.forEach((colorTexture, i3) => {
          const source9 = colorTexture.source;
          if (source9.antialias) {
            if (renderer.context.supports.msaa) {
              glRenderTarget.msaa = true;
            } else {
              warn("[RenderTexture] Antialiasing on textures is not supported in WebGL1");
            }
          }
          renderer.texture.bindSource(source9, 0);
          const glSource = renderer.texture.getGlSource(source9);
          const glTexture = glSource.texture;
          gl.framebufferTexture2D(
            gl.FRAMEBUFFER,
            gl.COLOR_ATTACHMENT0 + i3,
            3553,
            // texture.target,
            glTexture,
            0
          );
        });
        if (glRenderTarget.msaa) {
          const viewFramebuffer = gl.createFramebuffer();
          glRenderTarget.framebuffer = viewFramebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
          renderTarget.colorTextures.forEach((_, i3) => {
            const msaaRenderBuffer = gl.createRenderbuffer();
            glRenderTarget.msaaRenderBuffer[i3] = msaaRenderBuffer;
          });
        } else {
          glRenderTarget.framebuffer = resolveTargetFramebuffer;
        }
        this._resizeColor(renderTarget, glRenderTarget);
      }
      _resizeColor(renderTarget, glRenderTarget) {
        const source9 = renderTarget.colorTexture.source;
        glRenderTarget.width = source9.pixelWidth;
        glRenderTarget.height = source9.pixelHeight;
        renderTarget.colorTextures.forEach((colorTexture, i3) => {
          if (i3 === 0)
            return;
          colorTexture.source.resize(source9.width, source9.height, source9._resolution);
        });
        if (glRenderTarget.msaa) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const viewFramebuffer = glRenderTarget.framebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
          renderTarget.colorTextures.forEach((colorTexture, i3) => {
            const source22 = colorTexture.source;
            renderer.texture.bindSource(source22, 0);
            const glSource = renderer.texture.getGlSource(source22);
            const glInternalFormat = glSource.internalFormat;
            const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i3];
            gl.bindRenderbuffer(
              gl.RENDERBUFFER,
              msaaRenderBuffer
            );
            gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              4,
              glInternalFormat,
              source22.pixelWidth,
              source22.pixelHeight
            );
            gl.framebufferRenderbuffer(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i3,
              gl.RENDERBUFFER,
              msaaRenderBuffer
            );
          });
        }
      }
      _initStencil(glRenderTarget) {
        if (glRenderTarget.framebuffer === null)
          return;
        const gl = this._renderer.gl;
        const depthStencilRenderBuffer = gl.createRenderbuffer();
        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          depthStencilRenderBuffer
        );
        gl.framebufferRenderbuffer(
          gl.FRAMEBUFFER,
          gl.DEPTH_STENCIL_ATTACHMENT,
          gl.RENDERBUFFER,
          depthStencilRenderBuffer
        );
        this._resizeStencil(glRenderTarget);
      }
      _resizeStencil(glRenderTarget) {
        const gl = this._renderer.gl;
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          glRenderTarget.depthStencilRenderBuffer
        );
        if (glRenderTarget.msaa) {
          gl.renderbufferStorageMultisample(
            gl.RENDERBUFFER,
            4,
            gl.DEPTH24_STENCIL8,
            glRenderTarget.width,
            glRenderTarget.height
          );
        } else {
          gl.renderbufferStorage(
            gl.RENDERBUFFER,
            this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
            glRenderTarget.width,
            glRenderTarget.height
          );
        }
      }
      prerender(renderTarget) {
        const resource = renderTarget.colorTexture.resource;
        if (this._renderer.context.multiView && CanvasSource.test(resource)) {
          this._renderer.context.ensureCanvasSize(resource);
        }
      }
      postrender(renderTarget) {
        if (!this._renderer.context.multiView)
          return;
        if (CanvasSource.test(renderTarget.colorTexture.resource)) {
          const contextCanvas = this._renderer.context.canvas;
          const canvasSource = renderTarget.colorTexture;
          canvasSource.context2D.drawImage(
            contextCanvas,
            0,
            canvasSource.pixelHeight - contextCanvas.height
          );
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs
var GlRenderTargetSystem;
var init_GlRenderTargetSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_RenderTargetSystem();
    init_GlRenderTargetAdaptor();
    GlRenderTargetSystem = class extends RenderTargetSystem {
      constructor(renderer) {
        super(renderer);
        this.adaptor = new GlRenderTargetAdaptor();
        this.adaptor.init(renderer, this);
      }
    };
    GlRenderTargetSystem.extension = {
      type: [ExtensionType.WebGLSystem],
      name: "renderTarget"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs
function generateShaderSyncCode(shader, shaderSystem) {
  const funcFragments = [];
  const headerFragments = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
  let addedTextreSystem = false;
  let textureCount = 0;
  const programData = shaderSystem._getProgramData(shader.glProgram);
  for (const i3 in shader.groups) {
    const group = shader.groups[i3];
    funcFragments.push(`
            resources = g[${i3}].resources;
        `);
    for (const j2 in group.resources) {
      const resource = group.resources[j2];
      if (resource instanceof UniformGroup) {
        if (resource.ubo) {
          const resName = shader._uniformBindMap[i3][Number(j2)];
          funcFragments.push(`
                        sS.bindUniformBlock(
                            resources[${j2}],
                            '${resName}',
                            ${shader.glProgram._uniformBlockData[resName].index}
                        );
                    `);
        } else {
          funcFragments.push(`
                        ugS.updateUniformGroup(resources[${j2}], p, sD);
                    `);
        }
      } else if (resource instanceof BufferResource) {
        const resName = shader._uniformBindMap[i3][Number(j2)];
        funcFragments.push(`
                    sS.bindUniformBlock(
                        resources[${j2}],
                        '${resName}',
                        ${shader.glProgram._uniformBlockData[resName].index}
                    );
                `);
      } else if (resource instanceof TextureSource) {
        const uniformName = shader._uniformBindMap[i3][j2];
        const uniformData = programData.uniformData[uniformName];
        if (uniformData) {
          if (!addedTextreSystem) {
            addedTextreSystem = true;
            headerFragments.push(`
                        var tS = r.texture;
                        `);
          }
          shaderSystem._gl.uniform1i(uniformData.location, textureCount);
          funcFragments.push(`
                        tS.bind(resources[${j2}], ${textureCount});
                    `);
          textureCount++;
        }
      }
    }
  }
  const functionSource = [...headerFragments, ...funcFragments].join("\n");
  return new Function("r", "s", "sD", functionSource);
}
var init_GenerateShaderSyncCode = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs"() {
    init_define_AnParams();
    init_BufferResource();
    init_UniformGroup();
    init_TextureSource();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs
var IGLUniformData, GlProgramData;
var init_GlProgramData = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs"() {
    "use strict";
    init_define_AnParams();
    IGLUniformData = class {
    };
    GlProgramData = class {
      /**
       * Makes a new Pixi program.
       * @param program - webgl program
       * @param uniformData - uniforms
       */
      constructor(program, uniformData) {
        this.program = program;
        this.uniformData = uniformData;
        this.uniformGroups = {};
        this.uniformDirtyGroups = {};
        this.uniformBlockBindings = {};
      }
      /** Destroys this program. */
      destroy() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.uniformDirtyGroups = null;
        this.uniformBlockBindings = null;
        this.program = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs
function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
var init_compileShader = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
function booleanArray(size) {
  const array = new Array(size);
  for (let i3 = 0; i3 < array.length; i3++) {
    array[i3] = false;
  }
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_defaultValue = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i3 = 0; i3 < typeNames.length; ++i3) {
      const tn = typeNames[i3];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
function mapGlToVertexFormat(gl, type) {
  const typeValue = mapType(gl, type);
  return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";
}
var GL_TABLE, GL_TO_GLSL_TYPES, GLSL_TO_VERTEX_TYPES;
var init_mapType = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs"() {
    "use strict";
    init_define_AnParams();
    GL_TABLE = null;
    GL_TO_GLSL_TYPES = {
      FLOAT: "float",
      FLOAT_VEC2: "vec2",
      FLOAT_VEC3: "vec3",
      FLOAT_VEC4: "vec4",
      INT: "int",
      INT_VEC2: "ivec2",
      INT_VEC3: "ivec3",
      INT_VEC4: "ivec4",
      UNSIGNED_INT: "uint",
      UNSIGNED_INT_VEC2: "uvec2",
      UNSIGNED_INT_VEC3: "uvec3",
      UNSIGNED_INT_VEC4: "uvec4",
      BOOL: "bool",
      BOOL_VEC2: "bvec2",
      BOOL_VEC3: "bvec3",
      BOOL_VEC4: "bvec4",
      FLOAT_MAT2: "mat2",
      FLOAT_MAT3: "mat3",
      FLOAT_MAT4: "mat4",
      SAMPLER_2D: "sampler2D",
      INT_SAMPLER_2D: "sampler2D",
      UNSIGNED_INT_SAMPLER_2D: "sampler2D",
      SAMPLER_CUBE: "samplerCube",
      INT_SAMPLER_CUBE: "samplerCube",
      UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
      SAMPLER_2D_ARRAY: "sampler2DArray",
      INT_SAMPLER_2D_ARRAY: "sampler2DArray",
      UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    };
    GLSL_TO_VERTEX_TYPES = {
      float: "float32",
      vec2: "float32x2",
      vec3: "float32x3",
      vec4: "float32x4",
      int: "sint32",
      ivec2: "sint32x2",
      ivec3: "sint32x3",
      ivec4: "sint32x4",
      uint: "uint32",
      uvec2: "uint32x2",
      uvec3: "uint32x3",
      uvec4: "uint32x4",
      bool: "uint32",
      bvec2: "uint32x2",
      bvec3: "uint32x3",
      bvec4: "uint32x4"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs
function extractAttributesFromGlProgram(program, gl, sortAttributes = false) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i3 = 0; i3 < totalAttributes; i3++) {
    const attribData = gl.getActiveAttrib(program, i3);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const format = mapGlToVertexFormat(gl, attribData.type);
    attributes[attribData.name] = {
      location: 0,
      // set further down..
      format,
      stride: getAttributeInfoFromFormat(format).stride,
      offset: 0,
      instance: false,
      start: 0
    };
  }
  const keys = Object.keys(attributes);
  if (sortAttributes) {
    keys.sort((a2, b3) => a2 > b3 ? 1 : -1);
    for (let i3 = 0; i3 < keys.length; i3++) {
      attributes[keys[i3]].location = i3;
      gl.bindAttribLocation(program, i3, keys[i3]);
    }
    gl.linkProgram(program);
  } else {
    for (let i3 = 0; i3 < keys.length; i3++) {
      attributes[keys[i3]].location = gl.getAttribLocation(program, keys[i3]);
    }
  }
  return attributes;
}
var init_extractAttributesFromGlProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs"() {
    init_define_AnParams();
    init_getAttributeInfoFromFormat();
    init_mapType();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs
function getUboData(program, gl) {
  if (!gl.ACTIVE_UNIFORM_BLOCKS)
    return {};
  const uniformBlocks = {};
  const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
  for (let i3 = 0; i3 < totalUniformsBlocks; i3++) {
    const name = gl.getActiveUniformBlockName(program, i3);
    const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
    const size = gl.getActiveUniformBlockParameter(program, i3, gl.UNIFORM_BLOCK_DATA_SIZE);
    uniformBlocks[name] = {
      name,
      index: uniformBlockIndex,
      size
    };
  }
  return uniformBlocks;
}
var init_getUboData = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i3 = 0; i3 < totalUniforms; i3++) {
    const uniformData = gl.getActiveUniform(program, i3);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray = !!uniformData.name.match(/\[.*?\]$/);
    const type = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i3,
      type,
      size: uniformData.size,
      isArray,
      value: defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}
var init_getUniformData = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs"() {
    init_define_AnParams();
    init_defaultValue();
    init_mapType();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
    if (n2 && !dedupe[n2]) {
      dedupe[n2] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
var init_logProgramError = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
function generateProgram(gl, program) {
  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(
        webGLProgram,
        transformFeedbackVaryings.names,
        transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
      );
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program._attributeData = extractAttributesFromGlProgram(
    webGLProgram,
    gl,
    !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertex)
  );
  program._uniformData = getUniformData(webGLProgram, gl);
  program._uniformBlockData = getUboData(webGLProgram, gl);
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i3 in program._uniformData) {
    const data = program._uniformData[i3];
    uniformData[i3] = {
      location: gl.getUniformLocation(webGLProgram, i3),
      value: defaultValue(data.type, data.size)
    };
  }
  const glProgram3 = new GlProgramData(webGLProgram, uniformData);
  return glProgram3;
}
var init_generateProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs"() {
    init_define_AnParams();
    init_warn();
    init_GlProgramData();
    init_compileShader();
    init_defaultValue();
    init_extractAttributesFromGlProgram();
    init_getUboData();
    init_getUniformData();
    init_logProgramError();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
var defaultSyncData, GlShaderSystem;
var init_GlShaderSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_maxRecommendedTextures();
    init_GenerateShaderSyncCode();
    init_generateProgram();
    defaultSyncData = {
      textureCount: 0,
      blockIndex: 0
    };
    GlShaderSystem = class {
      constructor(renderer) {
        this._activeProgram = null;
        this._programDataHash = /* @__PURE__ */ Object.create(null);
        this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
      }
      contextChange(gl) {
        this._gl = gl;
        this._programDataHash = /* @__PURE__ */ Object.create(null);
        this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
        this._activeProgram = null;
        this.maxTextures = getMaxTexturesPerBatch();
      }
      /**
       * Changes the current shader to the one given in parameter.
       * @param shader - the new shader
       * @param skipSync - false if the shader should automatically sync its uniforms.
       * @returns the glProgram that belongs to the shader.
       */
      bind(shader, skipSync) {
        this._setProgram(shader.glProgram);
        if (skipSync)
          return;
        defaultSyncData.textureCount = 0;
        defaultSyncData.blockIndex = 0;
        let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];
        if (!syncFunction) {
          syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);
        }
        this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);
        syncFunction(this._renderer, shader, defaultSyncData);
      }
      /**
       * Updates the uniform group.
       * @param uniformGroup - the uniform group to update
       */
      updateUniformGroup(uniformGroup) {
        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);
      }
      /**
       * Binds a uniform block to the shader.
       * @param uniformGroup - the uniform group to bind
       * @param name - the name of the uniform block
       * @param index - the index of the uniform block
       */
      bindUniformBlock(uniformGroup, name, index = 0) {
        const bufferSystem = this._renderer.buffer;
        const programData = this._getProgramData(this._activeProgram);
        const isBufferResource = uniformGroup._bufferResource;
        if (!isBufferResource) {
          this._renderer.ubo.updateUniformGroup(uniformGroup);
        }
        const buffer = uniformGroup.buffer;
        const glBuffer = bufferSystem.updateBuffer(buffer);
        const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);
        if (isBufferResource) {
          const { offset, size } = uniformGroup;
          if (offset === 0 && size === buffer.data.byteLength) {
            bufferSystem.bindBufferBase(glBuffer, boundLocation);
          } else {
            bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);
          }
        } else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation) {
          bufferSystem.bindBufferBase(glBuffer, boundLocation);
        }
        const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;
        if (programData.uniformBlockBindings[index] === boundLocation)
          return;
        programData.uniformBlockBindings[index] = boundLocation;
        this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);
      }
      _setProgram(program) {
        if (this._activeProgram === program)
          return;
        this._activeProgram = program;
        const programData = this._getProgramData(program);
        this._gl.useProgram(programData.program);
      }
      /**
       * @param program - the program to get the data for
       * @internal
       * @private
       */
      _getProgramData(program) {
        return this._programDataHash[program._key] || this._createProgramData(program);
      }
      _createProgramData(program) {
        const key = program._key;
        this._programDataHash[key] = generateProgram(this._gl, program);
        return this._programDataHash[key];
      }
      destroy() {
        for (const key of Object.keys(this._programDataHash)) {
          const programData = this._programDataHash[key];
          programData.destroy();
          this._programDataHash[key] = null;
        }
        this._programDataHash = null;
      }
      /**
       * Creates a function that can be executed that will sync the shader as efficiently as possible.
       * Overridden by the unsafe eval package if you don't want eval used in your project.
       * @param shader - the shader to generate the sync function for
       * @param shaderSystem - the shader system to use
       * @returns - the generated sync function
       * @ignore
       */
      _generateShaderSync(shader, shaderSystem) {
        return generateShaderSyncCode(shader, shaderSystem);
      }
      resetState() {
        this._activeProgram = null;
      }
    };
    GlShaderSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "shader"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs
var UNIFORM_TO_SINGLE_SETTERS, UNIFORM_TO_ARRAY_SETTERS;
var init_generateUniformsSyncTypes = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs"() {
    "use strict";
    init_define_AnParams();
    UNIFORM_TO_SINGLE_SETTERS = {
      f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
      "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
      "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
      "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
      i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
      "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
      "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
      "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
      u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
      "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
      "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
      "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
      bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
      "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
      "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
      "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
      "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
      "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
      "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`
    };
    UNIFORM_TO_ARRAY_SETTERS = {
      f32: `gl.uniform1fv(location, v);`,
      "vec2<f32>": `gl.uniform2fv(location, v);`,
      "vec3<f32>": `gl.uniform3fv(location, v);`,
      "vec4<f32>": `gl.uniform4fv(location, v);`,
      "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
      "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
      "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,
      i32: `gl.uniform1iv(location, v);`,
      "vec2<i32>": `gl.uniform2iv(location, v);`,
      "vec3<i32>": `gl.uniform3iv(location, v);`,
      "vec4<i32>": `gl.uniform4iv(location, v);`,
      u32: `gl.uniform1iv(location, v);`,
      "vec2<u32>": `gl.uniform2iv(location, v);`,
      "vec3<u32>": `gl.uniform3iv(location, v);`,
      "vec4<u32>": `gl.uniform4iv(location, v);`,
      bool: `gl.uniform1iv(location, v);`,
      "vec2<bool>": `gl.uniform2iv(location, v);`,
      "vec3<bool>": `gl.uniform3iv(location, v);`,
      "vec4<bool>": `gl.uniform4iv(location, v);`
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs
function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
  for (const i3 in group.uniforms) {
    if (!uniformData[i3]) {
      if (group.uniforms[i3] instanceof UniformGroup) {
        if (group.uniforms[i3].ubo) {
          funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i3}, "${i3}");
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i3});
                    `);
        }
      } else if (group.uniforms[i3] instanceof BufferResource) {
        funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i3}, "${i3}");
                    `);
      }
      continue;
    }
    const uniform = group.uniformStructures[i3];
    let parsed = false;
    for (let j2 = 0; j2 < uniformParsers.length; j2++) {
      const parser = uniformParsers[j2];
      if (uniform.type === parser.type && parser.test(uniform)) {
        funcFragments.push(`name = "${i3}";`, uniformParsers[j2].uniform);
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;
      const template = templateType[uniform.type].replace("location", `ud["${i3}"].location`);
      funcFragments.push(`
            cu = ud["${i3}"];
            cv = cu.value;
            v = uv["${i3}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var init_generateUniformsSync = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs"() {
    init_define_AnParams();
    init_BufferResource();
    init_UniformGroup();
    init_uniformParsers();
    init_generateUniformsSyncTypes();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
var GlUniformGroupSystem;
var init_GlUniformGroupSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_generateUniformsSync();
    GlUniformGroupSystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._cache = {};
        this._uniformGroupSyncHash = {};
        this._renderer = renderer;
        this.gl = null;
        this._cache = {};
      }
      contextChange(gl) {
        this.gl = gl;
      }
      /**
       * Uploads the uniforms values to the currently bound shader.
       * @param group - the uniforms values that be applied to the current shader
       * @param program
       * @param syncData
       * @param syncData.textureCount
       */
      updateUniformGroup(group, program, syncData) {
        const programData = this._renderer.shader._getProgramData(program);
        if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {
          programData.uniformDirtyGroups[group.uid] = group._dirtyId;
          const syncFunc = this._getUniformSyncFunction(group, program);
          syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
        }
      }
      /**
       * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.
       * @param group
       * @param program
       */
      _getUniformSyncFunction(group, program) {
        return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);
      }
      _createUniformSyncFunction(group, program) {
        const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});
        const id = this._getSignature(group, program._uniformData, "u");
        if (!this._cache[id]) {
          this._cache[id] = this._generateUniformsSync(group, program._uniformData);
        }
        uniformGroupSyncHash[program._key] = this._cache[id];
        return uniformGroupSyncHash[program._key];
      }
      _generateUniformsSync(group, uniformData) {
        return generateUniformsSync(group, uniformData);
      }
      /**
       * Takes a uniform group and data and generates a unique signature for them.
       * @param group - The uniform group to get signature of
       * @param group.uniforms
       * @param uniformData - Uniform information generated by the shader
       * @param preFix
       * @returns Unique signature of the uniform group
       */
      _getSignature(group, uniformData, preFix) {
        const uniforms = group.uniforms;
        const strings = [`${preFix}-`];
        for (const i3 in uniforms) {
          strings.push(i3);
          if (uniformData[i3]) {
            strings.push(uniformData[i3].type);
          }
        }
        return strings.join("-");
      }
      /** Destroys this System and removes all its textures. */
      destroy() {
        this._renderer = null;
        this._cache = null;
      }
    };
    GlUniformGroupSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "uniformGroup"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
function mapWebGLBlendModesToPixi(gl) {
  const blendMap = {};
  blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.add = [gl.ONE, gl.ONE];
  blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.none = [0, 0];
  blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());
  if (isWebGl2) {
    blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];
    blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];
  } else {
    const ext = gl.getExtension("EXT_blend_minmax");
    if (ext) {
      blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];
      blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];
    }
  }
  return blendMap;
}
var init_mapWebGLBlendModesToPixi = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs"() {
    init_define_AnParams();
    init_adapter();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs
var BLEND2, OFFSET2, CULLING2, DEPTH_TEST2, WINDING2, DEPTH_MASK2, _GlStateSystem, GlStateSystem;
var init_GlStateSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_State();
    init_mapWebGLBlendModesToPixi();
    BLEND2 = 0;
    OFFSET2 = 1;
    CULLING2 = 2;
    DEPTH_TEST2 = 3;
    WINDING2 = 4;
    DEPTH_MASK2 = 5;
    _GlStateSystem = class _GlStateSystem2 {
      constructor(renderer) {
        this._invertFrontFace = false;
        this.gl = null;
        this.stateId = 0;
        this.polygonOffset = 0;
        this.blendMode = "none";
        this._blendEq = false;
        this.map = [];
        this.map[BLEND2] = this.setBlend;
        this.map[OFFSET2] = this.setOffset;
        this.map[CULLING2] = this.setCullFace;
        this.map[DEPTH_TEST2] = this.setDepthTest;
        this.map[WINDING2] = this.setFrontFace;
        this.map[DEPTH_MASK2] = this.setDepthMask;
        this.checks = [];
        this.defaultState = State.for2d();
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      onRenderTargetChange(renderTarget) {
        this._invertFrontFace = !renderTarget.isRoot;
        if (this._cullFace) {
          this.setFrontFace(this._frontFace);
        } else {
          this._frontFaceDirty = true;
        }
      }
      contextChange(gl) {
        this.gl = gl;
        this.blendModesMap = mapWebGLBlendModesToPixi(gl);
        this.resetState();
      }
      /**
       * Sets the current state
       * @param {*} state - The state to set.
       */
      set(state) {
        state || (state = this.defaultState);
        if (this.stateId !== state.data) {
          let diff = this.stateId ^ state.data;
          let i3 = 0;
          while (diff) {
            if (diff & 1) {
              this.map[i3].call(this, !!(state.data & 1 << i3));
            }
            diff >>= 1;
            i3++;
          }
          this.stateId = state.data;
        }
        for (let i3 = 0; i3 < this.checks.length; i3++) {
          this.checks[i3](this, state);
        }
      }
      /**
       * Sets the state, when previous state is unknown.
       * @param {*} state - The state to set
       */
      forceState(state) {
        state || (state = this.defaultState);
        for (let i3 = 0; i3 < this.map.length; i3++) {
          this.map[i3].call(this, !!(state.data & 1 << i3));
        }
        for (let i3 = 0; i3 < this.checks.length; i3++) {
          this.checks[i3](this, state);
        }
        this.stateId = state.data;
      }
      /**
       * Sets whether to enable or disable blending.
       * @param value - Turn on or off WebGl blending.
       */
      setBlend(value) {
        this._updateCheck(_GlStateSystem2._checkBlendMode, value);
        this.gl[value ? "enable" : "disable"](this.gl.BLEND);
      }
      /**
       * Sets whether to enable or disable polygon offset fill.
       * @param value - Turn on or off webgl polygon offset testing.
       */
      setOffset(value) {
        this._updateCheck(_GlStateSystem2._checkPolygonOffset, value);
        this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      }
      /**
       * Sets whether to enable or disable depth test.
       * @param value - Turn on or off webgl depth testing.
       */
      setDepthTest(value) {
        this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
      }
      /**
       * Sets whether to enable or disable depth mask.
       * @param value - Turn on or off webgl depth mask.
       */
      setDepthMask(value) {
        this.gl.depthMask(value);
      }
      /**
       * Sets whether to enable or disable cull face.
       * @param {boolean} value - Turn on or off webgl cull face.
       */
      setCullFace(value) {
        this._cullFace = value;
        this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
        if (this._cullFace && this._frontFaceDirty) {
          this.setFrontFace(this._frontFace);
        }
      }
      /**
       * Sets the gl front face.
       * @param {boolean} value - true is clockwise and false is counter-clockwise
       */
      setFrontFace(value) {
        this._frontFace = value;
        this._frontFaceDirty = false;
        const faceMode = this._invertFrontFace ? !value : value;
        if (this._glFrontFace !== faceMode) {
          this._glFrontFace = faceMode;
          this.gl.frontFace(this.gl[faceMode ? "CW" : "CCW"]);
        }
      }
      /**
       * Sets the blend mode.
       * @param {number} value - The blend mode to set to.
       */
      setBlendMode(value) {
        if (!this.blendModesMap[value]) {
          value = "normal";
        }
        if (value === this.blendMode) {
          return;
        }
        this.blendMode = value;
        const mode = this.blendModesMap[value];
        const gl = this.gl;
        if (mode.length === 2) {
          gl.blendFunc(mode[0], mode[1]);
        } else {
          gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
          this._blendEq = true;
          gl.blendEquationSeparate(mode[4], mode[5]);
        } else if (this._blendEq) {
          this._blendEq = false;
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
      }
      /**
       * Sets the polygon offset.
       * @param {number} value - the polygon offset
       * @param {number} scale - the polygon offset scale
       */
      setPolygonOffset(value, scale) {
        this.gl.polygonOffset(value, scale);
      }
      // used
      /** Resets all the logic and disables the VAOs. */
      resetState() {
        this._glFrontFace = false;
        this._frontFace = false;
        this._cullFace = false;
        this._frontFaceDirty = false;
        this._invertFrontFace = false;
        this.gl.frontFace(this.gl.CCW);
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(this.defaultState);
        this._blendEq = true;
        this.blendMode = "";
        this.setBlendMode("normal");
      }
      /**
       * Checks to see which updates should be checked based on which settings have been activated.
       *
       * For example, if blend is enabled then we should check the blend modes each time the state is changed
       * or if polygon fill is activated then we need to check if the polygon offset changes.
       * The idea is that we only check what we have too.
       * @param func - the checking function to add or remove
       * @param value - should the check function be added or removed.
       */
      _updateCheck(func, value) {
        const index = this.checks.indexOf(func);
        if (value && index === -1) {
          this.checks.push(func);
        } else if (!value && index !== -1) {
          this.checks.splice(index, 1);
        }
      }
      /**
       * A private little wrapper function that we call to check the blend mode.
       * @param system - the System to perform the state check on
       * @param state - the state that the blendMode will pulled from
       */
      static _checkBlendMode(system, state) {
        system.setBlendMode(state.blendMode);
      }
      /**
       * A private little wrapper function that we call to check the polygon offset.
       * @param system - the System to perform the state check on
       * @param state - the state that the blendMode will pulled from
       */
      static _checkPolygonOffset(system, state) {
        system.setPolygonOffset(1, state.polygonOffset);
      }
      /**
       * @ignore
       */
      destroy() {
        this.gl = null;
        this.checks.length = 0;
      }
    };
    _GlStateSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "state"
    };
    GlStateSystem = _GlStateSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs
var GlTexture;
var init_GlTexture = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs"() {
    init_define_AnParams();
    init_const10();
    GlTexture = class {
      constructor(texture) {
        this.target = GL_TARGETS.TEXTURE_2D;
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        this.type = GL_TYPES.UNSIGNED_BYTE;
        this.internalFormat = GL_FORMATS.RGBA;
        this.format = GL_FORMATS.RGBA;
        this.samplerType = 0;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
var glUploadBufferImageResource;
var init_glUploadBufferImageResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs"() {
    "use strict";
    init_define_AnParams();
    glUploadBufferImageResource = {
      id: "buffer",
      upload(source9, glTexture, gl) {
        if (glTexture.width === source9.width || glTexture.height === source9.height) {
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            source9.width,
            source9.height,
            glTexture.format,
            glTexture.type,
            source9.resource
          );
        } else {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            source9.width,
            source9.height,
            0,
            glTexture.format,
            glTexture.type,
            source9.resource
          );
        }
        glTexture.width = source9.width;
        glTexture.height = source9.height;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs
var compressedFormatMap, glUploadCompressedTextureResource;
var init_glUploadCompressedTextureResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs"() {
    "use strict";
    init_define_AnParams();
    compressedFormatMap = {
      "bc1-rgba-unorm": true,
      "bc1-rgba-unorm-srgb": true,
      "bc2-rgba-unorm": true,
      "bc2-rgba-unorm-srgb": true,
      "bc3-rgba-unorm": true,
      "bc3-rgba-unorm-srgb": true,
      "bc4-r-unorm": true,
      "bc4-r-snorm": true,
      "bc5-rg-unorm": true,
      "bc5-rg-snorm": true,
      "bc6h-rgb-ufloat": true,
      "bc6h-rgb-float": true,
      "bc7-rgba-unorm": true,
      "bc7-rgba-unorm-srgb": true,
      // ETC2 compressed formats usable if "texture-compression-etc2" is both
      // supported by the device/user agent and enabled in requestDevice.
      "etc2-rgb8unorm": true,
      "etc2-rgb8unorm-srgb": true,
      "etc2-rgb8a1unorm": true,
      "etc2-rgb8a1unorm-srgb": true,
      "etc2-rgba8unorm": true,
      "etc2-rgba8unorm-srgb": true,
      "eac-r11unorm": true,
      "eac-r11snorm": true,
      "eac-rg11unorm": true,
      "eac-rg11snorm": true,
      // ASTC compressed formats usable if "texture-compression-astc" is both
      // supported by the device/user agent and enabled in requestDevice.
      "astc-4x4-unorm": true,
      "astc-4x4-unorm-srgb": true,
      "astc-5x4-unorm": true,
      "astc-5x4-unorm-srgb": true,
      "astc-5x5-unorm": true,
      "astc-5x5-unorm-srgb": true,
      "astc-6x5-unorm": true,
      "astc-6x5-unorm-srgb": true,
      "astc-6x6-unorm": true,
      "astc-6x6-unorm-srgb": true,
      "astc-8x5-unorm": true,
      "astc-8x5-unorm-srgb": true,
      "astc-8x6-unorm": true,
      "astc-8x6-unorm-srgb": true,
      "astc-8x8-unorm": true,
      "astc-8x8-unorm-srgb": true,
      "astc-10x5-unorm": true,
      "astc-10x5-unorm-srgb": true,
      "astc-10x6-unorm": true,
      "astc-10x6-unorm-srgb": true,
      "astc-10x8-unorm": true,
      "astc-10x8-unorm-srgb": true,
      "astc-10x10-unorm": true,
      "astc-10x10-unorm-srgb": true,
      "astc-12x10-unorm": true,
      "astc-12x10-unorm-srgb": true,
      "astc-12x12-unorm": true,
      "astc-12x12-unorm-srgb": true
    };
    glUploadCompressedTextureResource = {
      id: "compressed",
      upload(source9, glTexture, gl) {
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        let mipWidth = source9.pixelWidth;
        let mipHeight = source9.pixelHeight;
        const compressed = !!compressedFormatMap[source9.format];
        for (let i3 = 0; i3 < source9.resource.length; i3++) {
          const levelBuffer = source9.resource[i3];
          if (compressed) {
            gl.compressedTexImage2D(
              gl.TEXTURE_2D,
              i3,
              glTexture.internalFormat,
              mipWidth,
              mipHeight,
              0,
              levelBuffer
            );
          } else {
            gl.texImage2D(
              gl.TEXTURE_2D,
              i3,
              glTexture.internalFormat,
              mipWidth,
              mipHeight,
              0,
              glTexture.format,
              glTexture.type,
              levelBuffer
            );
          }
          mipWidth = Math.max(mipWidth >> 1, 1);
          mipHeight = Math.max(mipHeight >> 1, 1);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
var glUploadImageResource;
var init_glUploadImageResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs"() {
    "use strict";
    init_define_AnParams();
    glUploadImageResource = {
      id: "image",
      upload(source9, glTexture, gl, webGLVersion) {
        const glWidth = glTexture.width;
        const glHeight = glTexture.height;
        const textureWidth = source9.pixelWidth;
        const textureHeight = source9.pixelHeight;
        const resourceWidth = source9.resourceWidth;
        const resourceHeight = source9.resourceHeight;
        if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
          if (glWidth !== textureWidth || glHeight !== textureHeight) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              textureWidth,
              textureHeight,
              0,
              glTexture.format,
              glTexture.type,
              null
            );
          }
          if (webGLVersion === 2) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              resourceWidth,
              resourceHeight,
              glTexture.format,
              glTexture.type,
              source9.resource
            );
          } else {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              glTexture.format,
              glTexture.type,
              source9.resource
            );
          }
        } else if (glWidth === textureWidth && glHeight === textureHeight) {
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            glTexture.format,
            glTexture.type,
            source9.resource
          );
        } else if (webGLVersion === 2) {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            textureWidth,
            textureHeight,
            0,
            glTexture.format,
            glTexture.type,
            source9.resource
          );
        } else {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            glTexture.format,
            glTexture.type,
            source9.resource
          );
        }
        glTexture.width = textureWidth;
        glTexture.height = textureHeight;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs
var glUploadVideoResource;
var init_glUploadVideoResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs"() {
    init_define_AnParams();
    init_glUploadImageResource();
    glUploadVideoResource = {
      id: "video",
      upload(source9, glTexture, gl, webGLVersion) {
        if (!source9.isValid) {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            1,
            1,
            0,
            glTexture.format,
            glTexture.type,
            null
          );
          return;
        }
        glUploadImageResource.upload(source9, glTexture, gl, webGLVersion);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
var scaleModeToGlFilter, mipmapScaleModeToGlFilter, wrapModeToGlAddress, compareModeToGlCompare;
var init_pixiToGlMaps = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs"() {
    "use strict";
    init_define_AnParams();
    scaleModeToGlFilter = {
      linear: 9729,
      nearest: 9728
    };
    mipmapScaleModeToGlFilter = {
      linear: {
        linear: 9987,
        nearest: 9985
      },
      nearest: {
        linear: 9986,
        nearest: 9984
      }
    };
    wrapModeToGlAddress = {
      "clamp-to-edge": 33071,
      repeat: 10497,
      "mirror-repeat": 33648
    };
    compareModeToGlCompare = {
      never: 512,
      less: 513,
      equal: 514,
      "less-equal": 515,
      greater: 516,
      "not-equal": 517,
      "greater-equal": 518,
      always: 519
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs
function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {
  const castParam = firstParam;
  if (!firstCreation || style.addressModeU !== "repeat" || style.addressModeV !== "repeat" || style.addressModeW !== "repeat") {
    const wrapModeS = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeU];
    const wrapModeT = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeV];
    const wrapModeR = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeW];
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);
    if (gl.TEXTURE_WRAP_R)
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);
  }
  if (!firstCreation || style.magFilter !== "linear") {
    gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
  }
  if (mipmaps) {
    if (!firstCreation || style.mipmapFilter !== "linear") {
      const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
    }
  } else {
    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
  }
  if (anisotropicExt && style.maxAnisotropy > 1) {
    const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
    gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
  }
  if (style.compare) {
    gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
  }
}
var init_applyStyleParams = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs"() {
    init_define_AnParams();
    init_pixiToGlMaps();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
function mapFormatToGlFormat(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.RED,
    r8snorm: gl.RED,
    r8uint: gl.RED,
    r8sint: gl.RED,
    // 16-bit formats
    r16uint: gl.RED,
    r16sint: gl.RED,
    r16float: gl.RED,
    rg8unorm: gl.RG,
    rg8snorm: gl.RG,
    rg8uint: gl.RG,
    rg8sint: gl.RG,
    // 32-bit formats
    r32uint: gl.RED,
    r32sint: gl.RED,
    r32float: gl.RED,
    rg16uint: gl.RG,
    rg16sint: gl.RG,
    rg16float: gl.RG,
    rgba8unorm: gl.RGBA,
    "rgba8unorm-srgb": gl.RGBA,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA,
    rgba8uint: gl.RGBA,
    rgba8sint: gl.RGBA,
    bgra8unorm: gl.RGBA,
    "bgra8unorm-srgb": gl.RGBA,
    rgb9e5ufloat: gl.RGB,
    rgb10a2unorm: gl.RGBA,
    rg11b10ufloat: gl.RGB,
    // 64-bit formats
    rg32uint: gl.RG,
    rg32sint: gl.RG,
    rg32float: gl.RG,
    rgba16uint: gl.RGBA,
    rgba16sint: gl.RGBA,
    rgba16float: gl.RGBA,
    // 128-bit formats
    rgba32uint: gl.RGBA,
    rgba32sint: gl.RGBA,
    rgba32float: gl.RGBA,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT,
    depth24plus: gl.DEPTH_COMPONENT,
    "depth24plus-stencil8": gl.DEPTH_STENCIL,
    depth32float: gl.DEPTH_COMPONENT,
    "depth32float-stencil8": gl.DEPTH_STENCIL
  };
}
var init_mapFormatToGlFormat = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
function mapFormatToGlInternalFormat(gl, extensions2) {
  let srgb = {};
  let bgra8unorm = gl.RGBA;
  if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext())) {
    srgb = {
      "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
      "bgra8unorm-srgb": gl.SRGB8_ALPHA8
    };
    bgra8unorm = gl.RGBA8;
  } else if (extensions2.srgb) {
    srgb = {
      "rgba8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT,
      "bgra8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT
    };
  }
  return {
    // 8-bit formats
    r8unorm: gl.R8,
    r8snorm: gl.R8_SNORM,
    r8uint: gl.R8UI,
    r8sint: gl.R8I,
    // 16-bit formats
    r16uint: gl.R16UI,
    r16sint: gl.R16I,
    r16float: gl.R16F,
    rg8unorm: gl.RG8,
    rg8snorm: gl.RG8_SNORM,
    rg8uint: gl.RG8UI,
    rg8sint: gl.RG8I,
    // 32-bit formats
    r32uint: gl.R32UI,
    r32sint: gl.R32I,
    r32float: gl.R32F,
    rg16uint: gl.RG16UI,
    rg16sint: gl.RG16I,
    rg16float: gl.RG16F,
    rgba8unorm: gl.RGBA,
    ...srgb,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA8_SNORM,
    rgba8uint: gl.RGBA8UI,
    rgba8sint: gl.RGBA8I,
    bgra8unorm,
    rgb9e5ufloat: gl.RGB9_E5,
    rgb10a2unorm: gl.RGB10_A2,
    rg11b10ufloat: gl.R11F_G11F_B10F,
    // 64-bit formats
    rg32uint: gl.RG32UI,
    rg32sint: gl.RG32I,
    rg32float: gl.RG32F,
    rgba16uint: gl.RGBA16UI,
    rgba16sint: gl.RGBA16I,
    rgba16float: gl.RGBA16F,
    // 128-bit formats
    rgba32uint: gl.RGBA32UI,
    rgba32sint: gl.RGBA32I,
    rgba32float: gl.RGBA32F,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT16,
    depth24plus: gl.DEPTH_COMPONENT24,
    "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
    depth32float: gl.DEPTH_COMPONENT32F,
    "depth32float-stencil8": gl.DEPTH32F_STENCIL8,
    // Compressed formats
    ...extensions2.s3tc ? {
      "bc1-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
    } : {},
    ...extensions2.s3tc_sRGB ? {
      "bc1-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
    } : {},
    ...extensions2.rgtc ? {
      "bc4-r-unorm": extensions2.rgtc.COMPRESSED_RED_RGTC1_EXT,
      "bc4-r-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
      "bc5-rg-unorm": extensions2.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
      "bc5-rg-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
    } : {},
    ...extensions2.bptc ? {
      "bc6h-rgb-float": extensions2.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
      "bc6h-rgb-ufloat": extensions2.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
      "bc7-rgba-unorm": extensions2.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
      "bc7-rgba-unorm-srgb": extensions2.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
    } : {},
    ...extensions2.etc ? {
      "etc2-rgb8unorm": extensions2.etc.COMPRESSED_RGB8_ETC2,
      "etc2-rgb8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ETC2,
      "etc2-rgb8a1unorm": extensions2.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgb8a1unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgba8unorm": extensions2.etc.COMPRESSED_RGBA8_ETC2_EAC,
      "etc2-rgba8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
      "eac-r11unorm": extensions2.etc.COMPRESSED_R11_EAC,
      // 'eac-r11snorm'
      "eac-rg11unorm": extensions2.etc.COMPRESSED_SIGNED_RG11_EAC
      // 'eac-rg11snorm'
    } : {},
    ...extensions2.astc ? {
      "astc-4x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
      "astc-4x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
      "astc-5x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
      "astc-5x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
      "astc-5x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
      "astc-5x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
      "astc-6x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
      "astc-6x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
      "astc-6x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
      "astc-6x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
      "astc-8x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
      "astc-8x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
      "astc-8x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
      "astc-8x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
      "astc-8x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
      "astc-8x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
      "astc-10x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
      "astc-10x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
      "astc-10x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
      "astc-10x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
      "astc-10x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
      "astc-10x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
      "astc-10x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
      "astc-10x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
      "astc-12x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
      "astc-12x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
      "astc-12x12-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
      "astc-12x12-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
    } : {}
  };
}
var init_mapFormatToGlInternalFormat = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs"() {
    init_define_AnParams();
    init_adapter();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
function mapFormatToGlType(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.UNSIGNED_BYTE,
    r8snorm: gl.BYTE,
    r8uint: gl.UNSIGNED_BYTE,
    r8sint: gl.BYTE,
    // 16-bit formats
    r16uint: gl.UNSIGNED_SHORT,
    r16sint: gl.SHORT,
    r16float: gl.HALF_FLOAT,
    rg8unorm: gl.UNSIGNED_BYTE,
    rg8snorm: gl.BYTE,
    rg8uint: gl.UNSIGNED_BYTE,
    rg8sint: gl.BYTE,
    // 32-bit formats
    r32uint: gl.UNSIGNED_INT,
    r32sint: gl.INT,
    r32float: gl.FLOAT,
    rg16uint: gl.UNSIGNED_SHORT,
    rg16sint: gl.SHORT,
    rg16float: gl.HALF_FLOAT,
    rgba8unorm: gl.UNSIGNED_BYTE,
    "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
    // Packed 32-bit formats
    rgba8snorm: gl.BYTE,
    rgba8uint: gl.UNSIGNED_BYTE,
    rgba8sint: gl.BYTE,
    bgra8unorm: gl.UNSIGNED_BYTE,
    "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
    rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
    rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
    rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
    // 64-bit formats
    rg32uint: gl.UNSIGNED_INT,
    rg32sint: gl.INT,
    rg32float: gl.FLOAT,
    rgba16uint: gl.UNSIGNED_SHORT,
    rgba16sint: gl.SHORT,
    rgba16float: gl.HALF_FLOAT,
    // 128-bit formats
    rgba32uint: gl.UNSIGNED_INT,
    rgba32sint: gl.INT,
    rgba32float: gl.FLOAT,
    // Depth/stencil formats
    stencil8: gl.UNSIGNED_BYTE,
    depth16unorm: gl.UNSIGNED_SHORT,
    depth24plus: gl.UNSIGNED_INT,
    "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
    depth32float: gl.FLOAT,
    "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
  };
}
var init_mapFormatToGlType = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs
function unpremultiplyAlpha2(pixels) {
  if (pixels instanceof Uint8ClampedArray) {
    pixels = new Uint8Array(pixels.buffer);
  }
  const n2 = pixels.length;
  for (let i3 = 0; i3 < n2; i3 += 4) {
    const alpha = pixels[i3 + 3];
    if (alpha !== 0) {
      const a2 = 255.001 / alpha;
      pixels[i3] = pixels[i3] * a2 + 0.5;
      pixels[i3 + 1] = pixels[i3 + 1] * a2 + 0.5;
      pixels[i3 + 2] = pixels[i3 + 2] * a2 + 0.5;
    }
  }
}
var init_unpremultiplyAlpha = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
var BYTES_PER_PIXEL, GlTextureSystem;
var init_GlTextureSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_Extensions();
    init_Texture();
    init_GlTexture();
    init_glUploadBufferImageResource();
    init_glUploadCompressedTextureResource();
    init_glUploadImageResource();
    init_glUploadVideoResource();
    init_applyStyleParams();
    init_mapFormatToGlFormat();
    init_mapFormatToGlInternalFormat();
    init_mapFormatToGlType();
    BYTES_PER_PIXEL = 4;
    GlTextureSystem = class {
      constructor(renderer) {
        this.managedTextures = [];
        this._glTextures = /* @__PURE__ */ Object.create(null);
        this._glSamplers = /* @__PURE__ */ Object.create(null);
        this._boundTextures = [];
        this._activeTextureLocation = -1;
        this._boundSamplers = /* @__PURE__ */ Object.create(null);
        this._uploads = {
          image: glUploadImageResource,
          buffer: glUploadBufferImageResource,
          video: glUploadVideoResource,
          compressed: glUploadCompressedTextureResource
        };
        this._premultiplyAlpha = false;
        this._useSeparateSamplers = false;
        this._renderer = renderer;
        this._renderer.renderableGC.addManagedHash(this, "_glTextures");
        this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
      }
      contextChange(gl) {
        this._gl = gl;
        if (!this._mapFormatToInternalFormat) {
          this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);
          this._mapFormatToType = mapFormatToGlType(gl);
          this._mapFormatToFormat = mapFormatToGlFormat(gl);
        }
        this._glTextures = /* @__PURE__ */ Object.create(null);
        this._glSamplers = /* @__PURE__ */ Object.create(null);
        this._boundSamplers = /* @__PURE__ */ Object.create(null);
        this._premultiplyAlpha = false;
        for (let i3 = 0; i3 < 16; i3++) {
          this.bind(Texture.EMPTY, i3);
        }
      }
      initSource(source9) {
        this.bind(source9);
      }
      bind(texture, location2 = 0) {
        const source9 = texture.source;
        if (texture) {
          this.bindSource(source9, location2);
          if (this._useSeparateSamplers) {
            this._bindSampler(source9.style, location2);
          }
        } else {
          this.bindSource(null, location2);
          if (this._useSeparateSamplers) {
            this._bindSampler(null, location2);
          }
        }
      }
      bindSource(source9, location2 = 0) {
        const gl = this._gl;
        source9._touched = this._renderer.textureGC.count;
        if (this._boundTextures[location2] !== source9) {
          this._boundTextures[location2] = source9;
          this._activateLocation(location2);
          source9 || (source9 = Texture.EMPTY.source);
          const glTexture = this.getGlSource(source9);
          gl.bindTexture(glTexture.target, glTexture.texture);
        }
      }
      _bindSampler(style, location2 = 0) {
        const gl = this._gl;
        if (!style) {
          this._boundSamplers[location2] = null;
          gl.bindSampler(location2, null);
          return;
        }
        const sampler = this._getGlSampler(style);
        if (this._boundSamplers[location2] !== sampler) {
          this._boundSamplers[location2] = sampler;
          gl.bindSampler(location2, sampler);
        }
      }
      unbind(texture) {
        const source9 = texture.source;
        const boundTextures = this._boundTextures;
        const gl = this._gl;
        for (let i3 = 0; i3 < boundTextures.length; i3++) {
          if (boundTextures[i3] === source9) {
            this._activateLocation(i3);
            const glTexture = this.getGlSource(source9);
            gl.bindTexture(glTexture.target, null);
            boundTextures[i3] = null;
          }
        }
      }
      _activateLocation(location2) {
        if (this._activeTextureLocation !== location2) {
          this._activeTextureLocation = location2;
          this._gl.activeTexture(this._gl.TEXTURE0 + location2);
        }
      }
      _initSource(source9) {
        const gl = this._gl;
        const glTexture = new GlTexture(gl.createTexture());
        glTexture.type = this._mapFormatToType[source9.format];
        glTexture.internalFormat = this._mapFormatToInternalFormat[source9.format];
        glTexture.format = this._mapFormatToFormat[source9.format];
        if (source9.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source9.isPowerOfTwo)) {
          const biggestDimension = Math.max(source9.width, source9.height);
          source9.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
        }
        this._glTextures[source9.uid] = glTexture;
        if (!this.managedTextures.includes(source9)) {
          source9.on("update", this.onSourceUpdate, this);
          source9.on("resize", this.onSourceUpdate, this);
          source9.on("styleChange", this.onStyleChange, this);
          source9.on("destroy", this.onSourceDestroy, this);
          source9.on("unload", this.onSourceUnload, this);
          source9.on("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.push(source9);
        }
        this.onSourceUpdate(source9);
        this.updateStyle(source9, false);
        return glTexture;
      }
      onStyleChange(source9) {
        this.updateStyle(source9, false);
      }
      updateStyle(source9, firstCreation) {
        const gl = this._gl;
        const glTexture = this.getGlSource(source9);
        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
        this._boundTextures[this._activeTextureLocation] = source9;
        applyStyleParams(
          source9.style,
          gl,
          source9.mipLevelCount > 1,
          this._renderer.context.extensions.anisotropicFiltering,
          "texParameteri",
          gl.TEXTURE_2D,
          // will force a clamp to edge if the texture is not a power of two
          !this._renderer.context.supports.nonPowOf2wrapping && !source9.isPowerOfTwo,
          firstCreation
        );
      }
      onSourceUnload(source9) {
        const glTexture = this._glTextures[source9.uid];
        if (!glTexture)
          return;
        this.unbind(source9);
        this._glTextures[source9.uid] = null;
        this._gl.deleteTexture(glTexture.texture);
      }
      onSourceUpdate(source9) {
        const gl = this._gl;
        const glTexture = this.getGlSource(source9);
        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
        this._boundTextures[this._activeTextureLocation] = source9;
        const premultipliedAlpha = source9.alphaMode === "premultiply-alpha-on-upload";
        if (this._premultiplyAlpha !== premultipliedAlpha) {
          this._premultiplyAlpha = premultipliedAlpha;
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
        }
        if (this._uploads[source9.uploadMethodId]) {
          this._uploads[source9.uploadMethodId].upload(source9, glTexture, gl, this._renderer.context.webGLVersion);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source9.pixelWidth, source9.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        if (source9.autoGenerateMipmaps && source9.mipLevelCount > 1) {
          this.onUpdateMipmaps(source9, false);
        }
      }
      onUpdateMipmaps(source9, bind = true) {
        if (bind)
          this.bindSource(source9, 0);
        const glTexture = this.getGlSource(source9);
        this._gl.generateMipmap(glTexture.target);
      }
      onSourceDestroy(source9) {
        source9.off("destroy", this.onSourceDestroy, this);
        source9.off("update", this.onSourceUpdate, this);
        source9.off("resize", this.onSourceUpdate, this);
        source9.off("unload", this.onSourceUnload, this);
        source9.off("styleChange", this.onStyleChange, this);
        source9.off("updateMipmaps", this.onUpdateMipmaps, this);
        this.managedTextures.splice(this.managedTextures.indexOf(source9), 1);
        this.onSourceUnload(source9);
      }
      _initSampler(style) {
        const gl = this._gl;
        const glSampler = this._gl.createSampler();
        this._glSamplers[style._resourceId] = glSampler;
        applyStyleParams(
          style,
          gl,
          this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
          this._renderer.context.extensions.anisotropicFiltering,
          "samplerParameteri",
          glSampler,
          false,
          true
        );
        return this._glSamplers[style._resourceId];
      }
      _getGlSampler(sampler) {
        return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
      }
      getGlSource(source9) {
        return this._glTextures[source9.uid] || this._initSource(source9);
      }
      generateCanvas(texture) {
        const { pixels, width, height } = this.getPixels(texture);
        const canvas = DOMAdapter.get().createCanvas();
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        if (ctx) {
          const imageData = ctx.createImageData(width, height);
          imageData.data.set(pixels);
          ctx.putImageData(imageData, 0, 0);
        }
        return canvas;
      }
      getPixels(texture) {
        const resolution = texture.source.resolution;
        const frame = texture.frame;
        const width = Math.max(Math.round(frame.width * resolution), 1);
        const height = Math.max(Math.round(frame.height * resolution), 1);
        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
        const renderer = this._renderer;
        const renderTarget = renderer.renderTarget.getRenderTarget(texture);
        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
        const gl = renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
        gl.readPixels(
          Math.round(frame.x * resolution),
          Math.round(frame.y * resolution),
          width,
          height,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          pixels
        );
        if (false) {
          unpremultiplyAlpha(pixels);
        }
        return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
      }
      destroy() {
        this.managedTextures.slice().forEach((source9) => this.onSourceDestroy(source9));
        this.managedTextures = null;
        this._renderer = null;
      }
      resetState() {
        this._activeTextureLocation = -1;
        this._boundTextures.fill(Texture.EMPTY.source);
        this._boundSamplers = /* @__PURE__ */ Object.create(null);
        const gl = this._gl;
        this._premultiplyAlpha = false;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
      }
    };
    GlTextureSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "texture"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs
var WebGLRenderer_exports = {};
__export(WebGLRenderer_exports, {
  WebGLRenderer: () => WebGLRenderer
});
var DefaultWebGLSystems, DefaultWebGLPipes, DefaultWebGLAdapters, systems2, renderPipes2, renderPipeAdaptors2, WebGLRenderer;
var init_WebGLRenderer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_GlGraphicsAdaptor();
    init_GlMeshAdaptor();
    init_GlBatchAdaptor();
    init_AbstractRenderer();
    init_SharedSystems();
    init_types2();
    init_GlBufferSystem();
    init_GlContextSystem();
    init_GlGeometrySystem();
    init_GlBackBufferSystem();
    init_GlColorMaskSystem();
    init_GlEncoderSystem();
    init_GlStencilSystem();
    init_GlUboSystem();
    init_GlRenderTargetSystem();
    init_GlShaderSystem();
    init_GlUniformGroupSystem();
    init_GlStateSystem();
    init_GlTextureSystem();
    DefaultWebGLSystems = [
      ...SharedSystems,
      GlUboSystem,
      GlBackBufferSystem,
      GlContextSystem,
      GlBufferSystem,
      GlTextureSystem,
      GlRenderTargetSystem,
      GlGeometrySystem,
      GlUniformGroupSystem,
      GlShaderSystem,
      GlEncoderSystem,
      GlStateSystem,
      GlStencilSystem,
      GlColorMaskSystem
    ];
    DefaultWebGLPipes = [...SharedRenderPipes];
    DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
    systems2 = [];
    renderPipes2 = [];
    renderPipeAdaptors2 = [];
    extensions.handleByNamedList(ExtensionType.WebGLSystem, systems2);
    extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes2);
    extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors2);
    extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
    WebGLRenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          name: "webgl",
          type: RendererType.WEBGL,
          systems: systems2,
          renderPipes: renderPipes2,
          renderPipeAdaptors: renderPipeAdaptors2
        };
        super(systemConfig);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs
async function autoDetectRenderer(options) {
  let preferredOrder = [];
  if (options.preference) {
    preferredOrder.push(options.preference);
    renderPriority.forEach((item) => {
      if (item !== options.preference) {
        preferredOrder.push(item);
      }
    });
  } else {
    preferredOrder = renderPriority.slice();
  }
  let RendererClass;
  let finalOptions = {};
  for (let i3 = 0; i3 < preferredOrder.length; i3++) {
    const rendererType = preferredOrder[i3];
    if (rendererType === "webgpu" && await isWebGPUSupported()) {
      const { WebGPURenderer: WebGPURenderer2 } = await Promise.resolve().then(() => (init_WebGPURenderer(), WebGPURenderer_exports));
      RendererClass = WebGPURenderer2;
      finalOptions = { ...options, ...options.webgpu };
      break;
    } else if (rendererType === "webgl" && isWebGLSupported(
      options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    )) {
      const { WebGLRenderer: WebGLRenderer3 } = await Promise.resolve().then(() => (init_WebGLRenderer(), WebGLRenderer_exports));
      RendererClass = WebGLRenderer3;
      finalOptions = { ...options, ...options.webgl };
      break;
    } else if (rendererType === "canvas") {
      finalOptions = { ...options };
      throw new Error("CanvasRenderer is not yet implemented");
    }
  }
  delete finalOptions.webgpu;
  delete finalOptions.webgl;
  if (!RendererClass) {
    throw new Error("No available renderer for the current environment");
  }
  const renderer = new RendererClass();
  await renderer.init(finalOptions);
  return renderer;
}
var renderPriority;
var init_autoDetectRenderer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs"() {
    init_define_AnParams();
    init_isWebGLSupported();
    init_isWebGPUSupported();
    init_AbstractRenderer();
    renderPriority = ["webgl", "webgpu", "canvas"];
  }
});

// node_modules/pixi.js/lib/app/Application.mjs
var _Application, Application;
var init_Application = __esm({
  "node_modules/pixi.js/lib/app/Application.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_autoDetectRenderer();
    init_Container();
    init_globalHooks();
    init_deprecation();
    _Application = class _Application2 {
      /** @ignore */
      constructor(...args) {
        this.stage = new Container();
        if (args[0] !== void 0) {
          deprecation(v8_0_0, "Application constructor options are deprecated, please use Application.init() instead.");
        }
      }
      /**
       * @param options - The optional application and renderer parameters.
       */
      async init(options) {
        options = { ...options };
        this.renderer = await autoDetectRenderer(options);
        _Application2._plugins.forEach((plugin) => {
          plugin.init.call(this, options);
        });
      }
      /** Render the current stage. */
      render() {
        this.renderer.render({ container: this.stage });
      }
      /**
       * Reference to the renderer's canvas element.
       * @readonly
       * @member {HTMLCanvasElement}
       */
      get canvas() {
        return this.renderer.canvas;
      }
      /**
       * Reference to the renderer's canvas element.
       * @member {HTMLCanvasElement}
       * @deprecated since 8.0.0
       */
      get view() {
        deprecation(v8_0_0, "Application.view is deprecated, please use Application.canvas instead.");
        return this.renderer.canvas;
      }
      /**
       * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
       * @readonly
       */
      get screen() {
        return this.renderer.screen;
      }
      /**
       * Destroys the application and all of its resources.
       * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.
       * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.
       * @param {object|boolean} [options=false] - The options for destroying the stage.
       * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method
       * called as well. `options` will be passed on to those calls.
       * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.
       * If options.children is set to true,
       * it should destroy the texture of the child sprite.
       * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
       *  If options.children is set to true,
       * it should destroy the texture source of the child sprite.
       * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
       * If options.children is set to true,
       * it should destroy the context of the child graphics.
       */
      destroy(rendererDestroyOptions = false, options = false) {
        const plugins = _Application2._plugins.slice(0);
        plugins.reverse();
        plugins.forEach((plugin) => {
          plugin.destroy.call(this);
        });
        this.stage.destroy(options);
        this.stage = null;
        this.renderer.destroy(rendererDestroyOptions);
        this.renderer = null;
      }
    };
    _Application._plugins = [];
    Application = _Application;
    extensions.handleByList(ExtensionType.Application, Application._plugins);
    extensions.add(ApplicationInitHook);
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs
var BitmapFont;
var init_BitmapFont = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs"() {
    init_define_AnParams();
    init_Rectangle();
    init_Texture();
    init_AbstractBitmapFont();
    init_BitmapFontManager();
    BitmapFont = class extends AbstractBitmapFont {
      constructor(options, url) {
        super();
        const { textures, data } = options;
        Object.keys(data.pages).forEach((key) => {
          const pageData = data.pages[parseInt(key, 10)];
          const texture = textures[pageData.id];
          this.pages.push({ texture });
        });
        Object.keys(data.chars).forEach((key) => {
          const charData = data.chars[key];
          const {
            frame: textureFrame,
            source: textureSource
          } = textures[charData.page];
          const frameReal = new Rectangle(
            charData.x + textureFrame.x,
            charData.y + textureFrame.y,
            charData.width,
            charData.height
          );
          const texture = new Texture({
            source: textureSource,
            frame: frameReal
          });
          this.chars[key] = {
            id: key.codePointAt(0),
            xOffset: charData.xOffset,
            yOffset: charData.yOffset,
            xAdvance: charData.xAdvance,
            kerning: charData.kerning ?? {},
            texture
          };
        });
        this.baseRenderedFontSize = data.fontSize;
        this.baseMeasurementFontSize = data.fontSize;
        this.fontMetrics = {
          ascent: 0,
          descent: 0,
          fontSize: data.fontSize
        };
        this.baseLineOffset = data.baseLineOffset;
        this.lineHeight = data.lineHeight;
        this.fontFamily = data.fontFamily;
        this.distanceField = data.distanceField ?? {
          type: "none",
          range: 0
        };
        this.url = url;
      }
      /** Destroys the BitmapFont object. */
      destroy() {
        super.destroy();
        for (let i3 = 0; i3 < this.pages.length; i3++) {
          const { texture } = this.pages[i3];
          texture.destroy(true);
        }
        this.pages = null;
      }
      /**
       * Generates a bitmap-font for the given style and character set
       * @param options - Setup options for font generation.
       * @returns Font generated by style options.
       * @example
       * import { BitmapFont, BitmapText } from 'pixi.js';
       *
       * BitmapFont.install('TitleFont', {
       *     fontFamily: 'Arial',
       *     fontSize: 12,
       *     strokeThickness: 2,
       *     fill: 'purple',
       * });
       *
       * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });
       */
      static install(options) {
        BitmapFontManager.install(options);
      }
      /**
       * Uninstalls a bitmap font from the cache.
       * @param {string} name - The name of the bitmap font to uninstall.
       */
      static uninstall(name) {
        BitmapFontManager.uninstall(name);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs
var bitmapFontTextParser;
var init_bitmapFontTextParser = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs"() {
    "use strict";
    init_define_AnParams();
    bitmapFontTextParser = {
      test(data) {
        return typeof data === "string" && data.startsWith("info face=");
      },
      parse(txt) {
        const items = txt.match(/^[a-z]+\s+.+$/gm);
        const rawData = {
          info: [],
          common: [],
          page: [],
          char: [],
          chars: [],
          kerning: [],
          kernings: [],
          distanceField: []
        };
        for (const i3 in items) {
          const name = items[i3].match(/^[a-z]+/gm)[0];
          const attributeList = items[i3].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
          const itemData = {};
          for (const i22 in attributeList) {
            const split = attributeList[i22].split("=");
            const key = split[0];
            const strValue = split[1].replace(/"/gm, "");
            const floatValue = parseFloat(strValue);
            const value = isNaN(floatValue) ? strValue : floatValue;
            itemData[key] = value;
          }
          rawData[name].push(itemData);
        }
        const font = {
          chars: {},
          pages: [],
          lineHeight: 0,
          fontSize: 0,
          fontFamily: "",
          distanceField: null,
          baseLineOffset: 0
        };
        const [info] = rawData.info;
        const [common] = rawData.common;
        const [distanceField] = rawData.distanceField ?? [];
        if (distanceField) {
          font.distanceField = {
            range: parseInt(distanceField.distanceRange, 10),
            type: distanceField.fieldType
          };
        }
        font.fontSize = parseInt(info.size, 10);
        font.fontFamily = info.face;
        font.lineHeight = parseInt(common.lineHeight, 10);
        const page = rawData.page;
        for (let i3 = 0; i3 < page.length; i3++) {
          font.pages.push({
            id: parseInt(page[i3].id, 10) || 0,
            file: page[i3].file
          });
        }
        const map = {};
        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);
        const char = rawData.char;
        for (let i3 = 0; i3 < char.length; i3++) {
          const charNode = char[i3];
          const id = parseInt(charNode.id, 10);
          let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);
          if (letter === "space")
            letter = " ";
          map[id] = letter;
          font.chars[letter] = {
            id,
            // texture deets..
            page: parseInt(charNode.page, 10) || 0,
            x: parseInt(charNode.x, 10),
            y: parseInt(charNode.y, 10),
            width: parseInt(charNode.width, 10),
            height: parseInt(charNode.height, 10),
            xOffset: parseInt(charNode.xoffset, 10),
            yOffset: parseInt(charNode.yoffset, 10),
            xAdvance: parseInt(charNode.xadvance, 10),
            kerning: {}
          };
        }
        const kerning = rawData.kerning || [];
        for (let i3 = 0; i3 < kerning.length; i3++) {
          const first = parseInt(kerning[i3].first, 10);
          const second = parseInt(kerning[i3].second, 10);
          const amount = parseInt(kerning[i3].amount, 10);
          font.chars[map[second]].kerning[map[first]] = amount;
        }
        return font;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs
var bitmapFontXMLParser;
var init_bitmapFontXMLParser = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs"() {
    "use strict";
    init_define_AnParams();
    bitmapFontXMLParser = {
      test(data) {
        const xml = data;
        return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
      },
      parse(xml) {
        const data = {
          chars: {},
          pages: [],
          lineHeight: 0,
          fontSize: 0,
          fontFamily: "",
          distanceField: null,
          baseLineOffset: 0
        };
        const info = xml.getElementsByTagName("info")[0];
        const common = xml.getElementsByTagName("common")[0];
        const distanceField = xml.getElementsByTagName("distanceField")[0];
        if (distanceField) {
          data.distanceField = {
            type: distanceField.getAttribute("fieldType"),
            range: parseInt(distanceField.getAttribute("distanceRange"), 10)
          };
        }
        const page = xml.getElementsByTagName("page");
        const char = xml.getElementsByTagName("char");
        const kerning = xml.getElementsByTagName("kerning");
        data.fontSize = parseInt(info.getAttribute("size"), 10);
        data.fontFamily = info.getAttribute("face");
        data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
        for (let i3 = 0; i3 < page.length; i3++) {
          data.pages.push({
            id: parseInt(page[i3].getAttribute("id"), 10) || 0,
            file: page[i3].getAttribute("file")
          });
        }
        const map = {};
        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute("base"), 10);
        for (let i3 = 0; i3 < char.length; i3++) {
          const charNode = char[i3];
          const id = parseInt(charNode.getAttribute("id"), 10);
          let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id);
          if (letter === "space")
            letter = " ";
          map[id] = letter;
          data.chars[letter] = {
            id,
            // texture deets..
            page: parseInt(charNode.getAttribute("page"), 10) || 0,
            x: parseInt(charNode.getAttribute("x"), 10),
            y: parseInt(charNode.getAttribute("y"), 10),
            width: parseInt(charNode.getAttribute("width"), 10),
            height: parseInt(charNode.getAttribute("height"), 10),
            // render deets..
            xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
            yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
            // + baseLineOffset,
            xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
            kerning: {}
          };
        }
        for (let i3 = 0; i3 < kerning.length; i3++) {
          const first = parseInt(kerning[i3].getAttribute("first"), 10);
          const second = parseInt(kerning[i3].getAttribute("second"), 10);
          const amount = parseInt(kerning[i3].getAttribute("amount"), 10);
          data.chars[map[second]].kerning[map[first]] = amount;
        }
        return data;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs
var bitmapFontXMLStringParser;
var init_bitmapFontXMLStringParser = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_bitmapFontXMLParser();
    bitmapFontXMLStringParser = {
      test(data) {
        if (typeof data === "string" && data.includes("<font>")) {
          return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));
        }
        return false;
      },
      parse(data) {
        return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs
var validExtensions, bitmapFontCachePlugin, loadBitmapFont;
var init_loadBitmapFont = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs"() {
    init_define_AnParams();
    init_LoaderParser();
    init_copySearchParams();
    init_adapter();
    init_Extensions();
    init_path();
    init_BitmapFont();
    init_bitmapFontTextParser();
    init_bitmapFontXMLStringParser();
    validExtensions = [".xml", ".fnt"];
    bitmapFontCachePlugin = {
      extension: {
        type: ExtensionType.CacheParser,
        name: "cacheBitmapFont"
      },
      test: (asset) => asset instanceof BitmapFont,
      getCacheableAssets(keys, asset) {
        const out2 = {};
        keys.forEach((key) => {
          out2[key] = asset;
          out2[`${key}-bitmap`] = asset;
        });
        out2[`${asset.fontFamily}-bitmap`] = asset;
        return out2;
      }
    };
    loadBitmapFont = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Normal
      },
      name: "loadBitmapFont",
      test(url) {
        return validExtensions.includes(path.extname(url).toLowerCase());
      },
      async testParse(data) {
        return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);
      },
      async parse(asset, data, loader) {
        const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);
        const { src } = data;
        const { pages } = bitmapFontData;
        const textureUrls = [];
        const textureOptions = bitmapFontData.distanceField ? {
          scaleMode: "linear",
          alphaMode: "premultiply-alpha-on-upload",
          autoGenerateMipmaps: false,
          resolution: 1
        } : {};
        for (let i3 = 0; i3 < pages.length; ++i3) {
          const pageFile = pages[i3].file;
          let imagePath = path.join(path.dirname(src), pageFile);
          imagePath = copySearchParams(imagePath, src);
          textureUrls.push({
            src: imagePath,
            data: textureOptions
          });
        }
        const loadedTextures = await loader.load(textureUrls);
        const textures = textureUrls.map((url) => loadedTextures[url.src]);
        const bitmapFont = new BitmapFont({
          data: bitmapFontData,
          textures
        }, src);
        return bitmapFont;
      },
      async load(url, _options) {
        const response = await DOMAdapter.get().fetch(url);
        return await response.text();
      },
      async unload(bitmapFont, _resolvedAsset, loader) {
        await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));
        bitmapFont.destroy();
      }
    };
  }
});

// node_modules/pixi.js/lib/assets/BackgroundLoader.mjs
var BackgroundLoader;
var init_BackgroundLoader = __esm({
  "node_modules/pixi.js/lib/assets/BackgroundLoader.mjs"() {
    "use strict";
    init_define_AnParams();
    BackgroundLoader = class {
      /**
       * @param loader
       * @param verbose - should the loader log to the console
       */
      constructor(loader, verbose = false) {
        this._loader = loader;
        this._assetList = [];
        this._isLoading = false;
        this._maxConcurrent = 1;
        this.verbose = verbose;
      }
      /**
       * Adds an array of assets to load.
       * @param assetUrls - assets to load
       */
      add(assetUrls) {
        assetUrls.forEach((a2) => {
          this._assetList.push(a2);
        });
        if (this.verbose) {
          console.log("[BackgroundLoader] assets: ", this._assetList);
        }
        if (this._isActive && !this._isLoading) {
          void this._next();
        }
      }
      /**
       * Loads the next set of assets. Will try to load as many assets as it can at the same time.
       *
       * The max assets it will try to load at one time will be 4.
       */
      async _next() {
        if (this._assetList.length && this._isActive) {
          this._isLoading = true;
          const toLoad = [];
          const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
          for (let i3 = 0; i3 < toLoadAmount; i3++) {
            toLoad.push(this._assetList.pop());
          }
          await this._loader.load(toLoad);
          this._isLoading = false;
          void this._next();
        }
      }
      /**
       * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.
       * @returns whether the class is active
       */
      get active() {
        return this._isActive;
      }
      set active(value) {
        if (this._isActive === value)
          return;
        this._isActive = value;
        if (value && !this._isLoading) {
          void this._next();
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs
var cacheTextureArray;
var init_cacheTextureArray = __esm({
  "node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Texture();
    cacheTextureArray = {
      extension: {
        type: ExtensionType.CacheParser,
        name: "cacheTextureArray"
      },
      test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture),
      getCacheableAssets: (keys, asset) => {
        const out2 = {};
        keys.forEach((key) => {
          asset.forEach((item, i3) => {
            out2[key + (i3 === 0 ? "" : i3 + 1)] = item;
          });
        });
        return out2;
      }
    };
  }
});

// node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs
async function testImageFormat(imageData) {
  if ("Image" in globalThis) {
    return new Promise((resolve) => {
      const image = new Image();
      image.onload = () => {
        resolve(true);
      };
      image.onerror = () => {
        resolve(false);
      };
      image.src = imageData;
    });
  }
  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
    try {
      const blob = await (await fetch(imageData)).blob();
      await createImageBitmap(blob);
    } catch (_e) {
      return false;
    }
    return true;
  }
  return false;
}
var init_testImageFormat = __esm({
  "node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs
var detectAvif;
var init_detectAvif = __esm({
  "node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_testImageFormat();
    detectAvif = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 1
      },
      test: async () => testImageFormat(
        // eslint-disable-next-line max-len
        "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
      ),
      add: async (formats) => [...formats, "avif"],
      remove: async (formats) => formats.filter((f2) => f2 !== "avif")
    };
  }
});

// node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs
var imageFormats, detectDefaults;
var init_detectDefaults = __esm({
  "node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs"() {
    init_define_AnParams();
    init_Extensions();
    imageFormats = ["png", "jpg", "jpeg"];
    detectDefaults = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: -1
      },
      test: () => Promise.resolve(true),
      add: async (formats) => [...formats, ...imageFormats],
      remove: async (formats) => formats.filter((f2) => !imageFormats.includes(f2))
    };
  }
});

// node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs
function testVideoFormat(mimeType) {
  if (inWorker) {
    return false;
  }
  const video = document.createElement("video");
  return video.canPlayType(mimeType) !== "";
}
var inWorker;
var init_testVideoFormat = __esm({
  "node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs"() {
    "use strict";
    init_define_AnParams();
    inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
  }
});

// node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs
var detectMp4;
var init_detectMp4 = __esm({
  "node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_testVideoFormat();
    detectMp4 = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat("video/mp4"),
      add: async (formats) => [...formats, "mp4", "m4v"],
      remove: async (formats) => formats.filter((f2) => f2 !== "mp4" && f2 !== "m4v")
    };
  }
});

// node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs
var detectOgv;
var init_detectOgv = __esm({
  "node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_testVideoFormat();
    detectOgv = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat("video/ogg"),
      add: async (formats) => [...formats, "ogv"],
      remove: async (formats) => formats.filter((f2) => f2 !== "ogv")
    };
  }
});

// node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs
var detectWebm;
var init_detectWebm = __esm({
  "node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_testVideoFormat();
    detectWebm = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testVideoFormat("video/webm"),
      add: async (formats) => [...formats, "webm"],
      remove: async (formats) => formats.filter((f2) => f2 !== "webm")
    };
  }
});

// node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs
var detectWebp;
var init_detectWebp = __esm({
  "node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_testImageFormat();
    detectWebp = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 0
      },
      test: async () => testImageFormat(
        "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
      ),
      add: async (formats) => [...formats, "webp"],
      remove: async (formats) => formats.filter((f2) => f2 !== "webp")
    };
  }
});

// node_modules/pixi.js/lib/assets/loader/Loader.mjs
var Loader;
var init_Loader = __esm({
  "node_modules/pixi.js/lib/assets/loader/Loader.mjs"() {
    init_define_AnParams();
    init_warn();
    init_path();
    init_convertToList();
    init_isSingleItem();
    Loader = class {
      constructor() {
        this._parsers = [];
        this._parsersValidated = false;
        this.parsers = new Proxy(this._parsers, {
          set: (target, key, value) => {
            this._parsersValidated = false;
            target[key] = value;
            return true;
          }
        });
        this.promiseCache = {};
      }
      /** function used for testing */
      reset() {
        this._parsersValidated = false;
        this.promiseCache = {};
      }
      /**
       * Used internally to generate a promise for the asset to be loaded.
       * @param url - The URL to be loaded
       * @param data - any custom additional information relevant to the asset being loaded
       * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
       */
      _getLoadPromiseAndParser(url, data) {
        const result = {
          promise: null,
          parser: null
        };
        result.promise = (async () => {
          let asset = null;
          let parser = null;
          if (data.loadParser) {
            parser = this._parserHash[data.loadParser];
            if (!parser) {
              warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`);
            }
          }
          if (!parser) {
            for (let i3 = 0; i3 < this.parsers.length; i3++) {
              const parserX = this.parsers[i3];
              if (parserX.load && parserX.test?.(url, data, this)) {
                parser = parserX;
                break;
              }
            }
            if (!parser) {
              warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
              return null;
            }
          }
          asset = await parser.load(url, data, this);
          result.parser = parser;
          for (let i3 = 0; i3 < this.parsers.length; i3++) {
            const parser2 = this.parsers[i3];
            if (parser2.parse) {
              if (parser2.parse && await parser2.testParse?.(asset, data, this)) {
                asset = await parser2.parse(asset, data, this) || asset;
                result.parser = parser2;
              }
            }
          }
          return asset;
        })();
        return result;
      }
      async load(assetsToLoadIn, onProgress) {
        if (!this._parsersValidated) {
          this._validateParsers();
        }
        let count2 = 0;
        const assets = {};
        const singleAsset = isSingleItem(assetsToLoadIn);
        const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
          alias: [item],
          src: item,
          data: {}
        }));
        const total = assetsToLoad.length;
        const promises = assetsToLoad.map(async (asset) => {
          const url = path.toAbsolute(asset.src);
          if (!assets[asset.src]) {
            try {
              if (!this.promiseCache[url]) {
                this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
              }
              assets[asset.src] = await this.promiseCache[url].promise;
              if (onProgress)
                onProgress(++count2 / total);
            } catch (e2) {
              delete this.promiseCache[url];
              delete assets[asset.src];
              throw new Error(`[Loader.load] Failed to load ${url}.
${e2}`);
            }
          }
        });
        await Promise.all(promises);
        return singleAsset ? assets[assetsToLoad[0].src] : assets;
      }
      /**
       * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
       * The parser that created the asset, will be the one that unloads it.
       * @example
       * // Single asset:
       * const asset = await Loader.load('cool.png');
       *
       * await Loader.unload('cool.png');
       *
       * console.log(asset.destroyed); // true
       * @param assetsToUnloadIn - urls that you want to unload, or a single one!
       */
      async unload(assetsToUnloadIn) {
        const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
          alias: [item],
          src: item
        }));
        const promises = assetsToUnload.map(async (asset) => {
          const url = path.toAbsolute(asset.src);
          const loadPromise = this.promiseCache[url];
          if (loadPromise) {
            const loadedAsset = await loadPromise.promise;
            delete this.promiseCache[url];
            await loadPromise.parser?.unload?.(loadedAsset, asset, this);
          }
        });
        await Promise.all(promises);
      }
      /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
      _validateParsers() {
        this._parsersValidated = true;
        this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {
          if (!parser.name) {
            warn(`[Assets] loadParser should have a name`);
          } else if (hash[parser.name]) {
            warn(`[Assets] loadParser name conflict "${parser.name}"`);
          }
          return { ...hash, [parser.name]: parser };
        }, {});
      }
    };
  }
});

// node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs
function checkDataUrl(url, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url.startsWith(`data:${mimes}`);
}
var init_checkDataUrl = __esm({
  "node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/assets/utils/checkExtension.mjs
function checkExtension(url, extension) {
  const tempURL = url.split("?")[0];
  const ext = path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext);
  }
  return ext === extension;
}
var init_checkExtension = __esm({
  "node_modules/pixi.js/lib/assets/utils/checkExtension.mjs"() {
    init_define_AnParams();
    init_path();
  }
});

// node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs
var validJSONExtension, validJSONMIME, loadJson;
var init_loadJson = __esm({
  "node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_Extensions();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validJSONExtension = ".json";
    validJSONMIME = "application/json";
    loadJson = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      name: "loadJson",
      test(url) {
        return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);
      },
      async load(url) {
        const response = await DOMAdapter.get().fetch(url);
        const json = await response.json();
        return json;
      }
    };
  }
});

// node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs
var validTXTExtension, validTXTMIME, loadTxt;
var init_loadTxt = __esm({
  "node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_Extensions();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validTXTExtension = ".txt";
    validTXTMIME = "text/plain";
    loadTxt = {
      name: "loadTxt",
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low,
        name: "loadTxt"
      },
      test(url) {
        return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);
      },
      async load(url) {
        const response = await DOMAdapter.get().fetch(url);
        const txt = await response.text();
        return txt;
      }
    };
  }
});

// node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs
function getFontFamilyName(url) {
  const ext = path.extname(url);
  const name = path.basename(url, ext);
  const nameWithSpaces = name.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
function encodeURIWhenNeeded(uri) {
  if (validURICharactersRegex.test(uri)) {
    return uri;
  }
  return encodeURI(uri);
}
var validWeights, validFontExtensions, validFontMIMEs, CSS_IDENT_TOKEN_REGEX, validURICharactersRegex, loadWebFont;
var init_loadWebFont = __esm({
  "node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_Extensions();
    init_warn();
    init_path();
    init_Cache();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    validWeights = [
      "normal",
      "bold",
      "100",
      "200",
      "300",
      "400",
      "500",
      "600",
      "700",
      "800",
      "900"
    ];
    validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
    validFontMIMEs = [
      "font/ttf",
      "font/otf",
      "font/woff",
      "font/woff2"
    ];
    CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
    validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
    loadWebFont = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low
      },
      name: "loadWebFont",
      test(url) {
        return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);
      },
      async load(url, options) {
        const fonts = DOMAdapter.get().getFontFaceSet();
        if (fonts) {
          const fontFaces = [];
          const name = options.data?.family ?? getFontFamilyName(url);
          const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ["normal"];
          const data = options.data ?? {};
          for (let i3 = 0; i3 < weights.length; i3++) {
            const weight = weights[i3];
            const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {
              ...data,
              weight
            });
            await font.load();
            fonts.add(font);
            fontFaces.push(font);
          }
          Cache.set(`${name}-and-url`, {
            url,
            fontFaces
          });
          return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
        }
        warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
        return null;
      },
      unload(font) {
        (Array.isArray(font) ? font : [font]).forEach((t2) => {
          Cache.remove(`${t2.family}-and-url`);
          DOMAdapter.get().getFontFaceSet().delete(t2);
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs
function getResolutionOfUrl(url, defaultValue2 = 1) {
  const resolution = Resolver.RETINA_PREFIX?.exec(url);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue2;
}
var init_getResolutionOfUrl = __esm({
  "node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs"() {
    init_define_AnParams();
    init_Resolver();
  }
});

// node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs
function createTexture(source9, loader, url) {
  source9.label = url;
  source9._sourceOrigin = url;
  const texture = new Texture({
    source: source9,
    label: url
  });
  const unload = () => {
    delete loader.promiseCache[url];
    if (Cache.has(url)) {
      Cache.remove(url);
    }
  };
  texture.source.once("destroy", () => {
    if (loader.promiseCache[url]) {
      warn("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.");
      unload();
    }
  });
  texture.once("destroy", () => {
    if (!source9.destroyed) {
      warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");
      unload();
    }
  });
  return texture;
}
var init_createTexture = __esm({
  "node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs"() {
    init_define_AnParams();
    init_Texture();
    init_warn();
    init_Cache();
  }
});

// node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs
async function loadAsTexture(url, asset, loader, crossOrigin2) {
  const response = await DOMAdapter.get().fetch(url);
  const blob = await response.blob();
  const blobUrl = URL.createObjectURL(blob);
  const image = new Image();
  image.src = blobUrl;
  image.crossOrigin = crossOrigin2;
  await image.decode();
  URL.revokeObjectURL(blobUrl);
  const canvas = document.createElement("canvas");
  const context2 = canvas.getContext("2d");
  const resolution = asset.data?.resolution || getResolutionOfUrl(url);
  const width = asset.data?.width ?? image.width;
  const height = asset.data?.height ?? image.height;
  canvas.width = width * resolution;
  canvas.height = height * resolution;
  context2.drawImage(image, 0, 0, width * resolution, height * resolution);
  const { parseAsGraphicsContext: _p, ...rest } = asset.data ?? {};
  const base = new ImageSource({
    resource: canvas,
    alphaMode: "premultiply-alpha-on-upload",
    resolution,
    ...rest
  });
  return createTexture(base, loader, url);
}
async function loadAsGraphics(url) {
  const response = await DOMAdapter.get().fetch(url);
  const svgSource = await response.text();
  const context2 = new GraphicsContext();
  context2.svg(svgSource);
  return context2;
}
var validSVGExtension, validSVGMIME, loadSvg;
var init_loadSVG = __esm({
  "node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_Extensions();
    init_ImageSource();
    init_GraphicsContext();
    init_getResolutionOfUrl();
    init_checkDataUrl();
    init_checkExtension();
    init_LoaderParser();
    init_createTexture();
    validSVGExtension = ".svg";
    validSVGMIME = "image/svg+xml";
    loadSvg = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.Low,
        name: "loadSVG"
      },
      name: "loadSVG",
      config: {
        crossOrigin: "anonymous",
        parseAsGraphicsContext: false
      },
      test(url) {
        return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);
      },
      async load(url, asset, loader) {
        if (asset.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {
          return loadAsGraphics(url);
        }
        return loadAsTexture(url, asset, loader, this.config.crossOrigin);
      },
      unload(asset) {
        asset.destroy(true);
      }
    };
  }
});

// node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs
var WORKER_CODE, WORKER_URL, WorkerInstance;
var init_checkImageBitmap_worker = __esm({
  "node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs"() {
    init_define_AnParams();
    WORKER_CODE = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
    WORKER_URL = null;
    WorkerInstance = class {
      constructor() {
        if (!WORKER_URL) {
          WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: "application/javascript" }));
        }
        this.worker = new Worker(WORKER_URL);
      }
    };
    WorkerInstance.revokeObjectURL = function revokeObjectURL() {
      if (WORKER_URL) {
        URL.revokeObjectURL(WORKER_URL);
        WORKER_URL = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs
var WORKER_CODE2, WORKER_URL2, WorkerInstance2;
var init_loadImageBitmap_worker = __esm({
  "node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs"() {
    init_define_AnParams();
    WORKER_CODE2 = '(function () {\n    \'use strict\';\n\n    async function loadImageBitmap(url, alphaMode) {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n      }\n      const imageBlob = await response.blob();\n      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);\n    }\n    self.onmessage = async (event) => {\n      try {\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\n        self.postMessage({\n          data: imageBitmap,\n          uuid: event.data.uuid,\n          id: event.data.id\n        }, [imageBitmap]);\n      } catch (e) {\n        self.postMessage({\n          error: e,\n          uuid: event.data.uuid,\n          id: event.data.id\n        });\n      }\n    };\n\n})();\n';
    WORKER_URL2 = null;
    WorkerInstance2 = class {
      constructor() {
        if (!WORKER_URL2) {
          WORKER_URL2 = URL.createObjectURL(new Blob([WORKER_CODE2], { type: "application/javascript" }));
        }
        this.worker = new Worker(WORKER_URL2);
      }
    };
    WorkerInstance2.revokeObjectURL = function revokeObjectURL2() {
      if (WORKER_URL2) {
        URL.revokeObjectURL(WORKER_URL2);
        WORKER_URL2 = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs
var UUID, MAX_WORKERS, WorkerManagerClass, WorkerManager;
var init_WorkerManager = __esm({
  "node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs"() {
    init_define_AnParams();
    init_checkImageBitmap_worker();
    init_loadImageBitmap_worker();
    UUID = 0;
    WorkerManagerClass = class {
      constructor() {
        this._initialized = false;
        this._createdWorkers = 0;
        this._workerPool = [];
        this._queue = [];
        this._resolveHash = {};
      }
      isImageBitmapSupported() {
        if (this._isImageBitmapSupported !== void 0)
          return this._isImageBitmapSupported;
        this._isImageBitmapSupported = new Promise((resolve) => {
          const { worker } = new WorkerInstance();
          worker.addEventListener("message", (event) => {
            worker.terminate();
            WorkerInstance.revokeObjectURL();
            resolve(event.data);
          });
        });
        return this._isImageBitmapSupported;
      }
      loadImageBitmap(src, asset) {
        return this._run("loadImageBitmap", [src, asset?.data?.alphaMode]);
      }
      async _initWorkers() {
        if (this._initialized)
          return;
        this._initialized = true;
      }
      _getWorker() {
        if (MAX_WORKERS === void 0) {
          MAX_WORKERS = navigator.hardwareConcurrency || 4;
        }
        let worker = this._workerPool.pop();
        if (!worker && this._createdWorkers < MAX_WORKERS) {
          this._createdWorkers++;
          worker = new WorkerInstance2().worker;
          worker.addEventListener("message", (event) => {
            this._complete(event.data);
            this._returnWorker(event.target);
            this._next();
          });
        }
        return worker;
      }
      _returnWorker(worker) {
        this._workerPool.push(worker);
      }
      _complete(data) {
        if (data.error !== void 0) {
          this._resolveHash[data.uuid].reject(data.error);
        } else {
          this._resolveHash[data.uuid].resolve(data.data);
        }
        this._resolveHash[data.uuid] = null;
      }
      async _run(id, args) {
        await this._initWorkers();
        const promise2 = new Promise((resolve, reject) => {
          this._queue.push({ id, arguments: args, resolve, reject });
        });
        this._next();
        return promise2;
      }
      _next() {
        if (!this._queue.length)
          return;
        const worker = this._getWorker();
        if (!worker) {
          return;
        }
        const toDo = this._queue.pop();
        const id = toDo.id;
        this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
        worker.postMessage({
          data: toDo.arguments,
          uuid: UUID++,
          id
        });
      }
    };
    WorkerManager = new WorkerManagerClass();
  }
});

// node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs
async function loadImageBitmap(url, asset) {
  const response = await DOMAdapter.get().fetch(url);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  return asset?.data?.alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
}
var validImageExtensions, validImageMIMEs, loadTextures;
var init_loadTextures = __esm({
  "node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs"() {
    init_define_AnParams();
    init_adapter();
    init_Extensions();
    init_ImageSource();
    init_getResolutionOfUrl();
    init_checkDataUrl();
    init_checkExtension();
    init_WorkerManager();
    init_LoaderParser();
    init_createTexture();
    validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
    validImageMIMEs = [
      "image/jpeg",
      "image/png",
      "image/webp",
      "image/avif"
    ];
    loadTextures = {
      name: "loadTextures",
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.High,
        name: "loadTextures"
      },
      config: {
        preferWorkers: true,
        preferCreateImageBitmap: true,
        crossOrigin: "anonymous"
      },
      test(url) {
        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);
      },
      async load(url, asset, loader) {
        let src = null;
        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
          if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
            src = await WorkerManager.loadImageBitmap(url, asset);
          } else {
            src = await loadImageBitmap(url, asset);
          }
        } else {
          src = await new Promise((resolve, reject) => {
            src = new Image();
            src.crossOrigin = this.config.crossOrigin;
            src.src = url;
            if (src.complete) {
              resolve(src);
            } else {
              src.onload = () => {
                resolve(src);
              };
              src.onerror = reject;
            }
          });
        }
        const base = new ImageSource({
          resource: src,
          alphaMode: "premultiply-alpha-on-upload",
          resolution: asset.data?.resolution || getResolutionOfUrl(url),
          ...asset.data
        });
        return createTexture(base, loader, url);
      },
      unload(texture) {
        texture.destroy(true);
      }
    };
  }
});

// node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs
function crossOrigin(element, url, crossorigin) {
  if (crossorigin === void 0 && !url.startsWith("data:")) {
    element.crossOrigin = determineCrossOrigin(url);
  } else if (crossorigin !== false) {
    element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
  }
}
function preloadVideo(element) {
  return new Promise((resolve, reject) => {
    element.addEventListener("canplaythrough", loaded);
    element.addEventListener("error", error);
    element.load();
    function loaded() {
      cleanup();
      resolve();
    }
    function error(err2) {
      cleanup();
      reject(err2);
    }
    function cleanup() {
      element.removeEventListener("canplaythrough", loaded);
      element.removeEventListener("error", error);
    }
  });
}
function determineCrossOrigin(url, loc = globalThis.location) {
  if (url.startsWith("data:")) {
    return "";
  }
  loc || (loc = globalThis.location);
  const parsedUrl = new URL(url, document.baseURI);
  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
var validVideoExtensions, validVideoMIMEs, loadVideoTextures;
var init_loadVideoTextures = __esm({
  "node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_VideoSource();
    init_detectVideoAlphaMode();
    init_getResolutionOfUrl();
    init_checkDataUrl();
    init_checkExtension();
    init_createTexture();
    validVideoExtensions = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
    validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);
    loadVideoTextures = {
      name: "loadVideo",
      extension: {
        type: ExtensionType.LoadParser,
        name: "loadVideo"
      },
      test(url) {
        const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);
        const isValidExtension = checkExtension(url, validVideoExtensions);
        return isValidDataUrl || isValidExtension;
      },
      async load(url, asset, loader) {
        const options = {
          ...VideoSource.defaultOptions,
          resolution: asset.data?.resolution || getResolutionOfUrl(url),
          alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),
          ...asset.data
        };
        const videoElement = document.createElement("video");
        const attributeMap = {
          preload: options.autoLoad !== false ? "auto" : void 0,
          "webkit-playsinline": options.playsinline !== false ? "" : void 0,
          playsinline: options.playsinline !== false ? "" : void 0,
          muted: options.muted === true ? "" : void 0,
          loop: options.loop === true ? "" : void 0,
          autoplay: options.autoPlay !== false ? "" : void 0
        };
        Object.keys(attributeMap).forEach((key) => {
          const value = attributeMap[key];
          if (value !== void 0)
            videoElement.setAttribute(key, value);
        });
        if (options.muted === true) {
          videoElement.muted = true;
        }
        crossOrigin(videoElement, url, options.crossorigin);
        const sourceElement = document.createElement("source");
        let mime;
        if (url.startsWith("data:")) {
          mime = url.slice(5, url.indexOf(";"));
        } else if (!url.startsWith("blob:")) {
          const ext = url.split("?")[0].slice(url.lastIndexOf(".") + 1).toLowerCase();
          mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;
        }
        sourceElement.src = url;
        if (mime) {
          sourceElement.type = mime;
        }
        return new Promise((resolve) => {
          const onCanPlay = async () => {
            const base = new VideoSource({ ...options, resource: videoElement });
            videoElement.removeEventListener("canplay", onCanPlay);
            if (asset.data.preload) {
              await preloadVideo(videoElement);
            }
            resolve(createTexture(base, loader, url));
          };
          videoElement.addEventListener("canplay", onCanPlay);
          videoElement.appendChild(sourceElement);
        });
      },
      unload(texture) {
        texture.destroy(true);
      }
    };
  }
});

// node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs
var resolveTextureUrl;
var init_resolveTextureUrl = __esm({
  "node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_loadTextures();
    init_Resolver();
    resolveTextureUrl = {
      extension: {
        type: ExtensionType.ResolveParser,
        name: "resolveTexture"
      },
      test: loadTextures.test,
      parse: (value) => ({
        resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: value.split(".").pop(),
        src: value
      })
    };
  }
});

// node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs
var resolveJsonUrl;
var init_resolveJsonUrl = __esm({
  "node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Resolver();
    init_resolveTextureUrl();
    resolveJsonUrl = {
      extension: {
        type: ExtensionType.ResolveParser,
        priority: -2,
        name: "resolveJson"
      },
      test: (value) => Resolver.RETINA_PREFIX.test(value) && value.endsWith(".json"),
      parse: resolveTextureUrl.parse
    };
  }
});

// node_modules/pixi.js/lib/assets/Assets.mjs
var AssetsClass, Assets, assetKeyMap;
var init_Assets = __esm({
  "node_modules/pixi.js/lib/assets/Assets.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_loadBitmapFont();
    init_warn();
    init_BackgroundLoader();
    init_Cache();
    init_cacheTextureArray();
    init_detectAvif();
    init_detectDefaults();
    init_detectMp4();
    init_detectOgv();
    init_detectWebm();
    init_detectWebp();
    init_Loader();
    init_loadJson();
    init_loadTxt();
    init_loadWebFont();
    init_loadSVG();
    init_loadTextures();
    init_loadVideoTextures();
    init_resolveJsonUrl();
    init_resolveTextureUrl();
    init_Resolver();
    init_convertToList();
    init_isSingleItem();
    AssetsClass = class {
      constructor() {
        this._detections = [];
        this._initialized = false;
        this.resolver = new Resolver();
        this.loader = new Loader();
        this.cache = Cache;
        this._backgroundLoader = new BackgroundLoader(this.loader);
        this._backgroundLoader.active = true;
        this.reset();
      }
      /**
       * Best practice is to call this function before any loading commences
       * Initiating is the best time to add any customization to the way things are loaded.
       *
       * you do not need to call this for the Assets class to work, only if you want to set any initial properties
       * @param options - options to initialize the Assets manager with
       */
      async init(options = {}) {
        if (this._initialized) {
          warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
          return;
        }
        this._initialized = true;
        if (options.defaultSearchParams) {
          this.resolver.setDefaultSearchParams(options.defaultSearchParams);
        }
        if (options.basePath) {
          this.resolver.basePath = options.basePath;
        }
        if (options.bundleIdentifier) {
          this.resolver.setBundleIdentifier(options.bundleIdentifier);
        }
        if (options.manifest) {
          let manifest = options.manifest;
          if (typeof manifest === "string") {
            manifest = await this.load(manifest);
          }
          this.resolver.addManifest(manifest);
        }
        const resolutionPref = options.texturePreference?.resolution ?? 1;
        const resolution = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
        const formats = await this._detectFormats({
          preferredFormats: options.texturePreference?.format,
          skipDetections: options.skipDetections,
          detections: this._detections
        });
        this.resolver.prefer({
          params: {
            format: formats,
            resolution
          }
        });
        if (options.preferences) {
          this.setPreferences(options.preferences);
        }
      }
      /**
       * Allows you to specify how to resolve any assets load requests.
       * There are a few ways to add things here as shown below:
       * @example
       * import { Assets } from 'pixi.js';
       *
       * // Simple
       * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});
       * const bunny = await Assets.load('bunnyBooBoo');
       *
       * // Multiple keys:
       * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});
       *
       * const bunny = await Assets.load('burger');
       * const bunny2 = await Assets.load('chicken');
       *
       * // passing options to to the object
       * Assets.add({
       *     alias: 'bunnyBooBooSmooth',
       *     src: 'bunny.{png,webp}',
       *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options
       * });
       *
       * // Multiple assets
       *
       * // The following all do the same thing:
       *
       * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.{png,webp}'});
       *
       * Assets.add({
       *     alias: 'bunnyBooBoo',
       *     src: [
       *         'bunny.png',
       *         'bunny.webp',
       *    ],
       * });
       *
       * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available
       * @param assets - the unresolved assets to add to the resolver
       */
      add(assets) {
        this.resolver.add(assets);
      }
      async load(urls, onProgress) {
        if (!this._initialized) {
          await this.init();
        }
        const singleAsset = isSingleItem(urls);
        const urlArray = convertToList(urls).map((url) => {
          if (typeof url !== "string") {
            const aliases = this.resolver.getAlias(url);
            if (aliases.some((alias) => !this.resolver.hasKey(alias))) {
              this.add(url);
            }
            return Array.isArray(aliases) ? aliases[0] : aliases;
          }
          if (!this.resolver.hasKey(url))
            this.add({ alias: url, src: url });
          return url;
        });
        const resolveResults = this.resolver.resolve(urlArray);
        const out2 = await this._mapLoadToResolve(resolveResults, onProgress);
        return singleAsset ? out2[urlArray[0]] : out2;
      }
      /**
       * This adds a bundle of assets in one go so that you can load them as a group.
       * For example you could add a bundle for each screen in you pixi app
       * @example
       * import { Assets } from 'pixi.js';
       *
       * Assets.addBundle('animals', [
       *  { alias: 'bunny', src: 'bunny.png' },
       *  { alias: 'chicken', src: 'chicken.png' },
       *  { alias: 'thumper', src: 'thumper.png' },
       * ]);
       * // or
       * Assets.addBundle('animals', {
       *     bunny: 'bunny.png',
       *     chicken: 'chicken.png',
       *     thumper: 'thumper.png',
       * });
       *
       * const assets = await Assets.loadBundle('animals');
       * @param bundleId - the id of the bundle to add
       * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key
       */
      addBundle(bundleId, assets) {
        this.resolver.addBundle(bundleId, assets);
      }
      /**
       * Bundles are a way to load multiple assets at once.
       * If a manifest has been provided to the init function then you can load a bundle, or bundles.
       * you can also add bundles via `addBundle`
       * @example
       * import { Assets } from 'pixi.js';
       *
       * // Manifest Example
       * const manifest = {
       *     bundles: [
       *         {
       *             name: 'load-screen',
       *             assets: [
       *                 {
       *                     alias: 'background',
       *                     src: 'sunset.png',
       *                 },
       *                 {
       *                     alias: 'bar',
       *                     src: 'load-bar.{png,webp}',
       *                 },
       *             ],
       *         },
       *         {
       *             name: 'game-screen',
       *             assets: [
       *                 {
       *                     alias: 'character',
       *                     src: 'robot.png',
       *                 },
       *                 {
       *                     alias: 'enemy',
       *                     src: 'bad-guy.png',
       *                 },
       *             ],
       *         },
       *     ]
       * };
       *
       * await Assets.init({ manifest });
       *
       * // Load a bundle...
       * loadScreenAssets = await Assets.loadBundle('load-screen');
       * // Load another bundle...
       * gameScreenAssets = await Assets.loadBundle('game-screen');
       * @param bundleIds - the bundle id or ids to load
       * @param onProgress - Optional function that is called when progress on asset loading is made.
       * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)
       * of the assets loaded. Do not use this function to detect when assets are complete and available,
       * instead use the Promise returned by this function.
       * @returns all the bundles assets or a hash of assets for each bundle specified
       */
      async loadBundle(bundleIds, onProgress) {
        if (!this._initialized) {
          await this.init();
        }
        let singleAsset = false;
        if (typeof bundleIds === "string") {
          singleAsset = true;
          bundleIds = [bundleIds];
        }
        const resolveResults = this.resolver.resolveBundle(bundleIds);
        const out2 = {};
        const keys = Object.keys(resolveResults);
        let count2 = 0;
        let total = 0;
        const _onProgress = () => {
          onProgress?.(++count2 / total);
        };
        const promises = keys.map((bundleId) => {
          const resolveResult = resolveResults[bundleId];
          total += Object.keys(resolveResult).length;
          return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {
            out2[bundleId] = resolveResult2;
          });
        });
        await Promise.all(promises);
        return singleAsset ? out2[bundleIds[0]] : out2;
      }
      /**
       * Initiate a background load of some assets. It will passively begin to load these assets in the background.
       * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately
       *
       * An example of this might be that you would background load game assets after your initial load.
       * then when you got to actually load your game screen assets when a player goes to the game - the loading
       * would already have stared or may even be complete, saving you having to show an interim load bar.
       * @example
       * import { Assets } from 'pixi.js';
       *
       * Assets.backgroundLoad('bunny.png');
       *
       * // later on in your app...
       * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!
       * @param urls - the url / urls you want to background load
       */
      async backgroundLoad(urls) {
        if (!this._initialized) {
          await this.init();
        }
        if (typeof urls === "string") {
          urls = [urls];
        }
        const resolveResults = this.resolver.resolve(urls);
        this._backgroundLoader.add(Object.values(resolveResults));
      }
      /**
       * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.
       * this can only be used if the loader has been initiated with a manifest
       * @example
       * import { Assets } from 'pixi.js';
       *
       * await Assets.init({
       *     manifest: {
       *         bundles: [
       *             {
       *                 name: 'load-screen',
       *                 assets: [...],
       *             },
       *             ...
       *         ],
       *     },
       * });
       *
       * Assets.backgroundLoadBundle('load-screen');
       *
       * // Later on in your app...
       * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!
       * @param bundleIds - the bundleId / bundleIds you want to background load
       */
      async backgroundLoadBundle(bundleIds) {
        if (!this._initialized) {
          await this.init();
        }
        if (typeof bundleIds === "string") {
          bundleIds = [bundleIds];
        }
        const resolveResults = this.resolver.resolveBundle(bundleIds);
        Object.values(resolveResults).forEach((resolveResult) => {
          this._backgroundLoader.add(Object.values(resolveResult));
        });
      }
      /**
       * Only intended for development purposes.
       * This will wipe the resolver and caches.
       * You will need to reinitialize the Asset
       */
      reset() {
        this.resolver.reset();
        this.loader.reset();
        this.cache.reset();
        this._initialized = false;
      }
      get(keys) {
        if (typeof keys === "string") {
          return Cache.get(keys);
        }
        const assets = {};
        for (let i3 = 0; i3 < keys.length; i3++) {
          assets[i3] = Cache.get(keys[i3]);
        }
        return assets;
      }
      /**
       * helper function to map resolved assets back to loaded assets
       * @param resolveResults - the resolve results from the resolver
       * @param onProgress - the progress callback
       */
      async _mapLoadToResolve(resolveResults, onProgress) {
        const resolveArray = [...new Set(Object.values(resolveResults))];
        this._backgroundLoader.active = false;
        const loadedAssets = await this.loader.load(resolveArray, onProgress);
        this._backgroundLoader.active = true;
        const out2 = {};
        resolveArray.forEach((resolveResult) => {
          const asset = loadedAssets[resolveResult.src];
          const keys = [resolveResult.src];
          if (resolveResult.alias) {
            keys.push(...resolveResult.alias);
          }
          keys.forEach((key) => {
            out2[key] = asset;
          });
          Cache.set(keys, asset);
        });
        return out2;
      }
      /**
       * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function
       * this will make sure to destroy any assets and release them from memory.
       * Once unloaded, you will need to load the asset again.
       *
       * Use this to help manage assets if you find that you have a large app and you want to free up memory.
       *
       * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,
       * Pixi won't break but you will end up with missing assets. Not a good look for the user!
       * @example
       * import { Assets } from 'pixi.js';
       *
       * // Load a URL:
       * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture
       *
       * await Assets.unload('http://some.url.com/image.png')
       *
       * // myImageTexture will be destroyed now.
       *
       * // Unload multiple assets:
       * const textures = await Assets.unload(['thumper', 'chicko']);
       * @param urls - the urls to unload
       */
      async unload(urls) {
        if (!this._initialized) {
          await this.init();
        }
        const urlArray = convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);
        const resolveResults = this.resolver.resolve(urlArray);
        await this._unloadFromResolved(resolveResults);
      }
      /**
       * Bundles are a way to manage multiple assets at once.
       * this will unload all files in a bundle.
       *
       * once a bundle has been unloaded, you need to load it again to have access to the assets.
       * @example
       * import { Assets } from 'pixi.js';
       *
       * Assets.addBundle({
       *     'thumper': 'http://some.url.com/thumper.png',
       * })
       *
       * const assets = await Assets.loadBundle('thumper');
       *
       * // Now to unload...
       *
       * await Assets.unloadBundle('thumper');
       *
       * // All assets in the assets object will now have been destroyed and purged from the cache
       * @param bundleIds - the bundle id or ids to unload
       */
      async unloadBundle(bundleIds) {
        if (!this._initialized) {
          await this.init();
        }
        bundleIds = convertToList(bundleIds);
        const resolveResults = this.resolver.resolveBundle(bundleIds);
        const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
        await Promise.all(promises);
      }
      async _unloadFromResolved(resolveResult) {
        const resolveArray = Object.values(resolveResult);
        resolveArray.forEach((resolveResult2) => {
          Cache.remove(resolveResult2.src);
        });
        await this.loader.unload(resolveArray);
      }
      /**
       * Detects the supported formats for the browser, and returns an array of supported formats, respecting
       * the users preferred formats order.
       * @param options - the options to use when detecting formats
       * @param options.preferredFormats - the preferred formats to use
       * @param options.skipDetections - if we should skip the detections altogether
       * @param options.detections - the detections to use
       * @returns - the detected formats
       */
      async _detectFormats(options) {
        let formats = [];
        if (options.preferredFormats) {
          formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];
        }
        for (const detection of options.detections) {
          if (options.skipDetections || await detection.test()) {
            formats = await detection.add(formats);
          } else if (!options.skipDetections) {
            formats = await detection.remove(formats);
          }
        }
        formats = formats.filter((format, index) => formats.indexOf(format) === index);
        return formats;
      }
      /** All the detection parsers currently added to the Assets class. */
      get detections() {
        return this._detections;
      }
      /**
       * General setter for preferences. This is a helper function to set preferences on all parsers.
       * @param preferences - the preferences to set
       */
      setPreferences(preferences) {
        this.loader.parsers.forEach((parser) => {
          if (!parser.config)
            return;
          Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {
            parser.config[key] = preferences[key];
          });
        });
      }
    };
    Assets = new AssetsClass();
    extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
    extensions.add(
      cacheTextureArray,
      detectDefaults,
      detectAvif,
      detectWebp,
      detectMp4,
      detectOgv,
      detectWebm,
      loadJson,
      loadTxt,
      loadWebFont,
      loadSvg,
      loadTextures,
      loadVideoTextures,
      loadBitmapFont,
      bitmapFontCachePlugin,
      resolveTextureUrl,
      resolveJsonUrl
    );
    assetKeyMap = {
      loader: ExtensionType.LoadParser,
      resolver: ExtensionType.ResolveParser,
      cache: ExtensionType.CacheParser,
      detection: ExtensionType.DetectionParser
    };
    extensions.handle(ExtensionType.Asset, (extension) => {
      const ref = extension.ref;
      Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(
        ref[key],
        // Allow the function to optionally define it's own
        // ExtensionMetadata, the use cases here is priority for LoaderParsers
        { extension: ref[key].extension ?? type }
      )));
    }, (extension) => {
      const ref = extension.ref;
      Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));
    });
  }
});

// node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.mjs
var detectBasis;
var init_detectBasis = __esm({
  "node_modules/pixi.js/lib/compressed-textures/basis/detectBasis.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_isWebGLSupported();
    init_isWebGPUSupported();
    detectBasis = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 3
      },
      test: async () => {
        if (await isWebGPUSupported())
          return true;
        if (isWebGLSupported())
          return true;
        return false;
      },
      add: async (formats) => [...formats, "basis"],
      remove: async (formats) => formats.filter((f2) => f2 !== "basis")
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs
var CompressedSource;
var init_CompressedSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CompressedSource.mjs"() {
    init_define_AnParams();
    init_TextureSource();
    CompressedSource = class extends TextureSource {
      constructor(options) {
        super(options);
        this.uploadMethodId = "compressed";
        this.resource = options.resource;
        this.mipLevelCount = this.resource.length;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs
function getSupportedGlCompressedTextureFormats() {
  if (supportedGLCompressedTextureFormats)
    return supportedGLCompressedTextureFormats;
  const canvas = document.createElement("canvas");
  const gl = canvas.getContext("webgl");
  if (!gl) {
    return [];
  }
  supportedGLCompressedTextureFormats = [
    // BC compressed formats usable if "texture-compression-bc" is both
    // supported by the device/user agent and enabled in requestDevice.
    // 'bc6h-rgb-ufloat'
    // 'bc6h-rgb-float'
    // 'bc7-rgba-unorm',
    // 'bc7-rgba-unorm-srgb',
    ...gl.getExtension("EXT_texture_compression_bptc") ? [
      "bc6h-rgb-ufloat",
      "bc6h-rgb-float",
      "bc7-rgba-unorm",
      "bc7-rgba-unorm-srgb"
    ] : [],
    // BC compressed formats usable if "texture-compression-bc" is both
    // supported by the device/user agent and enabled in requestDevice.
    // 'bc1-rgba-unorm',
    // 'bc1-rgba-unorm-srgb',
    // 'bc4-r-unorm'
    // 'bc4-r-snorm'
    // 'bc5-rg-unorm'
    // 'bc5-rg-snorm'
    ...gl.getExtension("WEBGL_compressed_texture_s3tc") ? [
      "bc1-rgba-unorm",
      "bc2-rgba-unorm",
      "bc3-rgba-unorm"
    ] : [],
    ...gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") ? [
      "bc1-rgba-unorm-srgb",
      "bc2-rgba-unorm-srgb",
      "bc3-rgba-unorm-srgb"
    ] : [],
    ...gl.getExtension("EXT_texture_compression_rgtc") ? [
      "bc4-r-unorm",
      "bc4-r-snorm",
      "bc5-rg-unorm",
      "bc5-rg-snorm"
    ] : [],
    // ETC2 compressed formats usable if "texture-compression-etc2" is both
    // supported by the device/user agent and enabled in requestDevice.
    ...gl.getExtension("WEBGL_compressed_texture_etc") ? [
      "etc2-rgb8unorm",
      "etc2-rgb8unorm-srgb",
      "etc2-rgba8unorm",
      "etc2-rgba8unorm-srgb",
      "etc2-rgb8a1unorm",
      "etc2-rgb8a1unorm-srgb",
      "eac-r11unorm",
      "eac-rg11unorm"
    ] : [],
    // 'eac-r11snorm',
    // 'eac-rg11snorm',
    // ASTC compressed formats usable if "texture-compression-astc" is both
    // supported by the device/user agent and enabled in requestDevice.
    ...gl.getExtension("WEBGL_compressed_texture_astc") ? [
      "astc-4x4-unorm",
      "astc-4x4-unorm-srgb",
      "astc-5x4-unorm",
      "astc-5x4-unorm-srgb",
      "astc-5x5-unorm",
      "astc-5x5-unorm-srgb",
      "astc-6x5-unorm",
      "astc-6x5-unorm-srgb",
      "astc-6x6-unorm",
      "astc-6x6-unorm-srgb",
      "astc-8x5-unorm",
      "astc-8x5-unorm-srgb",
      "astc-8x6-unorm",
      "astc-8x6-unorm-srgb",
      "astc-8x8-unorm",
      "astc-8x8-unorm-srgb",
      "astc-10x5-unorm",
      "astc-10x5-unorm-srgb",
      "astc-10x6-unorm",
      "astc-10x6-unorm-srgb",
      "astc-10x8-unorm",
      "astc-10x8-unorm-srgb",
      "astc-10x10-unorm",
      "astc-10x10-unorm-srgb",
      "astc-12x10-unorm",
      "astc-12x10-unorm-srgb",
      "astc-12x12-unorm",
      "astc-12x12-unorm-srgb"
    ] : []
  ];
  return supportedGLCompressedTextureFormats;
}
var supportedGLCompressedTextureFormats;
var init_getSupportedGlCompressedTextureFormats = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs
async function getSupportedGPUCompressedTextureFormats() {
  if (supportedGPUCompressedTextureFormats)
    return supportedGPUCompressedTextureFormats;
  const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter();
  supportedGPUCompressedTextureFormats = [
    ...adapter.features.has("texture-compression-bc") ? [
      // BC compressed formats usable if "texture-compression-bc" is both
      // supported by the device/user agent and enabled in requestDevice.
      "bc1-rgba-unorm",
      "bc1-rgba-unorm-srgb",
      "bc2-rgba-unorm",
      "bc2-rgba-unorm-srgb",
      "bc3-rgba-unorm",
      "bc3-rgba-unorm-srgb",
      "bc4-r-unorm",
      "bc4-r-snorm",
      "bc5-rg-unorm",
      "bc5-rg-snorm",
      "bc6h-rgb-ufloat",
      "bc6h-rgb-float",
      "bc7-rgba-unorm",
      "bc7-rgba-unorm-srgb"
    ] : [],
    ...adapter.features.has("texture-compression-etc2") ? [
      // ETC2 compressed formats usable if "texture-compression-etc2" is both
      // supported by the device/user agent and enabled in requestDevice.
      "etc2-rgb8unorm",
      "etc2-rgb8unorm-srgb",
      "etc2-rgb8a1unorm",
      "etc2-rgb8a1unorm-srgb",
      "etc2-rgba8unorm",
      "etc2-rgba8unorm-srgb",
      "eac-r11unorm",
      "eac-r11snorm",
      "eac-rg11unorm",
      "eac-rg11snorm"
    ] : [],
    ...adapter.features.has("texture-compression-astc") ? [
      // ASTC compressed formats usable if "texture-compression-astc" is both
      // supported by the device/user agent and enabled in requestDevice.
      "astc-4x4-unorm",
      "astc-4x4-unorm-srgb",
      "astc-5x4-unorm",
      "astc-5x4-unorm-srgb",
      "astc-5x5-unorm",
      "astc-5x5-unorm-srgb",
      "astc-6x5-unorm",
      "astc-6x5-unorm-srgb",
      "astc-6x6-unorm",
      "astc-6x6-unorm-srgb",
      "astc-8x5-unorm",
      "astc-8x5-unorm-srgb",
      "astc-8x6-unorm",
      "astc-8x6-unorm-srgb",
      "astc-8x8-unorm",
      "astc-8x8-unorm-srgb",
      "astc-10x5-unorm",
      "astc-10x5-unorm-srgb",
      "astc-10x6-unorm",
      "astc-10x6-unorm-srgb",
      "astc-10x8-unorm",
      "astc-10x8-unorm-srgb",
      "astc-10x10-unorm",
      "astc-10x10-unorm-srgb",
      "astc-12x10-unorm",
      "astc-12x10-unorm-srgb",
      "astc-12x12-unorm",
      "astc-12x12-unorm-srgb"
    ] : []
  ];
  return supportedGPUCompressedTextureFormats;
}
var supportedGPUCompressedTextureFormats;
var init_getSupportedGPUCompressedTextureFormats = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs"() {
    init_define_AnParams();
    init_adapter();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs
async function getSupportedCompressedTextureFormats() {
  if (supportedCompressedTextureFormats !== void 0)
    return supportedCompressedTextureFormats;
  supportedCompressedTextureFormats = await (async () => {
    const _isWebGPUSupported2 = await isWebGPUSupported();
    const _isWebGLSupported2 = isWebGLSupported();
    if (_isWebGPUSupported2 && _isWebGLSupported2) {
      const gpuTextureFormats = await getSupportedGPUCompressedTextureFormats();
      const glTextureFormats = getSupportedGlCompressedTextureFormats();
      return gpuTextureFormats.filter((format) => glTextureFormats.includes(format));
    } else if (_isWebGPUSupported2) {
      return await getSupportedGPUCompressedTextureFormats();
    } else if (_isWebGLSupported2) {
      return getSupportedGlCompressedTextureFormats();
    }
    return [];
  })();
  return supportedCompressedTextureFormats;
}
var supportedCompressedTextureFormats;
var init_getSupportedCompressedTextureFormats = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs"() {
    init_define_AnParams();
    init_isWebGLSupported();
    init_isWebGPUSupported();
    init_getSupportedGlCompressedTextureFormats();
    init_getSupportedGPUCompressedTextureFormats();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs
async function getSupportedTextureFormats() {
  if (supportedTextureFormats !== void 0)
    return supportedTextureFormats;
  const compressedTextureFormats = await getSupportedCompressedTextureFormats();
  supportedTextureFormats = [
    ...nonCompressedFormats,
    ...compressedTextureFormats
  ];
  return supportedTextureFormats;
}
var nonCompressedFormats, supportedTextureFormats;
var init_getSupportedTextureFormats = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs"() {
    init_define_AnParams();
    init_getSupportedCompressedTextureFormats();
    nonCompressedFormats = [
      // 8-bit formats
      "r8unorm",
      "r8snorm",
      "r8uint",
      "r8sint",
      // 16-bit formats
      "r16uint",
      "r16sint",
      "r16float",
      "rg8unorm",
      "rg8snorm",
      "rg8uint",
      "rg8sint",
      // 32-bit formats
      "r32uint",
      "r32sint",
      "r32float",
      "rg16uint",
      "rg16sint",
      "rg16float",
      "rgba8unorm",
      "rgba8unorm-srgb",
      "rgba8snorm",
      "rgba8uint",
      "rgba8sint",
      "bgra8unorm",
      "bgra8unorm-srgb",
      // Packed 32-bit formats
      "rgb9e5ufloat",
      "rgb10a2unorm",
      "rg11b10ufloat",
      // 64-bit formats
      "rg32uint",
      "rg32sint",
      "rg32float",
      "rgba16uint",
      "rgba16sint",
      "rgba16float",
      // 128-bit formats
      "rgba32uint",
      "rgba32sint",
      "rgba32float",
      // Depth/stencil formats
      "stencil8",
      "depth16unorm",
      "depth24plus",
      "depth24plus-stencil8",
      "depth32float",
      // "depth32float-stencil8" feature
      "depth32float-stencil8"
    ];
  }
});

// node_modules/pixi.js/lib/_virtual/basis.worker.mjs
var WORKER_CODE3, WORKER_URL3, WorkerInstance3;
var init_basis_worker = __esm({
  "node_modules/pixi.js/lib/_virtual/basis.worker.mjs"() {
    init_define_AnParams();
    WORKER_CODE3 = '(function () {\n    \'use strict\';\n\n    function createLevelBuffers(basisTexture, basisTranscoderFormat) {\n      const images = basisTexture.getNumImages();\n      const levels = basisTexture.getNumLevels(0);\n      const success = basisTexture.startTranscoding();\n      if (!success) {\n        throw new Error("startTranscoding failed");\n      }\n      const levelBuffers = [];\n      for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {\n        for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {\n          const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);\n          const levelBuffer = new Uint8Array(transcodeSize);\n          const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);\n          if (!success2) {\n            throw new Error("transcodeImage failed");\n          }\n          levelBuffers.push(levelBuffer);\n        }\n      }\n      return levelBuffers;\n    }\n\n    const gpuFormatToBasisTranscoderFormatMap = {\n      "bc3-rgba-unorm": 3,\n      // cTFBC3_RGBA\n      "bc7-rgba-unorm": 6,\n      // cTFBC7_RGBA,\n      "etc2-rgba8unorm": 1,\n      // cTFETC2_RGBA,\n      "astc-4x4-unorm": 10,\n      // cTFASTC_4x4_RGBA,\n      // Uncompressed\n      rgba8unorm: 13,\n      // cTFRGBA32,\n      rgba4unorm: 16\n      // cTFRGBA4444,\n    };\n    function gpuFormatToBasisTranscoderFormat(transcoderFormat) {\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n    }\n\n    const settings = {\n      jsUrl: "basis/basis_transcoder.js",\n      wasmUrl: "basis/basis_transcoder.wasm"\n    };\n    let basisTranscoderFormat;\n    let basisTranscodedTextureFormat;\n    let basisPromise;\n    async function getBasis() {\n      if (!basisPromise) {\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\n        importScripts(absoluteJsUrl);\n        basisPromise = new Promise((resolve) => {\n          BASIS({\n            locateFile: (_file) => absoluteWasmUrl\n          }).then((module) => {\n            module.initializeBasis();\n            resolve(module.BasisFile);\n          });\n        });\n      }\n      return basisPromise;\n    }\n    async function fetchBasisTexture(url, BasisTexture) {\n      const basisResponse = await fetch(url);\n      if (basisResponse.ok) {\n        const basisArrayBuffer = await basisResponse.arrayBuffer();\n        return new BasisTexture(new Uint8Array(basisArrayBuffer));\n      }\n      throw new Error(`Failed to load Basis texture: ${url}`);\n    }\n    const preferredTranscodedFormat = [\n      "bc7-rgba-unorm",\n      "astc-4x4-unorm",\n      "etc2-rgba8unorm",\n      "bc3-rgba-unorm",\n      "rgba8unorm"\n    ];\n    async function load(url) {\n      const BasisTexture = await getBasis();\n      const basisTexture = await fetchBasisTexture(url, BasisTexture);\n      const levelBuffers = createLevelBuffers(basisTexture, basisTranscoderFormat);\n      return {\n        width: basisTexture.getImageWidth(0, 0),\n        height: basisTexture.getImageHeight(0, 0),\n        format: basisTranscodedTextureFormat,\n        resource: levelBuffers,\n        alphaMode: "no-premultiply-alpha"\n      };\n    }\n    async function init(jsUrl, wasmUrl, supportedTextures) {\n      if (jsUrl)\n        settings.jsUrl = jsUrl;\n      if (wasmUrl)\n        settings.wasmUrl = wasmUrl;\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\n      basisTranscoderFormat = gpuFormatToBasisTranscoderFormat(basisTranscodedTextureFormat);\n      await getBasis();\n    }\n    const messageHandlers = {\n      init: async (data) => {\n        const { jsUrl, wasmUrl, supportedTextures } = data;\n        await init(jsUrl, wasmUrl, supportedTextures);\n      },\n      load: async (data) => {\n        try {\n          const textureOptions = await load(data.url);\n          return {\n            type: "load",\n            url: data.url,\n            success: true,\n            textureOptions,\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\n          };\n        } catch (e) {\n          throw e;\n        }\n      }\n    };\n    self.onmessage = async (messageEvent) => {\n      const message = messageEvent.data;\n      const response = await messageHandlers[message.type](message);\n      if (response) {\n        self.postMessage(response, response.transferables);\n      }\n    };\n\n})();\n';
    WORKER_URL3 = null;
    WorkerInstance3 = class {
      constructor() {
        if (!WORKER_URL3) {
          WORKER_URL3 = URL.createObjectURL(new Blob([WORKER_CODE3], { type: "application/javascript" }));
        }
        this.worker = new Worker(WORKER_URL3);
      }
    };
    WorkerInstance3.revokeObjectURL = function revokeObjectURL3() {
      if (WORKER_URL3) {
        URL.revokeObjectURL(WORKER_URL3);
        WORKER_URL3 = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.mjs
function setBasisTranscoderPath(config2) {
  Object.assign(basisTranscoderUrls, config2);
}
var basisTranscoderUrls;
var init_setBasisTranscoderPath = __esm({
  "node_modules/pixi.js/lib/compressed-textures/basis/utils/setBasisTranscoderPath.mjs"() {
    "use strict";
    init_define_AnParams();
    basisTranscoderUrls = {
      jsUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.js",
      wasmUrl: "https://files.pixijs.download/transcoders/basis/basis_transcoder.wasm"
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.mjs
function getBasisWorker(supportedTextures) {
  if (!basisWorker) {
    basisWorker = new WorkerInstance3().worker;
    basisWorker.onmessage = (messageEvent) => {
      const { success, url, textureOptions } = messageEvent.data;
      if (!success) {
        console.warn("Failed to load Basis texture", url);
      }
      urlHash[url](textureOptions);
    };
    basisWorker.postMessage({
      type: "init",
      jsUrl: basisTranscoderUrls.jsUrl,
      wasmUrl: basisTranscoderUrls.wasmUrl,
      supportedTextures
    });
  }
  return basisWorker;
}
function loadBasisOnWorker(url, supportedTextures) {
  const ktxWorker2 = getBasisWorker(supportedTextures);
  return new Promise((resolve) => {
    urlHash[url] = resolve;
    ktxWorker2.postMessage({ type: "load", url });
  });
}
var basisWorker, urlHash;
var init_loadBasisOnWorker = __esm({
  "node_modules/pixi.js/lib/compressed-textures/basis/worker/loadBasisOnWorker.mjs"() {
    init_define_AnParams();
    init_basis_worker();
    init_setBasisTranscoderPath();
    urlHash = {};
  }
});

// node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.mjs
var loadBasis;
var init_loadBasis = __esm({
  "node_modules/pixi.js/lib/compressed-textures/basis/loadBasis.mjs"() {
    init_define_AnParams();
    init_LoaderParser();
    init_createTexture();
    init_checkExtension();
    init_Extensions();
    init_CompressedSource();
    init_getSupportedTextureFormats();
    init_loadBasisOnWorker();
    loadBasis = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.High,
        name: "loadBasis"
      },
      name: "loadBasis",
      test(url) {
        return checkExtension(url, [".basis"]);
      },
      async load(url, _asset, loader) {
        const supportedTextures = await getSupportedTextureFormats();
        const textureOptions = await loadBasisOnWorker(url, supportedTextures);
        const compressedTextureSource = new CompressedSource(textureOptions);
        return createTexture(compressedTextureSource, loader, url);
      },
      unload(texture) {
        if (Array.isArray(texture)) {
          texture.forEach((t2) => t2.destroy(true));
        } else {
          texture.destroy(true);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.mjs
function createLevelBuffers(basisTexture, basisTranscoderFormat) {
  const images = basisTexture.getNumImages();
  const levels = basisTexture.getNumLevels(0);
  const success = basisTexture.startTranscoding();
  if (!success) {
    throw new Error("startTranscoding failed");
  }
  const levelBuffers = [];
  for (let levelIndex = 0; levelIndex < levels; ++levelIndex) {
    for (let sliceIndex = 0; sliceIndex < images; ++sliceIndex) {
      const transcodeSize = basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);
      const levelBuffer = new Uint8Array(transcodeSize);
      const success2 = basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);
      if (!success2) {
        throw new Error("transcodeImage failed");
      }
      levelBuffers.push(levelBuffer);
    }
  }
  return levelBuffers;
}
var init_createLevelBuffers = __esm({
  "node_modules/pixi.js/lib/compressed-textures/basis/utils/createLevelBuffers.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs
function gpuFormatToBasisTranscoderFormat(transcoderFormat) {
  const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];
  if (format) {
    return format;
  }
  throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);
}
var gpuFormatToBasisTranscoderFormatMap;
var init_gpuFormatToBasisTranscoderFormat = __esm({
  "node_modules/pixi.js/lib/compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs"() {
    "use strict";
    init_define_AnParams();
    gpuFormatToBasisTranscoderFormatMap = {
      "bc3-rgba-unorm": 3,
      // cTFBC3_RGBA
      "bc7-rgba-unorm": 6,
      // cTFBC7_RGBA,
      "etc2-rgba8unorm": 1,
      // cTFETC2_RGBA,
      "astc-4x4-unorm": 10,
      // cTFASTC_4x4_RGBA,
      // Uncompressed
      rgba8unorm: 13,
      // cTFRGBA32,
      rgba4unorm: 16
      // cTFRGBA4444,
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/dds/const.mjs
function fourCCToInt32(value) {
  return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
}
var DDS_HEADER_FIELDS, DDS_DX10_FIELDS, DXGI_FORMAT, D3D10_RESOURCE_DIMENSION, D3DFMT, FOURCC_TO_TEXTURE_FORMAT, DXGI_TO_TEXTURE_FORMAT, DDS, TEXTURE_FORMAT_BLOCK_SIZE;
var init_const11 = __esm({
  "node_modules/pixi.js/lib/compressed-textures/dds/const.mjs"() {
    "use strict";
    init_define_AnParams();
    DDS_HEADER_FIELDS = {
      MAGIC: 0,
      SIZE: 1,
      FLAGS: 2,
      HEIGHT: 3,
      WIDTH: 4,
      MIPMAP_COUNT: 7,
      PIXEL_FORMAT: 19,
      PF_FLAGS: 20,
      FOURCC: 21,
      RGB_BITCOUNT: 22,
      R_BIT_MASK: 23,
      G_BIT_MASK: 24,
      B_BIT_MASK: 25,
      A_BIT_MASK: 26
    };
    DDS_DX10_FIELDS = {
      DXGI_FORMAT: 0,
      RESOURCE_DIMENSION: 1,
      MISC_FLAG: 2,
      ARRAY_SIZE: 3,
      MISC_FLAGS2: 4
    };
    DXGI_FORMAT = /* @__PURE__ */ ((DXGI_FORMAT2) => {
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
      DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
      return DXGI_FORMAT2;
    })(DXGI_FORMAT || {});
    D3D10_RESOURCE_DIMENSION = /* @__PURE__ */ ((D3D10_RESOURCE_DIMENSION2) => {
      D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
      D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
      D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
      return D3D10_RESOURCE_DIMENSION2;
    })(D3D10_RESOURCE_DIMENSION || {});
    D3DFMT = ((D3DFMT2) => {
      D3DFMT2[D3DFMT2["UNKNOWN"] = 0] = "UNKNOWN";
      D3DFMT2[D3DFMT2["R8G8B8"] = 20] = "R8G8B8";
      D3DFMT2[D3DFMT2["A8R8G8B8"] = 21] = "A8R8G8B8";
      D3DFMT2[D3DFMT2["X8R8G8B8"] = 22] = "X8R8G8B8";
      D3DFMT2[D3DFMT2["R5G6B5"] = 23] = "R5G6B5";
      D3DFMT2[D3DFMT2["X1R5G5B5"] = 24] = "X1R5G5B5";
      D3DFMT2[D3DFMT2["A1R5G5B5"] = 25] = "A1R5G5B5";
      D3DFMT2[D3DFMT2["A4R4G4B4"] = 26] = "A4R4G4B4";
      D3DFMT2[D3DFMT2["R3G3B2"] = 27] = "R3G3B2";
      D3DFMT2[D3DFMT2["A8"] = 28] = "A8";
      D3DFMT2[D3DFMT2["A8R3G3B2"] = 29] = "A8R3G3B2";
      D3DFMT2[D3DFMT2["X4R4G4B4"] = 30] = "X4R4G4B4";
      D3DFMT2[D3DFMT2["A2B10G10R10"] = 31] = "A2B10G10R10";
      D3DFMT2[D3DFMT2["A8B8G8R8"] = 32] = "A8B8G8R8";
      D3DFMT2[D3DFMT2["X8B8G8R8"] = 33] = "X8B8G8R8";
      D3DFMT2[D3DFMT2["G16R16"] = 34] = "G16R16";
      D3DFMT2[D3DFMT2["A2R10G10B10"] = 35] = "A2R10G10B10";
      D3DFMT2[D3DFMT2["A16B16G16R16"] = 36] = "A16B16G16R16";
      D3DFMT2[D3DFMT2["A8P8"] = 40] = "A8P8";
      D3DFMT2[D3DFMT2["P8"] = 41] = "P8";
      D3DFMT2[D3DFMT2["L8"] = 50] = "L8";
      D3DFMT2[D3DFMT2["A8L8"] = 51] = "A8L8";
      D3DFMT2[D3DFMT2["A4L4"] = 52] = "A4L4";
      D3DFMT2[D3DFMT2["V8U8"] = 60] = "V8U8";
      D3DFMT2[D3DFMT2["L6V5U5"] = 61] = "L6V5U5";
      D3DFMT2[D3DFMT2["X8L8V8U8"] = 62] = "X8L8V8U8";
      D3DFMT2[D3DFMT2["Q8W8V8U8"] = 63] = "Q8W8V8U8";
      D3DFMT2[D3DFMT2["V16U16"] = 64] = "V16U16";
      D3DFMT2[D3DFMT2["A2W10V10U10"] = 67] = "A2W10V10U10";
      D3DFMT2[D3DFMT2["Q16W16V16U16"] = 110] = "Q16W16V16U16";
      D3DFMT2[D3DFMT2["R16F"] = 111] = "R16F";
      D3DFMT2[D3DFMT2["G16R16F"] = 112] = "G16R16F";
      D3DFMT2[D3DFMT2["A16B16G16R16F"] = 113] = "A16B16G16R16F";
      D3DFMT2[D3DFMT2["R32F"] = 114] = "R32F";
      D3DFMT2[D3DFMT2["G32R32F"] = 115] = "G32R32F";
      D3DFMT2[D3DFMT2["A32B32G32R32F"] = 116] = "A32B32G32R32F";
      D3DFMT2[D3DFMT2["UYVY"] = fourCCToInt32("UYVY")] = "UYVY";
      D3DFMT2[D3DFMT2["R8G8_B8G8"] = fourCCToInt32("RGBG")] = "R8G8_B8G8";
      D3DFMT2[D3DFMT2["YUY2"] = fourCCToInt32("YUY2")] = "YUY2";
      D3DFMT2[D3DFMT2["D3DFMT_G8R8_G8B8"] = fourCCToInt32("GRGB")] = "D3DFMT_G8R8_G8B8";
      D3DFMT2[D3DFMT2["DXT1"] = fourCCToInt32("DXT1")] = "DXT1";
      D3DFMT2[D3DFMT2["DXT2"] = fourCCToInt32("DXT2")] = "DXT2";
      D3DFMT2[D3DFMT2["DXT3"] = fourCCToInt32("DXT3")] = "DXT3";
      D3DFMT2[D3DFMT2["DXT4"] = fourCCToInt32("DXT4")] = "DXT4";
      D3DFMT2[D3DFMT2["DXT5"] = fourCCToInt32("DXT5")] = "DXT5";
      D3DFMT2[D3DFMT2["ATI1"] = fourCCToInt32("ATI1")] = "ATI1";
      D3DFMT2[D3DFMT2["AT1N"] = fourCCToInt32("AT1N")] = "AT1N";
      D3DFMT2[D3DFMT2["ATI2"] = fourCCToInt32("ATI2")] = "ATI2";
      D3DFMT2[D3DFMT2["AT2N"] = fourCCToInt32("AT2N")] = "AT2N";
      D3DFMT2[D3DFMT2["BC4U"] = fourCCToInt32("BC4U")] = "BC4U";
      D3DFMT2[D3DFMT2["BC4S"] = fourCCToInt32("BC4S")] = "BC4S";
      D3DFMT2[D3DFMT2["BC5U"] = fourCCToInt32("BC5U")] = "BC5U";
      D3DFMT2[D3DFMT2["BC5S"] = fourCCToInt32("BC5S")] = "BC5S";
      D3DFMT2[D3DFMT2["DX10"] = fourCCToInt32("DX10")] = "DX10";
      return D3DFMT2;
    })(D3DFMT || {});
    FOURCC_TO_TEXTURE_FORMAT = {
      [D3DFMT.DXT1]: "bc1-rgba-unorm",
      [D3DFMT.DXT2]: "bc2-rgba-unorm",
      [D3DFMT.DXT3]: "bc2-rgba-unorm",
      [D3DFMT.DXT4]: "bc3-rgba-unorm",
      [D3DFMT.DXT5]: "bc3-rgba-unorm",
      [D3DFMT.ATI1]: "bc4-r-unorm",
      [D3DFMT.BC4U]: "bc4-r-unorm",
      [D3DFMT.BC4S]: "bc4-r-snorm",
      [D3DFMT.ATI2]: "bc5-rg-unorm",
      [D3DFMT.BC5U]: "bc5-rg-unorm",
      [D3DFMT.BC5S]: "bc5-rg-snorm",
      [
        36
        /* A16B16G16R16 */
      ]: "rgba16uint",
      [
        110
        /* Q16W16V16U16 */
      ]: "rgba16sint",
      [
        111
        /* R16F */
      ]: "r16float",
      [
        112
        /* G16R16F */
      ]: "rg16float",
      [
        113
        /* A16B16G16R16F */
      ]: "rgba16float",
      [
        114
        /* R32F */
      ]: "r32float",
      [
        115
        /* G32R32F */
      ]: "rg32float",
      [
        116
        /* A32B32G32R32F */
      ]: "rgba32float"
    };
    DXGI_TO_TEXTURE_FORMAT = {
      [
        70
        /* DXGI_FORMAT_BC1_TYPELESS */
      ]: "bc1-rgba-unorm",
      [
        71
        /* DXGI_FORMAT_BC1_UNORM */
      ]: "bc1-rgba-unorm",
      [
        72
        /* DXGI_FORMAT_BC1_UNORM_SRGB */
      ]: "bc1-rgba-unorm-srgb",
      [
        73
        /* DXGI_FORMAT_BC2_TYPELESS */
      ]: "bc2-rgba-unorm",
      [
        74
        /* DXGI_FORMAT_BC2_UNORM */
      ]: "bc2-rgba-unorm",
      [
        75
        /* DXGI_FORMAT_BC2_UNORM_SRGB */
      ]: "bc2-rgba-unorm-srgb",
      [
        76
        /* DXGI_FORMAT_BC3_TYPELESS */
      ]: "bc3-rgba-unorm",
      [
        77
        /* DXGI_FORMAT_BC3_UNORM */
      ]: "bc3-rgba-unorm",
      [
        78
        /* DXGI_FORMAT_BC3_UNORM_SRGB */
      ]: "bc3-rgba-unorm-srgb",
      [
        79
        /* DXGI_FORMAT_BC4_TYPELESS */
      ]: "bc4-r-unorm",
      [
        80
        /* DXGI_FORMAT_BC4_UNORM */
      ]: "bc4-r-unorm",
      [
        81
        /* DXGI_FORMAT_BC4_SNORM */
      ]: "bc4-r-snorm",
      [
        82
        /* DXGI_FORMAT_BC5_TYPELESS */
      ]: "bc5-rg-unorm",
      [
        83
        /* DXGI_FORMAT_BC5_UNORM */
      ]: "bc5-rg-unorm",
      [
        84
        /* DXGI_FORMAT_BC5_SNORM */
      ]: "bc5-rg-snorm",
      [
        94
        /* DXGI_FORMAT_BC6H_TYPELESS */
      ]: "bc6h-rgb-ufloat",
      [
        95
        /* DXGI_FORMAT_BC6H_UF16 */
      ]: "bc6h-rgb-ufloat",
      [
        96
        /* DXGI_FORMAT_BC6H_SF16 */
      ]: "bc6h-rgb-float",
      [
        97
        /* DXGI_FORMAT_BC7_TYPELESS */
      ]: "bc7-rgba-unorm",
      [
        98
        /* DXGI_FORMAT_BC7_UNORM */
      ]: "bc7-rgba-unorm",
      [
        99
        /* DXGI_FORMAT_BC7_UNORM_SRGB */
      ]: "bc7-rgba-unorm-srgb",
      [
        28
        /* DXGI_FORMAT_R8G8B8A8_UNORM */
      ]: "rgba8unorm",
      [
        29
        /* DXGI_FORMAT_R8G8B8A8_UNORM_SRGB */
      ]: "rgba8unorm-srgb",
      [
        87
        /* DXGI_FORMAT_B8G8R8A8_UNORM */
      ]: "bgra8unorm",
      [
        91
        /* DXGI_FORMAT_B8G8R8A8_UNORM_SRGB */
      ]: "bgra8unorm-srgb",
      [
        41
        /* DXGI_FORMAT_R32_FLOAT */
      ]: "r32float",
      [
        49
        /* DXGI_FORMAT_R8G8_UNORM */
      ]: "rg8unorm",
      [
        56
        /* DXGI_FORMAT_R16_UNORM */
      ]: "r16uint",
      [
        61
        /* DXGI_FORMAT_R8_UNORM */
      ]: "r8unorm",
      [
        24
        /* DXGI_FORMAT_R10G10B10A2_UNORM */
      ]: "rgb10a2unorm",
      [
        11
        /* DXGI_FORMAT_R16G16B16A16_UNORM */
      ]: "rgba16uint",
      [
        13
        /* DXGI_FORMAT_R16G16B16A16_SNORM */
      ]: "rgba16sint",
      [
        10
        /* DXGI_FORMAT_R16G16B16A16_FLOAT */
      ]: "rgba16float",
      [
        54
        /* DXGI_FORMAT_R16_FLOAT */
      ]: "r16float",
      [
        34
        /* DXGI_FORMAT_R16G16_FLOAT */
      ]: "rg16float",
      [
        16
        /* DXGI_FORMAT_R32G32_FLOAT */
      ]: "rg32float",
      [
        2
        /* DXGI_FORMAT_R32G32B32A32_FLOAT */
      ]: "rgba32float"
    };
    DDS = {
      MAGIC_VALUE: 542327876,
      MAGIC_SIZE: 4,
      HEADER_SIZE: 124,
      HEADER_DX10_SIZE: 20,
      PIXEL_FORMAT_FLAGS: {
        // PIXEL_FORMAT flags
        // https://github.com/Microsoft/DirectXTex/blob/main/DirectXTex/DDS.h
        // https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dds-pixelformat
        ALPHAPIXELS: 1,
        ALPHA: 2,
        FOURCC: 4,
        RGB: 64,
        RGBA: 65,
        YUV: 512,
        LUMINANCE: 131072,
        LUMINANCEA: 131073
      },
      RESOURCE_MISC_TEXTURECUBE: 4,
      HEADER_FIELDS: DDS_HEADER_FIELDS,
      HEADER_DX10_FIELDS: DDS_DX10_FIELDS,
      DXGI_FORMAT,
      D3D10_RESOURCE_DIMENSION,
      D3DFMT
    };
    TEXTURE_FORMAT_BLOCK_SIZE = {
      "bc1-rgba-unorm": 8,
      "bc1-rgba-unorm-srgb": 8,
      "bc2-rgba-unorm": 16,
      "bc2-rgba-unorm-srgb": 16,
      "bc3-rgba-unorm": 16,
      "bc3-rgba-unorm-srgb": 16,
      "bc4-r-unorm": 8,
      "bc4-r-snorm": 8,
      "bc5-rg-unorm": 16,
      "bc5-rg-snorm": 16,
      "bc6h-rgb-ufloat": 16,
      "bc6h-rgb-float": 16,
      "bc7-rgba-unorm": 16,
      "bc7-rgba-unorm-srgb": 16
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.mjs
function parseDDS(arrayBuffer, supportedFormats) {
  const {
    format,
    fourCC,
    width,
    height,
    dataOffset,
    mipmapCount
  } = parseDDSHeader(arrayBuffer);
  if (!supportedFormats.includes(format)) {
    throw new Error(`Unsupported texture format: ${fourCC} ${format}, supported: ${supportedFormats}`);
  }
  if (mipmapCount <= 1) {
    return {
      format,
      width,
      height,
      resource: [new Uint8Array(arrayBuffer, dataOffset)],
      alphaMode: "no-premultiply-alpha"
    };
  }
  const levelBuffers = getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer);
  const textureOptions = {
    format,
    width,
    height,
    resource: levelBuffers,
    alphaMode: "no-premultiply-alpha"
  };
  return textureOptions;
}
function getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer) {
  const levelBuffers = [];
  const blockBytes = TEXTURE_FORMAT_BLOCK_SIZE[format];
  let mipWidth = width;
  let mipHeight = height;
  let offset = dataOffset;
  for (let level = 0; level < mipmapCount; ++level) {
    const alignedWidth = Math.ceil(Math.max(4, mipWidth) / 4) * 4;
    const alignedHeight = Math.ceil(Math.max(4, mipHeight) / 4) * 4;
    const byteLength = blockBytes ? alignedWidth / 4 * alignedHeight / 4 * blockBytes : mipWidth * mipHeight * 4;
    const levelBuffer = new Uint8Array(arrayBuffer, offset, byteLength);
    levelBuffers.push(levelBuffer);
    offset += byteLength;
    mipWidth = Math.max(mipWidth >> 1, 1);
    mipHeight = Math.max(mipHeight >> 1, 1);
  }
  return levelBuffers;
}
function parseDDSHeader(buffer) {
  const header = new Uint32Array(buffer, 0, DDS.HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
  if (header[DDS.HEADER_FIELDS.MAGIC] !== DDS.MAGIC_VALUE) {
    throw new Error("Invalid magic number in DDS header");
  }
  const height = header[DDS.HEADER_FIELDS.HEIGHT];
  const width = header[DDS.HEADER_FIELDS.WIDTH];
  const mipmapCount = Math.max(1, header[DDS.HEADER_FIELDS.MIPMAP_COUNT]);
  const flags = header[DDS.HEADER_FIELDS.PF_FLAGS];
  const fourCC = header[DDS.HEADER_FIELDS.FOURCC];
  const format = getTextureFormat(header, flags, fourCC, buffer);
  const dataOffset = DDS.MAGIC_SIZE + DDS.HEADER_SIZE + (fourCC === DDS.D3DFMT.DX10 ? DDS.HEADER_DX10_SIZE : 0);
  return {
    format,
    fourCC,
    width,
    height,
    dataOffset,
    mipmapCount
  };
}
function getTextureFormat(header, flags, fourCC, buffer) {
  if (flags & DDS.PIXEL_FORMAT_FLAGS.FOURCC) {
    if (fourCC === DDS.D3DFMT.DX10) {
      const dx10Header = new Uint32Array(
        buffer,
        DDS.MAGIC_SIZE + DDS.HEADER_SIZE,
        // there is a 20-byte DDS_HEADER_DX10 after DDS_HEADER
        DDS.HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT
      );
      const miscFlag = dx10Header[DDS.HEADER_DX10_FIELDS.MISC_FLAG];
      if (miscFlag === DDS.RESOURCE_MISC_TEXTURECUBE) {
        throw new Error("DDSParser does not support cubemap textures");
      }
      const resourceDimension = dx10Header[DDS.HEADER_DX10_FIELDS.RESOURCE_DIMENSION];
      if (resourceDimension === DDS.D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {
        throw new Error("DDSParser does not supported 3D texture data");
      }
      const dxgiFormat = dx10Header[DDS.HEADER_DX10_FIELDS.DXGI_FORMAT];
      if (dxgiFormat in DXGI_TO_TEXTURE_FORMAT) {
        return DXGI_TO_TEXTURE_FORMAT[dxgiFormat];
      }
      throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);
    }
    if (fourCC in FOURCC_TO_TEXTURE_FORMAT) {
      return FOURCC_TO_TEXTURE_FORMAT[fourCC];
    }
    throw new Error(`DDSParser cannot parse texture data with fourCC format ${fourCC}`);
  }
  if (flags & DDS.PIXEL_FORMAT_FLAGS.RGB || flags & DDS.PIXEL_FORMAT_FLAGS.RGBA) {
    return getUncompressedTextureFormat(header);
  }
  if (flags & DDS.PIXEL_FORMAT_FLAGS.YUV) {
    throw new Error("DDSParser does not supported YUV uncompressed texture data.");
  }
  if (flags & DDS.PIXEL_FORMAT_FLAGS.LUMINANCE || flags & DDS.PIXEL_FORMAT_FLAGS.LUMINANCEA) {
    throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
  }
  if (flags & DDS.PIXEL_FORMAT_FLAGS.ALPHA || flags & DDS.PIXEL_FORMAT_FLAGS.ALPHAPIXELS) {
    throw new Error("DDSParser does not support single-channel (alpha) texture data!");
  }
  throw new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
function getUncompressedTextureFormat(header) {
  const bitCount = header[DDS.HEADER_FIELDS.RGB_BITCOUNT];
  const rBitMask = header[DDS.HEADER_FIELDS.R_BIT_MASK];
  const gBitMask = header[DDS.HEADER_FIELDS.G_BIT_MASK];
  const bBitMask = header[DDS.HEADER_FIELDS.B_BIT_MASK];
  const aBitMask = header[DDS.HEADER_FIELDS.A_BIT_MASK];
  switch (bitCount) {
    case 32:
      if (rBitMask === 255 && gBitMask === 65280 && bBitMask === 16711680 && aBitMask === 4278190080) {
        return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM];
      }
      if (rBitMask === 16711680 && gBitMask === 65280 && bBitMask === 255 && aBitMask === 4278190080) {
        return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM];
      }
      if (rBitMask === 1072693248 && gBitMask === 1047552 && bBitMask === 1023 && aBitMask === 3221225472) {
        return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM];
      }
      if (rBitMask === 65535 && gBitMask === 4294901760 && bBitMask === 0 && aBitMask === 0) {
        return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM];
      }
      if (rBitMask === 4294967295 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
        return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT];
      }
      break;
    case 24:
      if (rBitMask === 16711680 && gBitMask === 65280 && bBitMask === 255 && aBitMask === 32768) {
      }
      break;
    case 16:
      if (rBitMask === 31744 && gBitMask === 992 && bBitMask === 31 && aBitMask === 32768) {
        return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];
      }
      if (rBitMask === 63488 && gBitMask === 2016 && bBitMask === 31 && aBitMask === 0) {
        return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM];
      }
      if (rBitMask === 3840 && gBitMask === 240 && bBitMask === 15 && aBitMask === 61440) {
        return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM];
      }
      if (rBitMask === 255 && gBitMask === 0 && bBitMask === 0 && aBitMask === 65280) {
        return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM];
      }
      if (rBitMask === 65535 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
        return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM];
      }
      break;
    case 8:
      if (rBitMask === 255 && gBitMask === 0 && bBitMask === 0 && aBitMask === 0) {
        return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM];
      }
      break;
  }
  throw new Error(`DDSParser does not support uncompressed texture with configuration:
                bitCount = ${bitCount}, rBitMask = ${rBitMask}, gBitMask = ${gBitMask}, aBitMask = ${aBitMask}`);
}
var init_parseDDS = __esm({
  "node_modules/pixi.js/lib/compressed-textures/dds/parseDDS.mjs"() {
    init_define_AnParams();
    init_const11();
  }
});

// node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.mjs
var loadDDS;
var init_loadDDS = __esm({
  "node_modules/pixi.js/lib/compressed-textures/dds/loadDDS.mjs"() {
    init_define_AnParams();
    init_LoaderParser();
    init_createTexture();
    init_checkExtension();
    init_Extensions();
    init_CompressedSource();
    init_getSupportedTextureFormats();
    init_parseDDS();
    loadDDS = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.High,
        name: "loadDDS"
      },
      name: "loadDDS",
      test(url) {
        return checkExtension(url, [".dds"]);
      },
      async load(url, _asset, loader) {
        const supportedTextures = await getSupportedTextureFormats();
        const ddsResponse = await fetch(url);
        const ddsArrayBuffer = await ddsResponse.arrayBuffer();
        const textureOptions = parseDDS(ddsArrayBuffer, supportedTextures);
        const compressedTextureSource = new CompressedSource(textureOptions);
        return createTexture(compressedTextureSource, loader, url);
      },
      unload(texture) {
        if (Array.isArray(texture)) {
          texture.forEach((t2) => t2.destroy(true));
        } else {
          texture.destroy(true);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/ktx2/const.mjs
var GL_INTERNAL_FORMAT, INTERNAL_FORMAT_TO_TEXTURE_FORMATS, FILE_IDENTIFIER, FIELDS, FILE_HEADER_SIZE, ENDIANNESS, TYPES_TO_BYTES_PER_COMPONENT, FORMATS_TO_COMPONENTS, TYPES_TO_BYTES_PER_PIXEL, INTERNAL_FORMAT_TO_BYTES_PER_PIXEL, KTX;
var init_const12 = __esm({
  "node_modules/pixi.js/lib/compressed-textures/ktx2/const.mjs"() {
    "use strict";
    init_define_AnParams();
    GL_INTERNAL_FORMAT = /* @__PURE__ */ ((GL_INTERNAL_FORMAT2) => {
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA"] = 6408] = "RGBA";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8UI"] = 36220] = "RGBA8UI";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8I"] = 36238] = "RGBA8I";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["RGBA8"] = 32856] = "RGBA8";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
      GL_INTERNAL_FORMAT2[GL_INTERNAL_FORMAT2["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
      return GL_INTERNAL_FORMAT2;
    })(GL_INTERNAL_FORMAT || {});
    INTERNAL_FORMAT_TO_TEXTURE_FORMATS = {
      [
        33776
        /* COMPRESSED_RGB_S3TC_DXT1_EXT */
      ]: "bc1-rgba-unorm",
      // TODO: ???
      [
        33777
        /* COMPRESSED_RGBA_S3TC_DXT1_EXT */
      ]: "bc1-rgba-unorm",
      [
        33778
        /* COMPRESSED_RGBA_S3TC_DXT3_EXT */
      ]: "bc2-rgba-unorm",
      [
        33779
        /* COMPRESSED_RGBA_S3TC_DXT5_EXT */
      ]: "bc3-rgba-unorm",
      [
        35916
        /* COMPRESSED_SRGB_S3TC_DXT1_EXT */
      ]: "bc1-rgba-unorm-srgb",
      // TODO: ???
      [
        35917
        /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */
      ]: "bc1-rgba-unorm-srgb",
      [
        35918
        /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */
      ]: "bc2-rgba-unorm-srgb",
      [
        35919
        /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */
      ]: "bc3-rgba-unorm-srgb",
      [
        36283
        /* COMPRESSED_RED_RGTC1_EXT */
      ]: "bc4-r-unorm",
      [
        36284
        /* COMPRESSED_SIGNED_RED_RGTC1_EXT */
      ]: "bc4-r-snorm",
      [
        36285
        /* COMPRESSED_RED_GREEN_RGTC2_EXT */
      ]: "bc5-rg-unorm",
      [
        36286
        /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */
      ]: "bc5-rg-snorm",
      [
        37488
        /* COMPRESSED_R11_EAC */
      ]: "eac-r11unorm",
      // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_R11_EAC]: 'eac-r11snorm',
      [
        37490
        /* COMPRESSED_RG11_EAC */
      ]: "eac-rg11snorm",
      // [GL_INTERNAL_FORMAT.COMPRESSED_SIGNED_RG11_EAC]: 'eac-rg11unorm',
      [
        37492
        /* COMPRESSED_RGB8_ETC2 */
      ]: "etc2-rgb8unorm",
      [
        37496
        /* COMPRESSED_RGBA8_ETC2_EAC */
      ]: "etc2-rgba8unorm",
      [
        37493
        /* COMPRESSED_SRGB8_ETC2 */
      ]: "etc2-rgb8unorm-srgb",
      [
        37497
        /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */
      ]: "etc2-rgba8unorm-srgb",
      [
        37494
        /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
      ]: "etc2-rgb8a1unorm",
      [
        37495
        /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
      ]: "etc2-rgb8a1unorm-srgb",
      [
        37808
        /* COMPRESSED_RGBA_ASTC_4x4_KHR */
      ]: "astc-4x4-unorm",
      [
        37840
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */
      ]: "astc-4x4-unorm-srgb",
      [
        37809
        /* COMPRESSED_RGBA_ASTC_5x4_KHR */
      ]: "astc-5x4-unorm",
      [
        37841
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */
      ]: "astc-5x4-unorm-srgb",
      [
        37810
        /* COMPRESSED_RGBA_ASTC_5x5_KHR */
      ]: "astc-5x5-unorm",
      [
        37842
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */
      ]: "astc-5x5-unorm-srgb",
      [
        37811
        /* COMPRESSED_RGBA_ASTC_6x5_KHR */
      ]: "astc-6x5-unorm",
      [
        37843
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */
      ]: "astc-6x5-unorm-srgb",
      [
        37812
        /* COMPRESSED_RGBA_ASTC_6x6_KHR */
      ]: "astc-6x6-unorm",
      [
        37844
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */
      ]: "astc-6x6-unorm-srgb",
      [
        37813
        /* COMPRESSED_RGBA_ASTC_8x5_KHR */
      ]: "astc-8x5-unorm",
      [
        37845
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */
      ]: "astc-8x5-unorm-srgb",
      [
        37814
        /* COMPRESSED_RGBA_ASTC_8x6_KHR */
      ]: "astc-8x6-unorm",
      [
        37846
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */
      ]: "astc-8x6-unorm-srgb",
      [
        37815
        /* COMPRESSED_RGBA_ASTC_8x8_KHR */
      ]: "astc-8x8-unorm",
      [
        37847
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */
      ]: "astc-8x8-unorm-srgb",
      [
        37816
        /* COMPRESSED_RGBA_ASTC_10x5_KHR */
      ]: "astc-10x5-unorm",
      [
        37848
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */
      ]: "astc-10x5-unorm-srgb",
      [
        37817
        /* COMPRESSED_RGBA_ASTC_10x6_KHR */
      ]: "astc-10x6-unorm",
      [
        37849
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */
      ]: "astc-10x6-unorm-srgb",
      [
        37818
        /* COMPRESSED_RGBA_ASTC_10x8_KHR */
      ]: "astc-10x8-unorm",
      [
        37850
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */
      ]: "astc-10x8-unorm-srgb",
      [
        37819
        /* COMPRESSED_RGBA_ASTC_10x10_KHR */
      ]: "astc-10x10-unorm",
      [
        37851
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */
      ]: "astc-10x10-unorm-srgb",
      [
        37820
        /* COMPRESSED_RGBA_ASTC_12x10_KHR */
      ]: "astc-12x10-unorm",
      [
        37852
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */
      ]: "astc-12x10-unorm-srgb",
      [
        37821
        /* COMPRESSED_RGBA_ASTC_12x12_KHR */
      ]: "astc-12x12-unorm",
      [
        37853
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */
      ]: "astc-12x12-unorm-srgb",
      [
        36492
        /* COMPRESSED_RGBA_BPTC_UNORM_EXT */
      ]: "bc7-rgba-unorm",
      [
        36493
        /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */
      ]: "bc7-rgba-unorm-srgb",
      [
        36494
        /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */
      ]: "bc6h-rgb-float",
      [
        36495
        /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */
      ]: "bc6h-rgb-ufloat",
      [
        35907
        /* SRGB8_ALPHA8 */
      ]: "rgba8unorm-srgb",
      [
        36759
        /* RGBA8_SNORM */
      ]: "rgba8snorm",
      [
        36220
        /* RGBA8UI */
      ]: "rgba8uint",
      [
        36238
        /* RGBA8I */
      ]: "rgba8sint",
      [
        6408
        /* RGBA */
      ]: "rgba8unorm"
      // [GL_INTERNAL_FORMAT.RGBA8]: 'bgra8unorm'
    };
    FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
    FIELDS = {
      FILE_IDENTIFIER: 0,
      ENDIANNESS: 12,
      GL_TYPE: 16,
      GL_TYPE_SIZE: 20,
      GL_FORMAT: 24,
      GL_INTERNAL_FORMAT: 28,
      GL_BASE_INTERNAL_FORMAT: 32,
      PIXEL_WIDTH: 36,
      PIXEL_HEIGHT: 40,
      PIXEL_DEPTH: 44,
      NUMBER_OF_ARRAY_ELEMENTS: 48,
      NUMBER_OF_FACES: 52,
      NUMBER_OF_MIPMAP_LEVELS: 56,
      BYTES_OF_KEY_VALUE_DATA: 60
    };
    FILE_HEADER_SIZE = 64;
    ENDIANNESS = 67305985;
    TYPES_TO_BYTES_PER_COMPONENT = {
      [
        5121
        /* UNSIGNED_BYTE */
      ]: 1,
      [
        5123
        /* UNSIGNED_SHORT */
      ]: 2,
      [
        5124
        /* INT */
      ]: 4,
      [
        5125
        /* UNSIGNED_INT */
      ]: 4,
      [
        5126
        /* FLOAT */
      ]: 4,
      [
        36193
        /* HALF_FLOAT */
      ]: 8
    };
    FORMATS_TO_COMPONENTS = {
      [
        6408
        /* RGBA */
      ]: 4,
      [
        6407
        /* RGB */
      ]: 3,
      [
        33319
        /* RG */
      ]: 2,
      [
        6403
        /* RED */
      ]: 1,
      [
        6409
        /* LUMINANCE */
      ]: 1,
      [
        6410
        /* LUMINANCE_ALPHA */
      ]: 2,
      [
        6406
        /* ALPHA */
      ]: 1
    };
    TYPES_TO_BYTES_PER_PIXEL = {
      [
        32819
        /* UNSIGNED_SHORT_4_4_4_4 */
      ]: 2,
      [
        32820
        /* UNSIGNED_SHORT_5_5_5_1 */
      ]: 2,
      [
        33635
        /* UNSIGNED_SHORT_5_6_5 */
      ]: 2
    };
    INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
      [
        33776
        /* COMPRESSED_RGB_S3TC_DXT1_EXT */
      ]: 0.5,
      [
        33777
        /* COMPRESSED_RGBA_S3TC_DXT1_EXT */
      ]: 0.5,
      [
        33778
        /* COMPRESSED_RGBA_S3TC_DXT3_EXT */
      ]: 1,
      [
        33779
        /* COMPRESSED_RGBA_S3TC_DXT5_EXT */
      ]: 1,
      [
        35916
        /* COMPRESSED_SRGB_S3TC_DXT1_EXT */
      ]: 0.5,
      [
        35917
        /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */
      ]: 0.5,
      [
        35918
        /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */
      ]: 1,
      [
        35919
        /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */
      ]: 1,
      [
        36283
        /* COMPRESSED_RED_RGTC1_EXT */
      ]: 0.5,
      [
        36284
        /* COMPRESSED_SIGNED_RED_RGTC1_EXT */
      ]: 0.5,
      [
        36285
        /* COMPRESSED_RED_GREEN_RGTC2_EXT */
      ]: 1,
      [
        36286
        /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */
      ]: 1,
      [
        37488
        /* COMPRESSED_R11_EAC */
      ]: 0.5,
      [
        37489
        /* COMPRESSED_SIGNED_R11_EAC */
      ]: 0.5,
      [
        37490
        /* COMPRESSED_RG11_EAC */
      ]: 1,
      [
        37491
        /* COMPRESSED_SIGNED_RG11_EAC */
      ]: 1,
      [
        37492
        /* COMPRESSED_RGB8_ETC2 */
      ]: 0.5,
      [
        37496
        /* COMPRESSED_RGBA8_ETC2_EAC */
      ]: 1,
      [
        37493
        /* COMPRESSED_SRGB8_ETC2 */
      ]: 0.5,
      [
        37497
        /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */
      ]: 1,
      [
        37494
        /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
      ]: 0.5,
      [
        37495
        /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */
      ]: 0.5,
      [
        37808
        /* COMPRESSED_RGBA_ASTC_4x4_KHR */
      ]: 1,
      [
        37840
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */
      ]: 1,
      [
        37809
        /* COMPRESSED_RGBA_ASTC_5x4_KHR */
      ]: 0.8,
      [
        37841
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */
      ]: 0.8,
      [
        37810
        /* COMPRESSED_RGBA_ASTC_5x5_KHR */
      ]: 0.64,
      [
        37842
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */
      ]: 0.64,
      [
        37811
        /* COMPRESSED_RGBA_ASTC_6x5_KHR */
      ]: 0.53375,
      [
        37843
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */
      ]: 0.53375,
      [
        37812
        /* COMPRESSED_RGBA_ASTC_6x6_KHR */
      ]: 0.445,
      [
        37844
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */
      ]: 0.445,
      [
        37813
        /* COMPRESSED_RGBA_ASTC_8x5_KHR */
      ]: 0.4,
      [
        37845
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */
      ]: 0.4,
      [
        37814
        /* COMPRESSED_RGBA_ASTC_8x6_KHR */
      ]: 0.33375,
      [
        37846
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */
      ]: 0.33375,
      [
        37815
        /* COMPRESSED_RGBA_ASTC_8x8_KHR */
      ]: 0.25,
      [
        37847
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */
      ]: 0.25,
      [
        37816
        /* COMPRESSED_RGBA_ASTC_10x5_KHR */
      ]: 0.32,
      [
        37848
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */
      ]: 0.32,
      [
        37817
        /* COMPRESSED_RGBA_ASTC_10x6_KHR */
      ]: 0.26625,
      [
        37849
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */
      ]: 0.26625,
      [
        37818
        /* COMPRESSED_RGBA_ASTC_10x8_KHR */
      ]: 0.2,
      [
        37850
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */
      ]: 0.2,
      [
        37819
        /* COMPRESSED_RGBA_ASTC_10x10_KHR */
      ]: 0.16,
      [
        37851
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */
      ]: 0.16,
      [
        37820
        /* COMPRESSED_RGBA_ASTC_12x10_KHR */
      ]: 0.13375,
      [
        37852
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */
      ]: 0.13375,
      [
        37821
        /* COMPRESSED_RGBA_ASTC_12x12_KHR */
      ]: 0.11125,
      [
        37853
        /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */
      ]: 0.11125,
      [
        36492
        /* COMPRESSED_RGBA_BPTC_UNORM_EXT */
      ]: 1,
      [
        36493
        /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */
      ]: 1,
      [
        36494
        /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */
      ]: 1,
      [
        36495
        /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */
      ]: 1
    };
    KTX = {
      FILE_HEADER_SIZE,
      FILE_IDENTIFIER,
      FORMATS_TO_COMPONENTS,
      INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,
      INTERNAL_FORMAT_TO_TEXTURE_FORMATS,
      FIELDS,
      TYPES_TO_BYTES_PER_COMPONENT,
      TYPES_TO_BYTES_PER_PIXEL,
      ENDIANNESS
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.mjs
function parseKTX(arrayBuffer, supportedFormats) {
  const dataView = new DataView(arrayBuffer);
  if (!validate(dataView)) {
    throw new Error("Invalid KTX identifier in header");
  }
  const {
    littleEndian,
    glType,
    glFormat,
    glInternalFormat,
    pixelWidth,
    pixelHeight,
    numberOfMipmapLevels,
    offset
  } = parseKTXHeader(dataView);
  const textureFormat = KTX.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[glInternalFormat];
  if (!textureFormat) {
    throw new Error(`Unknown texture format ${glInternalFormat}`);
  }
  if (!supportedFormats.includes(textureFormat)) {
    throw new Error(`Unsupported texture format: ${textureFormat}, supportedFormats: ${supportedFormats}`);
  }
  const imagePixelByteSize = getImagePixelByteSize(glType, glFormat, glInternalFormat);
  const imageBuffers = getImageBuffers(
    dataView,
    glType,
    imagePixelByteSize,
    pixelWidth,
    pixelHeight,
    offset,
    numberOfMipmapLevels,
    littleEndian
  );
  return {
    format: textureFormat,
    width: pixelWidth,
    height: pixelHeight,
    resource: imageBuffers,
    alphaMode: "no-premultiply-alpha"
  };
}
function getImageBuffers(dataView, glType, imagePixelByteSize, pixelWidth, pixelHeight, offset, numberOfMipmapLevels, littleEndian) {
  const alignedWidth = pixelWidth + 3 & ~3;
  const alignedHeight = pixelHeight + 3 & ~3;
  let imagePixels = pixelWidth * pixelHeight;
  if (glType === 0) {
    imagePixels = alignedWidth * alignedHeight;
  }
  let mipByteSize = imagePixels * imagePixelByteSize;
  let mipWidth = pixelWidth;
  let mipHeight = pixelHeight;
  let alignedMipWidth = alignedWidth;
  let alignedMipHeight = alignedHeight;
  let imageOffset = offset;
  const imageBuffers = new Array(numberOfMipmapLevels);
  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
    const imageSize = dataView.getUint32(imageOffset, littleEndian);
    let elementOffset = imageOffset + 4;
    imageBuffers[mipmapLevel] = new Uint8Array(dataView.buffer, elementOffset, mipByteSize);
    elementOffset += mipByteSize;
    imageOffset += imageSize + 4;
    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
    mipWidth = mipWidth >> 1 || 1;
    mipHeight = mipHeight >> 1 || 1;
    alignedMipWidth = mipWidth + 4 - 1 & ~(4 - 1);
    alignedMipHeight = mipHeight + 4 - 1 & ~(4 - 1);
    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
  }
  return imageBuffers;
}
function getImagePixelByteSize(glType, glFormat, glInternalFormat) {
  let imagePixelByteSize = KTX.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
  if (glType !== 0) {
    if (KTX.TYPES_TO_BYTES_PER_COMPONENT[glType]) {
      imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_COMPONENT[glType] * KTX.FORMATS_TO_COMPONENTS[glFormat];
    } else {
      imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_PIXEL[glType];
    }
  }
  if (imagePixelByteSize === void 0) {
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  }
  return imagePixelByteSize;
}
function parseKTXHeader(dataView) {
  const littleEndian = dataView.getUint32(KTX.FIELDS.ENDIANNESS, true) === KTX.ENDIANNESS;
  const glType = dataView.getUint32(KTX.FIELDS.GL_TYPE, littleEndian);
  const glFormat = dataView.getUint32(KTX.FIELDS.GL_FORMAT, littleEndian);
  const glInternalFormat = dataView.getUint32(KTX.FIELDS.GL_INTERNAL_FORMAT, littleEndian);
  const pixelWidth = dataView.getUint32(KTX.FIELDS.PIXEL_WIDTH, littleEndian);
  const pixelHeight = dataView.getUint32(KTX.FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
  const pixelDepth = dataView.getUint32(KTX.FIELDS.PIXEL_DEPTH, littleEndian) || 1;
  const numberOfArrayElements = dataView.getUint32(KTX.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
  const numberOfFaces = dataView.getUint32(KTX.FIELDS.NUMBER_OF_FACES, littleEndian);
  const numberOfMipmapLevels = dataView.getUint32(KTX.FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
  const bytesOfKeyValueData = dataView.getUint32(KTX.FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
  if (pixelHeight === 0 || pixelDepth !== 1) {
    throw new Error("Only 2D textures are supported");
  }
  if (numberOfFaces !== 1) {
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  }
  if (numberOfArrayElements !== 1) {
    throw new Error("WebGL does not support array textures");
  }
  return {
    littleEndian,
    glType,
    glFormat,
    glInternalFormat,
    pixelWidth,
    pixelHeight,
    numberOfMipmapLevels,
    offset: KTX.FILE_HEADER_SIZE + bytesOfKeyValueData
  };
}
function validate(dataView) {
  for (let i3 = 0; i3 < KTX.FILE_IDENTIFIER.length; i3++) {
    if (dataView.getUint8(i3) !== KTX.FILE_IDENTIFIER[i3]) {
      return false;
    }
  }
  return true;
}
var init_parseKTX = __esm({
  "node_modules/pixi.js/lib/compressed-textures/ktx/parseKTX.mjs"() {
    init_define_AnParams();
    init_const12();
  }
});

// node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.mjs
var loadKTX;
var init_loadKTX = __esm({
  "node_modules/pixi.js/lib/compressed-textures/ktx/loadKTX.mjs"() {
    init_define_AnParams();
    init_LoaderParser();
    init_createTexture();
    init_checkExtension();
    init_Extensions();
    init_CompressedSource();
    init_getSupportedTextureFormats();
    init_parseKTX();
    loadKTX = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.High,
        name: "loadKTX"
      },
      name: "loadKTX",
      test(url) {
        return checkExtension(url, ".ktx");
      },
      async load(url, _asset, loader) {
        const supportedTextures = await getSupportedTextureFormats();
        const ktxResponse = await fetch(url);
        const ktxArrayBuffer = await ktxResponse.arrayBuffer();
        const textureOptions = parseKTX(ktxArrayBuffer, supportedTextures);
        const compressedTextureSource = new CompressedSource(textureOptions);
        return createTexture(compressedTextureSource, loader, url);
      },
      unload(texture) {
        if (Array.isArray(texture)) {
          texture.forEach((t2) => t2.destroy(true));
        } else {
          texture.destroy(true);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/_virtual/ktx.worker.mjs
var WORKER_CODE4, WORKER_URL4, WorkerInstance4;
var init_ktx_worker = __esm({
  "node_modules/pixi.js/lib/_virtual/ktx.worker.mjs"() {
    init_define_AnParams();
    WORKER_CODE4 = '(function () {\n    \'use strict\';\n\n    const converters = {\n      rgb8unorm: {\n        convertedFormat: "rgba8unorm",\n        convertFunction: convertRGBtoRGBA\n      },\n      "rgb8unorm-srgb": {\n        convertedFormat: "rgba8unorm-srgb",\n        convertFunction: convertRGBtoRGBA\n      }\n    };\n    function convertFormatIfRequired(textureOptions) {\n      const format = textureOptions.format;\n      if (converters[format]) {\n        const convertFunction = converters[format].convertFunction;\n        const levelBuffers = textureOptions.resource;\n        for (let i = 0; i < levelBuffers.length; i++) {\n          levelBuffers[i] = convertFunction(levelBuffers[i]);\n        }\n        textureOptions.format = converters[format].convertedFormat;\n      }\n    }\n    function convertRGBtoRGBA(levelBuffer) {\n      const pixelCount = levelBuffer.byteLength / 3;\n      const levelBufferWithAlpha = new Uint32Array(pixelCount);\n      for (let i = 0; i < pixelCount; ++i) {\n        levelBufferWithAlpha[i] = levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] << 8) + (levelBuffer[i * 3 + 2] << 16) + 4278190080;\n      }\n      return new Uint8Array(levelBufferWithAlpha.buffer);\n    }\n\n    function createLevelBuffersFromKTX(ktxTexture) {\n      const levelBuffers = [];\n      for (let i = 0; i < ktxTexture.numLevels; i++) {\n        const imageData = ktxTexture.getImageData(i, 0, 0);\n        const levelBuffer = new Uint8Array(imageData.byteLength);\n        levelBuffer.set(imageData);\n        levelBuffers.push(levelBuffer);\n      }\n      return levelBuffers;\n    }\n\n    const glFormatToGPUFormatMap = {\n      6408: "rgba8unorm",\n      32856: "bgra8unorm",\n      //\n      32857: "rgb10a2unorm",\n      33189: "depth16unorm",\n      33190: "depth24plus",\n      33321: "r8unorm",\n      33323: "rg8unorm",\n      33325: "r16float",\n      33326: "r32float",\n      33327: "rg16float",\n      33328: "rg32float",\n      33329: "r8sint",\n      33330: "r8uint",\n      33331: "r16sint",\n      33332: "r16uint",\n      33333: "r32sint",\n      33334: "r32uint",\n      33335: "rg8sint",\n      33336: "rg8uint",\n      33337: "rg16sint",\n      33338: "rg16uint",\n      33339: "rg32sint",\n      33340: "rg32uint",\n      33778: "bc2-rgba-unorm",\n      33779: "bc3-rgba-unorm",\n      34836: "rgba32float",\n      34842: "rgba16float",\n      35056: "depth24plus-stencil8",\n      35898: "rg11b10ufloat",\n      35901: "rgb9e5ufloat",\n      35907: "rgba8unorm-srgb",\n      // bgra8unorm-srgb\n      36012: "depth32float",\n      36013: "depth32float-stencil8",\n      36168: "stencil8",\n      36208: "rgba32uint",\n      36214: "rgba16uint",\n      36220: "rgba8uint",\n      36226: "rgba32sint",\n      36232: "rgba16sint",\n      36238: "rgba8sint",\n      36492: "bc7-rgba-unorm",\n      36756: "r8snorm",\n      36757: "rg8snorm",\n      36759: "rgba8snorm",\n      37496: "etc2-rgba8unorm",\n      37808: "astc-4x4-unorm"\n    };\n    function glFormatToGPUFormat(glInternalFormat) {\n      const format = glFormatToGPUFormatMap[glInternalFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);\n    }\n\n    const vkFormatToGPUFormatMap = {\n      23: "rgb8unorm",\n      // VK_FORMAT_R8G8B8_UNORM\n      37: "rgba8unorm",\n      // VK_FORMAT_R8G8B8A8_UNORM\n      43: "rgba8unorm-srgb"\n      // VK_FORMAT_R8G8B8A8_SRGB\n      // TODO add more!\n    };\n    function vkFormatToGPUFormat(vkFormat) {\n      const format = vkFormatToGPUFormatMap[vkFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported VkFormat: ${vkFormat}`);\n    }\n\n    function getTextureFormatFromKTXTexture(ktxTexture) {\n      if (ktxTexture.classId === 2) {\n        return vkFormatToGPUFormat(ktxTexture.vkFormat);\n      }\n      return glFormatToGPUFormat(ktxTexture.glInternalformat);\n    }\n\n    const gpuFormatToBasisTranscoderFormatMap = {\n      "bc3-rgba-unorm": "BC3_RGBA",\n      "bc7-rgba-unorm": "BC7_M5_RGBA",\n      "etc2-rgba8unorm": "ETC2_RGBA",\n      "astc-4x4-unorm": "ASTC_4x4_RGBA",\n      // Uncompressed\n      rgba8unorm: "RGBA32",\n      rg11b10ufloat: "R11F_G11F_B10F"\n    };\n    function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {\n      const format = gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n    }\n\n    const settings = {\n      jsUrl: "",\n      wasmUrl: ""\n    };\n    let basisTranscoderFormat;\n    let basisTranscodedTextureFormat;\n    let ktxPromise;\n    async function getKTX() {\n      if (!ktxPromise) {\n        const absoluteJsUrl = new URL(settings.jsUrl, location.origin).href;\n        const absoluteWasmUrl = new URL(settings.wasmUrl, location.origin).href;\n        importScripts(absoluteJsUrl);\n        ktxPromise = new Promise((resolve) => {\n          LIBKTX({\n            locateFile: (_file) => absoluteWasmUrl\n          }).then((libktx) => {\n            resolve(libktx);\n          });\n        });\n      }\n      return ktxPromise;\n    }\n    async function fetchKTXTexture(url, ktx) {\n      const ktx2Response = await fetch(url);\n      if (ktx2Response.ok) {\n        const ktx2ArrayBuffer = await ktx2Response.arrayBuffer();\n        return new ktx.ktxTexture(new Uint8Array(ktx2ArrayBuffer));\n      }\n      throw new Error(`Failed to load KTX(2) texture: ${url}`);\n    }\n    const preferredTranscodedFormat = [\n      "bc7-rgba-unorm",\n      "astc-4x4-unorm",\n      "etc2-rgba8unorm",\n      "bc3-rgba-unorm",\n      "rgba8unorm"\n    ];\n    async function load(url) {\n      const ktx = await getKTX();\n      const ktxTexture = await fetchKTXTexture(url, ktx);\n      let format;\n      if (ktxTexture.needsTranscoding) {\n        format = basisTranscodedTextureFormat;\n        const transcodeFormat = ktx.TranscodeTarget[basisTranscoderFormat];\n        const result = ktxTexture.transcodeBasis(transcodeFormat, 0);\n        if (result !== ktx.ErrorCode.SUCCESS) {\n          throw new Error("Unable to transcode basis texture.");\n        }\n      } else {\n        format = getTextureFormatFromKTXTexture(ktxTexture);\n      }\n      const levelBuffers = createLevelBuffersFromKTX(ktxTexture);\n      const textureOptions = {\n        width: ktxTexture.baseWidth,\n        height: ktxTexture.baseHeight,\n        format,\n        mipLevelCount: ktxTexture.numLevels,\n        resource: levelBuffers,\n        alphaMode: "no-premultiply-alpha"\n      };\n      convertFormatIfRequired(textureOptions);\n      return textureOptions;\n    }\n    async function init(jsUrl, wasmUrl, supportedTextures) {\n      if (jsUrl)\n        settings.jsUrl = jsUrl;\n      if (wasmUrl)\n        settings.wasmUrl = wasmUrl;\n      basisTranscodedTextureFormat = preferredTranscodedFormat.filter((format) => supportedTextures.includes(format))[0];\n      basisTranscoderFormat = gpuFormatToKTXBasisTranscoderFormat(basisTranscodedTextureFormat);\n      await getKTX();\n    }\n    const messageHandlers = {\n      init: async (data) => {\n        const { jsUrl, wasmUrl, supportedTextures } = data;\n        await init(jsUrl, wasmUrl, supportedTextures);\n      },\n      load: async (data) => {\n        try {\n          const textureOptions = await load(data.url);\n          return {\n            type: "load",\n            url: data.url,\n            success: true,\n            textureOptions,\n            transferables: textureOptions.resource?.map((arr) => arr.buffer)\n          };\n        } catch (e) {\n          throw e;\n        }\n      }\n    };\n    self.onmessage = async (messageEvent) => {\n      const message = messageEvent.data;\n      const response = await messageHandlers[message.type]?.(message);\n      if (response) {\n        self.postMessage(response, response.transferables);\n      }\n    };\n\n})();\n';
    WORKER_URL4 = null;
    WorkerInstance4 = class {
      constructor() {
        if (!WORKER_URL4) {
          WORKER_URL4 = URL.createObjectURL(new Blob([WORKER_CODE4], { type: "application/javascript" }));
        }
        this.worker = new Worker(WORKER_URL4);
      }
    };
    WorkerInstance4.revokeObjectURL = function revokeObjectURL4() {
      if (WORKER_URL4) {
        URL.revokeObjectURL(WORKER_URL4);
        WORKER_URL4 = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs
function setKTXTranscoderPath(config2) {
  Object.assign(ktxTranscoderUrls, config2);
}
var ktxTranscoderUrls;
var init_setKTXTranscoderPath = __esm({
  "node_modules/pixi.js/lib/compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs"() {
    "use strict";
    init_define_AnParams();
    ktxTranscoderUrls = {
      jsUrl: "https://files.pixijs.download/transcoders/ktx/libktx.js",
      wasmUrl: "https://files.pixijs.download/transcoders/ktx/libktx.wasm"
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.mjs
function getKTX2Worker(supportedTextures) {
  if (!ktxWorker) {
    ktxWorker = new WorkerInstance4().worker;
    ktxWorker.onmessage = (messageEvent) => {
      const { success, url, textureOptions } = messageEvent.data;
      if (!success) {
        console.warn("Failed to load KTX texture", url);
      }
      urlHash2[url](textureOptions);
    };
    ktxWorker.postMessage({
      type: "init",
      jsUrl: ktxTranscoderUrls.jsUrl,
      wasmUrl: ktxTranscoderUrls.wasmUrl,
      supportedTextures
    });
  }
  return ktxWorker;
}
function loadKTX2onWorker(url, supportedTextures) {
  const ktxWorker2 = getKTX2Worker(supportedTextures);
  return new Promise((resolve) => {
    urlHash2[url] = resolve;
    ktxWorker2.postMessage({ type: "load", url });
  });
}
var ktxWorker, urlHash2;
var init_loadKTX2onWorker = __esm({
  "node_modules/pixi.js/lib/compressed-textures/ktx2/worker/loadKTX2onWorker.mjs"() {
    init_define_AnParams();
    init_ktx_worker();
    init_setKTXTranscoderPath();
    urlHash2 = {};
  }
});

// node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.mjs
var loadKTX2;
var init_loadKTX2 = __esm({
  "node_modules/pixi.js/lib/compressed-textures/ktx2/loadKTX2.mjs"() {
    init_define_AnParams();
    init_LoaderParser();
    init_createTexture();
    init_checkExtension();
    init_Extensions();
    init_CompressedSource();
    init_getSupportedTextureFormats();
    init_loadKTX2onWorker();
    loadKTX2 = {
      extension: {
        type: ExtensionType.LoadParser,
        priority: LoaderParserPriority.High,
        name: "loadKTX2"
      },
      name: "loadKTX2",
      test(url) {
        return checkExtension(url, ".ktx2");
      },
      async load(url, _asset, loader) {
        const supportedTextures = await getSupportedTextureFormats();
        const textureOptions = await loadKTX2onWorker(url, supportedTextures);
        const compressedTextureSource = new CompressedSource(textureOptions);
        return createTexture(compressedTextureSource, loader, url);
      },
      async unload(texture) {
        if (Array.isArray(texture)) {
          texture.forEach((t2) => t2.destroy(true));
        } else {
          texture.destroy(true);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.mjs
function convertFormatIfRequired(textureOptions) {
  const format = textureOptions.format;
  if (converters[format]) {
    const convertFunction = converters[format].convertFunction;
    const levelBuffers = textureOptions.resource;
    for (let i3 = 0; i3 < levelBuffers.length; i3++) {
      levelBuffers[i3] = convertFunction(levelBuffers[i3]);
    }
    textureOptions.format = converters[format].convertedFormat;
  }
}
function convertRGBtoRGBA(levelBuffer) {
  const pixelCount = levelBuffer.byteLength / 3;
  const levelBufferWithAlpha = new Uint32Array(pixelCount);
  for (let i3 = 0; i3 < pixelCount; ++i3) {
    levelBufferWithAlpha[i3] = levelBuffer[i3 * 3] + (levelBuffer[i3 * 3 + 1] << 8) + (levelBuffer[i3 * 3 + 2] << 16) + 4278190080;
  }
  return new Uint8Array(levelBufferWithAlpha.buffer);
}
var converters;
var init_convertFormatIfRequired = __esm({
  "node_modules/pixi.js/lib/compressed-textures/ktx2/utils/convertFormatIfRequired.mjs"() {
    "use strict";
    init_define_AnParams();
    converters = {
      rgb8unorm: {
        convertedFormat: "rgba8unorm",
        convertFunction: convertRGBtoRGBA
      },
      "rgb8unorm-srgb": {
        convertedFormat: "rgba8unorm-srgb",
        convertFunction: convertRGBtoRGBA
      }
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs
function createLevelBuffersFromKTX(ktxTexture) {
  const levelBuffers = [];
  for (let i3 = 0; i3 < ktxTexture.numLevels; i3++) {
    const imageData = ktxTexture.getImageData(i3, 0, 0);
    const levelBuffer = new Uint8Array(imageData.byteLength);
    levelBuffer.set(imageData);
    levelBuffers.push(levelBuffer);
  }
  return levelBuffers;
}
var init_createLevelBuffersFromKTX = __esm({
  "node_modules/pixi.js/lib/compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs
function glFormatToGPUFormat(glInternalFormat) {
  const format = glFormatToGPUFormatMap[glInternalFormat];
  if (format) {
    return format;
  }
  throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);
}
var glFormatToGPUFormatMap;
var init_glFormatToGPUFormat = __esm({
  "node_modules/pixi.js/lib/compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs"() {
    "use strict";
    init_define_AnParams();
    glFormatToGPUFormatMap = {
      6408: "rgba8unorm",
      32856: "bgra8unorm",
      //
      32857: "rgb10a2unorm",
      33189: "depth16unorm",
      33190: "depth24plus",
      33321: "r8unorm",
      33323: "rg8unorm",
      33325: "r16float",
      33326: "r32float",
      33327: "rg16float",
      33328: "rg32float",
      33329: "r8sint",
      33330: "r8uint",
      33331: "r16sint",
      33332: "r16uint",
      33333: "r32sint",
      33334: "r32uint",
      33335: "rg8sint",
      33336: "rg8uint",
      33337: "rg16sint",
      33338: "rg16uint",
      33339: "rg32sint",
      33340: "rg32uint",
      33778: "bc2-rgba-unorm",
      33779: "bc3-rgba-unorm",
      34836: "rgba32float",
      34842: "rgba16float",
      35056: "depth24plus-stencil8",
      35898: "rg11b10ufloat",
      35901: "rgb9e5ufloat",
      35907: "rgba8unorm-srgb",
      // bgra8unorm-srgb
      36012: "depth32float",
      36013: "depth32float-stencil8",
      36168: "stencil8",
      36208: "rgba32uint",
      36214: "rgba16uint",
      36220: "rgba8uint",
      36226: "rgba32sint",
      36232: "rgba16sint",
      36238: "rgba8sint",
      36492: "bc7-rgba-unorm",
      36756: "r8snorm",
      36757: "rg8snorm",
      36759: "rgba8snorm",
      37496: "etc2-rgba8unorm",
      37808: "astc-4x4-unorm"
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs
function vkFormatToGPUFormat(vkFormat) {
  const format = vkFormatToGPUFormatMap[vkFormat];
  if (format) {
    return format;
  }
  throw new Error(`Unsupported VkFormat: ${vkFormat}`);
}
var vkFormatToGPUFormatMap;
var init_vkFormatToGPUFormat = __esm({
  "node_modules/pixi.js/lib/compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs"() {
    "use strict";
    init_define_AnParams();
    vkFormatToGPUFormatMap = {
      23: "rgb8unorm",
      // VK_FORMAT_R8G8B8_UNORM
      37: "rgba8unorm",
      // VK_FORMAT_R8G8B8A8_UNORM
      43: "rgba8unorm-srgb"
      // VK_FORMAT_R8G8B8A8_SRGB
      // TODO add more!
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs
function getTextureFormatFromKTXTexture(ktxTexture) {
  if (ktxTexture.classId === 2) {
    return vkFormatToGPUFormat(ktxTexture.vkFormat);
  }
  return glFormatToGPUFormat(ktxTexture.glInternalformat);
}
var init_getTextureFormatFromKTXTexture = __esm({
  "node_modules/pixi.js/lib/compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs"() {
    init_define_AnParams();
    init_glFormatToGPUFormat();
    init_vkFormatToGPUFormat();
  }
});

// node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs
function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {
  const format = gpuFormatToBasisTranscoderFormatMap2[transcoderFormat];
  if (format) {
    return format;
  }
  throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);
}
var gpuFormatToBasisTranscoderFormatMap2;
var init_gpuFormatToKTXBasisTranscoderFormat = __esm({
  "node_modules/pixi.js/lib/compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs"() {
    "use strict";
    init_define_AnParams();
    gpuFormatToBasisTranscoderFormatMap2 = {
      "bc3-rgba-unorm": "BC3_RGBA",
      "bc7-rgba-unorm": "BC7_M5_RGBA",
      "etc2-rgba8unorm": "ETC2_RGBA",
      "astc-4x4-unorm": "ASTC_4x4_RGBA",
      // Uncompressed
      rgba8unorm: "RGBA32",
      rg11b10ufloat: "R11F_G11F_B10F"
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.mjs
var validFormats, resolveCompressedTextureUrl;
var init_resolveCompressedTextureUrl = __esm({
  "node_modules/pixi.js/lib/compressed-textures/shared/resolveCompressedTextureUrl.mjs"() {
    init_define_AnParams();
    init_Resolver();
    init_checkExtension();
    init_Extensions();
    validFormats = ["basis", "bc7", "bc6h", "astc", "etc2", "bc5", "bc4", "bc3", "bc2", "bc1", "eac"];
    resolveCompressedTextureUrl = {
      extension: ExtensionType.ResolveParser,
      test: (value) => checkExtension(value, [".ktx", ".ktx2", ".dds"]),
      parse: (value) => {
        let format;
        const splitValue = value.split(".");
        if (splitValue.length > 2) {
          const newFormat = splitValue[splitValue.length - 2];
          if (validFormats.includes(newFormat)) {
            format = newFormat;
          }
        } else {
          format = splitValue[splitValue.length - 1];
        }
        return {
          resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
          format,
          src: value
        };
      }
    };
  }
});

// node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.mjs
function extractExtensionsForCompressedTextureFormats(formats) {
  const extensions2 = ["basis"];
  const dupeMap = {};
  formats.forEach((format) => {
    const extension = format.split("-")[0];
    if (extension && !dupeMap[extension]) {
      dupeMap[extension] = true;
      extensions2.push(extension);
    }
  });
  extensions2.sort((a2, b3) => {
    const aIndex = validFormats.indexOf(a2);
    const bIndex = validFormats.indexOf(b3);
    if (aIndex === -1) {
      return 1;
    }
    if (bIndex === -1) {
      return -1;
    }
    return aIndex - bIndex;
  });
  return extensions2;
}
var compressedTextureExtensions, detectCompressed;
var init_detectCompressed = __esm({
  "node_modules/pixi.js/lib/compressed-textures/shared/detectCompressed.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_getSupportedCompressedTextureFormats();
    init_isWebGLSupported();
    init_isWebGPUSupported();
    init_resolveCompressedTextureUrl();
    detectCompressed = {
      extension: {
        type: ExtensionType.DetectionParser,
        priority: 2
      },
      test: async () => {
        if (await isWebGPUSupported())
          return true;
        if (isWebGLSupported())
          return true;
        return false;
      },
      add: async (formats) => {
        const supportedCompressedTextureFormats2 = await getSupportedCompressedTextureFormats();
        compressedTextureExtensions = extractExtensionsForCompressedTextureFormats(supportedCompressedTextureFormats2);
        return [...compressedTextureExtensions, ...formats];
      },
      remove: async (formats) => {
        if (compressedTextureExtensions) {
          return formats.filter((f2) => !(f2 in compressedTextureExtensions));
        }
        return formats;
      }
    };
  }
});

// node_modules/pixi.js/lib/culling/Culler.mjs
var tempBounds5, _Culler, Culler;
var init_Culler = __esm({
  "node_modules/pixi.js/lib/culling/Culler.mjs"() {
    init_define_AnParams();
    init_Bounds();
    init_getGlobalBounds();
    tempBounds5 = new Bounds();
    _Culler = class _Culler2 {
      /**
       * Culls the children of a specific container based on the given view. This will also cull items that are not
       * being explicitly managed by the culler.
       * @param container - The container to cull.
       * @param view - The view rectangle.
       * @param skipUpdateTransform - Whether to skip updating the transform.
       */
      cull(container, view, skipUpdateTransform = true) {
        this._cullRecursive(container, view, skipUpdateTransform);
      }
      _cullRecursive(container, view, skipUpdateTransform = true) {
        if (container.cullable && container.measurable && container.includeInBuild) {
          const bounds = container.cullArea ?? getGlobalBounds(container, skipUpdateTransform, tempBounds5);
          container.culled = bounds.x >= view.x + view.width || bounds.y >= view.y + view.height || bounds.x + bounds.width <= view.x || bounds.y + bounds.height <= view.y;
        } else {
          container.culled = false;
        }
        if (!container.cullableChildren || container.culled || !container.renderable || !container.measurable || !container.includeInBuild)
          return;
        for (let i3 = 0; i3 < container.children.length; i3++) {
          this._cullRecursive(container.children[i3], view, skipUpdateTransform);
        }
      }
    };
    _Culler.shared = new _Culler();
    Culler = _Culler;
  }
});

// node_modules/pixi.js/lib/culling/CullerPlugin.mjs
var CullerPlugin;
var init_CullerPlugin = __esm({
  "node_modules/pixi.js/lib/culling/CullerPlugin.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_Culler();
    CullerPlugin = class {
      static init() {
        this._renderRef = this.render.bind(this);
        this.render = () => {
          Culler.shared.cull(this.stage, this.renderer.screen);
          this.renderer.render({ container: this.stage });
        };
      }
      static destroy() {
        this.render = this._renderRef;
      }
    };
    CullerPlugin.extension = {
      priority: 10,
      type: ExtensionType.Application,
      name: "culler"
    };
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports) {
    "use strict";
    init_define_AnParams();
    function find(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i3 = 0; i3 < list.length; i3++) {
        if (Object.prototype.hasOwnProperty.call(list, i3)) {
          var item = list[i3];
          if (predicate.call(void 0, item, i3, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    function assign(target, source9) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source9) {
        if (Object.prototype.hasOwnProperty.call(source9, key)) {
          target[key] = source9[key];
        }
      }
      return target;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports.assign = assign;
    exports.find = find;
    exports.freeze = freeze;
    exports.MIME_TYPE = MIME_TYPE;
    exports.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports) {
    init_define_AnParams();
    var conventions = require_conventions();
    var find = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input) return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p2 in src) {
        if (Object.prototype.hasOwnProperty.call(src, p2)) {
          dest[p2] = src[p2];
        }
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t3 = function() {
        };
        var t2 = t3;
        ;
        t3.prototype = Super.prototype;
        t3 = new t3();
        copy(pt, t3);
        Class.prototype = pt = t3;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message) this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i3 = 0; i3 < this.length; i3++) {
          serializeToString(this[i3], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i3 = ls.length; i3 in list; i3++) {
            if (Object.prototype.hasOwnProperty.call(list, i3)) {
              delete list[i3];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i3) {
      _updateLiveList(this);
      return this[i3] || null;
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i3 = list.length;
      while (i3--) {
        if (list[i3] === node) {
          return i3;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i3 = _findNodeIndex(list, attr);
      if (i3 >= 0) {
        var lastIndex = list.length - 1;
        while (i3 < lastIndex) {
          list[i3] = list[++i3];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i3 = this.length;
        while (i3--) {
          var attr = this[i3];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
      //for level2
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i3 = this.length;
        while (i3--) {
          var node = this[i3];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function(feature, version) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node() {
    }
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n2 in map) {
              if (Object.prototype.hasOwnProperty.call(map, n2) && map[n2] === namespaceURI) {
                return n2;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (Object.prototype.hasOwnProperty.call(map, prefix)) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c2) {
      return c2 == "<" && "&lt;" || c2 == ">" && "&gt;" || c2 == "&" && "&amp;" || c2 == '"' && "&quot;" || "&#" + c2.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
      this.ownerDocument = this;
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i3 = 0;
          while (child) {
            cs[i3++] = child;
            child = child.nextSibling;
          }
          cs.length = i3;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node.ELEMENT_NODE;
    }
    function isTextNode(node) {
      return node && node.nodeType === Node.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent2, node, child) {
      if (!hasValidParentNodeType(parent2)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent2.nodeType);
      }
      if (child && child.parentNode !== parent2) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent2.nodeType !== Node.DOCUMENT_NODE
      ) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node.nodeType + " for parent node type " + parent2.nodeType
        );
      }
    }
    function assertPreInsertionValidityInDocument(parent2, node, child) {
      var parentChildNodes = parent2.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent2, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent2, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent2, node, child) {
      var parentChildNodes = parent2.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent2, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent2, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild2 = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent2, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent2, node, child);
      if (parent2.nodeType === Node.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent2, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent2.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent2.firstChild = newFirst;
      }
      if (child == null) {
        parent2.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent2;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent2.ownerDocument || parent2, parent2);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      return newChild;
    }
    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        newChild.ownerDocument = this;
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        newChild.ownerDocument = this;
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      //document factory method:
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text2();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      //four real opeartion method
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count2) {
        return this.data.substring(offset, offset + count2);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count2) {
        this.replaceData(offset, count2, "");
      },
      replaceData: function(offset, count2, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count2);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node);
    function Text2() {
    }
    Text2.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text2, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node);
    function XMLSerializer2() {
    }
    XMLSerializer2.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i3 = visibleNamespaces.length;
      while (i3--) {
        var ns = visibleNamespaces[i3];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i3 = 0; i3 < len; i3++) {
            var attr = attrs.item(i3);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i3 = 0; i3 < len; i3++) {
            var attr = attrs.item(i3);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(
            node.data.replace(/[<&>]/g, _xmlEncoder)
          );
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        //case ENTITY_NODE:
        //case NOTATION_NODE:
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        //var attrs = node2.attributes;
        //var len = attrs.length;
        //for(var i=0;i<len;i++){
        //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
        //}
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n2 in node) {
        if (Object.prototype.hasOwnProperty.call(node, n2)) {
          var v2 = node[n2];
          if (typeof v2 != "object") {
            if (v2 != node2[n2]) {
              node2[n2] = v2;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i3 = 0; i3 < len; i3++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i3), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e2) {
    }
    var getTextContent;
    exports.DocumentType = DocumentType;
    exports.DOMException = DOMException;
    exports.DOMImplementation = DOMImplementation;
    exports.Element = Element;
    exports.Node = Node;
    exports.NodeList = NodeList;
    exports.XMLSerializer = XMLSerializer2;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports) {
    "use strict";
    init_define_AnParams();
    var freeze = require_conventions().freeze;
    exports.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports.HTML_ENTITIES = freeze({
      Aacute: "\xC1",
      aacute: "\xE1",
      Abreve: "\u0102",
      abreve: "\u0103",
      ac: "\u223E",
      acd: "\u223F",
      acE: "\u223E\u0333",
      Acirc: "\xC2",
      acirc: "\xE2",
      acute: "\xB4",
      Acy: "\u0410",
      acy: "\u0430",
      AElig: "\xC6",
      aelig: "\xE6",
      af: "\u2061",
      Afr: "\u{1D504}",
      afr: "\u{1D51E}",
      Agrave: "\xC0",
      agrave: "\xE0",
      alefsym: "\u2135",
      aleph: "\u2135",
      Alpha: "\u0391",
      alpha: "\u03B1",
      Amacr: "\u0100",
      amacr: "\u0101",
      amalg: "\u2A3F",
      AMP: "&",
      amp: "&",
      And: "\u2A53",
      and: "\u2227",
      andand: "\u2A55",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsd: "\u2221",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\xC5",
      angzarr: "\u237C",
      Aogon: "\u0104",
      aogon: "\u0105",
      Aopf: "\u{1D538}",
      aopf: "\u{1D552}",
      ap: "\u2248",
      apacir: "\u2A6F",
      apE: "\u2A70",
      ape: "\u224A",
      apid: "\u224B",
      apos: "'",
      ApplyFunction: "\u2061",
      approx: "\u2248",
      approxeq: "\u224A",
      Aring: "\xC5",
      aring: "\xE5",
      Ascr: "\u{1D49C}",
      ascr: "\u{1D4B6}",
      Assign: "\u2254",
      ast: "*",
      asymp: "\u2248",
      asympeq: "\u224D",
      Atilde: "\xC3",
      atilde: "\xE3",
      Auml: "\xC4",
      auml: "\xE4",
      awconint: "\u2233",
      awint: "\u2A11",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      barvee: "\u22BD",
      Barwed: "\u2306",
      barwed: "\u2305",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      Bcy: "\u0411",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      Because: "\u2235",
      because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      Bfr: "\u{1D505}",
      bfr: "\u{1D51F}",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "=\u20E5",
      bnequiv: "\u2261\u20E5",
      bNot: "\u2AED",
      bnot: "\u2310",
      Bopf: "\u{1D539}",
      bopf: "\u{1D553}",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxbox: "\u29C9",
      boxDL: "\u2557",
      boxDl: "\u2556",
      boxdL: "\u2555",
      boxdl: "\u2510",
      boxDR: "\u2554",
      boxDr: "\u2553",
      boxdR: "\u2552",
      boxdr: "\u250C",
      boxH: "\u2550",
      boxh: "\u2500",
      boxHD: "\u2566",
      boxHd: "\u2564",
      boxhD: "\u2565",
      boxhd: "\u252C",
      boxHU: "\u2569",
      boxHu: "\u2567",
      boxhU: "\u2568",
      boxhu: "\u2534",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxUL: "\u255D",
      boxUl: "\u255C",
      boxuL: "\u255B",
      boxul: "\u2518",
      boxUR: "\u255A",
      boxUr: "\u2559",
      boxuR: "\u2558",
      boxur: "\u2514",
      boxV: "\u2551",
      boxv: "\u2502",
      boxVH: "\u256C",
      boxVh: "\u256B",
      boxvH: "\u256A",
      boxvh: "\u253C",
      boxVL: "\u2563",
      boxVl: "\u2562",
      boxvL: "\u2561",
      boxvl: "\u2524",
      boxVR: "\u2560",
      boxVr: "\u255F",
      boxvR: "\u255E",
      boxvr: "\u251C",
      bprime: "\u2035",
      Breve: "\u02D8",
      breve: "\u02D8",
      brvbar: "\xA6",
      Bscr: "\u212C",
      bscr: "\u{1D4B7}",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsol: "\\",
      bsolb: "\u29C5",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      Bumpeq: "\u224E",
      bumpeq: "\u224F",
      Cacute: "\u0106",
      cacute: "\u0107",
      Cap: "\u22D2",
      cap: "\u2229",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      capcup: "\u2A47",
      capdot: "\u2A40",
      CapitalDifferentialD: "\u2145",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      Cayleys: "\u212D",
      ccaps: "\u2A4D",
      Ccaron: "\u010C",
      ccaron: "\u010D",
      Ccedil: "\xC7",
      ccedil: "\xE7",
      Ccirc: "\u0108",
      ccirc: "\u0109",
      Cconint: "\u2230",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      Cdot: "\u010A",
      cdot: "\u010B",
      cedil: "\xB8",
      Cedilla: "\xB8",
      cemptyv: "\u29B2",
      cent: "\xA2",
      CenterDot: "\xB7",
      centerdot: "\xB7",
      Cfr: "\u212D",
      cfr: "\u{1D520}",
      CHcy: "\u0427",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      Chi: "\u03A7",
      chi: "\u03C7",
      cir: "\u25CB",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      CircleDot: "\u2299",
      circledR: "\xAE",
      circledS: "\u24C8",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      cirE: "\u29C3",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      clubs: "\u2663",
      clubsuit: "\u2663",
      Colon: "\u2237",
      colon: ":",
      Colone: "\u2A74",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: ",",
      commat: "@",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      Congruent: "\u2261",
      Conint: "\u222F",
      conint: "\u222E",
      ContourIntegral: "\u222E",
      Copf: "\u2102",
      copf: "\u{1D554}",
      coprod: "\u2210",
      Coproduct: "\u2210",
      COPY: "\xA9",
      copy: "\xA9",
      copysr: "\u2117",
      CounterClockwiseContourIntegral: "\u2233",
      crarr: "\u21B5",
      Cross: "\u2A2F",
      cross: "\u2717",
      Cscr: "\u{1D49E}",
      cscr: "\u{1D4B8}",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      Cup: "\u22D3",
      cup: "\u222A",
      cupbrcap: "\u2A48",
      CupCap: "\u224D",
      cupcap: "\u2A46",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curren: "\xA4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      Dagger: "\u2021",
      dagger: "\u2020",
      daleth: "\u2138",
      Darr: "\u21A1",
      dArr: "\u21D3",
      darr: "\u2193",
      dash: "\u2010",
      Dashv: "\u2AE4",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      Dcaron: "\u010E",
      dcaron: "\u010F",
      Dcy: "\u0414",
      dcy: "\u0434",
      DD: "\u2145",
      dd: "\u2146",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      DDotrahd: "\u2911",
      ddotseq: "\u2A77",
      deg: "\xB0",
      Del: "\u2207",
      Delta: "\u0394",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      Dfr: "\u{1D507}",
      dfr: "\u{1D521}",
      dHar: "\u2965",
      dharl: "\u21C3",
      dharr: "\u21C2",
      DiacriticalAcute: "\xB4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "`",
      DiacriticalTilde: "\u02DC",
      diam: "\u22C4",
      Diamond: "\u22C4",
      diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\xA8",
      DifferentialD: "\u2146",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\xF7",
      divide: "\xF7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      DJcy: "\u0402",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "$",
      Dopf: "\u{1D53B}",
      dopf: "\u{1D555}",
      Dot: "\xA8",
      dot: "\u02D9",
      DotDot: "\u20DC",
      doteq: "\u2250",
      doteqdot: "\u2251",
      DotEqual: "\u2250",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\xA8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrow: "\u2193",
      Downarrow: "\u21D3",
      downarrow: "\u2193",
      DownArrowBar: "\u2913",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVector: "\u21BD",
      DownLeftVectorBar: "\u2956",
      DownRightTeeVector: "\u295F",
      DownRightVector: "\u21C1",
      DownRightVectorBar: "\u2957",
      DownTee: "\u22A4",
      DownTeeArrow: "\u21A7",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      Dscr: "\u{1D49F}",
      dscr: "\u{1D4B9}",
      DScy: "\u0405",
      dscy: "\u0455",
      dsol: "\u29F6",
      Dstrok: "\u0110",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      DZcy: "\u040F",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      Eacute: "\xC9",
      eacute: "\xE9",
      easter: "\u2A6E",
      Ecaron: "\u011A",
      ecaron: "\u011B",
      ecir: "\u2256",
      Ecirc: "\xCA",
      ecirc: "\xEA",
      ecolon: "\u2255",
      Ecy: "\u042D",
      ecy: "\u044D",
      eDDot: "\u2A77",
      Edot: "\u0116",
      eDot: "\u2251",
      edot: "\u0117",
      ee: "\u2147",
      efDot: "\u2252",
      Efr: "\u{1D508}",
      efr: "\u{1D522}",
      eg: "\u2A9A",
      Egrave: "\xC8",
      egrave: "\xE8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      Element: "\u2208",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      Emacr: "\u0112",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      EmptySmallSquare: "\u25FB",
      emptyv: "\u2205",
      EmptyVerySmallSquare: "\u25AB",
      emsp: "\u2003",
      emsp13: "\u2004",
      emsp14: "\u2005",
      ENG: "\u014A",
      eng: "\u014B",
      ensp: "\u2002",
      Eogon: "\u0118",
      eogon: "\u0119",
      Eopf: "\u{1D53C}",
      eopf: "\u{1D556}",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      Epsilon: "\u0395",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      Equal: "\u2A75",
      equals: "=",
      EqualTilde: "\u2242",
      equest: "\u225F",
      Equilibrium: "\u21CC",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erarr: "\u2971",
      erDot: "\u2253",
      Escr: "\u2130",
      escr: "\u212F",
      esdot: "\u2250",
      Esim: "\u2A73",
      esim: "\u2242",
      Eta: "\u0397",
      eta: "\u03B7",
      ETH: "\xD0",
      eth: "\xF0",
      Euml: "\xCB",
      euml: "\xEB",
      euro: "\u20AC",
      excl: "!",
      exist: "\u2203",
      Exists: "\u2203",
      expectation: "\u2130",
      ExponentialE: "\u2147",
      exponentiale: "\u2147",
      fallingdotseq: "\u2252",
      Fcy: "\u0424",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      Ffr: "\u{1D509}",
      ffr: "\u{1D523}",
      filig: "\uFB01",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      fjlig: "fj",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      Fopf: "\u{1D53D}",
      fopf: "\u{1D557}",
      ForAll: "\u2200",
      forall: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      Fouriertrf: "\u2131",
      fpartint: "\u2A0D",
      frac12: "\xBD",
      frac13: "\u2153",
      frac14: "\xBC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac34: "\xBE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      Fscr: "\u2131",
      fscr: "\u{1D4BB}",
      gacute: "\u01F5",
      Gamma: "\u0393",
      gamma: "\u03B3",
      Gammad: "\u03DC",
      gammad: "\u03DD",
      gap: "\u2A86",
      Gbreve: "\u011E",
      gbreve: "\u011F",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      gcirc: "\u011D",
      Gcy: "\u0413",
      gcy: "\u0433",
      Gdot: "\u0120",
      gdot: "\u0121",
      gE: "\u2267",
      ge: "\u2265",
      gEl: "\u2A8C",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      ges: "\u2A7E",
      gescc: "\u2AA9",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      Gfr: "\u{1D50A}",
      gfr: "\u{1D524}",
      Gg: "\u22D9",
      gg: "\u226B",
      ggg: "\u22D9",
      gimel: "\u2137",
      GJcy: "\u0403",
      gjcy: "\u0453",
      gl: "\u2277",
      gla: "\u2AA5",
      glE: "\u2A92",
      glj: "\u2AA4",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gnE: "\u2269",
      gne: "\u2A88",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      Gopf: "\u{1D53E}",
      gopf: "\u{1D558}",
      grave: "`",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\u{1D4A2}",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      Gt: "\u226B",
      GT: ">",
      gt: ">",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      Hacek: "\u02C7",
      hairsp: "\u200A",
      half: "\xBD",
      hamilt: "\u210B",
      HARDcy: "\u042A",
      hardcy: "\u044A",
      hArr: "\u21D4",
      harr: "\u2194",
      harrcir: "\u2948",
      harrw: "\u21AD",
      Hat: "^",
      hbar: "\u210F",
      Hcirc: "\u0124",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      Hfr: "\u210C",
      hfr: "\u{1D525}",
      HilbertSpace: "\u210B",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      Hopf: "\u210D",
      hopf: "\u{1D559}",
      horbar: "\u2015",
      HorizontalLine: "\u2500",
      Hscr: "\u210B",
      hscr: "\u{1D4BD}",
      hslash: "\u210F",
      Hstrok: "\u0126",
      hstrok: "\u0127",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      hybull: "\u2043",
      hyphen: "\u2010",
      Iacute: "\xCD",
      iacute: "\xED",
      ic: "\u2063",
      Icirc: "\xCE",
      icirc: "\xEE",
      Icy: "\u0418",
      icy: "\u0438",
      Idot: "\u0130",
      IEcy: "\u0415",
      iecy: "\u0435",
      iexcl: "\xA1",
      iff: "\u21D4",
      Ifr: "\u2111",
      ifr: "\u{1D526}",
      Igrave: "\xCC",
      igrave: "\xEC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      IJlig: "\u0132",
      ijlig: "\u0133",
      Im: "\u2111",
      Imacr: "\u012A",
      imacr: "\u012B",
      image: "\u2111",
      ImaginaryI: "\u2148",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      imof: "\u22B7",
      imped: "\u01B5",
      Implies: "\u21D2",
      in: "\u2208",
      incare: "\u2105",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      Int: "\u222C",
      int: "\u222B",
      intcal: "\u22BA",
      integers: "\u2124",
      Integral: "\u222B",
      intercal: "\u22BA",
      Intersection: "\u22C2",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      IOcy: "\u0401",
      iocy: "\u0451",
      Iogon: "\u012E",
      iogon: "\u012F",
      Iopf: "\u{1D540}",
      iopf: "\u{1D55A}",
      Iota: "\u0399",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iquest: "\xBF",
      Iscr: "\u2110",
      iscr: "\u{1D4BE}",
      isin: "\u2208",
      isindot: "\u22F5",
      isinE: "\u22F9",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      Itilde: "\u0128",
      itilde: "\u0129",
      Iukcy: "\u0406",
      iukcy: "\u0456",
      Iuml: "\xCF",
      iuml: "\xEF",
      Jcirc: "\u0134",
      jcirc: "\u0135",
      Jcy: "\u0419",
      jcy: "\u0439",
      Jfr: "\u{1D50D}",
      jfr: "\u{1D527}",
      jmath: "\u0237",
      Jopf: "\u{1D541}",
      jopf: "\u{1D55B}",
      Jscr: "\u{1D4A5}",
      jscr: "\u{1D4BF}",
      Jsercy: "\u0408",
      jsercy: "\u0458",
      Jukcy: "\u0404",
      jukcy: "\u0454",
      Kappa: "\u039A",
      kappa: "\u03BA",
      kappav: "\u03F0",
      Kcedil: "\u0136",
      kcedil: "\u0137",
      Kcy: "\u041A",
      kcy: "\u043A",
      Kfr: "\u{1D50E}",
      kfr: "\u{1D528}",
      kgreen: "\u0138",
      KHcy: "\u0425",
      khcy: "\u0445",
      KJcy: "\u040C",
      kjcy: "\u045C",
      Kopf: "\u{1D542}",
      kopf: "\u{1D55C}",
      Kscr: "\u{1D4A6}",
      kscr: "\u{1D4C0}",
      lAarr: "\u21DA",
      Lacute: "\u0139",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      Lambda: "\u039B",
      lambda: "\u03BB",
      Lang: "\u27EA",
      lang: "\u27E8",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      Laplacetrf: "\u2112",
      laquo: "\xAB",
      Larr: "\u219E",
      lArr: "\u21D0",
      larr: "\u2190",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      lat: "\u2AAB",
      lAtail: "\u291B",
      latail: "\u2919",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lBarr: "\u290E",
      lbarr: "\u290C",
      lbbrk: "\u2772",
      lbrace: "{",
      lbrack: "[",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      Lcaron: "\u013D",
      lcaron: "\u013E",
      Lcedil: "\u013B",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "{",
      Lcy: "\u041B",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      lE: "\u2266",
      le: "\u2264",
      LeftAngleBracket: "\u27E8",
      LeftArrow: "\u2190",
      Leftarrow: "\u21D0",
      leftarrow: "\u2190",
      LeftArrowBar: "\u21E4",
      LeftArrowRightArrow: "\u21C6",
      leftarrowtail: "\u21A2",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVector: "\u21C3",
      LeftDownVectorBar: "\u2959",
      LeftFloor: "\u230A",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      LeftRightArrow: "\u2194",
      Leftrightarrow: "\u21D4",
      leftrightarrow: "\u2194",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      LeftRightVector: "\u294E",
      LeftTee: "\u22A3",
      LeftTeeArrow: "\u21A4",
      LeftTeeVector: "\u295A",
      leftthreetimes: "\u22CB",
      LeftTriangle: "\u22B2",
      LeftTriangleBar: "\u29CF",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVector: "\u21BF",
      LeftUpVectorBar: "\u2958",
      LeftVector: "\u21BC",
      LeftVectorBar: "\u2952",
      lEg: "\u2A8B",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      les: "\u2A7D",
      lescc: "\u2AA8",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      lessgtr: "\u2276",
      LessLess: "\u2AA1",
      lesssim: "\u2272",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      Lfr: "\u{1D50F}",
      lfr: "\u{1D529}",
      lg: "\u2276",
      lgE: "\u2A91",
      lHar: "\u2962",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      LJcy: "\u0409",
      ljcy: "\u0459",
      Ll: "\u22D8",
      ll: "\u226A",
      llarr: "\u21C7",
      llcorner: "\u231E",
      Lleftarrow: "\u21DA",
      llhard: "\u296B",
      lltri: "\u25FA",
      Lmidot: "\u013F",
      lmidot: "\u0140",
      lmoust: "\u23B0",
      lmoustache: "\u23B0",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lnE: "\u2268",
      lne: "\u2A87",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      LongLeftArrow: "\u27F5",
      Longleftarrow: "\u27F8",
      longleftarrow: "\u27F5",
      LongLeftRightArrow: "\u27F7",
      Longleftrightarrow: "\u27FA",
      longleftrightarrow: "\u27F7",
      longmapsto: "\u27FC",
      LongRightArrow: "\u27F6",
      Longrightarrow: "\u27F9",
      longrightarrow: "\u27F6",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      Lopf: "\u{1D543}",
      lopf: "\u{1D55D}",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "_",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "(",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      Lscr: "\u2112",
      lscr: "\u{1D4C1}",
      Lsh: "\u21B0",
      lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "[",
      lsquo: "\u2018",
      lsquor: "\u201A",
      Lstrok: "\u0141",
      lstrok: "\u0142",
      Lt: "\u226A",
      LT: "<",
      lt: "<",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      ltrPar: "\u2996",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      macr: "\xAF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      Map: "\u2905",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      Mcy: "\u041C",
      mcy: "\u043C",
      mdash: "\u2014",
      mDDot: "\u223A",
      measuredangle: "\u2221",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\u{1D510}",
      mfr: "\u{1D52A}",
      mho: "\u2127",
      micro: "\xB5",
      mid: "\u2223",
      midast: "*",
      midcir: "\u2AF0",
      middot: "\xB7",
      minus: "\u2212",
      minusb: "\u229F",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      MinusPlus: "\u2213",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      Mopf: "\u{1D544}",
      mopf: "\u{1D55E}",
      mp: "\u2213",
      Mscr: "\u2133",
      mscr: "\u{1D4C2}",
      mstpos: "\u223E",
      Mu: "\u039C",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nabla: "\u2207",
      Nacute: "\u0143",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natur: "\u266E",
      natural: "\u266E",
      naturals: "\u2115",
      nbsp: "\xA0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      Ncaron: "\u0147",
      ncaron: "\u0148",
      Ncedil: "\u0145",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      Ncy: "\u041D",
      ncy: "\u043D",
      ndash: "\u2013",
      ne: "\u2260",
      nearhk: "\u2924",
      neArr: "\u21D7",
      nearr: "\u2197",
      nearrow: "\u2197",
      nedot: "\u2250\u0338",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\n",
      nexist: "\u2204",
      nexists: "\u2204",
      Nfr: "\u{1D511}",
      nfr: "\u{1D52B}",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      nGg: "\u22D9\u0338",
      ngsim: "\u2275",
      nGt: "\u226B\u20D2",
      ngt: "\u226F",
      ngtr: "\u226F",
      nGtv: "\u226B\u0338",
      nhArr: "\u21CE",
      nharr: "\u21AE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      NJcy: "\u040A",
      njcy: "\u045A",
      nlArr: "\u21CD",
      nlarr: "\u219A",
      nldr: "\u2025",
      nlE: "\u2266\u0338",
      nle: "\u2270",
      nLeftarrow: "\u21CD",
      nleftarrow: "\u219A",
      nLeftrightarrow: "\u21CE",
      nleftrightarrow: "\u21AE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nLl: "\u22D8\u0338",
      nlsim: "\u2274",
      nLt: "\u226A\u20D2",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nLtv: "\u226A\u0338",
      nmid: "\u2224",
      NoBreak: "\u2060",
      NonBreakingSpace: "\xA0",
      Nopf: "\u2115",
      nopf: "\u{1D55F}",
      Not: "\u2AEC",
      not: "\xAC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      notin: "\u2209",
      notindot: "\u22F5\u0338",
      notinE: "\u22F9\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangle: "\u22EB",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      npar: "\u2226",
      nparallel: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      npre: "\u2AAF\u0338",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      nrArr: "\u21CF",
      nrarr: "\u219B",
      nrarrc: "\u2933\u0338",
      nrarrw: "\u219D\u0338",
      nRightarrow: "\u21CF",
      nrightarrow: "\u219B",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      Nscr: "\u{1D4A9}",
      nscr: "\u{1D4C3}",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      Ntilde: "\xD1",
      ntilde: "\xF1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      Nu: "\u039D",
      nu: "\u03BD",
      num: "#",
      numero: "\u2116",
      numsp: "\u2007",
      nvap: "\u224D\u20D2",
      nVDash: "\u22AF",
      nVdash: "\u22AE",
      nvDash: "\u22AD",
      nvdash: "\u22AC",
      nvge: "\u2265\u20D2",
      nvgt: ">\u20D2",
      nvHarr: "\u2904",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "<\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwarhk: "\u2923",
      nwArr: "\u21D6",
      nwarr: "\u2196",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      Oacute: "\xD3",
      oacute: "\xF3",
      oast: "\u229B",
      ocir: "\u229A",
      Ocirc: "\xD4",
      ocirc: "\xF4",
      Ocy: "\u041E",
      ocy: "\u043E",
      odash: "\u229D",
      Odblac: "\u0150",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      OElig: "\u0152",
      oelig: "\u0153",
      ofcir: "\u29BF",
      Ofr: "\u{1D512}",
      ofr: "\u{1D52C}",
      ogon: "\u02DB",
      Ograve: "\xD2",
      ograve: "\xF2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      Omacr: "\u014C",
      omacr: "\u014D",
      Omega: "\u03A9",
      omega: "\u03C9",
      Omicron: "\u039F",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      Oopf: "\u{1D546}",
      oopf: "\u{1D560}",
      opar: "\u29B7",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      operp: "\u29B9",
      oplus: "\u2295",
      Or: "\u2A54",
      or: "\u2228",
      orarr: "\u21BB",
      ord: "\u2A5D",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\xAA",
      ordm: "\xBA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oS: "\u24C8",
      Oscr: "\u{1D4AA}",
      oscr: "\u2134",
      Oslash: "\xD8",
      oslash: "\xF8",
      osol: "\u2298",
      Otilde: "\xD5",
      otilde: "\xF5",
      Otimes: "\u2A37",
      otimes: "\u2297",
      otimesas: "\u2A36",
      Ouml: "\xD6",
      ouml: "\xF6",
      ovbar: "\u233D",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      par: "\u2225",
      para: "\xB6",
      parallel: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      PartialD: "\u2202",
      Pcy: "\u041F",
      pcy: "\u043F",
      percnt: "%",
      period: ".",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      Pfr: "\u{1D513}",
      pfr: "\u{1D52D}",
      Phi: "\u03A6",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      Pi: "\u03A0",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plus: "+",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      PlusMinus: "\xB1",
      plusmn: "\xB1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\xB1",
      Poincareplane: "\u210C",
      pointint: "\u2A15",
      Popf: "\u2119",
      popf: "\u{1D561}",
      pound: "\xA3",
      Pr: "\u2ABB",
      pr: "\u227A",
      prap: "\u2AB7",
      prcue: "\u227C",
      prE: "\u2AB3",
      pre: "\u2AAF",
      prec: "\u227A",
      precapprox: "\u2AB7",
      preccurlyeq: "\u227C",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      precsim: "\u227E",
      Prime: "\u2033",
      prime: "\u2032",
      primes: "\u2119",
      prnap: "\u2AB9",
      prnE: "\u2AB5",
      prnsim: "\u22E8",
      prod: "\u220F",
      Product: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      Proportion: "\u2237",
      Proportional: "\u221D",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      Pscr: "\u{1D4AB}",
      pscr: "\u{1D4C5}",
      Psi: "\u03A8",
      psi: "\u03C8",
      puncsp: "\u2008",
      Qfr: "\u{1D514}",
      qfr: "\u{1D52E}",
      qint: "\u2A0C",
      Qopf: "\u211A",
      qopf: "\u{1D562}",
      qprime: "\u2057",
      Qscr: "\u{1D4AC}",
      qscr: "\u{1D4C6}",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "?",
      questeq: "\u225F",
      QUOT: '"',
      quot: '"',
      rAarr: "\u21DB",
      race: "\u223D\u0331",
      Racute: "\u0154",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      Rang: "\u27EB",
      rang: "\u27E9",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raquo: "\xBB",
      Rarr: "\u21A0",
      rArr: "\u21D2",
      rarr: "\u2192",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      Rarrtl: "\u2916",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      rAtail: "\u291C",
      ratail: "\u291A",
      ratio: "\u2236",
      rationals: "\u211A",
      RBarr: "\u2910",
      rBarr: "\u290F",
      rbarr: "\u290D",
      rbbrk: "\u2773",
      rbrace: "}",
      rbrack: "]",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      Rcaron: "\u0158",
      rcaron: "\u0159",
      Rcedil: "\u0156",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "}",
      Rcy: "\u0420",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      Re: "\u211C",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      rect: "\u25AD",
      REG: "\xAE",
      reg: "\xAE",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      rfisht: "\u297D",
      rfloor: "\u230B",
      Rfr: "\u211C",
      rfr: "\u{1D52F}",
      rHar: "\u2964",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      Rho: "\u03A1",
      rho: "\u03C1",
      rhov: "\u03F1",
      RightAngleBracket: "\u27E9",
      RightArrow: "\u2192",
      Rightarrow: "\u21D2",
      rightarrow: "\u2192",
      RightArrowBar: "\u21E5",
      RightArrowLeftArrow: "\u21C4",
      rightarrowtail: "\u21A3",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVector: "\u21C2",
      RightDownVectorBar: "\u2955",
      RightFloor: "\u230B",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      RightTee: "\u22A2",
      RightTeeArrow: "\u21A6",
      RightTeeVector: "\u295B",
      rightthreetimes: "\u22CC",
      RightTriangle: "\u22B3",
      RightTriangleBar: "\u29D0",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVector: "\u21BE",
      RightUpVectorBar: "\u2954",
      RightVector: "\u21C0",
      RightVectorBar: "\u2953",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoust: "\u23B1",
      rmoustache: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      Ropf: "\u211D",
      ropf: "\u{1D563}",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      RoundImplies: "\u2970",
      rpar: ")",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      Rrightarrow: "\u21DB",
      rsaquo: "\u203A",
      Rscr: "\u211B",
      rscr: "\u{1D4C7}",
      Rsh: "\u21B1",
      rsh: "\u21B1",
      rsqb: "]",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      RuleDelayed: "\u29F4",
      ruluhar: "\u2968",
      rx: "\u211E",
      Sacute: "\u015A",
      sacute: "\u015B",
      sbquo: "\u201A",
      Sc: "\u2ABC",
      sc: "\u227B",
      scap: "\u2AB8",
      Scaron: "\u0160",
      scaron: "\u0161",
      sccue: "\u227D",
      scE: "\u2AB4",
      sce: "\u2AB0",
      Scedil: "\u015E",
      scedil: "\u015F",
      Scirc: "\u015C",
      scirc: "\u015D",
      scnap: "\u2ABA",
      scnE: "\u2AB6",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      Scy: "\u0421",
      scy: "\u0441",
      sdot: "\u22C5",
      sdotb: "\u22A1",
      sdote: "\u2A66",
      searhk: "\u2925",
      seArr: "\u21D8",
      searr: "\u2198",
      searrow: "\u2198",
      sect: "\xA7",
      semi: ";",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      Sfr: "\u{1D516}",
      sfr: "\u{1D530}",
      sfrown: "\u2322",
      sharp: "\u266F",
      SHCHcy: "\u0429",
      shchcy: "\u0449",
      SHcy: "\u0428",
      shcy: "\u0448",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      shy: "\xAD",
      Sigma: "\u03A3",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      SmallCircle: "\u2218",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      SOFTcy: "\u042C",
      softcy: "\u044C",
      sol: "/",
      solb: "\u29C4",
      solbar: "\u233F",
      Sopf: "\u{1D54A}",
      sopf: "\u{1D564}",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      Sqrt: "\u221A",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      squ: "\u25A1",
      Square: "\u25A1",
      square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      squarf: "\u25AA",
      squf: "\u25AA",
      srarr: "\u2192",
      Sscr: "\u{1D4AE}",
      sscr: "\u{1D4C8}",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      Star: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\xAF",
      Sub: "\u22D0",
      sub: "\u2282",
      subdot: "\u2ABD",
      subE: "\u2AC5",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      Subset: "\u22D0",
      subset: "\u2282",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      SubsetEqual: "\u2286",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succ: "\u227B",
      succapprox: "\u2AB8",
      succcurlyeq: "\u227D",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      SuchThat: "\u220B",
      Sum: "\u2211",
      sum: "\u2211",
      sung: "\u266A",
      Sup: "\u22D1",
      sup: "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supE: "\u2AC6",
      supe: "\u2287",
      supedot: "\u2AC4",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      Supset: "\u22D1",
      supset: "\u2283",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swarhk: "\u2926",
      swArr: "\u21D9",
      swarr: "\u2199",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szlig: "\xDF",
      Tab: "	",
      target: "\u2316",
      Tau: "\u03A4",
      tau: "\u03C4",
      tbrk: "\u23B4",
      Tcaron: "\u0164",
      tcaron: "\u0165",
      Tcedil: "\u0162",
      tcedil: "\u0163",
      Tcy: "\u0422",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      Tfr: "\u{1D517}",
      tfr: "\u{1D531}",
      there4: "\u2234",
      Therefore: "\u2234",
      therefore: "\u2234",
      Theta: "\u0398",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      ThickSpace: "\u205F\u200A",
      thinsp: "\u2009",
      ThinSpace: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      THORN: "\xDE",
      thorn: "\xFE",
      Tilde: "\u223C",
      tilde: "\u02DC",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      times: "\xD7",
      timesb: "\u22A0",
      timesbar: "\u2A31",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      top: "\u22A4",
      topbot: "\u2336",
      topcir: "\u2AF1",
      Topf: "\u{1D54B}",
      topf: "\u{1D565}",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      TRADE: "\u2122",
      trade: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      TripleDot: "\u20DB",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      Tscr: "\u{1D4AF}",
      tscr: "\u{1D4C9}",
      TScy: "\u0426",
      tscy: "\u0446",
      TSHcy: "\u040B",
      tshcy: "\u045B",
      Tstrok: "\u0166",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      Uacute: "\xDA",
      uacute: "\xFA",
      Uarr: "\u219F",
      uArr: "\u21D1",
      uarr: "\u2191",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      ubrcy: "\u045E",
      Ubreve: "\u016C",
      ubreve: "\u016D",
      Ucirc: "\xDB",
      ucirc: "\xFB",
      Ucy: "\u0423",
      ucy: "\u0443",
      udarr: "\u21C5",
      Udblac: "\u0170",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      Ufr: "\u{1D518}",
      ufr: "\u{1D532}",
      Ugrave: "\xD9",
      ugrave: "\xF9",
      uHar: "\u2963",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      Umacr: "\u016A",
      umacr: "\u016B",
      uml: "\xA8",
      UnderBar: "_",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      uogon: "\u0173",
      Uopf: "\u{1D54C}",
      uopf: "\u{1D566}",
      UpArrow: "\u2191",
      Uparrow: "\u21D1",
      uparrow: "\u2191",
      UpArrowBar: "\u2912",
      UpArrowDownArrow: "\u21C5",
      UpDownArrow: "\u2195",
      Updownarrow: "\u21D5",
      updownarrow: "\u2195",
      UpEquilibrium: "\u296E",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      Upsi: "\u03D2",
      upsi: "\u03C5",
      upsih: "\u03D2",
      Upsilon: "\u03A5",
      upsilon: "\u03C5",
      UpTee: "\u22A5",
      UpTeeArrow: "\u21A5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      Uring: "\u016E",
      uring: "\u016F",
      urtri: "\u25F9",
      Uscr: "\u{1D4B0}",
      uscr: "\u{1D4CA}",
      utdot: "\u22F0",
      Utilde: "\u0168",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      Uuml: "\xDC",
      uuml: "\xFC",
      uwangle: "\u29A7",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      vArr: "\u21D5",
      varr: "\u2195",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      Vbar: "\u2AEB",
      vBar: "\u2AE8",
      vBarv: "\u2AE9",
      Vcy: "\u0412",
      vcy: "\u0432",
      VDash: "\u22AB",
      Vdash: "\u22A9",
      vDash: "\u22A8",
      vdash: "\u22A2",
      Vdashl: "\u2AE6",
      Vee: "\u22C1",
      vee: "\u2228",
      veebar: "\u22BB",
      veeeq: "\u225A",
      vellip: "\u22EE",
      Verbar: "\u2016",
      verbar: "|",
      Vert: "\u2016",
      vert: "|",
      VerticalBar: "\u2223",
      VerticalLine: "|",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\u{1D519}",
      vfr: "\u{1D533}",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      Vopf: "\u{1D54D}",
      vopf: "\u{1D567}",
      vprop: "\u221D",
      vrtri: "\u22B3",
      Vscr: "\u{1D4B1}",
      vscr: "\u{1D4CB}",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      Vvdash: "\u22AA",
      vzigzag: "\u299A",
      Wcirc: "\u0174",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      Wedge: "\u22C0",
      wedge: "\u2227",
      wedgeq: "\u2259",
      weierp: "\u2118",
      Wfr: "\u{1D51A}",
      wfr: "\u{1D534}",
      Wopf: "\u{1D54E}",
      wopf: "\u{1D568}",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      Wscr: "\u{1D4B2}",
      wscr: "\u{1D4CC}",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      Xfr: "\u{1D51B}",
      xfr: "\u{1D535}",
      xhArr: "\u27FA",
      xharr: "\u27F7",
      Xi: "\u039E",
      xi: "\u03BE",
      xlArr: "\u27F8",
      xlarr: "\u27F5",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      Xopf: "\u{1D54F}",
      xopf: "\u{1D569}",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrArr: "\u27F9",
      xrarr: "\u27F6",
      Xscr: "\u{1D4B3}",
      xscr: "\u{1D4CD}",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      Yacute: "\xDD",
      yacute: "\xFD",
      YAcy: "\u042F",
      yacy: "\u044F",
      Ycirc: "\u0176",
      ycirc: "\u0177",
      Ycy: "\u042B",
      ycy: "\u044B",
      yen: "\xA5",
      Yfr: "\u{1D51C}",
      yfr: "\u{1D536}",
      YIcy: "\u0407",
      yicy: "\u0457",
      Yopf: "\u{1D550}",
      yopf: "\u{1D56A}",
      Yscr: "\u{1D4B4}",
      yscr: "\u{1D4CE}",
      YUcy: "\u042E",
      yucy: "\u044E",
      Yuml: "\u0178",
      yuml: "\xFF",
      Zacute: "\u0179",
      zacute: "\u017A",
      Zcaron: "\u017D",
      zcaron: "\u017E",
      Zcy: "\u0417",
      zcy: "\u0437",
      Zdot: "\u017B",
      zdot: "\u017C",
      zeetrf: "\u2128",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      zeta: "\u03B6",
      Zfr: "\u2128",
      zfr: "\u{1D537}",
      ZHcy: "\u0416",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      Zopf: "\u2124",
      zopf: "\u{1D56B}",
      Zscr: "\u{1D4B5}",
      zscr: "\u{1D4CF}",
      zwj: "\u200D",
      zwnj: "\u200C"
    });
    exports.entityMap = exports.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports) {
    init_define_AnParams();
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source9, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse2(
          source9,
          defaultNSMap,
          entityMap,
          domBuilder,
          this.errorHandler
        );
        domBuilder.endDocument();
      }
    };
    function parse2(source9, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a3) {
        var k2 = a3.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k2)) {
          return entityMap[k2];
        } else if (k2.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k2.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a3);
          return a3;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source9.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      function position(p2, m2) {
        while (p2 >= lineEnd && (m2 = linePattern.exec(source9))) {
          lineStart = m2.index;
          lineEnd = lineStart + m2[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p2 - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source9.indexOf("<", start);
          if (tagStart < 0) {
            if (!source9.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source9.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source9.charAt(tagStart + 1)) {
            case "/":
              var end = source9.indexOf(">", tagStart + 3);
              var tagName = source9.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config2 = parseStack.pop();
              if (end < 0) {
                tagName = source9.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config2.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config2.localNSMap;
              var endMatch = config2.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config2.tagName && config2.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config2.uri, config2.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config2.tagName);
                }
              } else {
                parseStack.push(config2);
              }
              end++;
              break;
            // end elment
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source9, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source9, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source9, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source9, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i3 = 0; i3 < len; i3++) {
                  var a2 = el[i3];
                  position(a2.offset);
                  a2.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source9, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e2) {
          if (e2 instanceof ParseError) {
            throw e2;
          }
          errorHandler.error("element parse error: " + e2);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f2, t2) {
      t2.lineNumber = f2.lineNumber;
      t2.columnNumber = f2.columnNumber;
      return t2;
    }
    function parseElementStartPart(source9, start, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p2 = ++start;
      var s2 = S_TAG;
      while (true) {
        var c2 = source9.charAt(p2);
        switch (c2) {
          case "=":
            if (s2 === S_ATTR) {
              attrName = source9.slice(start, p2);
              s2 = S_EQ;
            } else if (s2 === S_ATTR_SPACE) {
              s2 = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s2 === S_EQ || s2 === S_ATTR) {
              if (s2 === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source9.slice(start, p2);
              }
              start = p2 + 1;
              p2 = source9.indexOf(c2, start);
              if (p2 > 0) {
                value = source9.slice(start, p2);
                addAttribute(attrName, value, start - 1);
                s2 = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c2 + "' match");
              }
            } else if (s2 == S_ATTR_NOQUOT_VALUE) {
              value = source9.slice(start, p2);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c2 + ")!!");
              start = p2 + 1;
              s2 = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s2) {
              case S_TAG:
                el.setTagName(source9.slice(start, p2));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s2 = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              //case S_EQ:
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s2 == S_TAG) {
              el.setTagName(source9.slice(start, p2));
            }
            return p2;
          case ">":
            switch (s2) {
              case S_TAG:
                el.setTagName(source9.slice(start, p2));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              //normal
              case S_ATTR_NOQUOT_VALUE:
              //Compatible state
              case S_ATTR:
                value = source9.slice(start, p2);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s2 === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s2 == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p2;
          /*xml space '\x20' | #x9 | #xD | #xA; */
          case "\x80":
            c2 = " ";
          default:
            if (c2 <= " ") {
              switch (s2) {
                case S_TAG:
                  el.setTagName(source9.slice(start, p2));
                  s2 = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source9.slice(start, p2);
                  s2 = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source9.slice(start, p2);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s2 = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s2) {
                //case S_TAG:void();break;
                //case S_ATTR:void();break;
                //case S_ATTR_NOQUOT_VALUE:void();break;
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p2;
                  s2 = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s2 = S_ATTR;
                  start = p2;
                  break;
                case S_EQ:
                  s2 = S_ATTR_NOQUOT_VALUE;
                  start = p2;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p2++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i3 = el.length;
      while (i3--) {
        var a2 = el[i3];
        var qName = a2.qName;
        var value = a2.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a2.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a2.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a2.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i3 = el.length;
      while (i3--) {
        a2 = el[i3];
        var prefix = a2.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a2.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a2.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source9, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source9.indexOf("</" + tagName + ">", elStartEnd);
        var text = source9.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source9, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source9.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source9.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source9, target) {
      for (var n2 in source9) {
        if (Object.prototype.hasOwnProperty.call(source9, n2)) {
          target[n2] = source9[n2];
        }
      }
    }
    function parseDCC(source9, start, domBuilder, errorHandler) {
      var next = source9.charAt(start + 2);
      switch (next) {
        case "-":
          if (source9.charAt(start + 3) === "-") {
            var end = source9.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source9, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source9.substr(start + 3, 6) == "CDATA[") {
            var end = source9.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source9, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source9, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source9, start, domBuilder) {
      var end = source9.indexOf("?>", start);
      if (end) {
        var match = source9.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i3) {
        return this[i3].localName;
      },
      getLocator: function(i3) {
        return this[i3].locator;
      },
      getQName: function(i3) {
        return this[i3].qName;
      },
      getURI: function(i3) {
        return this[i3].uri;
      },
      getValue: function(i3) {
        return this[i3].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    function split(source9, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source9);
      while (match = reg.exec(source9)) {
        buf.push(match);
        if (match[1]) return buf;
      }
    }
    exports.XMLReader = XMLReader;
    exports.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports) {
    init_define_AnParams();
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    function DOMParser3(options) {
      this.options = options || { locator: {} };
    }
    DOMParser3.prototype.parseFromString = function(source9, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source9 && typeof source9 === "string") {
        sax2.parse(
          normalize(source9),
          defaultNSMap,
          entityMap
        );
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn && function(msg) {
          fn("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i3 = 0; i3 < len; i3++) {
          var namespaceURI = attrs.getURI(i3);
          var value = attrs.getValue(i3);
          var qName = attrs.getQName(i3);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i3), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch3, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l2) {
      if (l2) {
        return "\n@" + (l2.systemId || "") + "#[line:" + l2.lineNumber + ",col:" + l2.columnNumber + "]";
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports.__DOMHandler = DOMHandler;
    exports.normalizeLineEndings = normalizeLineEndings;
    exports.DOMParser = DOMParser3;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports) {
    init_define_AnParams();
    var dom = require_dom();
    exports.DOMImplementation = dom.DOMImplementation;
    exports.XMLSerializer = dom.XMLSerializer;
    exports.DOMParser = require_dom_parser().DOMParser;
  }
});

// node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.mjs
var import_xmldom, WebWorkerAdapter;
var init_WebWorkerAdapter = __esm({
  "node_modules/pixi.js/lib/environment-webworker/WebWorkerAdapter.mjs"() {
    init_define_AnParams();
    import_xmldom = __toESM(require_lib(), 1);
    WebWorkerAdapter = {
      createCanvas: (width, height) => new OffscreenCanvas(width ?? 0, height ?? 0),
      getCanvasRenderingContext2D: () => OffscreenCanvasRenderingContext2D,
      getWebGLRenderingContext: () => WebGLRenderingContext,
      getNavigator: () => navigator,
      getBaseUrl: () => globalThis.location.href,
      getFontFaceSet: () => globalThis.fonts,
      fetch: (url, options) => fetch(url, options),
      parseXML: (xml) => {
        const parser = new import_xmldom.DOMParser();
        return parser.parseFromString(xml, "text/xml");
      }
    };
  }
});

// node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs
var vertex3;
var init_defaultFilter_vert = __esm({
  "node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs"() {
    init_define_AnParams();
    vertex3 = "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.mjs
var fragment3;
var init_alpha_frag = __esm({
  "node_modules/pixi.js/lib/filters/defaults/alpha/alpha.frag.mjs"() {
    init_define_AnParams();
    fragment3 = "\nin vec2 vTextureCoord;\n\nout vec4 finalColor;\n\nuniform float uAlpha;\nuniform sampler2D uTexture;\n\nvoid main()\n{\n    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.mjs
var source2;
var init_alpha_wgsl = __esm({
  "node_modules/pixi.js/lib/filters/defaults/alpha/alpha.wgsl.mjs"() {
    init_define_AnParams();
    source2 = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct AlphaUniforms {\n  uAlpha:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n \n    var sample = textureSample(uTexture, uSampler, uv);\n    \n    return sample * alphaUniforms.uAlpha;\n}";
  }
});

// node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs
var _AlphaFilter, AlphaFilter;
var init_AlphaFilter = __esm({
  "node_modules/pixi.js/lib/filters/defaults/alpha/AlphaFilter.mjs"() {
    init_define_AnParams();
    init_GlProgram();
    init_GpuProgram();
    init_UniformGroup();
    init_Filter();
    init_defaultFilter_vert();
    init_alpha_frag();
    init_alpha_wgsl();
    _AlphaFilter = class _AlphaFilter2 extends Filter {
      constructor(options) {
        options = { ..._AlphaFilter2.defaultOptions, ...options };
        const gpuProgram3 = GpuProgram.from({
          vertex: {
            source: source2,
            entryPoint: "mainVertex"
          },
          fragment: {
            source: source2,
            entryPoint: "mainFragment"
          }
        });
        const glProgram3 = GlProgram.from({
          vertex: vertex3,
          fragment: fragment3,
          name: "alpha-filter"
        });
        const { alpha, ...rest } = options;
        const alphaUniforms = new UniformGroup({
          uAlpha: { value: alpha, type: "f32" }
        });
        super({
          ...rest,
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          resources: {
            alphaUniforms
          }
        });
      }
      /**
       * Coefficient for alpha multiplication
       * @default 1
       */
      get alpha() {
        return this.resources.alphaUniforms.uniforms.uAlpha;
      }
      set alpha(value) {
        this.resources.alphaUniforms.uniforms.uAlpha = value;
      }
    };
    _AlphaFilter.defaultOptions = {
      /** Amount of alpha from 0 to 1, where 0 is transparent */
      alpha: 1
    };
    AlphaFilter = _AlphaFilter;
  }
});

// node_modules/pixi.js/lib/filters/defaults/blur/const.mjs
var GAUSSIAN_VALUES;
var init_const13 = __esm({
  "node_modules/pixi.js/lib/filters/defaults/blur/const.mjs"() {
    "use strict";
    init_define_AnParams();
    GAUSSIAN_VALUES = {
      5: [0.153388, 0.221461, 0.250301],
      7: [0.071303, 0.131514, 0.189879, 0.214607],
      9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
      11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
      13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
      15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
    };
  }
});

// node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.mjs
function generateBlurFragSource(kernelSize) {
  const kernel = GAUSSIAN_VALUES[kernelSize];
  const halfLength = kernel.length;
  let fragSource = fragTemplate2;
  let blurLoop = "";
  const template = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";
  let value;
  for (let i3 = 0; i3 < kernelSize; i3++) {
    let blur = template.replace("%index%", i3.toString());
    value = i3;
    if (i3 >= halfLength) {
      value = kernelSize - i3 - 1;
    }
    blur = blur.replace("%value%", kernel[value].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}
var fragTemplate2;
var init_generateBlurFragSource = __esm({
  "node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurFragSource.mjs"() {
    init_define_AnParams();
    init_const13();
    fragTemplate2 = [
      "in vec2 vBlurTexCoords[%size%];",
      "uniform sampler2D uTexture;",
      "out vec4 finalColor;",
      "void main(void)",
      "{",
      "    finalColor = vec4(0.0);",
      "    %blur%",
      "}"
    ].join("\n");
  }
});

// node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.mjs
function generateBlurVertSource(kernelSize, x2) {
  const halfLength = Math.ceil(kernelSize / 2);
  let vertSource = vertTemplate;
  let blurLoop = "";
  let template;
  if (x2) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
  }
  for (let i3 = 0; i3 < kernelSize; i3++) {
    let blur = template.replace("%index%", i3.toString());
    blur = blur.replace("%sampleIndex%", `${i3 - (halfLength - 1)}.0`);
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  vertSource = vertSource.replace("%dimension%", x2 ? "z" : "w");
  return vertSource;
}
var vertTemplate;
var init_generateBlurVertSource = __esm({
  "node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurVertSource.mjs"() {
    "use strict";
    init_define_AnParams();
    vertTemplate = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
  }
});

// node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.mjs
function generateBlurGlProgram(horizontal, kernelSize) {
  const vertex6 = generateBlurVertSource(kernelSize, horizontal);
  const fragment9 = generateBlurFragSource(kernelSize);
  return GlProgram.from({
    vertex: vertex6,
    fragment: fragment9,
    name: `blur-${horizontal ? "horizontal" : "vertical"}-pass-filter`
  });
}
var init_generateBlurGlProgram = __esm({
  "node_modules/pixi.js/lib/filters/defaults/blur/gl/generateBlurGlProgram.mjs"() {
    init_define_AnParams();
    init_GlProgram();
    init_generateBlurFragSource();
    init_generateBlurVertSource();
  }
});

// node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.mjs
var source3;
var init_blur_template_wgsl = __esm({
  "node_modules/pixi.js/lib/filters/defaults/blur/gpu/blur-template.wgsl.mjs"() {
    init_define_AnParams();
    source3 = "\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct BlurUniforms {\n  uStrength:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    %blur-struct%\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n\n  let filteredCord = filterTextureCoord(aPosition);\n\n  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;\n\n  return VSOutput(\n   filterVertexPosition(aPosition),\n    %blur-vertex-out%\n  );\n}\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  %blur-fragment-in%\n) -> @location(0) vec4<f32> {\n\n    var   finalColor = vec4(0.0);\n\n    %blur-sampling%\n\n    return finalColor;\n}";
  }
});

// node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.mjs
function generateBlurProgram(horizontal, kernelSize) {
  const kernel = GAUSSIAN_VALUES[kernelSize];
  const halfLength = kernel.length;
  const blurStructSource = [];
  const blurOutSource = [];
  const blurSamplingSource = [];
  for (let i3 = 0; i3 < kernelSize; i3++) {
    blurStructSource[i3] = `@location(${i3}) offset${i3}: vec2<f32>,`;
    if (horizontal) {
      blurOutSource[i3] = `filteredCord + vec2(${i3 - halfLength + 1} * pixelStrength, 0.0),`;
    } else {
      blurOutSource[i3] = `filteredCord + vec2(0.0, ${i3 - halfLength + 1} * pixelStrength),`;
    }
    const kernelIndex = i3 < halfLength ? i3 : kernelSize - i3 - 1;
    const kernelValue = kernel[kernelIndex].toString();
    blurSamplingSource[i3] = `finalColor += textureSample(uTexture, uSampler, offset${i3}) * ${kernelValue};`;
  }
  const blurStruct = blurStructSource.join("\n");
  const blurOut = blurOutSource.join("\n");
  const blurSampling = blurSamplingSource.join("\n");
  const finalSource = source3.replace("%blur-struct%", blurStruct).replace("%blur-vertex-out%", blurOut).replace("%blur-fragment-in%", blurStruct).replace("%blur-sampling%", blurSampling).replace("%dimension%", horizontal ? "z" : "w");
  return GpuProgram.from({
    vertex: {
      source: finalSource,
      entryPoint: "mainVertex"
    },
    fragment: {
      source: finalSource,
      entryPoint: "mainFragment"
    }
  });
}
var init_generateBlurProgram = __esm({
  "node_modules/pixi.js/lib/filters/defaults/blur/gpu/generateBlurProgram.mjs"() {
    init_define_AnParams();
    init_GpuProgram();
    init_const13();
    init_blur_template_wgsl();
  }
});

// node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.mjs
var _BlurFilterPass, BlurFilterPass;
var init_BlurFilterPass = __esm({
  "node_modules/pixi.js/lib/filters/defaults/blur/BlurFilterPass.mjs"() {
    init_define_AnParams();
    init_TexturePool();
    init_types2();
    init_Filter();
    init_generateBlurGlProgram();
    init_generateBlurProgram();
    _BlurFilterPass = class _BlurFilterPass2 extends Filter {
      /**
       * @param options
       * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).
       * @param options.strength - The strength of the blur filter.
       * @param options.quality - The quality of the blur filter.
       * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
       */
      constructor(options) {
        options = { ..._BlurFilterPass2.defaultOptions, ...options };
        const glProgram3 = generateBlurGlProgram(options.horizontal, options.kernelSize);
        const gpuProgram3 = generateBlurProgram(options.horizontal, options.kernelSize);
        super({
          glProgram: glProgram3,
          gpuProgram: gpuProgram3,
          resources: {
            blurUniforms: {
              uStrength: { value: 0, type: "f32" }
            }
          },
          ...options
        });
        this.horizontal = options.horizontal;
        this._quality = 0;
        this.quality = options.quality;
        this.blur = options.strength;
        this._uniforms = this.resources.blurUniforms.uniforms;
      }
      /**
       * Applies the filter.
       * @param filterManager - The manager.
       * @param input - The input target.
       * @param output - The output target.
       * @param clearMode - How to clear
       */
      apply(filterManager, input, output, clearMode) {
        this._uniforms.uStrength = this.strength / this.passes;
        if (this.passes === 1) {
          filterManager.applyFilter(this, input, output, clearMode);
        } else {
          const tempTexture = TexturePool.getSameSizeTexture(input);
          let flip = input;
          let flop = tempTexture;
          this._state.blend = false;
          const shouldClear = filterManager.renderer.type === RendererType.WEBGPU;
          for (let i3 = 0; i3 < this.passes - 1; i3++) {
            filterManager.applyFilter(this, flip, flop, i3 === 0 ? true : shouldClear);
            const temp = flop;
            flop = flip;
            flip = temp;
          }
          this._state.blend = true;
          filterManager.applyFilter(this, flip, output, clearMode);
          TexturePool.returnTexture(tempTexture);
        }
      }
      /**
       * Sets the strength of both the blur.
       * @default 16
       */
      get blur() {
        return this.strength;
      }
      set blur(value) {
        this.padding = 1 + Math.abs(value) * 2;
        this.strength = value;
      }
      /**
       * Sets the quality of the blur by modifying the number of passes. More passes means higher
       * quality blurring but the lower the performance.
       * @default 4
       */
      get quality() {
        return this._quality;
      }
      set quality(value) {
        this._quality = value;
        this.passes = value;
      }
    };
    _BlurFilterPass.defaultOptions = {
      /** The strength of the blur filter. */
      strength: 8,
      /** The quality of the blur filter. */
      quality: 4,
      /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
      kernelSize: 5
    };
    BlurFilterPass = _BlurFilterPass;
  }
});

// node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.mjs
var BlurFilter;
var init_BlurFilter = __esm({
  "node_modules/pixi.js/lib/filters/defaults/blur/BlurFilter.mjs"() {
    init_define_AnParams();
    init_TexturePool();
    init_types2();
    init_deprecation();
    init_Filter();
    init_BlurFilterPass();
    BlurFilter = class extends Filter {
      constructor(...args) {
        let options = args[0] ?? {};
        if (typeof options === "number") {
          deprecation(v8_0_0, "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }");
          options = { strength: options };
          if (args[1] !== void 0)
            options.quality = args[1];
          if (args[2] !== void 0)
            options.resolution = args[2] || "inherit";
          if (args[3] !== void 0)
            options.kernelSize = args[3];
        }
        options = { ...BlurFilterPass.defaultOptions, ...options };
        const { strength, strengthX, strengthY, quality, ...rest } = options;
        super({
          ...rest,
          compatibleRenderers: RendererType.BOTH,
          resources: {}
        });
        this._repeatEdgePixels = false;
        this.blurXFilter = new BlurFilterPass({ horizontal: true, ...options });
        this.blurYFilter = new BlurFilterPass({ horizontal: false, ...options });
        this.quality = quality;
        this.strengthX = strengthX ?? strength;
        this.strengthY = strengthY ?? strength;
        this.repeatEdgePixels = false;
      }
      /**
       * Applies the filter.
       * @param filterManager - The manager.
       * @param input - The input target.
       * @param output - The output target.
       * @param clearMode - How to clear
       */
      apply(filterManager, input, output, clearMode) {
        const xStrength = Math.abs(this.blurXFilter.strength);
        const yStrength = Math.abs(this.blurYFilter.strength);
        if (xStrength && yStrength) {
          const tempTexture = TexturePool.getSameSizeTexture(input);
          this.blurXFilter.blendMode = "normal";
          this.blurXFilter.apply(filterManager, input, tempTexture, true);
          this.blurYFilter.blendMode = this.blendMode;
          this.blurYFilter.apply(filterManager, tempTexture, output, clearMode);
          TexturePool.returnTexture(tempTexture);
        } else if (yStrength) {
          this.blurYFilter.blendMode = this.blendMode;
          this.blurYFilter.apply(filterManager, input, output, clearMode);
        } else {
          this.blurXFilter.blendMode = this.blendMode;
          this.blurXFilter.apply(filterManager, input, output, clearMode);
        }
      }
      updatePadding() {
        if (this._repeatEdgePixels) {
          this.padding = 0;
        } else {
          this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;
        }
      }
      /**
       * Sets the strength of both the blurX and blurY properties simultaneously
       * @default 8
       */
      get strength() {
        if (this.strengthX !== this.strengthY) {
          throw new Error("BlurFilter's strengthX and strengthY are different");
        }
        return this.strengthX;
      }
      set strength(value) {
        this.blurXFilter.blur = this.blurYFilter.blur = value;
        this.updatePadding();
      }
      /**
       * Sets the number of passes for blur. More passes means higher quality bluring.
       * @default 1
       */
      get quality() {
        return this.blurXFilter.quality;
      }
      set quality(value) {
        this.blurXFilter.quality = this.blurYFilter.quality = value;
      }
      /**
       * Sets the strength of horizontal blur
       * @default 8
       */
      get strengthX() {
        return this.blurXFilter.blur;
      }
      set strengthX(value) {
        this.blurXFilter.blur = value;
        this.updatePadding();
      }
      /**
       * Sets the strength of the vertical blur
       * @default 8
       */
      get strengthY() {
        return this.blurYFilter.blur;
      }
      set strengthY(value) {
        this.blurYFilter.blur = value;
        this.updatePadding();
      }
      /**
       * Sets the strength of both the blurX and blurY properties simultaneously
       * @default 2
       * @deprecated since 8.3.0
       * @see BlurFilter.strength
       */
      get blur() {
        deprecation("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");
        return this.strength;
      }
      set blur(value) {
        deprecation("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");
        this.strength = value;
      }
      /**
       * Sets the strength of the blurX property
       * @default 2
       * @deprecated since 8.3.0
       * @see BlurFilter.strengthX
       */
      get blurX() {
        deprecation("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");
        return this.strengthX;
      }
      set blurX(value) {
        deprecation("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");
        this.strengthX = value;
      }
      /**
       * Sets the strength of the blurY property
       * @default 2
       * @deprecated since 8.3.0
       * @see BlurFilter.strengthY
       */
      get blurY() {
        deprecation("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");
        return this.strengthY;
      }
      set blurY(value) {
        deprecation("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");
        this.strengthY = value;
      }
      /**
       * If set to true the edge of the target will be clamped
       * @default false
       */
      get repeatEdgePixels() {
        return this._repeatEdgePixels;
      }
      set repeatEdgePixels(value) {
        this._repeatEdgePixels = value;
        this.updatePadding();
      }
    };
    BlurFilter.defaultOptions = {
      /** The strength of the blur filter. */
      strength: 8,
      /** The quality of the blur filter. */
      quality: 4,
      /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
      kernelSize: 5
    };
  }
});

// node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.mjs
var fragment4;
var init_colorMatrixFilter_frag = __esm({
  "node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.frag.mjs"() {
    init_define_AnParams();
    fragment4 = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uColorMatrix[20];\nuniform float uAlpha;\n\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * 0.2);\n    float diff = (randomValue - 0.5) *  0.5;\n\n    if (uAlpha == 0.0) {\n        finalColor = color;\n        return;\n    }\n\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    vec4 result;\n\n    result.r = (uColorMatrix[0] * color.r);\n        result.r += (uColorMatrix[1] * color.g);\n        result.r += (uColorMatrix[2] * color.b);\n        result.r += (uColorMatrix[3] * color.a);\n        result.r += uColorMatrix[4];\n\n    result.g = (uColorMatrix[5] * color.r);\n        result.g += (uColorMatrix[6] * color.g);\n        result.g += (uColorMatrix[7] * color.b);\n        result.g += (uColorMatrix[8] * color.a);\n        result.g += uColorMatrix[9];\n\n    result.b = (uColorMatrix[10] * color.r);\n       result.b += (uColorMatrix[11] * color.g);\n       result.b += (uColorMatrix[12] * color.b);\n       result.b += (uColorMatrix[13] * color.a);\n       result.b += uColorMatrix[14];\n\n    result.a = (uColorMatrix[15] * color.r);\n       result.a += (uColorMatrix[16] * color.g);\n       result.a += (uColorMatrix[17] * color.b);\n       result.a += (uColorMatrix[18] * color.a);\n       result.a += uColorMatrix[19];\n\n    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    finalColor = vec4(rgb, result.a);\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs
var source4;
var init_colorMatrixFilter_wgsl = __esm({
  "node_modules/pixi.js/lib/filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs"() {
    init_define_AnParams();
    source4 = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct ColorMatrixUniforms {\n  uColorMatrix:array<vec4<f32>, 5>,\n  uAlpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n  };\n  \nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n  );\n}\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n\n\n  var c = textureSample(uTexture, uSampler, uv);\n  \n  if (colorMatrixUniforms.uAlpha == 0.0) {\n    return c;\n  }\n\n \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.r /= c.a;\n      c.g /= c.a;\n      c.b /= c.a;\n    }\n\n    var cm = colorMatrixUniforms.uColorMatrix;\n\n\n    var result = vec4<f32>(0.);\n\n    result.r = (cm[0][0] * c.r);\n    result.r += (cm[0][1] * c.g);\n    result.r += (cm[0][2] * c.b);\n    result.r += (cm[0][3] * c.a);\n    result.r += cm[1][0];\n\n    result.g = (cm[1][1] * c.r);\n    result.g += (cm[1][2] * c.g);\n    result.g += (cm[1][3] * c.b);\n    result.g += (cm[2][0] * c.a);\n    result.g += cm[2][1];\n\n    result.b = (cm[2][2] * c.r);\n    result.b += (cm[2][3] * c.g);\n    result.b += (cm[3][0] * c.b);\n    result.b += (cm[3][1] * c.a);\n    result.b += cm[3][2];\n\n    result.a = (cm[3][3] * c.r);\n    result.a += (cm[4][0] * c.g);\n    result.a += (cm[4][1] * c.b);\n    result.a += (cm[4][2] * c.a);\n    result.a += cm[4][3];\n\n    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);\n\n    rgb.r *= result.a;\n    rgb.g *= result.a;\n    rgb.b *= result.a;\n\n    return vec4(rgb, result.a);\n}";
  }
});

// node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.mjs
var ColorMatrixFilter;
var init_ColorMatrixFilter = __esm({
  "node_modules/pixi.js/lib/filters/defaults/color-matrix/ColorMatrixFilter.mjs"() {
    init_define_AnParams();
    init_Color();
    init_GlProgram();
    init_GpuProgram();
    init_UniformGroup();
    init_Filter();
    init_defaultFilter_vert();
    init_colorMatrixFilter_frag();
    init_colorMatrixFilter_wgsl();
    ColorMatrixFilter = class extends Filter {
      constructor(options = {}) {
        const colorMatrixUniforms = new UniformGroup({
          uColorMatrix: {
            value: [
              1,
              0,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              1,
              0
            ],
            type: "f32",
            size: 20
          },
          uAlpha: {
            value: 1,
            type: "f32"
          }
        });
        const gpuProgram3 = GpuProgram.from({
          vertex: {
            source: source4,
            entryPoint: "mainVertex"
          },
          fragment: {
            source: source4,
            entryPoint: "mainFragment"
          }
        });
        const glProgram3 = GlProgram.from({
          vertex: vertex3,
          fragment: fragment4,
          name: "color-matrix-filter"
        });
        super({
          ...options,
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          resources: {
            colorMatrixUniforms
          }
        });
        this.alpha = 1;
      }
      /**
       * Transforms current matrix and set the new one
       * @param {number[]} matrix - 5x4 matrix
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      _loadMatrix(matrix, multiply = false) {
        let newMatrix = matrix;
        if (multiply) {
          this._multiply(newMatrix, this.matrix, matrix);
          newMatrix = this._colorMatrix(newMatrix);
        }
        this.resources.colorMatrixUniforms.uniforms.uColorMatrix = newMatrix;
        this.resources.colorMatrixUniforms.update();
      }
      /**
       * Multiplies two mat5's
       * @private
       * @param out - 5x4 matrix the receiving matrix
       * @param a - 5x4 matrix the first operand
       * @param b - 5x4 matrix the second operand
       * @returns {number[]} 5x4 matrix
       */
      _multiply(out2, a2, b3) {
        out2[0] = a2[0] * b3[0] + a2[1] * b3[5] + a2[2] * b3[10] + a2[3] * b3[15];
        out2[1] = a2[0] * b3[1] + a2[1] * b3[6] + a2[2] * b3[11] + a2[3] * b3[16];
        out2[2] = a2[0] * b3[2] + a2[1] * b3[7] + a2[2] * b3[12] + a2[3] * b3[17];
        out2[3] = a2[0] * b3[3] + a2[1] * b3[8] + a2[2] * b3[13] + a2[3] * b3[18];
        out2[4] = a2[0] * b3[4] + a2[1] * b3[9] + a2[2] * b3[14] + a2[3] * b3[19] + a2[4];
        out2[5] = a2[5] * b3[0] + a2[6] * b3[5] + a2[7] * b3[10] + a2[8] * b3[15];
        out2[6] = a2[5] * b3[1] + a2[6] * b3[6] + a2[7] * b3[11] + a2[8] * b3[16];
        out2[7] = a2[5] * b3[2] + a2[6] * b3[7] + a2[7] * b3[12] + a2[8] * b3[17];
        out2[8] = a2[5] * b3[3] + a2[6] * b3[8] + a2[7] * b3[13] + a2[8] * b3[18];
        out2[9] = a2[5] * b3[4] + a2[6] * b3[9] + a2[7] * b3[14] + a2[8] * b3[19] + a2[9];
        out2[10] = a2[10] * b3[0] + a2[11] * b3[5] + a2[12] * b3[10] + a2[13] * b3[15];
        out2[11] = a2[10] * b3[1] + a2[11] * b3[6] + a2[12] * b3[11] + a2[13] * b3[16];
        out2[12] = a2[10] * b3[2] + a2[11] * b3[7] + a2[12] * b3[12] + a2[13] * b3[17];
        out2[13] = a2[10] * b3[3] + a2[11] * b3[8] + a2[12] * b3[13] + a2[13] * b3[18];
        out2[14] = a2[10] * b3[4] + a2[11] * b3[9] + a2[12] * b3[14] + a2[13] * b3[19] + a2[14];
        out2[15] = a2[15] * b3[0] + a2[16] * b3[5] + a2[17] * b3[10] + a2[18] * b3[15];
        out2[16] = a2[15] * b3[1] + a2[16] * b3[6] + a2[17] * b3[11] + a2[18] * b3[16];
        out2[17] = a2[15] * b3[2] + a2[16] * b3[7] + a2[17] * b3[12] + a2[18] * b3[17];
        out2[18] = a2[15] * b3[3] + a2[16] * b3[8] + a2[17] * b3[13] + a2[18] * b3[18];
        out2[19] = a2[15] * b3[4] + a2[16] * b3[9] + a2[17] * b3[14] + a2[18] * b3[19] + a2[19];
        return out2;
      }
      /**
       * Create a Float32 Array and normalize the offset component to 0-1
       * @param {number[]} matrix - 5x4 matrix
       * @returns {number[]} 5x4 matrix with all values between 0-1
       */
      _colorMatrix(matrix) {
        const m2 = new Float32Array(matrix);
        m2[4] /= 255;
        m2[9] /= 255;
        m2[14] /= 255;
        m2[19] /= 255;
        return m2;
      }
      /**
       * Adjusts brightness
       * @param b - value of the brightness (0-1, where 0 is black)
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      brightness(b3, multiply) {
        const matrix = [
          b3,
          0,
          0,
          0,
          0,
          0,
          b3,
          0,
          0,
          0,
          0,
          0,
          b3,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Sets each channel on the diagonal of the color matrix.
       * This can be used to achieve a tinting effect on Containers similar to the tint field of some
       * display objects like Sprite, Text, Graphics, and Mesh.
       * @param color - Color of the tint. This is a hex value.
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      tint(color, multiply) {
        const [r2, g2, b3] = Color.shared.setValue(color).toArray();
        const matrix = [
          r2,
          0,
          0,
          0,
          0,
          0,
          g2,
          0,
          0,
          0,
          0,
          0,
          b3,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Set the matrices in grey scales
       * @param scale - value of the grey (0-1, where 0 is black)
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      greyscale(scale, multiply) {
        const matrix = [
          scale,
          scale,
          scale,
          0,
          0,
          scale,
          scale,
          scale,
          0,
          0,
          scale,
          scale,
          scale,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * for our american friends!
       * @param scale
       * @param multiply
       */
      grayscale(scale, multiply) {
        this.greyscale(scale, multiply);
      }
      /**
       * Set the black and white matrice.
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      blackAndWhite(multiply) {
        const matrix = [
          0.3,
          0.6,
          0.1,
          0,
          0,
          0.3,
          0.6,
          0.1,
          0,
          0,
          0.3,
          0.6,
          0.1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Set the hue property of the color
       * @param rotation - in degrees
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      hue(rotation, multiply) {
        rotation = (rotation || 0) / 180 * Math.PI;
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);
        const sqrt = Math.sqrt;
        const w2 = 1 / 3;
        const sqrW = sqrt(w2);
        const a00 = cosR + (1 - cosR) * w2;
        const a01 = w2 * (1 - cosR) - sqrW * sinR;
        const a02 = w2 * (1 - cosR) + sqrW * sinR;
        const a10 = w2 * (1 - cosR) + sqrW * sinR;
        const a11 = cosR + w2 * (1 - cosR);
        const a12 = w2 * (1 - cosR) - sqrW * sinR;
        const a20 = w2 * (1 - cosR) - sqrW * sinR;
        const a21 = w2 * (1 - cosR) + sqrW * sinR;
        const a22 = cosR + w2 * (1 - cosR);
        const matrix = [
          a00,
          a01,
          a02,
          0,
          0,
          a10,
          a11,
          a12,
          0,
          0,
          a20,
          a21,
          a22,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Set the contrast matrix, increase the separation between dark and bright
       * Increase contrast : shadows darker and highlights brighter
       * Decrease contrast : bring the shadows up and the highlights down
       * @param amount - value of the contrast (0-1)
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      contrast(amount, multiply) {
        const v2 = (amount || 0) + 1;
        const o2 = -0.5 * (v2 - 1);
        const matrix = [
          v2,
          0,
          0,
          0,
          o2,
          0,
          v2,
          0,
          0,
          o2,
          0,
          0,
          v2,
          0,
          o2,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Set the saturation matrix, increase the separation between colors
       * Increase saturation : increase contrast, brightness, and sharpness
       * @param amount - The saturation amount (0-1)
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      saturate(amount = 0, multiply) {
        const x2 = amount * 2 / 3 + 1;
        const y2 = (x2 - 1) * -0.5;
        const matrix = [
          x2,
          y2,
          y2,
          0,
          0,
          y2,
          x2,
          y2,
          0,
          0,
          y2,
          y2,
          x2,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /** Desaturate image (remove color) Call the saturate function */
      desaturate() {
        this.saturate(-1);
      }
      /**
       * Negative image (inverse of classic rgb matrix)
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      negative(multiply) {
        const matrix = [
          -1,
          0,
          0,
          1,
          0,
          0,
          -1,
          0,
          1,
          0,
          0,
          0,
          -1,
          1,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Sepia image
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      sepia(multiply) {
        const matrix = [
          0.393,
          0.7689999,
          0.18899999,
          0,
          0,
          0.349,
          0.6859999,
          0.16799999,
          0,
          0,
          0.272,
          0.5339999,
          0.13099999,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      technicolor(multiply) {
        const matrix = [
          1.9125277891456083,
          -0.8545344976951645,
          -0.09155508482755585,
          0,
          11.793603434377337,
          -0.3087833385928097,
          1.7658908555458428,
          -0.10601743074722245,
          0,
          -70.35205161461398,
          -0.231103377548616,
          -0.7501899197440212,
          1.847597816108189,
          0,
          30.950940869491138,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Polaroid filter
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      polaroid(multiply) {
        const matrix = [
          1.438,
          -0.062,
          -0.062,
          0,
          0,
          -0.122,
          1.378,
          -0.122,
          0,
          0,
          -0.016,
          -0.016,
          1.483,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Filter who transforms : Red -> Blue and Blue -> Red
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      toBGR(multiply) {
        const matrix = [
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      kodachrome(multiply) {
        const matrix = [
          1.1285582396593525,
          -0.3967382283601348,
          -0.03992559172921793,
          0,
          63.72958762196502,
          -0.16404339962244616,
          1.0835251566291304,
          -0.05498805115633132,
          0,
          24.732407896706203,
          -0.16786010706155763,
          -0.5603416277695248,
          1.6014850761964943,
          0,
          35.62982807460946,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Brown delicious browni filter (thanks Dominic Szablewski)
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      browni(multiply) {
        const matrix = [
          0.5997023498159715,
          0.34553243048391263,
          -0.2708298674538042,
          0,
          47.43192855600873,
          -0.037703249837783157,
          0.8609577587992641,
          0.15059552388459913,
          0,
          -36.96841498319127,
          0.24113635128153335,
          -0.07441037908422492,
          0.44972182064877153,
          0,
          -7.562075277591283,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Vintage filter (thanks Dominic Szablewski)
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      vintage(multiply) {
        const matrix = [
          0.6279345635605994,
          0.3202183420819367,
          -0.03965408211312453,
          0,
          9.651285835294123,
          0.02578397704808868,
          0.6441188644374771,
          0.03259127616149294,
          0,
          7.462829176470591,
          0.0466055556782719,
          -0.0851232987247891,
          0.5241648018700465,
          0,
          5.159190588235296,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * We don't know exactly what it does, kind of gradient map, but funny to play with!
       * @param desaturation - Tone values.
       * @param toned - Tone values.
       * @param lightColor - Tone values, example: `0xFFE580`
       * @param darkColor - Tone values, example: `0xFFE580`
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      colorTone(desaturation, toned, lightColor, darkColor, multiply) {
        desaturation || (desaturation = 0.2);
        toned || (toned = 0.15);
        lightColor || (lightColor = 16770432);
        darkColor || (darkColor = 3375104);
        const temp = Color.shared;
        const [lR, lG, lB] = temp.setValue(lightColor).toArray();
        const [dR, dG, dB] = temp.setValue(darkColor).toArray();
        const matrix = [
          0.3,
          0.59,
          0.11,
          0,
          0,
          lR,
          lG,
          lB,
          desaturation,
          0,
          dR,
          dG,
          dB,
          toned,
          0,
          lR - dR,
          lG - dG,
          lB - dB,
          0,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Night effect
       * @param intensity - The intensity of the night effect.
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      night(intensity, multiply) {
        intensity || (intensity = 0.1);
        const matrix = [
          intensity * -2,
          -intensity,
          0,
          0,
          0,
          -intensity,
          0,
          intensity,
          0,
          0,
          0,
          intensity,
          intensity * 2,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * Predator effect
       *
       * Erase the current matrix by setting a new independent one
       * @param amount - how much the predator feels his future victim
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      predator(amount, multiply) {
        const matrix = [
          // row 1
          11.224130630493164 * amount,
          -4.794486999511719 * amount,
          -2.8746118545532227 * amount,
          0 * amount,
          0.40342438220977783 * amount,
          // row 2
          -3.6330697536468506 * amount,
          9.193157196044922 * amount,
          -2.951810836791992 * amount,
          0 * amount,
          -1.316135048866272 * amount,
          // row 3
          -3.2184197902679443 * amount,
          -4.2375030517578125 * amount,
          7.476448059082031 * amount,
          0 * amount,
          0.8044459223747253 * amount,
          // row 4
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /**
       * LSD effect
       *
       * Multiply the current matrix
       * @param multiply - if true, current matrix and matrix are multiplied. If false,
       *  just set the current matrix with @param matrix
       */
      lsd(multiply) {
        const matrix = [
          2,
          -0.4,
          0.5,
          0,
          0,
          -0.5,
          2,
          -0.4,
          0,
          0,
          -0.4,
          -0.5,
          3,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, multiply);
      }
      /** Erase the current matrix by setting the default one. */
      reset() {
        const matrix = [
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ];
        this._loadMatrix(matrix, false);
      }
      /**
       * The matrix of the color matrix filter
       * @member {number[]}
       * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
       */
      get matrix() {
        return this.resources.colorMatrixUniforms.uniforms.uColorMatrix;
      }
      set matrix(value) {
        this.resources.colorMatrixUniforms.uniforms.uColorMatrix = value;
      }
      /**
       * The opacity value to use when mixing the original and resultant colors.
       *
       * When the value is 0, the original color is used without modification.
       * When the value is 1, the result color is used.
       * When in the range (0, 1) the color is interpolated between the original and result by this amount.
       * @default 1
       */
      get alpha() {
        return this.resources.colorMatrixUniforms.uniforms.uAlpha;
      }
      set alpha(value) {
        this.resources.colorMatrixUniforms.uniforms.uAlpha = value;
      }
    };
  }
});

// node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs
var fragment5;
var init_displacement_frag = __esm({
  "node_modules/pixi.js/lib/filters/defaults/displacement/displacement.frag.mjs"() {
    init_define_AnParams();
    fragment5 = "\nin vec2 vTextureCoord;\nin vec2 vFilterUv;\n\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\n\nuniform vec4 uInputClamp;\nuniform highp vec4 uInputSize;\nuniform mat2 uRotation;\nuniform vec2 uScale;\n\nvoid main()\n{\n    vec4 map = texture(uMapTexture, vFilterUv);\n    \n    vec2 offset = uInputSize.zw * (uRotation * (map.xy - 0.5)) * uScale; \n\n    finalColor = texture(uTexture, clamp(vTextureCoord + offset, uInputClamp.xy, uInputClamp.zw));\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs
var vertex4;
var init_displacement_vert = __esm({
  "node_modules/pixi.js/lib/filters/defaults/displacement/displacement.vert.mjs"() {
    init_define_AnParams();
    vertex4 = "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 vFilterUv;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( void )\n{\n  return ( uFilterMatrix * vec3( filterTextureCoord(), 1.0)  ).xy;\n}\n\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    vFilterUv = getFilterCoord();\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs
var source5;
var init_displacement_wgsl = __esm({
  "node_modules/pixi.js/lib/filters/defaults/displacement/displacement.wgsl.mjs"() {
    init_define_AnParams();
    source5 = "\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct DisplacementUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uScale:vec2<f32>,\n  uRotation:mat2x2<f32>\n};\n\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : DisplacementUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n@group(1) @binding(2) var uMapSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var map = textureSample(uMapTexture, uMapSampler, filterUv);\n\n    var offset =  gfu.uInputSize.zw * (filterUniforms.uRotation * (map.xy - 0.5)) * filterUniforms.uScale; \n   \n    return textureSample(uTexture, uSampler, clamp(uv + offset, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n}";
  }
});

// node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.mjs
var DisplacementFilter;
var init_DisplacementFilter = __esm({
  "node_modules/pixi.js/lib/filters/defaults/displacement/DisplacementFilter.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_Point();
    init_GlProgram();
    init_GpuProgram();
    init_UniformGroup();
    init_Sprite();
    init_deprecation();
    init_Filter();
    init_displacement_frag();
    init_displacement_vert();
    init_displacement_wgsl();
    DisplacementFilter = class extends Filter {
      constructor(...args) {
        let options = args[0];
        if (options instanceof Sprite) {
          if (args[1]) {
            deprecation(v8_0_0, "DisplacementFilter now uses options object instead of params. {sprite, scale}");
          }
          options = { sprite: options, scale: args[1] };
        }
        const { sprite, scale: scaleOption, ...rest } = options;
        let scale = scaleOption ?? 20;
        if (typeof scale === "number") {
          scale = new Point(scale, scale);
        }
        const filterUniforms = new UniformGroup({
          uFilterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uScale: { value: scale, type: "vec2<f32>" },
          uRotation: { value: new Float32Array([0, 0, 0, 0]), type: "mat2x2<f32>" }
        });
        const glProgram3 = GlProgram.from({
          vertex: vertex4,
          fragment: fragment5,
          name: "displacement-filter"
        });
        const gpuProgram3 = GpuProgram.from({
          vertex: {
            source: source5,
            entryPoint: "mainVertex"
          },
          fragment: {
            source: source5,
            entryPoint: "mainFragment"
          }
        });
        const textureSource = sprite.texture.source;
        super({
          ...rest,
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          resources: {
            filterUniforms,
            uMapTexture: textureSource,
            uMapSampler: textureSource.style
          }
        });
        this._sprite = options.sprite;
        this._sprite.renderable = false;
      }
      /**
       * Applies the filter.
       * @param filterManager - The manager.
       * @param input - The input target.
       * @param output - The output target.
       * @param clearMode - clearMode.
       */
      apply(filterManager, input, output, clearMode) {
        const uniforms = this.resources.filterUniforms.uniforms;
        filterManager.calculateSpriteMatrix(
          uniforms.uFilterMatrix,
          this._sprite
        );
        const wt = this._sprite.worldTransform;
        const lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
        const lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
        if (lenX !== 0 && lenY !== 0) {
          uniforms.uRotation[0] = wt.a / lenX;
          uniforms.uRotation[1] = wt.b / lenX;
          uniforms.uRotation[2] = wt.c / lenY;
          uniforms.uRotation[3] = wt.d / lenY;
        }
        this.resources.uMapTexture = this._sprite.texture.source;
        filterManager.applyFilter(this, input, output, clearMode);
      }
      /** scaleX, scaleY for displacements */
      get scale() {
        return this.resources.filterUniforms.uniforms.uScale;
      }
    };
  }
});

// node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.mjs
var fragment6;
var init_noise_frag = __esm({
  "node_modules/pixi.js/lib/filters/defaults/noise/noise.frag.mjs"() {
    init_define_AnParams();
    fragment6 = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) *  uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    finalColor = color;\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.mjs
var source6;
var init_noise_wgsl = __esm({
  "node_modules/pixi.js/lib/filters/defaults/noise/noise.wgsl.mjs"() {
    init_define_AnParams();
    source6 = "\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct NoiseUniforms {\n  uNoise:f32,\n  uSeed:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> noiseUniforms : NoiseUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\nfn rand(co:vec2<f32>) -> f32\n{\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var pixelPosition =  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);\n  \n    \n    var sample = textureSample(uTexture, uSampler, uv);\n    var randomValue =  rand(pixelPosition.xy * noiseUniforms.uSeed);\n    var diff = (randomValue - 0.5) * noiseUniforms.uNoise;\n  \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (sample.a > 0.0) {\n      sample.r /= sample.a;\n      sample.g /= sample.a;\n      sample.b /= sample.a;\n    }\n\n    sample.r += diff;\n    sample.g += diff;\n    sample.b += diff;\n\n    // Premultiply alpha again.\n    sample.r *= sample.a;\n    sample.g *= sample.a;\n    sample.b *= sample.a;\n    \n    return sample;\n}";
  }
});

// node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.mjs
var _NoiseFilter, NoiseFilter;
var init_NoiseFilter = __esm({
  "node_modules/pixi.js/lib/filters/defaults/noise/NoiseFilter.mjs"() {
    init_define_AnParams();
    init_GlProgram();
    init_GpuProgram();
    init_UniformGroup();
    init_Filter();
    init_defaultFilter_vert();
    init_noise_frag();
    init_noise_wgsl();
    _NoiseFilter = class _NoiseFilter2 extends Filter {
      /**
       * @param options - The options of the noise filter.
       */
      constructor(options = {}) {
        options = { ..._NoiseFilter2.defaultOptions, ...options };
        const gpuProgram3 = GpuProgram.from({
          vertex: {
            source: source6,
            entryPoint: "mainVertex"
          },
          fragment: {
            source: source6,
            entryPoint: "mainFragment"
          }
        });
        const glProgram3 = GlProgram.from({
          vertex: vertex3,
          fragment: fragment6,
          name: "noise-filter"
        });
        const { noise, seed, ...rest } = options;
        super({
          ...rest,
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          resources: {
            noiseUniforms: new UniformGroup({
              uNoise: { value: 1, type: "f32" },
              uSeed: { value: 1, type: "f32" }
            })
          }
        });
        this.noise = noise;
        this.seed = seed ?? Math.random();
      }
      /**
       * The amount of noise to apply, this value should be in the range (0, 1].
       * @default 0.5
       */
      get noise() {
        return this.resources.noiseUniforms.uniforms.uNoise;
      }
      set noise(value) {
        this.resources.noiseUniforms.uniforms.uNoise = value;
      }
      /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
      get seed() {
        return this.resources.noiseUniforms.uniforms.uSeed;
      }
      set seed(value) {
        this.resources.noiseUniforms.uniforms.uSeed = value;
      }
    };
    _NoiseFilter.defaultOptions = {
      noise: 0.5
    };
    NoiseFilter = _NoiseFilter;
  }
});

// node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.mjs
var hsl;
var init_hsl_wgsl = __esm({
  "node_modules/pixi.js/lib/filters/blend-modes/hsl.wgsl.mjs"() {
    init_define_AnParams();
    hsl = "fn getLuminosity(c: vec3<f32>) -> f32 {\n  return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\n}\n\nfn setLuminosity(c: vec3<f32>, lum: f32) -> vec3<f32> {\n  let d: f32 = lum - getLuminosity(c);\n  let newColor: vec3<f32> = c.rgb + vec3<f32>(d, d, d);\n\n  // clip back into legal range\n  let newLum: f32 = getLuminosity(newColor);\n  let cMin: f32 = min(newColor.r, min(newColor.g, newColor.b));\n  let cMax: f32 = max(newColor.r, max(newColor.g, newColor.b));\n\n  let t1: f32 = newLum / (newLum - cMin);\n  let t2: f32 = (1.0 - newLum) / (cMax - newLum);\n\n  let finalColor = mix(vec3<f32>(newLum, newLum, newLum), newColor, select(select(1.0, t2, cMax > 1.0), t1, cMin < 0.0));\n\n  return finalColor;\n}\n\nfn getSaturation(c: vec3<f32>) -> f32 {\n  return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n}\n\n// Set saturation if color components are sorted in ascending order.\nfn setSaturationMinMidMax(cSorted: vec3<f32>, s: f32) -> vec3<f32> {\n  var result: vec3<f32>;\n  if (cSorted.z > cSorted.x) {\n    let newY = (((cSorted.y - cSorted.x) * s) / (cSorted.z - cSorted.x));\n    result = vec3<f32>(0.0, newY, s);\n  } else {\n    result = vec3<f32>(0.0, 0.0, 0.0);\n  }\n  return vec3<f32>(result.x, result.y, result.z);\n}\n\nfn setSaturation(c: vec3<f32>, s: f32) -> vec3<f32> {\n    var result: vec3<f32> = c;\n\n    if (c.r <= c.g && c.r <= c.b) {\n        if (c.g <= c.b) {\n            result = setSaturationMinMidMax(result, s);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.r, result.b, result.g);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.r, temp.b, temp.g);\n        }\n    } else if (c.g <= c.r && c.g <= c.b) {\n        if (c.r <= c.b) {\n            var temp: vec3<f32> = vec3<f32>(result.g, result.r, result.b);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.g, temp.r, temp.b);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.g, result.b, result.r);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.g, temp.b, temp.r);\n        }\n    } else {\n        if (c.r <= c.g) {\n            var temp: vec3<f32> = vec3<f32>(result.b, result.r, result.g);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.b, temp.r, temp.g);\n        } else {\n            var temp: vec3<f32> = vec3<f32>(result.b, result.g, result.r);\n            temp = setSaturationMinMidMax(temp, s);\n            result = vec3<f32>(temp.b, temp.g, temp.r);\n        }\n    }\n\n    return result;\n}";
  }
});

// node_modules/pixi.js/lib/maths/point/pointInTriangle.mjs
function pointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
  const v2x = x3 - x1;
  const v2y = y3 - y1;
  const v1x = x2 - x1;
  const v1y = y2 - y1;
  const v0x = px - x1;
  const v0y = py - y1;
  const dot00 = v2x * v2x + v2y * v2y;
  const dot01 = v2x * v1x + v2y * v1y;
  const dot02 = v2x * v0x + v2y * v0y;
  const dot11 = v1x * v1x + v1y * v1y;
  const dot12 = v1x * v0x + v1y * v0y;
  const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
  const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
  const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
  return u2 >= 0 && v2 >= 0 && u2 + v2 < 1;
}
var init_pointInTriangle = __esm({
  "node_modules/pixi.js/lib/maths/point/pointInTriangle.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/maths/shapes/Triangle.mjs
var Triangle;
var init_Triangle = __esm({
  "node_modules/pixi.js/lib/maths/shapes/Triangle.mjs"() {
    init_define_AnParams();
    init_squaredDistanceToLineSegment();
    init_Rectangle();
    Triangle = class _Triangle {
      /**
       * @param x - The X coord of the first point.
       * @param y - The Y coord of the first point.
       * @param x2 - The X coord of the second point.
       * @param y2 - The Y coord of the second point.
       * @param x3 - The X coord of the third point.
       * @param y3 - The Y coord of the third point.
       */
      constructor(x2 = 0, y2 = 0, x22 = 0, y22 = 0, x3 = 0, y3 = 0) {
        this.type = "triangle";
        this.x = x2;
        this.y = y2;
        this.x2 = x22;
        this.y2 = y22;
        this.x3 = x3;
        this.y3 = y3;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this triangle
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Triangle
       */
      contains(x2, y2) {
        const s2 = (this.x - this.x3) * (y2 - this.y3) - (this.y - this.y3) * (x2 - this.x3);
        const t2 = (this.x2 - this.x) * (y2 - this.y) - (this.y2 - this.y) * (x2 - this.x);
        if (s2 < 0 !== t2 < 0 && s2 !== 0 && t2 !== 0) {
          return false;
        }
        const d2 = (this.x3 - this.x2) * (y2 - this.y2) - (this.y3 - this.y2) * (x2 - this.x2);
        return d2 === 0 || d2 < 0 === s2 + t2 <= 0;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this triangle including the stroke.
       * @param pointX - The X coordinate of the point to test
       * @param pointY - The Y coordinate of the point to test
       * @param strokeWidth - The width of the line to check
       * @param _alignment - The alignment of the stroke
       * @returns Whether the x/y coordinates are within this triangle
       */
      strokeContains(pointX, pointY, strokeWidth, _alignment = 0.5) {
        const halfStrokeWidth = strokeWidth / 2;
        const halfStrokeWidthSquared = halfStrokeWidth * halfStrokeWidth;
        const { x: x2, x2: x22, x3, y: y2, y2: y22, y3 } = this;
        if (squaredDistanceToLineSegment(pointX, pointY, x2, y2, x22, y3) <= halfStrokeWidthSquared || squaredDistanceToLineSegment(pointX, pointY, x22, y22, x3, y3) <= halfStrokeWidthSquared || squaredDistanceToLineSegment(pointX, pointY, x3, y3, x2, y2) <= halfStrokeWidthSquared) {
          return true;
        }
        return false;
      }
      /**
       * Creates a clone of this Triangle
       * @returns a copy of the triangle
       */
      clone() {
        const triangle = new _Triangle(
          this.x,
          this.y,
          this.x2,
          this.y2,
          this.x3,
          this.y3
        );
        return triangle;
      }
      /**
       * Copies another triangle to this one.
       * @param triangle - The triangle to copy from.
       * @returns Returns itself.
       */
      copyFrom(triangle) {
        this.x = triangle.x;
        this.y = triangle.y;
        this.x2 = triangle.x2;
        this.y2 = triangle.y2;
        this.x3 = triangle.x3;
        this.y3 = triangle.y3;
        return this;
      }
      /**
       * Copies this triangle to another one.
       * @param triangle - The triangle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(triangle) {
        triangle.copyFrom(this);
        return triangle;
      }
      /**
       * Returns the framing rectangle of the triangle as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 || (out2 = new Rectangle());
        const minX = Math.min(this.x, this.x2, this.x3);
        const maxX = Math.max(this.x, this.x2, this.x3);
        const minY = Math.min(this.y, this.y2, this.y3);
        const maxY = Math.max(this.y, this.y2, this.y3);
        out2.x = minX;
        out2.y = minY;
        out2.width = maxX - minX;
        out2.height = maxY - minY;
        return out2;
      }
    };
  }
});

// node_modules/pixi.js/lib/prepare/PrepareBase.mjs
var _PrepareBase, PrepareBase;
var init_PrepareBase = __esm({
  "node_modules/pixi.js/lib/prepare/PrepareBase.mjs"() {
    init_define_AnParams();
    init_Container();
    init_const2();
    init_Ticker();
    _PrepareBase = class _PrepareBase2 {
      /**
       * @param {rendering.Renderer} renderer - A reference to the current renderer
       */
      constructor(renderer) {
        this._tick = () => {
          this.timeout = setTimeout(this._processQueue, 0);
        };
        this._processQueue = () => {
          const { queue } = this;
          let itemsProcessed = 0;
          while (queue.length && itemsProcessed < _PrepareBase2.uploadsPerFrame) {
            const queueItem = queue.shift();
            this.uploadQueueItem(queueItem);
            itemsProcessed++;
          }
          if (queue.length) {
            Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);
          } else {
            this._resolve();
          }
        };
        this.renderer = renderer;
        this.queue = [];
        this.resolves = [];
      }
      /**
       * Return a copy of the queue
       * @returns {PrepareQueueItem[]} The queue
       */
      getQueue() {
        return [...this.queue];
      }
      /**
       * Add a textures or graphics resource to the queue
       * @param {PrepareSourceItem | PrepareSourceItem[]} resource
       */
      add(resource) {
        const resourceArray = Array.isArray(resource) ? resource : [resource];
        for (const resourceItem of resourceArray) {
          if (resourceItem instanceof Container) {
            this._addContainer(resourceItem);
          } else {
            this.resolveQueueItem(resourceItem, this.queue);
          }
        }
        return this;
      }
      /**
       * Recursively add a container and its children to the queue
       * @param {Container} container - The container to add to the queue
       */
      _addContainer(container) {
        this.resolveQueueItem(container, this.queue);
        for (const child of container.children) {
          this._addContainer(child);
        }
      }
      /**
       * Upload all the textures and graphics to the GPU (optionally add more resources to the queue first)
       * @param {PrepareSourceItem | PrepareSourceItem[] | undefined} resource
       */
      upload(resource) {
        if (resource) {
          this.add(resource);
        }
        return new Promise((resolve) => {
          if (this.queue.length) {
            this.resolves.push(resolve);
            this.dedupeQueue();
            Ticker.system.addOnce(this._tick, this, UPDATE_PRIORITY.UTILITY);
          } else {
            resolve();
          }
        });
      }
      /** eliminate duplicates before processing */
      dedupeQueue() {
        const hash = /* @__PURE__ */ Object.create(null);
        let nextUnique = 0;
        for (let i3 = 0; i3 < this.queue.length; i3++) {
          const current = this.queue[i3];
          if (!hash[current.uid]) {
            hash[current.uid] = true;
            this.queue[nextUnique++] = current;
          }
        }
        this.queue.length = nextUnique;
      }
      /** Call all the resolve callbacks */
      _resolve() {
        const { resolves } = this;
        const array = resolves.slice(0);
        resolves.length = 0;
        for (const resolve of array) {
          resolve();
        }
      }
    };
    _PrepareBase.uploadsPerFrame = 4;
    PrepareBase = _PrepareBase;
  }
});

// node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs
var Mesh;
var init_Mesh = __esm({
  "node_modules/pixi.js/lib/scene/mesh/shared/Mesh.mjs"() {
    init_define_AnParams();
    init_pointInTriangle();
    init_Geometry();
    init_State();
    init_Texture();
    init_deprecation();
    init_ViewContainer();
    init_MeshGeometry();
    Mesh = class extends ViewContainer {
      constructor(...args) {
        let options = args[0];
        if (options instanceof Geometry) {
          deprecation(v8_0_0, "Mesh: use new Mesh({ geometry, shader }) instead");
          options = {
            geometry: options,
            shader: args[1]
          };
          if (args[3]) {
            deprecation(v8_0_0, "Mesh: drawMode argument has been removed, use geometry.topology instead");
            options.geometry.topology = args[3];
          }
        }
        const { geometry, shader, texture, roundPixels, state, ...rest } = options;
        super({
          label: "Mesh",
          ...rest
        });
        this.renderPipeId = "mesh";
        this._shader = null;
        this.allowChildren = false;
        this.shader = shader ?? null;
        this.texture = texture ?? shader?.texture ?? Texture.WHITE;
        this.state = state ?? State.for2d();
        this._geometry = geometry;
        this._geometry.on("update", this.onViewUpdate, this);
        this.roundPixels = roundPixels ?? false;
      }
      /** Alias for {@link scene.Mesh#shader}. */
      get material() {
        deprecation(v8_0_0, "mesh.material property has been removed, use mesh.shader instead");
        return this._shader;
      }
      /**
       * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
       * Can be shared between multiple Mesh objects.
       */
      set shader(value) {
        if (this._shader === value)
          return;
        this._shader = value;
        this.onViewUpdate();
      }
      get shader() {
        return this._shader;
      }
      /**
       * Includes vertex positions, face indices, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh objects.
       */
      set geometry(value) {
        if (this._geometry === value)
          return;
        this._geometry?.off("update", this.onViewUpdate, this);
        value.on("update", this.onViewUpdate, this);
        this._geometry = value;
        this.onViewUpdate();
      }
      get geometry() {
        return this._geometry;
      }
      /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
      set texture(value) {
        value || (value = Texture.EMPTY);
        const currentTexture = this._texture;
        if (currentTexture === value)
          return;
        if (currentTexture && currentTexture.dynamic)
          currentTexture.off("update", this.onViewUpdate, this);
        if (value.dynamic)
          value.on("update", this.onViewUpdate, this);
        if (this.shader) {
          this.shader.texture = value;
        }
        this._texture = value;
        this.onViewUpdate();
      }
      get texture() {
        return this._texture;
      }
      get batched() {
        if (this._shader)
          return false;
        if ((this.state.data & 12) !== 0)
          return false;
        if (this._geometry instanceof MeshGeometry) {
          if (this._geometry.batchMode === "auto") {
            return this._geometry.positions.length / 2 <= 100;
          }
          return this._geometry.batchMode === "batch";
        }
        return false;
      }
      /**
       * The local bounds of the mesh.
       * @type {rendering.Bounds}
       */
      get bounds() {
        return this._geometry.bounds;
      }
      /**
       * Update local bounds of the mesh.
       * @private
       */
      updateBounds() {
        this._bounds = this._geometry.bounds;
      }
      /**
       * Checks if the object contains the given point.
       * @param point - The point to check
       */
      containsPoint(point) {
        const { x: x2, y: y2 } = point;
        if (!this.bounds.containsPoint(x2, y2))
          return false;
        const vertices = this.geometry.getBuffer("aPosition").data;
        const step = this.geometry.topology === "triangle-strip" ? 3 : 1;
        if (this.geometry.getIndex()) {
          const indices = this.geometry.getIndex().data;
          const len = indices.length;
          for (let i3 = 0; i3 + 2 < len; i3 += step) {
            const ind0 = indices[i3] * 2;
            const ind1 = indices[i3 + 1] * 2;
            const ind2 = indices[i3 + 2] * 2;
            if (pointInTriangle(
              x2,
              y2,
              vertices[ind0],
              vertices[ind0 + 1],
              vertices[ind1],
              vertices[ind1 + 1],
              vertices[ind2],
              vertices[ind2 + 1]
            )) {
              return true;
            }
          }
        } else {
          const len = vertices.length / 2;
          for (let i3 = 0; i3 + 2 < len; i3 += step) {
            const ind0 = i3 * 2;
            const ind1 = (i3 + 1) * 2;
            const ind2 = (i3 + 2) * 2;
            if (pointInTriangle(
              x2,
              y2,
              vertices[ind0],
              vertices[ind0 + 1],
              vertices[ind1],
              vertices[ind1 + 1],
              vertices[ind2],
              vertices[ind2 + 1]
            )) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options) {
        super.destroy(options);
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          this._texture.destroy(destroyTextureSource);
        }
        this._geometry?.off("update", this.onViewUpdate, this);
        this._texture = null;
        this._geometry = null;
        this._shader = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs
var AnimatedSprite;
var init_AnimatedSprite = __esm({
  "node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs"() {
    init_define_AnParams();
    init_Texture();
    init_const2();
    init_Ticker();
    init_Sprite();
    AnimatedSprite = class _AnimatedSprite extends Sprite {
      /** @ignore */
      constructor(...args) {
        let options = args[0];
        if (Array.isArray(args[0])) {
          options = {
            textures: args[0],
            autoUpdate: args[1]
          };
        }
        const {
          animationSpeed = 1,
          autoPlay = false,
          autoUpdate = true,
          loop = true,
          onComplete = null,
          onFrameChange = null,
          onLoop = null,
          textures,
          updateAnchor = false,
          ...rest
        } = options;
        const [firstFrame] = textures;
        super({
          ...rest,
          texture: firstFrame instanceof Texture ? firstFrame : firstFrame.texture
        });
        this._textures = null;
        this._durations = null;
        this._autoUpdate = autoUpdate;
        this._isConnectedToTicker = false;
        this.animationSpeed = animationSpeed;
        this.loop = loop;
        this.updateAnchor = updateAnchor;
        this.onComplete = onComplete;
        this.onFrameChange = onFrameChange;
        this.onLoop = onLoop;
        this._currentTime = 0;
        this._playing = false;
        this._previousFrame = null;
        this.textures = textures;
        if (autoPlay) {
          this.play();
        }
      }
      /** Stops the AnimatedSprite. */
      stop() {
        if (!this._playing) {
          return;
        }
        this._playing = false;
        if (this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        }
      }
      /** Plays the AnimatedSprite. */
      play() {
        if (this._playing) {
          return;
        }
        this._playing = true;
        if (this._autoUpdate && !this._isConnectedToTicker) {
          Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
          this._isConnectedToTicker = true;
        }
      }
      /**
       * Stops the AnimatedSprite and goes to a specific frame.
       * @param frameNumber - Frame index to stop at.
       */
      gotoAndStop(frameNumber) {
        this.stop();
        this.currentFrame = frameNumber;
      }
      /**
       * Goes to a specific frame and begins playing the AnimatedSprite.
       * @param frameNumber - Frame index to start at.
       */
      gotoAndPlay(frameNumber) {
        this.currentFrame = frameNumber;
        this.play();
      }
      /**
       * Updates the object transform for rendering.
       * @param ticker - the ticker to use to update the object.
       */
      update(ticker) {
        if (!this._playing) {
          return;
        }
        const deltaTime = ticker.deltaTime;
        const elapsed = this.animationSpeed * deltaTime;
        const previousFrame = this.currentFrame;
        if (this._durations !== null) {
          let lag = this._currentTime % 1 * this._durations[this.currentFrame];
          lag += elapsed / 60 * 1e3;
          while (lag < 0) {
            this._currentTime--;
            lag += this._durations[this.currentFrame];
          }
          const sign = Math.sign(this.animationSpeed * deltaTime);
          this._currentTime = Math.floor(this._currentTime);
          while (lag >= this._durations[this.currentFrame]) {
            lag -= this._durations[this.currentFrame] * sign;
            this._currentTime += sign;
          }
          this._currentTime += lag / this._durations[this.currentFrame];
        } else {
          this._currentTime += elapsed;
        }
        if (this._currentTime < 0 && !this.loop) {
          this.gotoAndStop(0);
          if (this.onComplete) {
            this.onComplete();
          }
        } else if (this._currentTime >= this._textures.length && !this.loop) {
          this.gotoAndStop(this._textures.length - 1);
          if (this.onComplete) {
            this.onComplete();
          }
        } else if (previousFrame !== this.currentFrame) {
          if (this.loop && this.onLoop) {
            if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
              this.onLoop();
            }
          }
          this._updateTexture();
        }
      }
      /** Updates the displayed texture to match the current frame index. */
      _updateTexture() {
        const currentFrame = this.currentFrame;
        if (this._previousFrame === currentFrame) {
          return;
        }
        this._previousFrame = currentFrame;
        this.texture = this._textures[currentFrame];
        if (this.updateAnchor && this.texture.defaultAnchor) {
          this.anchor.copyFrom(this.texture.defaultAnchor);
        }
        if (this.onFrameChange) {
          this.onFrameChange(this.currentFrame);
        }
      }
      /** Stops the AnimatedSprite and destroys it. */
      destroy() {
        this.stop();
        super.destroy();
        this.onComplete = null;
        this.onFrameChange = null;
        this.onLoop = null;
      }
      /**
       * A short hand way of creating an AnimatedSprite from an array of frame ids.
       * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.
       * @returns - The new animated sprite with the specified frames.
       */
      static fromFrames(frames) {
        const textures = [];
        for (let i3 = 0; i3 < frames.length; ++i3) {
          textures.push(Texture.from(frames[i3]));
        }
        return new _AnimatedSprite(textures);
      }
      /**
       * A short hand way of creating an AnimatedSprite from an array of image ids.
       * @param images - The array of image urls the AnimatedSprite will use as its texture frames.
       * @returns The new animate sprite with the specified images as frames.
       */
      static fromImages(images) {
        const textures = [];
        for (let i3 = 0; i3 < images.length; ++i3) {
          textures.push(Texture.from(images[i3]));
        }
        return new _AnimatedSprite(textures);
      }
      /**
       * The total number of frames in the AnimatedSprite. This is the same as number of textures
       * assigned to the AnimatedSprite.
       * @readonly
       * @default 0
       */
      get totalFrames() {
        return this._textures.length;
      }
      /** The array of textures used for this AnimatedSprite. */
      get textures() {
        return this._textures;
      }
      set textures(value) {
        if (value[0] instanceof Texture) {
          this._textures = value;
          this._durations = null;
        } else {
          this._textures = [];
          this._durations = [];
          for (let i3 = 0; i3 < value.length; i3++) {
            this._textures.push(value[i3].texture);
            this._durations.push(value[i3].time);
          }
        }
        this._previousFrame = null;
        this.gotoAndStop(0);
        this._updateTexture();
      }
      /** The AnimatedSprite's current frame index. */
      get currentFrame() {
        let currentFrame = Math.floor(this._currentTime) % this._textures.length;
        if (currentFrame < 0) {
          currentFrame += this._textures.length;
        }
        return currentFrame;
      }
      set currentFrame(value) {
        if (value < 0 || value > this.totalFrames - 1) {
          throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
        }
        const previousFrame = this.currentFrame;
        this._currentTime = value;
        if (previousFrame !== this.currentFrame) {
          this._updateTexture();
        }
      }
      /**
       * Indicates if the AnimatedSprite is currently playing.
       * @readonly
       */
      get playing() {
        return this._playing;
      }
      /** Whether to use Ticker.shared to auto update animation time. */
      get autoUpdate() {
        return this._autoUpdate;
      }
      set autoUpdate(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          if (!this._autoUpdate && this._isConnectedToTicker) {
            Ticker.shared.remove(this.update, this);
            this._isConnectedToTicker = false;
          } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
            Ticker.shared.add(this.update, this);
            this._isConnectedToTicker = true;
          }
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/misc/Transform.mjs
var Transform;
var init_Transform = __esm({
  "node_modules/pixi.js/lib/utils/misc/Transform.mjs"() {
    init_define_AnParams();
    init_Matrix();
    init_ObservablePoint();
    Transform = class {
      /**
       * @param options - Options for the transform.
       * @param options.matrix - The matrix to use.
       * @param options.observer - The observer to use.
       */
      constructor({ matrix, observer } = {}) {
        this.dirty = true;
        this._matrix = matrix ?? new Matrix();
        this.observer = observer;
        this.position = new ObservablePoint(this, 0, 0);
        this.scale = new ObservablePoint(this, 1, 1);
        this.pivot = new ObservablePoint(this, 0, 0);
        this.skew = new ObservablePoint(this, 0, 0);
        this._rotation = 0;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
      }
      /**
       * This matrix is computed by combining this Transforms position, scale, rotation, skew, and pivot
       * properties into a single matrix.
       * @readonly
       */
      get matrix() {
        const lt = this._matrix;
        if (!this.dirty)
          return lt;
        lt.a = this._cx * this.scale.x;
        lt.b = this._sx * this.scale.x;
        lt.c = this._cy * this.scale.y;
        lt.d = this._sy * this.scale.y;
        lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
        lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
        this.dirty = false;
        return lt;
      }
      /**
       * Called when a value changes.
       * @param point
       * @internal
       * @private
       */
      _onUpdate(point) {
        this.dirty = true;
        if (point === this.skew) {
          this.updateSkew();
        }
        this.observer?._onUpdate(this);
      }
      /** Called when the skew or the rotation changes. */
      updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew.y);
        this._sx = Math.sin(this._rotation + this.skew.y);
        this._cy = -Math.sin(this._rotation - this.skew.x);
        this._sy = Math.cos(this._rotation - this.skew.x);
        this.dirty = true;
      }
      toString() {
        return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
      }
      /**
       * Decomposes a matrix and sets the transforms properties based on it.
       * @param matrix - The matrix to decompose
       */
      setFromMatrix(matrix) {
        matrix.decompose(this);
        this.dirty = true;
      }
      /** The rotation of the object in radians. */
      get rotation() {
        return this._rotation;
      }
      set rotation(value) {
        if (this._rotation !== value) {
          this._rotation = value;
          this._onUpdate(this.skew);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs
var _TilingSprite, TilingSprite;
var init_TilingSprite = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/TilingSprite.mjs"() {
    init_define_AnParams();
    init_Cache();
    init_ObservablePoint();
    init_Texture();
    init_deprecation();
    init_warn();
    init_Transform();
    init_ViewContainer();
    _TilingSprite = class _TilingSprite2 extends ViewContainer {
      constructor(...args) {
        let options = args[0] || {};
        if (options instanceof Texture) {
          options = { texture: options };
        }
        if (args.length > 1) {
          deprecation(v8_0_0, "use new TilingSprite({ texture, width:100, height:100 }) instead");
          options.width = args[1];
          options.height = args[2];
        }
        options = { ..._TilingSprite2.defaultOptions, ...options };
        const {
          texture,
          anchor,
          tilePosition,
          tileScale,
          tileRotation,
          width,
          height,
          applyAnchorToTexture,
          roundPixels,
          ...rest
        } = options ?? {};
        super({
          label: "TilingSprite",
          ...rest
        });
        this.renderPipeId = "tilingSprite";
        this.batched = true;
        this.allowChildren = false;
        this._anchor = new ObservablePoint(
          {
            _onUpdate: () => {
              this.onViewUpdate();
            }
          }
        );
        this.applyAnchorToTexture = applyAnchorToTexture;
        this.texture = texture;
        this._width = width ?? texture.width;
        this._height = height ?? texture.height;
        this._tileTransform = new Transform({
          observer: {
            _onUpdate: () => this.onViewUpdate()
          }
        });
        if (anchor)
          this.anchor = anchor;
        this.tilePosition = tilePosition;
        this.tileScale = tileScale;
        this.tileRotation = tileRotation;
        this.roundPixels = roundPixels ?? false;
      }
      /**
       * Creates a new tiling sprite.
       * @param source - The source to create the texture from.
       * @param options - The options for creating the tiling sprite.
       * @returns A new tiling sprite.
       */
      static from(source9, options = {}) {
        if (typeof source9 === "string") {
          return new _TilingSprite2({
            texture: Cache.get(source9),
            ...options
          });
        }
        return new _TilingSprite2({
          texture: source9,
          ...options
        });
      }
      /**
       * @see {@link scene.TilingSpriteOptions.applyAnchorToTexture}
       * @deprecated since 8.0.0
       */
      get uvRespectAnchor() {
        warn("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
        return this.applyAnchorToTexture;
      }
      set uvRespectAnchor(value) {
        warn("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
        this.applyAnchorToTexture = value;
      }
      /**
       * Changes frame clamping in corresponding textureMatrix
       * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
       * @default 0.5
       * @member {number}
       */
      get clampMargin() {
        return this._texture.textureMatrix.clampMargin;
      }
      set clampMargin(value) {
        this._texture.textureMatrix.clampMargin = value;
      }
      /**
       * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
       * and passed to the constructor.
       *
       * The default is `(0,0)`, this means the sprite's origin is the top left.
       *
       * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
       *
       * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
       *
       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
       * @example
       * import { TilingSprite } from 'pixi.js';
       *
       * const sprite = new TilingSprite({texture: Texture.WHITE});
       * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
       */
      get anchor() {
        return this._anchor;
      }
      set anchor(value) {
        typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
      }
      /** The offset of the image that is being tiled. */
      get tilePosition() {
        return this._tileTransform.position;
      }
      set tilePosition(value) {
        this._tileTransform.position.copyFrom(value);
      }
      /** The scaling of the image that is being tiled. */
      get tileScale() {
        return this._tileTransform.scale;
      }
      set tileScale(value) {
        typeof value === "number" ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);
      }
      set tileRotation(value) {
        this._tileTransform.rotation = value;
      }
      /** The rotation of the image that is being tiled. */
      get tileRotation() {
        return this._tileTransform.rotation;
      }
      /** The transform of the image that is being tiled. */
      get tileTransform() {
        return this._tileTransform;
      }
      set texture(value) {
        value || (value = Texture.EMPTY);
        const currentTexture = this._texture;
        if (currentTexture === value)
          return;
        if (currentTexture && currentTexture.dynamic)
          currentTexture.off("update", this.onViewUpdate, this);
        if (value.dynamic)
          value.on("update", this.onViewUpdate, this);
        this._texture = value;
        this.onViewUpdate();
      }
      /** The texture that the sprite is using. */
      get texture() {
        return this._texture;
      }
      /** The width of the tiling area. */
      set width(value) {
        this._width = value;
        this.onViewUpdate();
      }
      get width() {
        return this._width;
      }
      set height(value) {
        this._height = value;
        this.onViewUpdate();
      }
      /** The height of the tiling area. */
      get height() {
        return this._height;
      }
      /**
       * Sets the size of the TilingSprite to the specified width and height.
       * This is faster than setting the width and height separately.
       * @param value - This can be either a number or a [Size]{@link Size} object.
       * @param height - The height to set. Defaults to the value of `width` if not provided.
       */
      setSize(value, height) {
        if (typeof value === "object") {
          height = value.height ?? value.width;
          value = value.width;
        }
        this._width = value;
        this._height = height ?? value;
        this.onViewUpdate();
      }
      /**
       * Retrieves the size of the TilingSprite as a [Size]{@link Size} object.
       * This is faster than get the width and height separately.
       * @param out - Optional object to store the size in.
       * @returns - The size of the TilingSprite.
       */
      getSize(out2) {
        out2 || (out2 = {});
        out2.width = this._width;
        out2.height = this._height;
        return out2;
      }
      /**
       * @private
       */
      updateBounds() {
        const bounds = this._bounds;
        const anchor = this._anchor;
        const width = this._width;
        const height = this._height;
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * height;
        bounds.maxY = bounds.minY + height;
      }
      /**
       * Checks if the object contains the given point.
       * @param point - The point to check
       */
      containsPoint(point) {
        const width = this._width;
        const height = this._height;
        const x1 = -width * this._anchor._x;
        let y1 = 0;
        if (point.x >= x1 && point.x <= x1 + width) {
          y1 = -height * this._anchor._y;
          if (point.y >= y1 && point.y <= y1 + height)
            return true;
        }
        return false;
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options = false) {
        super.destroy(options);
        this._anchor = null;
        this._tileTransform = null;
        this._bounds = null;
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
      }
    };
    _TilingSprite.defaultOptions = {
      /** The texture to use for the sprite. */
      texture: Texture.EMPTY,
      /** The anchor point of the sprite */
      anchor: { x: 0, y: 0 },
      /** The offset of the image that is being tiled. */
      tilePosition: { x: 0, y: 0 },
      /** Scaling of the image that is being tiled. */
      tileScale: { x: 1, y: 1 },
      /** The rotation of the image that is being tiled. */
      tileRotation: 0,
      /**
       * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in
       * local space.
       *
       * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without
       * this, the top-left corner always gets the (0, 0) texture coordinate.
       * @default false
       */
      applyAnchorToTexture: false
    };
    TilingSprite = _TilingSprite;
  }
});

// node_modules/pixi.js/lib/scene/text/AbstractText.mjs
function ensureTextOptions(args, name) {
  let options = args[0] ?? {};
  if (typeof options === "string" || args[1]) {
    deprecation(v8_0_0, `use new ${name}({ text: "hi!", style }) instead`);
    options = {
      text: options,
      style: args[1]
    };
  }
  return options;
}
var AbstractText;
var init_AbstractText = __esm({
  "node_modules/pixi.js/lib/scene/text/AbstractText.mjs"() {
    init_define_AnParams();
    init_ObservablePoint();
    init_deprecation();
    init_ViewContainer();
    AbstractText = class extends ViewContainer {
      constructor(options, styleClass) {
        const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;
        super({
          ...rest
        });
        this.batched = true;
        this._resolution = null;
        this._autoResolution = true;
        this._didTextUpdate = true;
        this._styleClass = styleClass;
        this.text = text ?? "";
        this.style = style;
        this.resolution = resolution ?? null;
        this.allowChildren = false;
        this._anchor = new ObservablePoint(
          {
            _onUpdate: () => {
              this.onViewUpdate();
            }
          }
        );
        if (anchor)
          this.anchor = anchor;
        this.roundPixels = roundPixels ?? false;
        if (width !== void 0)
          this.width = width;
        if (height !== void 0)
          this.height = height;
      }
      /**
       * The anchor sets the origin point of the text.
       * The default is `(0,0)`, this means the text's origin is the top left.
       *
       * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
       *
       * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
       *
       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
       * @example
       * import { Text } from 'pixi.js';
       *
       * const text = new Text('hello world');
       * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
       */
      get anchor() {
        return this._anchor;
      }
      set anchor(value) {
        typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
      }
      /** Set the copy for the text object. To split a line you can use '\n'. */
      set text(value) {
        value = value.toString();
        if (this._text === value)
          return;
        this._text = value;
        this.onViewUpdate();
      }
      get text() {
        return this._text;
      }
      /**
       * The resolution / device pixel ratio of the canvas.
       * @default 1
       */
      set resolution(value) {
        this._autoResolution = value === null;
        this._resolution = value;
        this.onViewUpdate();
      }
      get resolution() {
        return this._resolution;
      }
      get style() {
        return this._style;
      }
      /**
       * Set the style of the text.
       *
       * Set up an event listener to listen for changes on the style object and mark the text as dirty.
       *
       * If setting the `style` can also be partial {@link AnyTextStyleOptions}.
       * @type {
       * text.TextStyle |
       * Partial<text.TextStyle> |
       * text.TextStyleOptions |
       * text.HTMLTextStyle |
       * Partial<text.HTMLTextStyle> |
       * text.HTMLTextStyleOptions
       * }
       */
      set style(style) {
        style || (style = {});
        this._style?.off("update", this.onViewUpdate, this);
        if (style instanceof this._styleClass) {
          this._style = style;
        } else {
          this._style = new this._styleClass(style);
        }
        this._style.on("update", this.onViewUpdate, this);
        this.onViewUpdate();
      }
      /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
      get width() {
        return Math.abs(this.scale.x) * this.bounds.width;
      }
      set width(value) {
        this._setWidth(value, this.bounds.width);
      }
      /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
      get height() {
        return Math.abs(this.scale.y) * this.bounds.height;
      }
      set height(value) {
        this._setHeight(value, this.bounds.height);
      }
      /**
       * Retrieves the size of the Text as a [Size]{@link Size} object.
       * This is faster than get the width and height separately.
       * @param out - Optional object to store the size in.
       * @returns - The size of the Text.
       */
      getSize(out2) {
        out2 || (out2 = {});
        out2.width = Math.abs(this.scale.x) * this.bounds.width;
        out2.height = Math.abs(this.scale.y) * this.bounds.height;
        return out2;
      }
      /**
       * Sets the size of the Text to the specified width and height.
       * This is faster than setting the width and height separately.
       * @param value - This can be either a number or a [Size]{@link Size} object.
       * @param height - The height to set. Defaults to the value of `width` if not provided.
       */
      setSize(value, height) {
        if (typeof value === "object") {
          height = value.height ?? value.width;
          value = value.width;
        } else {
          height ?? (height = value);
        }
        value !== void 0 && this._setWidth(value, this.bounds.width);
        height !== void 0 && this._setHeight(height, this.bounds.height);
      }
      /**
       * Checks if the text contains the given point.
       * @param point - The point to check
       */
      containsPoint(point) {
        const width = this.bounds.width;
        const height = this.bounds.height;
        const x1 = -width * this.anchor.x;
        let y1 = 0;
        if (point.x >= x1 && point.x <= x1 + width) {
          y1 = -height * this.anchor.y;
          if (point.y >= y1 && point.y <= y1 + height)
            return true;
        }
        return false;
      }
      onViewUpdate() {
        if (!this.didViewUpdate)
          this._didTextUpdate = true;
        super.onViewUpdate();
      }
      _getKey() {
        return `${this.text}:${this._style.styleKey}:${this._resolution}`;
      }
      /**
       * Destroys this text renderable and optionally its style texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style
       * @param {boolean} [options.style=false] - Should it destroy the style of the text
       */
      destroy(options = false) {
        super.destroy(options);
        this.owner = null;
        this._bounds = null;
        this._anchor = null;
        if (typeof options === "boolean" ? options : options?.style) {
          this._style.destroy(options);
        }
        this._style = null;
        this._text = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/Text.mjs
var Text;
var init_Text = __esm({
  "node_modules/pixi.js/lib/scene/text/Text.mjs"() {
    init_define_AnParams();
    init_AbstractText();
    init_CanvasTextMetrics();
    init_TextStyle();
    Text = class extends AbstractText {
      constructor(...args) {
        const options = ensureTextOptions(args, "Text");
        super(options, TextStyle);
        this.renderPipeId = "text";
      }
      /** @private */
      updateBounds() {
        const bounds = this._bounds;
        const anchor = this._anchor;
        const canvasMeasurement = CanvasTextMetrics.measureText(
          this._text,
          this._style
        );
        const { width, height } = canvasMeasurement;
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * height;
        bounds.maxY = bounds.minY + height;
      }
    };
  }
});

// node_modules/pixi.js/lib/prepare/PrepareQueue.mjs
var PrepareQueue;
var init_PrepareQueue = __esm({
  "node_modules/pixi.js/lib/prepare/PrepareQueue.mjs"() {
    init_define_AnParams();
    init_TextureSource();
    init_Texture();
    init_Container();
    init_Graphics();
    init_GraphicsContext();
    init_Mesh();
    init_Sprite();
    init_AnimatedSprite();
    init_TilingSprite();
    init_Text();
    init_PrepareBase();
    PrepareQueue = class extends PrepareBase {
      /**
       * Resolve the given resource type and return an item for the queue
       * @param source
       * @param queue
       */
      resolveQueueItem(source9, queue) {
        if (source9 instanceof Container) {
          this.resolveContainerQueueItem(source9, queue);
        } else if (source9 instanceof TextureSource || source9 instanceof Texture) {
          queue.push(source9.source);
        } else if (source9 instanceof GraphicsContext) {
          queue.push(source9);
        }
        return null;
      }
      /**
       * Resolve the given container and return an item for the queue
       * @param container
       * @param queue
       */
      resolveContainerQueueItem(container, queue) {
        if (container instanceof Sprite || container instanceof TilingSprite || container instanceof Mesh) {
          queue.push(container.texture.source);
        } else if (container instanceof Text) {
          queue.push(container);
        } else if (container instanceof Graphics) {
          queue.push(container.context);
        } else if (container instanceof AnimatedSprite) {
          container.textures.forEach((textureOrFrame) => {
            if (textureOrFrame.source) {
              queue.push(textureOrFrame.source);
            } else {
              queue.push(textureOrFrame.texture.source);
            }
          });
        }
      }
      /**
       * Resolve the given graphics context and return an item for the queue
       * @param graphicsContext
       */
      resolveGraphicsContextQueueItem(graphicsContext) {
        this.renderer.graphicsContext.getGpuContext(graphicsContext);
        const { instructions } = graphicsContext;
        for (const instruction of instructions) {
          if (instruction.action === "texture") {
            const { image } = instruction.data;
            return image.source;
          } else if (instruction.action === "fill") {
            const { texture } = instruction.data.style;
            return texture.source;
          }
        }
        return null;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.mjs
var BitmapText;
var init_BitmapText = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/BitmapText.mjs"() {
    init_define_AnParams();
    init_warn();
    init_AbstractText();
    init_TextStyle();
    init_BitmapFontManager();
    BitmapText = class extends AbstractText {
      constructor(...args) {
        var _a2;
        const options = ensureTextOptions(args, "BitmapText");
        options.style ?? (options.style = options.style || {});
        (_a2 = options.style).fill ?? (_a2.fill = 16777215);
        super(options, TextStyle);
        this.renderPipeId = "bitmapText";
      }
      /** @private */
      updateBounds() {
        const bounds = this._bounds;
        const anchor = this._anchor;
        const bitmapMeasurement = BitmapFontManager.measureText(this.text, this._style);
        const scale = bitmapMeasurement.scale;
        const offset = bitmapMeasurement.offsetY * scale;
        let width = bitmapMeasurement.width * scale;
        let height = bitmapMeasurement.height * scale;
        const stroke = this._style._stroke;
        if (stroke) {
          width += stroke.width;
          height += stroke.width;
        }
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * (height + offset);
        bounds.maxY = bounds.minY + height;
      }
      /**
       * The resolution / device pixel ratio of the canvas.
       * @default 1
       */
      set resolution(value) {
        if (value !== null) {
          warn(
            // eslint-disable-next-line max-len
            "[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont."
          );
        }
      }
      get resolution() {
        return this._resolution;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-html/HTMLText.mjs
var HTMLText;
var init_HTMLText = __esm({
  "node_modules/pixi.js/lib/scene/text-html/HTMLText.mjs"() {
    init_define_AnParams();
    init_AbstractText();
    init_HTMLTextStyle();
    init_measureHtmlText();
    HTMLText = class extends AbstractText {
      constructor(...args) {
        const options = ensureTextOptions(args, "HtmlText");
        super(options, HTMLTextStyle);
        this.renderPipeId = "htmlText";
      }
      /** @private */
      updateBounds() {
        const bounds = this._bounds;
        const anchor = this._anchor;
        const htmlMeasurement = measureHtmlText(this.text, this._style);
        const { width, height } = htmlMeasurement;
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * height;
        bounds.maxY = bounds.minY + height;
      }
    };
  }
});

// node_modules/pixi.js/lib/prepare/PrepareUpload.mjs
var PrepareUpload;
var init_PrepareUpload = __esm({
  "node_modules/pixi.js/lib/prepare/PrepareUpload.mjs"() {
    init_define_AnParams();
    init_TextureSource();
    init_GraphicsContext();
    init_Text();
    init_BitmapText();
    init_HTMLText();
    init_PrepareQueue();
    PrepareUpload = class extends PrepareQueue {
      /**
       * Upload the given queue item
       * @param item
       */
      uploadQueueItem(item) {
        if (item instanceof TextureSource) {
          this.uploadTextureSource(item);
        } else if (item instanceof Text) {
          this.uploadText(item);
        } else if (item instanceof HTMLText) {
          this.uploadHTMLText(item);
        } else if (item instanceof BitmapText) {
          this.uploadBitmapText(item);
        } else if (item instanceof GraphicsContext) {
          this.uploadGraphicsContext(item);
        }
      }
      uploadTextureSource(textureSource) {
        this.renderer.texture.initSource(textureSource);
      }
      uploadText(_text) {
        this.renderer.renderPipes.text.initGpuText(_text);
      }
      uploadBitmapText(_text) {
        this.renderer.renderPipes.bitmapText.initGpuText(_text);
      }
      uploadHTMLText(_text) {
        this.renderer.renderPipes.htmlText.initGpuText(_text);
      }
      /**
       * Resolve the given graphics context and return an item for the queue
       * @param graphicsContext
       */
      uploadGraphicsContext(graphicsContext) {
        this.renderer.graphicsContext.getGpuContext(graphicsContext);
        const { instructions } = graphicsContext;
        for (const instruction of instructions) {
          if (instruction.action === "texture") {
            const { image } = instruction.data;
            this.uploadTextureSource(image.source);
          } else if (instruction.action === "fill") {
            const { texture } = instruction.data.style;
            this.uploadTextureSource(texture.source);
          }
        }
        return null;
      }
    };
  }
});

// node_modules/pixi.js/lib/prepare/PrepareSystem.mjs
var PrepareSystem;
var init_PrepareSystem = __esm({
  "node_modules/pixi.js/lib/prepare/PrepareSystem.mjs"() {
    init_define_AnParams();
    init_Extensions();
    init_PrepareUpload();
    PrepareSystem = class extends PrepareUpload {
      /** Destroys the plugin, don't use after this. */
      destroy() {
        clearTimeout(this.timeout);
        this.renderer = null;
        this.queue = null;
        this.resolves = null;
      }
    };
    PrepareSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "prepare"
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gpu/generateGPULayout.mjs
function generateGPULayout(maxTextures2) {
  const gpuLayout = [];
  let bindIndex = 0;
  for (let i3 = 0; i3 < maxTextures2; i3++) {
    gpuLayout[bindIndex] = {
      texture: {
        sampleType: "float",
        viewDimension: "2d",
        multisampled: false
      },
      binding: bindIndex,
      visibility: GPUShaderStage.FRAGMENT
    };
    bindIndex++;
    gpuLayout[bindIndex] = {
      sampler: {
        type: "filtering"
      },
      binding: bindIndex,
      visibility: GPUShaderStage.FRAGMENT
    };
    bindIndex++;
  }
  return gpuLayout;
}
var init_generateGPULayout = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gpu/generateGPULayout.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gpu/generateLayout.mjs
function generateLayout(maxTextures2) {
  const layout = {};
  let bindIndex = 0;
  for (let i3 = 0; i3 < maxTextures2; i3++) {
    layout[`textureSource${i3 + 1}`] = bindIndex++;
    layout[`textureSampler${i3 + 1}`] = bindIndex++;
  }
  return layout;
}
var init_generateLayout = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gpu/generateLayout.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/formatShader.mjs
function formatShader(shader) {
  const spl = shader.split(/([\n{}])/g).map((a2) => a2.trim()).filter((a2) => a2.length);
  let indent = "";
  const formatted = spl.map((a2) => {
    let indentedLine = indent + a2;
    if (a2 === "{") {
      indent += "    ";
    } else if (a2 === "}") {
      indent = indent.substr(0, indent.length - 4);
      indentedLine = indent + a2;
    }
    return indentedLine;
  }).join("\n");
  return formatted;
}
var init_formatShader = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/formatShader.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/mask/scissor/ScissorMask.mjs
var ScissorMask;
var init_ScissorMask = __esm({
  "node_modules/pixi.js/lib/rendering/mask/scissor/ScissorMask.mjs"() {
    init_define_AnParams();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    ScissorMask = class {
      constructor(mask) {
        this.priority = 0;
        this.pipe = "scissorMask";
        this.mask = mask;
        this.mask.renderable = false;
        this.mask.measurable = false;
      }
      addBounds(bounds, skipUpdateTransform) {
        addMaskBounds(this.mask, bounds, skipUpdateTransform);
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds(this.mask, bounds, localRoot);
      }
      containsPoint(point, hitTestFn) {
        const mask = this.mask;
        return hitTestFn(mask, point);
      }
      reset() {
        this.mask.measurable = true;
        this.mask = null;
      }
      destroy() {
        this.reset();
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.mjs
function migrateFragmentFromV7toV8(fragmentShader) {
  fragmentShader = fragmentShader.replaceAll("texture2D", "texture").replaceAll("gl_FragColor", "finalColor").replaceAll("varying", "in");
  fragmentShader = `
        out vec4 finalColor;
    ${fragmentShader}
    `;
  return fragmentShader;
}
var init_migrateFragmentFromV7toV8 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/migrateFragmentFromV7toV8.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}
var GLSL_TO_SIZE;
var init_mapSize = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapSize.mjs"() {
    "use strict";
    init_define_AnParams();
    GLSL_TO_SIZE = {
      float: 1,
      vec2: 2,
      vec3: 3,
      vec4: 4,
      int: 1,
      ivec2: 2,
      ivec3: 3,
      ivec4: 4,
      uint: 1,
      uvec2: 2,
      uvec3: 3,
      uvec4: 4,
      bool: 1,
      bvec2: 2,
      bvec3: 3,
      bvec4: 4,
      mat2: 4,
      mat3: 9,
      mat4: 16,
      sampler2D: 1
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuReadBuffer.mjs
function GpuReadBuffer(buffer, renderer) {
  const bufferSize = buffer.descriptor.size;
  const device = renderer.gpu.device;
  const stagingBuffer = new Buffer2({
    data: new Float32Array(24e5),
    usage: BufferUsage.MAP_READ | BufferUsage.COPY_DST
  });
  const stagingGPUBuffer = renderer.buffer.createGPUBuffer(stagingBuffer);
  const commandEncoder = device.createCommandEncoder();
  commandEncoder.copyBufferToBuffer(
    renderer.buffer.getGPUBuffer(buffer),
    0,
    // Source offset
    stagingGPUBuffer,
    0,
    // Destination offset
    bufferSize
  );
  device.queue.submit([commandEncoder.finish()]);
  void stagingGPUBuffer.mapAsync(
    GPUMapMode.READ,
    0,
    // Offset
    bufferSize
    // Length
  ).then(() => {
    stagingGPUBuffer.getMappedRange(0, bufferSize);
    stagingGPUBuffer.unmap();
  });
}
var init_GpuReadBuffer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuReadBuffer.mjs"() {
    init_define_AnParams();
    init_Buffer();
    init_const4();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/const.mjs
var DEPRECATED_DRAW_MODES, DRAW_MODES;
var init_const14 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/const.mjs"() {
    init_define_AnParams();
    init_deprecation();
    DEPRECATED_DRAW_MODES = {
      POINTS: "point-list",
      LINES: "line-list",
      LINE_STRIP: "line-strip",
      TRIANGLES: "triangle-list",
      TRIANGLE_STRIP: "triangle-strip"
    };
    DRAW_MODES = new Proxy(DEPRECATED_DRAW_MODES, {
      get(target, prop) {
        deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_DRAW_MODES[prop]}' instead`);
        return target[prop];
      }
    });
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/viewportFromFrame.mjs
function viewportFromFrame(viewport, source9, frame) {
  frame || (frame = fullFrame);
  const pixelWidth = source9.pixelWidth;
  const pixelHeight = source9.pixelHeight;
  viewport.x = frame.x * pixelWidth | 0;
  viewport.y = frame.y * pixelHeight | 0;
  viewport.width = frame.width * pixelWidth | 0;
  viewport.height = frame.height * pixelHeight | 0;
  return viewport;
}
var fullFrame;
var init_viewportFromFrame = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/viewportFromFrame.mjs"() {
    init_define_AnParams();
    init_Rectangle();
    fullFrame = new Rectangle(0, 0, 1, 1);
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.mjs
var MSAA_QUALITY, DEPRECATED_WRAP_MODES, WRAP_MODES, DEPRECATED_SCALE_MODES, SCALE_MODES;
var init_const15 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/const.mjs"() {
    init_define_AnParams();
    init_deprecation();
    MSAA_QUALITY = /* @__PURE__ */ ((MSAA_QUALITY2) => {
      MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
      MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
      MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
      MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
      return MSAA_QUALITY2;
    })(MSAA_QUALITY || {});
    DEPRECATED_WRAP_MODES = /* @__PURE__ */ ((DEPRECATED_WRAP_MODES2) => {
      DEPRECATED_WRAP_MODES2["CLAMP"] = "clamp-to-edge";
      DEPRECATED_WRAP_MODES2["REPEAT"] = "repeat";
      DEPRECATED_WRAP_MODES2["MIRRORED_REPEAT"] = "mirror-repeat";
      return DEPRECATED_WRAP_MODES2;
    })(DEPRECATED_WRAP_MODES || {});
    WRAP_MODES = new Proxy(DEPRECATED_WRAP_MODES, {
      get(target, prop) {
        deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_WRAP_MODES[prop]}' instead`);
        return target[prop];
      }
    });
    DEPRECATED_SCALE_MODES = /* @__PURE__ */ ((DEPRECATED_SCALE_MODES2) => {
      DEPRECATED_SCALE_MODES2["NEAREST"] = "nearest";
      DEPRECATED_SCALE_MODES2["LINEAR"] = "linear";
      return DEPRECATED_SCALE_MODES2;
    })(DEPRECATED_SCALE_MODES || {});
    SCALE_MODES = new Proxy(DEPRECATED_SCALE_MODES, {
      get(target, prop) {
        deprecation(v8_0_0, `DRAW_MODES.${prop} is deprecated, use '${DEPRECATED_SCALE_MODES[prop]}' instead`);
        return target[prop];
      }
    });
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureUvs.mjs
var TextureUvs;
var init_TextureUvs = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureUvs.mjs"() {
    init_define_AnParams();
    init_groupD8();
    TextureUvs = class {
      constructor() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 1;
        this.y1 = 0;
        this.x2 = 1;
        this.y2 = 1;
        this.x3 = 0;
        this.y3 = 1;
        this.uvsFloat32 = new Float32Array(8);
      }
      /**
       * Sets the texture Uvs based on the given frame information.
       * @protected
       * @param frame - The frame of the texture
       * @param baseFrame - The base frame of the texture
       * @param rotate - Rotation of frame, see {@link groupD8}
       */
      set(frame, baseFrame, rotate) {
        const tw = baseFrame.width;
        const th = baseFrame.height;
        if (rotate) {
          const w2 = frame.width / 2 / tw;
          const h2 = frame.height / 2 / th;
          const cX = frame.x / tw + w2;
          const cY = frame.y / th + h2;
          rotate = groupD8.add(rotate, groupD8.NW);
          this.x0 = cX + w2 * groupD8.uX(rotate);
          this.y0 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          this.x1 = cX + w2 * groupD8.uX(rotate);
          this.y1 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          this.x2 = cX + w2 * groupD8.uX(rotate);
          this.y2 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          this.x3 = cX + w2 * groupD8.uX(rotate);
          this.y3 = cY + h2 * groupD8.uY(rotate);
        } else {
          this.x0 = frame.x / tw;
          this.y0 = frame.y / th;
          this.x1 = (frame.x + frame.width) / tw;
          this.y1 = frame.y / th;
          this.x2 = (frame.x + frame.width) / tw;
          this.y2 = (frame.y + frame.height) / th;
          this.x3 = frame.x / tw;
          this.y3 = (frame.y + frame.height) / th;
        }
        this.uvsFloat32[0] = this.x0;
        this.uvsFloat32[1] = this.y0;
        this.uvsFloat32[2] = this.x1;
        this.uvsFloat32[3] = this.y1;
        this.uvsFloat32[4] = this.x2;
        this.uvsFloat32[5] = this.y2;
        this.uvsFloat32[6] = this.x3;
        this.uvsFloat32[7] = this.y3;
      }
      toString() {
        return `[pixi.js/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/generateUID.mjs
function generateUID() {
  return uidCount++;
}
var uidCount;
var init_generateUID = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/generateUID.mjs"() {
    "use strict";
    init_define_AnParams();
    uidCount = 0;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/utils/parseFunctionBody.mjs
function parseFunctionBody(fn) {
  const fnStr = fn.toString();
  const bodyStart = fnStr.indexOf("{");
  const bodyEnd = fnStr.lastIndexOf("}");
  if (bodyStart === -1 || bodyEnd === -1) {
    throw new Error("getFunctionBody: No body found in function definition");
  }
  return fnStr.slice(bodyStart + 1, bodyEnd).trim();
}
var init_parseFunctionBody = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/utils/parseFunctionBody.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs
function getFastGlobalBounds(target, bounds) {
  deprecation("8.7.0", "Use container.getFastGlobalBounds() instead");
  return target.getFastGlobalBounds(true, bounds);
}
var init_getFastGlobalBounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs"() {
    init_define_AnParams();
    init_deprecation();
  }
});

// node_modules/pixi.js/lib/scene/container/RenderContainer.mjs
var RenderContainer;
var init_RenderContainer = __esm({
  "node_modules/pixi.js/lib/scene/container/RenderContainer.mjs"() {
    init_define_AnParams();
    init_ViewContainer();
    RenderContainer = class extends ViewContainer {
      /**
       * @param options - The options for the container.
       */
      constructor(options) {
        if (typeof options === "function") {
          options = { render: options };
        }
        const { render, ...rest } = options;
        super({
          label: "RenderContainer",
          ...rest
        });
        this.renderPipeId = "customRender";
        this.batched = false;
        if (render)
          this.render = render;
        this.containsPoint = options.containsPoint ?? (() => false);
        this.addBounds = options.addBounds ?? (() => false);
      }
      /** @private */
      updateBounds() {
        this._bounds.clear();
        this.addBounds(this._bounds);
      }
      /**
       * An overridable function that can be used to render the object using the current renderer.
       * @param _renderer - The current renderer
       */
      render(_renderer) {
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/utils/collectAllRenderables.mjs
function collectAllRenderables(container, instructionSet, rendererOrPipes) {
  deprecation("8.7.0", "Please use container.collectRenderables instead.");
  const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
  return container.collectRenderables(instructionSet, renderer, null);
}
var init_collectAllRenderables = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/collectAllRenderables.mjs"() {
    init_define_AnParams();
    init_deprecation();
  }
});

// node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs
function mixHexColors(color1, color2, ratio) {
  const r1 = color1 >> 16 & 255;
  const g1 = color1 >> 8 & 255;
  const b1 = color1 & 255;
  const r2 = color2 >> 16 & 255;
  const g2 = color2 >> 8 & 255;
  const b22 = color2 & 255;
  const r3 = r1 + (r2 - r1) * ratio;
  const g3 = g1 + (g2 - g1) * ratio;
  const b3 = b1 + (b22 - b1) * ratio;
  return (r3 << 16) + (g3 << 8) + b3;
}
var init_mixHexColors = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs
function updateLocalTransform(lt, container) {
  const scale = container._scale;
  const pivot = container._pivot;
  const position = container._position;
  const sx = scale._x;
  const sy = scale._y;
  const px = pivot._x;
  const py = pivot._y;
  lt.a = container._cx * sx;
  lt.b = container._sx * sx;
  lt.c = container._cy * sy;
  lt.d = container._sy * sy;
  lt.tx = position._x - (px * lt.a + py * lt.c);
  lt.ty = position._y - (px * lt.b + py * lt.d);
}
var init_updateLocalTransform = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/updateLocalTransform.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.mjs
function updateWorldTransform(local, parent2, world) {
  const lta = local.a;
  const ltb = local.b;
  const ltc = local.c;
  const ltd = local.d;
  const lttx = local.tx;
  const ltty = local.ty;
  const pta = parent2.a;
  const ptb = parent2.b;
  const ptc = parent2.c;
  const ptd = parent2.d;
  world.a = lta * pta + ltb * ptc;
  world.b = lta * ptb + ltb * ptd;
  world.c = ltc * pta + ltd * ptc;
  world.d = ltc * ptb + ltd * ptd;
  world.tx = lttx * pta + ltty * ptc + parent2.tx;
  world.ty = lttx * ptb + ltty * ptd + parent2.ty;
}
var init_updateWorldTransform = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/updateWorldTransform.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/buildGeometryFromPath.mjs
function buildGeometryFromPath(options) {
  if (options instanceof GraphicsPath) {
    options = {
      path: options,
      textureMatrix: null,
      out: null
    };
  }
  const vertices = [];
  const uvs = [];
  const indices = [];
  const shapePath = options.path.shapePath;
  const textureMatrix = options.textureMatrix;
  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }) => {
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build = buildMap[shape.type];
    build.build(shape, points);
    if (matrix) {
      transformVertices(points, matrix);
    }
    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
    const uvsOffset = uvs.length / 2;
    if (textureMatrix) {
      if (matrix) {
        textureMatrix.append(matrix.clone().invert());
      }
      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
    } else {
      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
    }
  });
  const out2 = options.out;
  if (out2) {
    out2.positions = new Float32Array(vertices);
    out2.uvs = new Float32Array(uvs);
    out2.indices = new Uint32Array(indices);
    return out2;
  }
  const geometry = new MeshGeometry({
    positions: new Float32Array(vertices),
    uvs: new Float32Array(uvs),
    indices: new Uint32Array(indices)
  });
  return geometry;
}
var buildMap;
var init_buildGeometryFromPath = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/buildGeometryFromPath.mjs"() {
    init_define_AnParams();
    init_buildUvs();
    init_transformVertices();
    init_MeshGeometry();
    init_buildCircle();
    init_buildPolygon();
    init_buildRectangle();
    init_buildTriangle();
    init_GraphicsPath();
    buildMap = {
      rectangle: buildRectangle,
      polygon: buildPolygon,
      triangle: buildTriangle,
      circle: buildCircle,
      ellipse: buildCircle,
      roundedRectangle: buildCircle
    };
  }
});

// node_modules/pixi.js/lib/scene/layers/RenderLayer.mjs
var _RenderLayerClass, RenderLayerClass, RenderLayer;
var init_RenderLayer = __esm({
  "node_modules/pixi.js/lib/scene/layers/RenderLayer.mjs"() {
    init_define_AnParams();
    init_warn();
    init_Container();
    _RenderLayerClass = class _RenderLayerClass2 extends Container {
      /**
       * Creates a new RenderLayer instance
       * @param options - Configuration options for the RenderLayer
       * @param {boolean} [options.sortableChildren=false] - If true, layer children will be automatically sorted each render
       * @param {Function} [options.sortFunction] - Custom function to sort layer children. Default sorts by zIndex
       */
      constructor(options = {}) {
        options = { ..._RenderLayerClass2.defaultOptions, ...options };
        super();
        this.renderLayerChildren = [];
        this.sortableChildren = options.sortableChildren;
        this.sortFunction = options.sortFunction;
      }
      /**
       * Add an Container to this render layer. The Container will be rendered as part of this layer
       * while maintaining its original parent in the scene graph.
       * If the Container already belongs to a layer, it will be removed from the old layer before being added to this one.
       * @param children - The Container(s) to add to this layer
       */
      attach(...children) {
        for (let i3 = 0; i3 < children.length; i3++) {
          const child = children[i3];
          if (child.parentRenderLayer) {
            if (child.parentRenderLayer === this)
              continue;
            child.parentRenderLayer.detach(child);
          }
          this.renderLayerChildren.push(child);
          child.parentRenderLayer = this;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.structureDidChange = true;
          }
        }
        return children[0];
      }
      /**
       * Remove an Container from this render layer. The Container will no longer be rendered
       * as part of this layer but maintains its original parent.
       * @param children - The Container(s) to remove from this layer
       */
      detach(...children) {
        for (let i3 = 0; i3 < children.length; i3++) {
          const child = children[i3];
          const index = this.renderLayerChildren.indexOf(child);
          if (index !== -1) {
            this.renderLayerChildren.splice(index, 1);
          }
          child.parentRenderLayer = null;
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.structureDidChange = true;
          }
        }
        return children[0];
      }
      /** Remove all objects from this render layer. */
      detachAll() {
        const layerChildren = this.renderLayerChildren;
        for (let i3 = 0; i3 < layerChildren.length; i3++) {
          layerChildren[i3].parentRenderLayer = null;
        }
        this.renderLayerChildren.length = 0;
      }
      collectRenderables(instructionSet, renderer, _currentLayer) {
        const layerChildren = this.renderLayerChildren;
        const length = layerChildren.length;
        if (this.sortableChildren) {
          this.sortRenderLayerChildren();
        }
        for (let i3 = 0; i3 < length; i3++) {
          if (!layerChildren[i3].parent) {
            warn(
              "Container must be added to both layer and scene graph. Layers only handle render order - the scene graph is required for transforms (addChild)",
              layerChildren[i3]
            );
          }
          layerChildren[i3].collectRenderables(instructionSet, renderer, this);
        }
      }
      /**
       * Sort the layer's children using the defined sort function.
       * Will be called each render if sortableChildren is true.
       * Otherwise can call this manually.
       */
      sortRenderLayerChildren() {
        this.renderLayerChildren.sort(this.sortFunction);
      }
      _getGlobalBoundsRecursive(factorRenderLayers, bounds, _currentLayer) {
        if (!factorRenderLayers)
          return;
        const children = this.renderLayerChildren;
        for (let i3 = 0; i3 < children.length; i3++) {
          children[i3]._getGlobalBoundsRecursive(true, bounds, this);
        }
      }
    };
    _RenderLayerClass.defaultOptions = {
      sortableChildren: false,
      sortFunction: (a2, b3) => a2.zIndex - b3.zIndex
    };
    RenderLayerClass = _RenderLayerClass;
    RenderLayer = RenderLayerClass;
  }
});

// node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs
function applyProjectiveTransformationToPlane(width, height, geometry, transformationMatrix) {
  const buffer = geometry.buffers[0];
  const vertices = buffer.data;
  const { verticesX, verticesY } = geometry;
  const sizeX = width / (verticesX - 1);
  const sizeY = height / (verticesY - 1);
  let index = 0;
  const a00 = transformationMatrix[0];
  const a01 = transformationMatrix[1];
  const a02 = transformationMatrix[2];
  const a10 = transformationMatrix[3];
  const a11 = transformationMatrix[4];
  const a12 = transformationMatrix[5];
  const a20 = transformationMatrix[6];
  const a21 = transformationMatrix[7];
  const a22 = transformationMatrix[8];
  for (let i3 = 0; i3 < vertices.length; i3 += 2) {
    const x2 = index % verticesX * sizeX;
    const y2 = (index / verticesX | 0) * sizeY;
    const newX = a00 * x2 + a01 * y2 + a02;
    const newY = a10 * x2 + a11 * y2 + a12;
    const w2 = a20 * x2 + a21 * y2 + a22;
    vertices[i3] = newX / w2;
    vertices[i3 + 1] = newY / w2;
    index++;
  }
  buffer.update();
}
var init_applyProjectiveTransformationToPlane = __esm({
  "node_modules/pixi.js/lib/scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.mjs
function computeAdjugate(out2, matrix) {
  const a00 = matrix[0];
  const a01 = matrix[1];
  const a02 = matrix[2];
  const a10 = matrix[3];
  const a11 = matrix[4];
  const a12 = matrix[5];
  const a20 = matrix[6];
  const a21 = matrix[7];
  const a22 = matrix[8];
  out2[0] = a11 * a22 - a12 * a21;
  out2[1] = a02 * a21 - a01 * a22;
  out2[2] = a01 * a12 - a02 * a11;
  out2[3] = a12 * a20 - a10 * a22;
  out2[4] = a00 * a22 - a02 * a20;
  out2[5] = a02 * a10 - a00 * a12;
  out2[6] = a10 * a21 - a11 * a20;
  out2[7] = a01 * a20 - a00 * a21;
  out2[8] = a00 * a11 - a01 * a10;
  return out2;
}
function multiplyMatrix3x3(out2, a2, b3) {
  const a00 = a2[0];
  const a01 = a2[1];
  const a02 = a2[2];
  const a10 = a2[3];
  const a11 = a2[4];
  const a12 = a2[5];
  const a20 = a2[6];
  const a21 = a2[7];
  const a22 = a2[8];
  const b00 = b3[0];
  const b01 = b3[1];
  const b02 = b3[2];
  const b10 = b3[3];
  const b11 = b3[4];
  const b12 = b3[5];
  const b20 = b3[6];
  const b21 = b3[7];
  const b22 = b3[8];
  out2[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out2[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out2[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out2[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out2[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out2[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out2[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out2[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out2[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out2;
}
function multiplyMatrixAndVector(out2, m2, v2) {
  const x2 = v2[0];
  const y2 = v2[1];
  const z = v2[2];
  out2[0] = m2[0] * x2 + m2[1] * y2 + m2[2] * z;
  out2[1] = m2[3] * x2 + m2[4] * y2 + m2[5] * z;
  out2[2] = m2[6] * x2 + m2[7] * y2 + m2[8] * z;
  return out2;
}
function generateBasisToPointsMatrix(out2, x1, y1, x2, y2, x3, y3, x4, y4) {
  const m2 = tempMatrix7;
  m2[0] = x1;
  m2[1] = x2;
  m2[2] = x3;
  m2[3] = y1;
  m2[4] = y2;
  m2[5] = y3;
  m2[6] = 1;
  m2[7] = 1;
  m2[8] = 1;
  const adjugateM = computeAdjugate(
    out2,
    // reusing out as adjugateM is only used once
    m2
  );
  tempVec2[0] = x4;
  tempVec2[1] = y4;
  tempVec2[2] = 1;
  const v2 = multiplyMatrixAndVector(
    tempVec,
    adjugateM,
    tempVec2
  );
  const diagonalMatrix = out2;
  out2[0] = v2[0];
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 0;
  out2[4] = v2[1];
  out2[5] = 0;
  out2[6] = 0;
  out2[7] = 0;
  out2[8] = v2[2];
  return multiplyMatrix3x3(out2, diagonalMatrix, m2);
}
function compute2DProjection(out2, x1s, y1s, x1d, y1d, x2s, y2s, x2d, y2d, x3s, y3s, x3d, y3d, x4s, y4s, x4d, y4d) {
  const sourceMatrix = generateBasisToPointsMatrix(
    tempSourceMatrix,
    x1s,
    y1s,
    x2s,
    y2s,
    x3s,
    y3s,
    x4s,
    y4s
  );
  const destinationMatrix = generateBasisToPointsMatrix(
    tempDestinationMatrix,
    x1d,
    y1d,
    x2d,
    y2d,
    x3d,
    y3d,
    x4d,
    y4d
  );
  return multiplyMatrix3x3(
    out2,
    computeAdjugate(sourceMatrix, sourceMatrix),
    destinationMatrix
  );
}
var tempMatrix7, tempVec, tempVec2, tempSourceMatrix, tempDestinationMatrix;
var init_compute2DProjections = __esm({
  "node_modules/pixi.js/lib/scene/mesh-perspective/utils/compute2DProjections.mjs"() {
    "use strict";
    init_define_AnParams();
    tempMatrix7 = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    tempVec = [0, 0, 0];
    tempVec2 = [0, 0, 0];
    tempSourceMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    tempDestinationMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  }
});

// node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.mjs
var PerspectivePlaneGeometry;
var init_PerspectivePlaneGeometry = __esm({
  "node_modules/pixi.js/lib/scene/mesh-perspective/PerspectivePlaneGeometry.mjs"() {
    init_define_AnParams();
    init_PlaneGeometry();
    init_applyProjectiveTransformationToPlane();
    init_compute2DProjections();
    PerspectivePlaneGeometry = class extends PlaneGeometry {
      /**
       * @param options - Options to be applied to MeshPlane
       * @param options.width - The width of the plane
       * @param options.height - The height of the plane
       * @param options.verticesX - The amount of vertices on the x axis
       * @param options.verticesY - The amount of vertices on the y axis
       */
      constructor(options) {
        super(options);
        this._projectionMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        const { width, height } = options;
        this.corners = [0, 0, width, 0, width, height, 0, height];
      }
      /**
       * Will set the corners of the quad to the given coordinates
       * Calculating the perspective so it looks correct!
       * @param x0 - x coordinate of the first corner
       * @param y0 - y coordinate of the first corner
       * @param x1 - x coordinate of the second corner
       * @param y1 - y coordinate of the second corner
       * @param x2 - x coordinate of the third corner
       * @param y2 - y coordinate of the third corner
       * @param x3 - x coordinate of the fourth corner
       * @param y3 - y coordinate of the fourth corner
       */
      setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {
        const corners = this.corners;
        corners[0] = x0;
        corners[1] = y0;
        corners[2] = x1;
        corners[3] = y1;
        corners[4] = x2;
        corners[5] = y2;
        corners[6] = x3;
        corners[7] = y3;
        this.updateProjection();
      }
      /** Update the projection matrix based on the corners */
      updateProjection() {
        const { width, height } = this;
        const corners = this.corners;
        const projectionMatrix = compute2DProjection(
          this._projectionMatrix,
          0,
          0,
          // top-left source
          corners[0],
          corners[1],
          // top-left dest
          width,
          0,
          // top-right source
          corners[2],
          corners[3],
          // top-right dest
          width,
          height,
          // bottom-right source
          corners[4],
          corners[5],
          // bottom-right dest
          0,
          height,
          // bottom-left source
          corners[6],
          corners[7]
          // bottom-left dest
        );
        applyProjectiveTransformationToPlane(
          width,
          height,
          this,
          projectionMatrix
        );
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.mjs
var _PerspectiveMesh, PerspectiveMesh;
var init_PerspectiveMesh = __esm({
  "node_modules/pixi.js/lib/scene/mesh-perspective/PerspectiveMesh.mjs"() {
    init_define_AnParams();
    init_Texture();
    init_definedProps();
    init_Mesh();
    init_PerspectivePlaneGeometry();
    _PerspectiveMesh = class _PerspectiveMesh2 extends Mesh {
      /**
       * @param options - Options to be applied to PerspectiveMesh
       */
      constructor(options) {
        options = { ..._PerspectiveMesh2.defaultOptions, ...options };
        const { texture, verticesX, verticesY, ...rest } = options;
        const planeGeometry = new PerspectivePlaneGeometry(definedProps({
          width: texture.width,
          height: texture.height,
          verticesX,
          verticesY
        }));
        super(definedProps({ ...rest, geometry: planeGeometry }));
        this._texture = texture;
        this.geometry.setCorners(
          options.x0,
          options.y0,
          options.x1,
          options.y1,
          options.x2,
          options.y2,
          options.x3,
          options.y3
        );
      }
      /** Update the geometry when the texture is updated */
      textureUpdated() {
        const geometry = this.geometry;
        if (!geometry)
          return;
        const { width, height } = this.texture;
        if (geometry.width !== width || geometry.height !== height) {
          geometry.width = width;
          geometry.height = height;
          geometry.updateProjection();
        }
      }
      set texture(value) {
        if (this._texture === value)
          return;
        super.texture = value;
        this.textureUpdated();
      }
      /** The texture that the mesh uses */
      get texture() {
        return this._texture;
      }
      /**
       * Set the corners of the quad to the given coordinates
       * The mesh will then calculate the perspective so it looks correct!
       * @param x0 - x coordinate of the first corner
       * @param y0 - y coordinate of the first corner
       * @param x1 - x coordinate of the second corner
       * @param y1 - y coordinate of the second corner
       * @param x2 - x coordinate of the third corner
       * @param y2 - y coordinate of the third corner
       * @param x3 - x coordinate of the fourth corner
       * @param y3 - y coordinate of the fourth corner
       */
      setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {
        this.geometry.setCorners(x0, y0, x1, y1, x2, y2, x3, y3);
      }
    };
    _PerspectiveMesh.defaultOptions = {
      texture: Texture.WHITE,
      verticesX: 10,
      verticesY: 10,
      x0: 0,
      y0: 0,
      x1: 100,
      y1: 0,
      x2: 100,
      y2: 100,
      x3: 0,
      y3: 100
    };
    PerspectiveMesh = _PerspectiveMesh;
  }
});

// node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.mjs
var MeshPlane;
var init_MeshPlane = __esm({
  "node_modules/pixi.js/lib/scene/mesh-plane/MeshPlane.mjs"() {
    init_define_AnParams();
    init_definedProps();
    init_Mesh();
    init_PlaneGeometry();
    MeshPlane = class extends Mesh {
      /**
       * @param options - Options to be applied to MeshPlane
       */
      constructor(options) {
        const { texture, verticesX, verticesY, ...rest } = options;
        const planeGeometry = new PlaneGeometry(definedProps({
          width: texture.width,
          height: texture.height,
          verticesX,
          verticesY
        }));
        super(definedProps({ ...rest, geometry: planeGeometry, texture }));
        this.texture = texture;
        this.autoResize = true;
      }
      /**
       * Method used for overrides, to do something in case texture frame was changed.
       * Meshes based on plane can override it and change more details based on texture.
       */
      textureUpdated() {
        const geometry = this.geometry;
        const { width, height } = this.texture;
        if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
          geometry.width = width;
          geometry.height = height;
          geometry.build({});
        }
      }
      set texture(value) {
        this._texture?.off("update", this.textureUpdated, this);
        super.texture = value;
        value.on("update", this.textureUpdated, this);
        this.textureUpdated();
      }
      /** The texture of the MeshPlane */
      get texture() {
        return this._texture;
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options) {
        this.texture.off("update", this.textureUpdated, this);
        super.destroy(options);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.mjs
var _RopeGeometry, RopeGeometry;
var init_RopeGeometry = __esm({
  "node_modules/pixi.js/lib/scene/mesh-simple/RopeGeometry.mjs"() {
    init_define_AnParams();
    init_MeshGeometry();
    _RopeGeometry = class _RopeGeometry2 extends MeshGeometry {
      /**
       * @param options - Options to be applied to rope geometry
       */
      constructor(options) {
        const { width, points, textureScale } = { ..._RopeGeometry2.defaultOptions, ...options };
        super({
          positions: new Float32Array(points.length * 4),
          uvs: new Float32Array(points.length * 4),
          indices: new Uint32Array((points.length - 1) * 6)
        });
        this.points = points;
        this._width = width;
        this.textureScale = textureScale;
        this._build();
      }
      /**
       * The width (i.e., thickness) of the rope.
       * @readonly
       */
      get width() {
        return this._width;
      }
      /** Refreshes Rope indices and uvs */
      _build() {
        const points = this.points;
        if (!points)
          return;
        const vertexBuffer = this.getBuffer("aPosition");
        const uvBuffer = this.getBuffer("aUV");
        const indexBuffer = this.getIndex();
        if (points.length < 1) {
          return;
        }
        if (vertexBuffer.data.length / 4 !== points.length) {
          vertexBuffer.data = new Float32Array(points.length * 4);
          uvBuffer.data = new Float32Array(points.length * 4);
          indexBuffer.data = new Uint16Array((points.length - 1) * 6);
        }
        const uvs = uvBuffer.data;
        const indices = indexBuffer.data;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        let amount = 0;
        let prev = points[0];
        const textureWidth = this._width * this.textureScale;
        const total = points.length;
        for (let i3 = 0; i3 < total; i3++) {
          const index = i3 * 4;
          if (this.textureScale > 0) {
            const dx = prev.x - points[i3].x;
            const dy = prev.y - points[i3].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            prev = points[i3];
            amount += distance / textureWidth;
          } else {
            amount = i3 / (total - 1);
          }
          uvs[index] = amount;
          uvs[index + 1] = 0;
          uvs[index + 2] = amount;
          uvs[index + 3] = 1;
        }
        let indexCount = 0;
        for (let i3 = 0; i3 < total - 1; i3++) {
          const index = i3 * 2;
          indices[indexCount++] = index;
          indices[indexCount++] = index + 1;
          indices[indexCount++] = index + 2;
          indices[indexCount++] = index + 2;
          indices[indexCount++] = index + 1;
          indices[indexCount++] = index + 3;
        }
        uvBuffer.update();
        indexBuffer.update();
        this.updateVertices();
      }
      /** refreshes vertices of Rope mesh */
      updateVertices() {
        const points = this.points;
        if (points.length < 1) {
          return;
        }
        let lastPoint = points[0];
        let nextPoint;
        let perpX = 0;
        let perpY = 0;
        const vertices = this.buffers[0].data;
        const total = points.length;
        const halfWidth = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
        for (let i3 = 0; i3 < total; i3++) {
          const point = points[i3];
          const index = i3 * 4;
          if (i3 < points.length - 1) {
            nextPoint = points[i3 + 1];
          } else {
            nextPoint = point;
          }
          perpY = -(nextPoint.x - lastPoint.x);
          perpX = nextPoint.y - lastPoint.y;
          let ratio = (1 - i3 / (total - 1)) * 10;
          if (ratio > 1) {
            ratio = 1;
          }
          const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
          if (perpLength < 1e-6) {
            perpX = 0;
            perpY = 0;
          } else {
            perpX /= perpLength;
            perpY /= perpLength;
            perpX *= halfWidth;
            perpY *= halfWidth;
          }
          vertices[index] = point.x + perpX;
          vertices[index + 1] = point.y + perpY;
          vertices[index + 2] = point.x - perpX;
          vertices[index + 3] = point.y - perpY;
          lastPoint = point;
        }
        this.buffers[0].update();
      }
      /** Refreshes Rope indices and uvs */
      update() {
        if (this.textureScale > 0) {
          this._build();
        } else {
          this.updateVertices();
        }
      }
    };
    _RopeGeometry.defaultOptions = {
      /** The width (i.e., thickness) of the rope. */
      width: 200,
      /** An array of points that determine the rope. */
      points: [],
      /** Rope texture scale, if zero then the rope texture is stretched. */
      textureScale: 0
    };
    RopeGeometry = _RopeGeometry;
  }
});

// node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.mjs
var _MeshRope, MeshRope;
var init_MeshRope = __esm({
  "node_modules/pixi.js/lib/scene/mesh-simple/MeshRope.mjs"() {
    init_define_AnParams();
    init_definedProps();
    init_Mesh();
    init_RopeGeometry();
    _MeshRope = class _MeshRope2 extends Mesh {
      /**
       * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.
       * @param options
       * @param options.texture - The texture to use on the rope.
       * @param options.points - An array of {@link math.Point} objects to construct this rope.
       * @param {number} options.textureScale - Optional. Positive values scale rope texture
       * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture
       * and downsampling here. If set to zero, texture will be stretched instead.
       */
      constructor(options) {
        const { texture, points, textureScale, ...rest } = { ..._MeshRope2.defaultOptions, ...options };
        const ropeGeometry = new RopeGeometry(definedProps({ width: texture.height, points, textureScale }));
        if (textureScale > 0) {
          texture.source.style.addressMode = "repeat";
        }
        super(definedProps({
          ...rest,
          texture,
          geometry: ropeGeometry
        }));
        this.autoUpdate = true;
        this.onRender = this._render;
      }
      _render() {
        const geometry = this.geometry;
        if (this.autoUpdate || geometry._width !== this.texture.height) {
          geometry._width = this.texture.height;
          geometry.update();
        }
      }
    };
    _MeshRope.defaultOptions = {
      textureScale: 0
    };
    MeshRope = _MeshRope;
  }
});

// node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.mjs
var MeshSimple;
var init_MeshSimple = __esm({
  "node_modules/pixi.js/lib/scene/mesh-simple/MeshSimple.mjs"() {
    init_define_AnParams();
    init_definedProps();
    init_Mesh();
    init_MeshGeometry();
    MeshSimple = class extends Mesh {
      /**
       * @param options - Options to be used for construction
       */
      constructor(options) {
        const { texture, vertices, uvs, indices, topology, ...rest } = options;
        const geometry = new MeshGeometry(definedProps({
          positions: vertices,
          uvs,
          indices,
          topology
        }));
        super(definedProps({
          ...rest,
          texture,
          geometry
        }));
        this.autoUpdate = true;
        this.onRender = this._render;
      }
      /**
       * Collection of vertices data.
       * @type {Float32Array}
       */
      get vertices() {
        return this.geometry.getBuffer("aPosition").data;
      }
      set vertices(value) {
        this.geometry.getBuffer("aPosition").data = value;
      }
      _render() {
        if (this.autoUpdate) {
          this.geometry.getBuffer("aPosition").update();
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.mjs
function getTextureDefaultMatrix(texture, out2) {
  const { width, height } = texture.frame;
  out2.scale(1 / width, 1 / height);
  return out2;
}
var init_getTextureDefaultMatrix = __esm({
  "node_modules/pixi.js/lib/scene/mesh/shared/getTextureDefaultMatrix.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/Particle.mjs
var _Particle, Particle;
var init_Particle = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/Particle.mjs"() {
    init_define_AnParams();
    init_Color();
    init_Texture();
    init_getGlobalMixin();
    init_assignWithIgnore();
    _Particle = class _Particle2 {
      constructor(options) {
        if (options instanceof Texture) {
          this.texture = options;
          assignWithIgnore(this, _Particle2.defaultOptions, {});
        } else {
          const combined = { ..._Particle2.defaultOptions, ...options };
          assignWithIgnore(this, combined, {});
        }
      }
      /** Gets or sets the alpha value of the particle. */
      get alpha() {
        return this._alpha;
      }
      set alpha(value) {
        this._alpha = Math.min(Math.max(value, 0), 1);
        this._updateColor();
      }
      /** Gets or sets the tint color of the particle. */
      get tint() {
        return bgr2rgb(this._tint);
      }
      set tint(value) {
        if (typeof value === "number") {
          this._tint = value;
        } else {
          this._tint = Color.shared.setValue(value ?? 16777215).toBgrNumber();
        }
        this._updateColor();
      }
      _updateColor() {
        this.color = this._tint + ((this._alpha * 255 | 0) << 24);
      }
    };
    _Particle.defaultOptions = {
      anchorX: 0,
      anchorY: 0,
      x: 0,
      y: 0,
      scaleX: 1,
      scaleY: 1,
      rotation: 0,
      tint: 16777215,
      alpha: 1
    };
    Particle = _Particle;
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/particleData.mjs
var particleData;
var init_particleData = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/particleData.mjs"() {
    "use strict";
    init_define_AnParams();
    particleData = {
      vertex: {
        attributeName: "aVertex",
        format: "float32x2",
        code: `
            const texture = p.texture;
            const sx = p.scaleX;
            const sy = p.scaleY;
            const ax = p.anchorX;
            const ay = p.anchorY;
            const trim = texture.trim;
            const orig = texture.orig;

            if (trim)
            {
                w1 = trim.x - (ax * orig.width);
                w0 = w1 + trim.width;

                h1 = trim.y - (ay * orig.height);
                h0 = h1 + trim.height;
            }
            else
            {
                w1 = -ax * (orig.width);
                w0 = w1 + orig.width;

                h1 = -ay * (orig.height);
                h0 = h1 + orig.height;
            }

            f32v[offset] = w1 * sx;
            f32v[offset + 1] = h1 * sy;

            f32v[offset + stride] = w0 * sx;
            f32v[offset + stride + 1] = h1 * sy;

            f32v[offset + (stride * 2)] = w0 * sx;
            f32v[offset + (stride * 2) + 1] = h0 * sy;

            f32v[offset + (stride * 3)] = w1 * sx;
            f32v[offset + (stride * 3) + 1] = h0 * sy;
        `,
        dynamic: false
      },
      // positionData
      position: {
        attributeName: "aPosition",
        format: "float32x2",
        code: `
            var x = p.x;
            var y = p.y;

            f32v[offset] = x;
            f32v[offset + 1] = y;

            f32v[offset + stride] = x;
            f32v[offset + stride + 1] = y;

            f32v[offset + (stride * 2)] = x;
            f32v[offset + (stride * 2) + 1] = y;

            f32v[offset + (stride * 3)] = x;
            f32v[offset + (stride * 3) + 1] = y;
        `,
        dynamic: true
      },
      // rotationData
      rotation: {
        attributeName: "aRotation",
        format: "float32",
        code: `
            var rotation = p.rotation;

            f32v[offset] = rotation;
            f32v[offset + stride] = rotation;
            f32v[offset + (stride * 2)] = rotation;
            f32v[offset + (stride * 3)] = rotation;
        `,
        dynamic: false
      },
      // uvsData
      uvs: {
        attributeName: "aUV",
        format: "float32x2",
        code: `
            var uvs = p.texture.uvs;

            f32v[offset] = uvs.x0;
            f32v[offset + 1] = uvs.y0;

            f32v[offset + stride] = uvs.x1;
            f32v[offset + stride + 1] = uvs.y1;

            f32v[offset + (stride * 2)] = uvs.x2;
            f32v[offset + (stride * 2) + 1] = uvs.y2;

            f32v[offset + (stride * 3)] = uvs.x3;
            f32v[offset + (stride * 3) + 1] = uvs.y3;
        `,
        dynamic: false
      },
      // tintData
      color: {
        attributeName: "aColor",
        format: "unorm8x4",
        code: `
            const c = p.color;

            u32v[offset] = c;
            u32v[offset + stride] = c;
            u32v[offset + (stride * 2)] = c;
            u32v[offset + (stride * 3)] = c;
        `,
        dynamic: false
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.mjs
var emptyBounds, _ParticleContainer, ParticleContainer;
var init_ParticleContainer = __esm({
  "node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainer.mjs"() {
    init_define_AnParams();
    init_Bounds();
    init_ViewContainer();
    init_particleData();
    emptyBounds = new Bounds(0, 0, 0, 0);
    _ParticleContainer = class _ParticleContainer2 extends ViewContainer {
      /**
       * @param options - The options for creating the sprite.
       */
      constructor(options = {}) {
        options = {
          ..._ParticleContainer2.defaultOptions,
          ...options,
          dynamicProperties: {
            ..._ParticleContainer2.defaultOptions.dynamicProperties,
            ...options?.dynamicProperties
          }
        };
        const { dynamicProperties, shader, roundPixels, texture, particles, ...rest } = options;
        super({
          label: "ParticleContainer",
          ...rest
        });
        this.renderPipeId = "particle";
        this.batched = false;
        this._childrenDirty = false;
        this.texture = texture || null;
        this.shader = shader;
        this._properties = {};
        for (const key in particleData) {
          const property = particleData[key];
          const dynamic = dynamicProperties[key];
          this._properties[key] = {
            ...property,
            dynamic
          };
        }
        this.allowChildren = true;
        this.roundPixels = roundPixels ?? false;
        this.particleChildren = particles ?? [];
      }
      /**
       * Adds one or more particles to the container.
       *
       * Multiple items can be added like so: `myContainer.addParticle(thingOne, thingTwo, thingThree)`
       * @param {...IParticle} children - The Particle(s) to add to the container
       * @returns {IParticle} - The first child that was added.
       */
      addParticle(...children) {
        for (let i3 = 0; i3 < children.length; i3++) {
          this.particleChildren.push(children[i3]);
        }
        this.onViewUpdate();
        return children[0];
      }
      /**
       * Removes one or more particles from the container.
       * @param {...IParticle} children - The Particle(s) to remove
       * @returns {IParticle} The first child that was removed.
       */
      removeParticle(...children) {
        let didRemove = false;
        for (let i3 = 0; i3 < children.length; i3++) {
          const index = this.particleChildren.indexOf(children[i3]);
          if (index > -1) {
            this.particleChildren.splice(index, 1);
            didRemove = true;
          }
        }
        if (didRemove)
          this.onViewUpdate();
        return children[0];
      }
      /**
       * Updates the particle container.
       * Please call this when you modify the particleChildren array.
       * or any static properties of the particles.
       */
      update() {
        this._childrenDirty = true;
      }
      onViewUpdate() {
        this._childrenDirty = true;
        super.onViewUpdate();
      }
      /**
       * ParticleContainer does not calculated bounds as it would slow things down,
       * its up to you to set this via the boundsArea property
       */
      get bounds() {
        return emptyBounds;
      }
      /** @private */
      updateBounds() {
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options = false) {
        super.destroy(options);
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          const texture = this.texture ?? this.particleChildren[0]?.texture;
          if (texture) {
            texture.destroy(destroyTextureSource);
          }
        }
        this.texture = null;
        this.shader?.destroy();
      }
      /**
       * Removes all particles from this container that are within the begin and end indexes.
       * @param beginIndex - The beginning position.
       * @param endIndex - The ending position. Default value is size of the container.
       * @returns - List of removed particles
       */
      removeParticles(beginIndex, endIndex) {
        const children = this.particleChildren.splice(beginIndex, endIndex);
        this.onViewUpdate();
        return children;
      }
      /**
       * Removes a particle from the specified index position.
       * @param index - The index to get the particle from
       * @returns The particle that was removed.
       */
      removeParticleAt(index) {
        const child = this.particleChildren.splice(index, 1);
        this.onViewUpdate();
        return child[0];
      }
      /**
       * Adds a particle to the container at a specified index. If the index is out of bounds an error will be thrown.
       * If the particle is already in this container, it will be moved to the specified index.
       * @param {Container} child - The particle to add.
       * @param {number} index - The absolute index where the particle will be positioned at the end of the operation.
       * @returns {Container} The particle that was added.
       */
      addParticleAt(child, index) {
        this.particleChildren.splice(index, 0, child);
        this.onViewUpdate();
        return child;
      }
      /**
       * This method is not available in ParticleContainer.
       *
       * Calling this method will throw an error. Please use `ParticleContainer.addParticle()` instead.
       * @param {...any} _children
       * @throws {Error} Always throws an error as this method is not available.
       */
      addChild(..._children) {
        throw new Error(
          "ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()"
        );
      }
      /**
       * This method is not available in ParticleContainer.
       * Calling this method will throw an error. Please use `ParticleContainer.removeParticle()` instead.
       * @param {...any} _children
       * @throws {Error} Always throws an error as this method is not available.
       */
      removeChild(..._children) {
        throw new Error(
          "ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()"
        );
      }
      /**
       * This method is not available in ParticleContainer.
       *
       * Calling this method will throw an error. Please use `ParticleContainer.removeParticles()` instead.
       * @param {number} [_beginIndex]
       * @param {number} [_endIndex]
       * @throws {Error} Always throws an error as this method is not available.
       */
      removeChildren(_beginIndex, _endIndex) {
        throw new Error(
          "ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()"
        );
      }
      /**
       * This method is not available in ParticleContainer.
       *
       * Calling this method will throw an error. Please use `ParticleContainer.removeParticleAt()` instead.
       * @param {number} _index
       * @throws {Error} Always throws an error as this method is not available.
       */
      removeChildAt(_index) {
        throw new Error(
          "ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()"
        );
      }
      /**
       * This method is not available in ParticleContainer.
       *
       * Calling this method will throw an error. Please use `ParticleContainer.getParticleAt()` instead.
       * @param {number} _index
       * @throws {Error} Always throws an error as this method is not available.
       */
      getChildAt(_index) {
        throw new Error(
          "ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()"
        );
      }
      /**
       * This method is not available in ParticleContainer.
       *
       * Calling this method will throw an error. Please use `ParticleContainer.setParticleIndex()` instead.
       * @param {ContainerChild} _child
       * @param {number} _index
       * @throws {Error} Always throws an error as this method is not available.
       */
      setChildIndex(_child, _index) {
        throw new Error(
          "ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()"
        );
      }
      /**
       * This method is not available in ParticleContainer.
       *
       * Calling this method will throw an error. Please use `ParticleContainer.getParticleIndex()` instead.
       * @param {ContainerChild} _child
       * @throws {Error} Always throws an error as this method is not available.
       */
      getChildIndex(_child) {
        throw new Error(
          "ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()"
        );
      }
      /**
       * This method is not available in ParticleContainer.
       *
       * Calling this method will throw an error. Please use `ParticleContainer.addParticleAt()` instead.
       * @param {ContainerChild} _child
       * @param {number} _index
       * @throws {Error} Always throws an error as this method is not available.
       */
      addChildAt(_child, _index) {
        throw new Error(
          "ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()"
        );
      }
      /**
       * This method is not available in ParticleContainer.
       *
       * Calling this method will throw an error. Please use `ParticleContainer.swapParticles()` instead.
       * @param {ContainerChild} _child
       * @param {ContainerChild} _child2
       */
      swapChildren(_child, _child2) {
        throw new Error(
          "ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()"
        );
      }
      /**
       * This method is not available in ParticleContainer.
       *
       * Calling this method will throw an error.
       * @param _child - The child to reparent
       * @throws {Error} Always throws an error as this method is not available.
       */
      reparentChild(..._child) {
        throw new Error("ParticleContainer.reparentChild() is not available with the particle container");
      }
      /**
       * This method is not available in ParticleContainer.
       *
       * Calling this method will throw an error.
       * @param _child - The child to reparent
       * @param _index - The index to reparent the child to
       * @throws {Error} Always throws an error as this method is not available.
       */
      reparentChildAt(_child, _index) {
        throw new Error("ParticleContainer.reparentChildAt() is not available with the particle container");
      }
    };
    _ParticleContainer.defaultOptions = {
      dynamicProperties: {
        vertex: false,
        // Indicates if vertex positions are dynamic.
        position: true,
        // Indicates if particle positions are dynamic.
        rotation: false,
        // Indicates if particle rotations are dynamic.
        uvs: false,
        // Indicates if UV coordinates are dynamic.
        color: false
        // Indicates if particle colors are dynamic.
      },
      roundPixels: false
      // Indicates if pixels should be rounded for rendering.
    };
    ParticleContainer = _ParticleContainer;
  }
});

// node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.mjs
var _NineSliceSprite, NineSliceSprite, NineSlicePlane;
var init_NineSliceSprite = __esm({
  "node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSprite.mjs"() {
    init_define_AnParams();
    init_ObservablePoint();
    init_Texture();
    init_deprecation();
    init_ViewContainer();
    init_NineSliceGeometry();
    _NineSliceSprite = class _NineSliceSprite2 extends ViewContainer {
      /**
       * @param {scene.NineSliceSpriteOptions|Texture} options - Options to use
       * @param options.texture - The texture to use on the NineSliceSprite.
       * @param options.leftWidth - Width of the left vertical bar (A)
       * @param options.topHeight - Height of the top horizontal bar (C)
       * @param options.rightWidth - Width of the right vertical bar (B)
       * @param options.bottomHeight - Height of the bottom horizontal bar (D)
       * @param options.width - Width of the NineSliceSprite,
       * setting this will actually modify the vertices and not the UV's of this plane.
       * @param options.height - Height of the NineSliceSprite,
       * setting this will actually modify the vertices and not UV's of this plane.
       */
      constructor(options) {
        if (options instanceof Texture) {
          options = { texture: options };
        }
        const {
          width,
          height,
          anchor,
          leftWidth,
          rightWidth,
          topHeight,
          bottomHeight,
          texture,
          roundPixels,
          ...rest
        } = options;
        super({
          label: "NineSliceSprite",
          ...rest
        });
        this.renderPipeId = "nineSliceSprite";
        this.batched = true;
        this._leftWidth = leftWidth ?? texture?.defaultBorders?.left ?? NineSliceGeometry.defaultOptions.leftWidth;
        this._topHeight = topHeight ?? texture?.defaultBorders?.top ?? NineSliceGeometry.defaultOptions.topHeight;
        this._rightWidth = rightWidth ?? texture?.defaultBorders?.right ?? NineSliceGeometry.defaultOptions.rightWidth;
        this._bottomHeight = bottomHeight ?? texture?.defaultBorders?.bottom ?? NineSliceGeometry.defaultOptions.bottomHeight;
        this._width = width ?? texture.width ?? NineSliceGeometry.defaultOptions.width;
        this._height = height ?? texture.height ?? NineSliceGeometry.defaultOptions.height;
        this.allowChildren = false;
        this.texture = texture ?? _NineSliceSprite2.defaultOptions.texture;
        this.roundPixels = roundPixels ?? false;
        this._anchor = new ObservablePoint(
          {
            _onUpdate: () => {
              this.onViewUpdate();
            }
          }
        );
        if (anchor) {
          this.anchor = anchor;
        } else if (this.texture.defaultAnchor) {
          this.anchor = this.texture.defaultAnchor;
        }
      }
      get anchor() {
        return this._anchor;
      }
      set anchor(value) {
        typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
      }
      /** The width of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */
      get width() {
        return this._width;
      }
      set width(value) {
        this._width = value;
        this.onViewUpdate();
      }
      /** The height of the NineSliceSprite, setting this will actually modify the vertices and UV's of this plane. */
      get height() {
        return this._height;
      }
      set height(value) {
        this._height = value;
        this.onViewUpdate();
      }
      /**
       * Sets the size of the NiceSliceSprite to the specified width and height.
       * setting this will actually modify the vertices and UV's of this plane
       * This is faster than setting the width and height separately.
       * @param value - This can be either a number or a [Size]{@link Size} object.
       * @param height - The height to set. Defaults to the value of `width` if not provided.
       */
      setSize(value, height) {
        if (typeof value === "object") {
          height = value.height ?? value.width;
          value = value.width;
        }
        this._width = value;
        this._height = height ?? value;
        this.onViewUpdate();
      }
      /**
       * Retrieves the size of the NineSliceSprite as a [Size]{@link Size} object.
       * This is faster than get the width and height separately.
       * @param out - Optional object to store the size in.
       * @returns - The size of the NineSliceSprite.
       */
      getSize(out2) {
        out2 || (out2 = {});
        out2.width = this._width;
        out2.height = this._height;
        return out2;
      }
      /** The width of the left column (a) of the NineSliceSprite. */
      get leftWidth() {
        return this._leftWidth;
      }
      set leftWidth(value) {
        this._leftWidth = value;
        this.onViewUpdate();
      }
      /** The width of the right column (b) of the NineSliceSprite. */
      get topHeight() {
        return this._topHeight;
      }
      set topHeight(value) {
        this._topHeight = value;
        this.onViewUpdate();
      }
      /** The width of the right column (b) of the NineSliceSprite. */
      get rightWidth() {
        return this._rightWidth;
      }
      set rightWidth(value) {
        this._rightWidth = value;
        this.onViewUpdate();
      }
      /** The width of the right column (b) of the NineSliceSprite. */
      get bottomHeight() {
        return this._bottomHeight;
      }
      set bottomHeight(value) {
        this._bottomHeight = value;
        this.onViewUpdate();
      }
      /** The texture that the NineSliceSprite is using. */
      get texture() {
        return this._texture;
      }
      set texture(value) {
        value || (value = Texture.EMPTY);
        const currentTexture = this._texture;
        if (currentTexture === value)
          return;
        if (currentTexture && currentTexture.dynamic)
          currentTexture.off("update", this.onViewUpdate, this);
        if (value.dynamic)
          value.on("update", this.onViewUpdate, this);
        this._texture = value;
        this.onViewUpdate();
      }
      /** The original width of the texture */
      get originalWidth() {
        return this._texture.width;
      }
      /** The original height of the texture */
      get originalHeight() {
        return this._texture.height;
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options) {
        super.destroy(options);
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
      }
      /**
       * @private
       */
      updateBounds() {
        const bounds = this._bounds;
        const anchor = this._anchor;
        const width = this._width;
        const height = this._height;
        bounds.minX = -anchor._x * width;
        bounds.maxX = bounds.minX + width;
        bounds.minY = -anchor._y * height;
        bounds.maxY = bounds.minY + height;
      }
    };
    _NineSliceSprite.defaultOptions = {
      /** @default Texture.EMPTY */
      texture: Texture.EMPTY
    };
    NineSliceSprite = _NineSliceSprite;
    NineSlicePlane = class extends NineSliceSprite {
      constructor(...args) {
        let options = args[0];
        if (options instanceof Texture) {
          deprecation(v8_0_0, "NineSlicePlane now uses the options object {texture, leftWidth, rightWidth, topHeight, bottomHeight}");
          options = {
            texture: options,
            leftWidth: args[1],
            topHeight: args[2],
            rightWidth: args[3],
            bottomHeight: args[4]
          };
        }
        deprecation(v8_0_0, "NineSlicePlane is deprecated. Use NineSliceSprite instead.");
        super(options);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/utils/ensureTextStyle.mjs
function ensureTextStyle(renderMode, style) {
  if (style instanceof TextStyle || style instanceof HTMLTextStyle) {
    return style;
  }
  return renderMode === "html" ? new HTMLTextStyle(style) : new TextStyle(style);
}
var init_ensureTextStyle = __esm({
  "node_modules/pixi.js/lib/scene/text/utils/ensureTextStyle.mjs"() {
    init_define_AnParams();
    init_HTMLTextStyle();
    init_TextStyle();
  }
});

// node_modules/pixi.js/lib/utils/logging/logDebugTexture.mjs
async function logDebugTexture(texture, renderer, size = 200) {
  const base64 = await renderer.extract.base64(texture);
  await renderer.encoder.commandFinished;
  const width = size;
  console.log(`logging texture ${texture.source.width}px ${texture.source.height}px`);
  const style = [
    "font-size: 1px;",
    `padding: ${width}px ${300}px;`,
    `background: url(${base64}) no-repeat;`,
    "background-size: contain;"
  ].join(" ");
  console.log("%c ", style);
}
var init_logDebugTexture = __esm({
  "node_modules/pixi.js/lib/utils/logging/logDebugTexture.mjs"() {
    "use strict";
    init_define_AnParams();
  }
});

// node_modules/pixi.js/lib/utils/logging/logScene.mjs
function logScene(container, depth = 0, data = { color: "#000000" }) {
  if (container.renderGroup) {
    data.color = colors[colorTick++];
  }
  let spaces = "";
  for (let i3 = 0; i3 < depth; i3++) {
    spaces += "    ";
  }
  let label = container.label;
  if (!label && container instanceof Sprite) {
    label = `sprite:${container.texture.label}`;
  }
  let output = `%c ${spaces}|- ${label} (worldX:${container.worldTransform.tx}, relativeRenderX:${container.relativeGroupTransform.tx}, renderX:${container.groupTransform.tx}, localX:${container.x})`;
  if (container.renderGroup) {
    output += " (RenderGroup)";
  }
  if (container.filters) {
    output += "(*filters)";
  }
  console.log(output, `color:${data.color}; font-weight:bold;`);
  depth++;
  for (let i3 = 0; i3 < container.children.length; i3++) {
    const child = container.children[i3];
    logScene(child, depth, { ...data });
  }
}
function logRenderGroupScene(renderGroup, depth = 0, data = { index: 0, color: "#000000" }) {
  let spaces = "";
  for (let i3 = 0; i3 < depth; i3++) {
    spaces += "    ";
  }
  const output = `%c ${spaces}- ${data.index}: ${renderGroup.root.label} worldX:${renderGroup.worldTransform.tx}`;
  console.log(output, `color:${data.color}; font-weight:bold;`);
  depth++;
  for (let i3 = 0; i3 < renderGroup.renderGroupChildren.length; i3++) {
    const child = renderGroup.renderGroupChildren[i3];
    logRenderGroupScene(child, depth, { ...data, index: i3 });
  }
}
var colors, colorTick;
var init_logScene = __esm({
  "node_modules/pixi.js/lib/utils/logging/logScene.mjs"() {
    init_define_AnParams();
    init_Sprite();
    colors = [
      "#000080",
      // Navy Blue
      "#228B22",
      // Forest Green
      "#8B0000",
      // Dark Red
      "#4169E1",
      // Royal Blue
      "#008080",
      // Teal
      "#800000",
      // Maroon
      "#9400D3",
      // Dark Violet
      "#FF8C00",
      // Dark Orange
      "#556B2F",
      // Olive Green
      "#8B008B"
      // Dark Magenta
    ];
    colorTick = 0;
  }
});

// node_modules/pixi.js/lib/index.mjs
var lib_exports = {};
__export(lib_exports, {
  AbstractBitmapFont: () => AbstractBitmapFont,
  AbstractRenderer: () => AbstractRenderer,
  AbstractText: () => AbstractText,
  AccessibilitySystem: () => AccessibilitySystem,
  AlphaFilter: () => AlphaFilter,
  AlphaMask: () => AlphaMask,
  AlphaMaskPipe: () => AlphaMaskPipe,
  AnimatedSprite: () => AnimatedSprite,
  Application: () => Application,
  ApplicationInitHook: () => ApplicationInitHook,
  Assets: () => Assets,
  AssetsClass: () => AssetsClass,
  BLEND_TO_NPM: () => BLEND_TO_NPM,
  BUFFER_TYPE: () => BUFFER_TYPE,
  BackgroundLoader: () => BackgroundLoader,
  BackgroundSystem: () => BackgroundSystem,
  Batch: () => Batch,
  BatchGeometry: () => BatchGeometry,
  BatchTextureArray: () => BatchTextureArray,
  BatchableGraphics: () => BatchableGraphics,
  BatchableMesh: () => BatchableMesh,
  BatchableSprite: () => BatchableSprite,
  Batcher: () => Batcher,
  BatcherPipe: () => BatcherPipe,
  BigPool: () => BigPool,
  BindGroup: () => BindGroup,
  BindGroupSystem: () => BindGroupSystem,
  BitmapFont: () => BitmapFont,
  BitmapFontManager: () => BitmapFontManager,
  BitmapText: () => BitmapText,
  BitmapTextPipe: () => BitmapTextPipe,
  BlendModeFilter: () => BlendModeFilter,
  BlendModePipe: () => BlendModePipe,
  BlurFilter: () => BlurFilter,
  BlurFilterPass: () => BlurFilterPass,
  Bounds: () => Bounds,
  BrowserAdapter: () => BrowserAdapter,
  Buffer: () => Buffer2,
  BufferImageSource: () => BufferImageSource,
  BufferResource: () => BufferResource,
  BufferUsage: () => BufferUsage,
  CLEAR: () => CLEAR,
  Cache: () => Cache,
  CanvasPool: () => CanvasPool,
  CanvasPoolClass: () => CanvasPoolClass,
  CanvasSource: () => CanvasSource,
  CanvasTextMetrics: () => CanvasTextMetrics,
  CanvasTextPipe: () => CanvasTextPipe,
  CanvasTextSystem: () => CanvasTextSystem,
  Circle: () => Circle,
  Color: () => Color,
  ColorBlend: () => ColorBlend,
  ColorBurnBlend: () => ColorBurnBlend,
  ColorDodgeBlend: () => ColorDodgeBlend,
  ColorMask: () => ColorMask,
  ColorMaskPipe: () => ColorMaskPipe,
  ColorMatrixFilter: () => ColorMatrixFilter,
  CompressedSource: () => CompressedSource,
  Container: () => Container,
  Culler: () => Culler,
  CullerPlugin: () => CullerPlugin,
  CustomRenderPipe: () => CustomRenderPipe,
  D3D10_RESOURCE_DIMENSION: () => D3D10_RESOURCE_DIMENSION,
  D3DFMT: () => D3DFMT,
  DATA_URI: () => DATA_URI,
  DDS: () => DDS,
  DEG_TO_RAD: () => DEG_TO_RAD,
  DEPRECATED_SCALE_MODES: () => DEPRECATED_SCALE_MODES,
  DEPRECATED_WRAP_MODES: () => DEPRECATED_WRAP_MODES,
  DOMAdapter: () => DOMAdapter,
  DOMContainer: () => DOMContainer,
  DOMPipe: () => DOMPipe,
  DRAW_MODES: () => DRAW_MODES,
  DXGI_FORMAT: () => DXGI_FORMAT,
  DXGI_TO_TEXTURE_FORMAT: () => DXGI_TO_TEXTURE_FORMAT,
  DarkenBlend: () => DarkenBlend,
  DefaultBatcher: () => DefaultBatcher,
  DefaultShader: () => DefaultShader,
  DifferenceBlend: () => DifferenceBlend,
  DisplacementFilter: () => DisplacementFilter,
  DivideBlend: () => DivideBlend,
  DynamicBitmapFont: () => DynamicBitmapFont,
  Ellipse: () => Ellipse,
  EventBoundary: () => EventBoundary,
  EventEmitter: () => eventemitter3_default,
  EventSystem: () => EventSystem,
  EventsTicker: () => EventsTicker,
  ExclusionBlend: () => ExclusionBlend,
  ExtensionType: () => ExtensionType,
  ExtractSystem: () => ExtractSystem,
  FOURCC_TO_TEXTURE_FORMAT: () => FOURCC_TO_TEXTURE_FORMAT,
  FederatedContainer: () => FederatedContainer,
  FederatedEvent: () => FederatedEvent,
  FederatedMouseEvent: () => FederatedMouseEvent,
  FederatedPointerEvent: () => FederatedPointerEvent,
  FederatedWheelEvent: () => FederatedWheelEvent,
  FillGradient: () => FillGradient,
  FillPattern: () => FillPattern,
  Filter: () => Filter,
  FilterEffect: () => FilterEffect,
  FilterPipe: () => FilterPipe,
  FilterSystem: () => FilterSystem,
  FontStylePromiseCache: () => FontStylePromiseCache,
  GAUSSIAN_VALUES: () => GAUSSIAN_VALUES,
  GL_FORMATS: () => GL_FORMATS,
  GL_INTERNAL_FORMAT: () => GL_INTERNAL_FORMAT,
  GL_TARGETS: () => GL_TARGETS,
  GL_TYPES: () => GL_TYPES,
  GL_WRAP_MODES: () => GL_WRAP_MODES,
  GenerateTextureSystem: () => GenerateTextureSystem,
  Geometry: () => Geometry,
  GlBackBufferSystem: () => GlBackBufferSystem,
  GlBatchAdaptor: () => GlBatchAdaptor,
  GlBuffer: () => GlBuffer,
  GlBufferSystem: () => GlBufferSystem,
  GlColorMaskSystem: () => GlColorMaskSystem,
  GlContextSystem: () => GlContextSystem,
  GlEncoderSystem: () => GlEncoderSystem,
  GlGeometrySystem: () => GlGeometrySystem,
  GlGraphicsAdaptor: () => GlGraphicsAdaptor,
  GlMeshAdaptor: () => GlMeshAdaptor,
  GlParticleContainerAdaptor: () => GlParticleContainerAdaptor,
  GlParticleContainerPipe: () => GlParticleContainerPipe,
  GlProgram: () => GlProgram,
  GlProgramData: () => GlProgramData,
  GlRenderTarget: () => GlRenderTarget,
  GlRenderTargetAdaptor: () => GlRenderTargetAdaptor,
  GlRenderTargetSystem: () => GlRenderTargetSystem,
  GlShaderSystem: () => GlShaderSystem,
  GlStateSystem: () => GlStateSystem,
  GlStencilSystem: () => GlStencilSystem,
  GlTexture: () => GlTexture,
  GlTextureSystem: () => GlTextureSystem,
  GlUboSystem: () => GlUboSystem,
  GlUniformGroupSystem: () => GlUniformGroupSystem,
  GlobalUniformSystem: () => GlobalUniformSystem,
  GpuBatchAdaptor: () => GpuBatchAdaptor,
  GpuBlendModesToPixi: () => GpuBlendModesToPixi,
  GpuBufferSystem: () => GpuBufferSystem,
  GpuColorMaskSystem: () => GpuColorMaskSystem,
  GpuDeviceSystem: () => GpuDeviceSystem,
  GpuEncoderSystem: () => GpuEncoderSystem,
  GpuGraphicsAdaptor: () => GpuGraphicsAdaptor,
  GpuGraphicsContext: () => GpuGraphicsContext,
  GpuMeshAdapter: () => GpuMeshAdapter,
  GpuMipmapGenerator: () => GpuMipmapGenerator,
  GpuParticleContainerAdaptor: () => GpuParticleContainerAdaptor,
  GpuParticleContainerPipe: () => GpuParticleContainerPipe,
  GpuProgram: () => GpuProgram,
  GpuReadBuffer: () => GpuReadBuffer,
  GpuRenderTarget: () => GpuRenderTarget,
  GpuRenderTargetAdaptor: () => GpuRenderTargetAdaptor,
  GpuRenderTargetSystem: () => GpuRenderTargetSystem,
  GpuShaderSystem: () => GpuShaderSystem,
  GpuStateSystem: () => GpuStateSystem,
  GpuStencilModesToPixi: () => GpuStencilModesToPixi,
  GpuStencilSystem: () => GpuStencilSystem,
  GpuTextureSystem: () => GpuTextureSystem,
  GpuUboSystem: () => GpuUboSystem,
  GpuUniformBatchPipe: () => GpuUniformBatchPipe,
  Graphics: () => Graphics,
  GraphicsContext: () => GraphicsContext,
  GraphicsContextRenderData: () => GraphicsContextRenderData,
  GraphicsContextSystem: () => GraphicsContextSystem,
  GraphicsPath: () => GraphicsPath,
  GraphicsPipe: () => GraphicsPipe,
  HTMLText: () => HTMLText,
  HTMLTextPipe: () => HTMLTextPipe,
  HTMLTextRenderData: () => HTMLTextRenderData,
  HTMLTextStyle: () => HTMLTextStyle,
  HTMLTextSystem: () => HTMLTextSystem,
  HardLightBlend: () => HardLightBlend,
  HardMixBlend: () => HardMixBlend,
  HelloSystem: () => HelloSystem,
  IGLUniformData: () => IGLUniformData,
  ImageSource: () => ImageSource,
  InstructionSet: () => InstructionSet,
  KTX: () => KTX,
  LightenBlend: () => LightenBlend,
  LinearBurnBlend: () => LinearBurnBlend,
  LinearDodgeBlend: () => LinearDodgeBlend,
  LinearLightBlend: () => LinearLightBlend,
  Loader: () => Loader,
  LoaderParserPriority: () => LoaderParserPriority,
  LuminosityBlend: () => LuminosityBlend,
  MSAA_QUALITY: () => MSAA_QUALITY,
  MaskEffectManager: () => MaskEffectManager,
  MaskEffectManagerClass: () => MaskEffectManagerClass,
  MaskFilter: () => MaskFilter,
  Matrix: () => Matrix,
  Mesh: () => Mesh,
  MeshGeometry: () => MeshGeometry,
  MeshPipe: () => MeshPipe,
  MeshPlane: () => MeshPlane,
  MeshRope: () => MeshRope,
  MeshSimple: () => MeshSimple,
  NOOP: () => NOOP,
  NegationBlend: () => NegationBlend,
  NineSliceGeometry: () => NineSliceGeometry,
  NineSlicePlane: () => NineSlicePlane,
  NineSliceSprite: () => NineSliceSprite,
  NineSliceSpritePipe: () => NineSliceSpritePipe,
  NoiseFilter: () => NoiseFilter,
  ObservablePoint: () => ObservablePoint,
  OverlayBlend: () => OverlayBlend,
  PI_2: () => PI_2,
  Particle: () => Particle,
  ParticleBuffer: () => ParticleBuffer,
  ParticleContainer: () => ParticleContainer,
  ParticleContainerPipe: () => ParticleContainerPipe,
  ParticleShader: () => ParticleShader,
  PerspectiveMesh: () => PerspectiveMesh,
  PerspectivePlaneGeometry: () => PerspectivePlaneGeometry,
  PinLightBlend: () => PinLightBlend,
  PipelineSystem: () => PipelineSystem,
  PlaneGeometry: () => PlaneGeometry,
  Point: () => Point,
  Polygon: () => Polygon,
  Pool: () => Pool,
  PoolGroupClass: () => PoolGroupClass,
  PrepareBase: () => PrepareBase,
  PrepareQueue: () => PrepareQueue,
  PrepareSystem: () => PrepareSystem,
  PrepareUpload: () => PrepareUpload,
  QuadGeometry: () => QuadGeometry,
  RAD_TO_DEG: () => RAD_TO_DEG,
  Rectangle: () => Rectangle,
  RenderContainer: () => RenderContainer,
  RenderGroup: () => RenderGroup,
  RenderGroupPipe: () => RenderGroupPipe,
  RenderGroupSystem: () => RenderGroupSystem,
  RenderLayer: () => RenderLayer,
  RenderLayerClass: () => RenderLayerClass,
  RenderTarget: () => RenderTarget,
  RenderTargetSystem: () => RenderTargetSystem,
  RenderTexture: () => RenderTexture,
  RenderableGCSystem: () => RenderableGCSystem,
  RendererInitHook: () => RendererInitHook,
  RendererType: () => RendererType,
  ResizePlugin: () => ResizePlugin,
  Resolver: () => Resolver,
  RopeGeometry: () => RopeGeometry,
  RoundedRectangle: () => RoundedRectangle,
  SCALE_MODES: () => SCALE_MODES,
  STENCIL_MODES: () => STENCIL_MODES,
  SVGParser: () => SVGParser,
  SaturationBlend: () => SaturationBlend,
  SchedulerSystem: () => SchedulerSystem,
  ScissorMask: () => ScissorMask,
  SdfShader: () => SdfShader,
  Shader: () => Shader,
  ShaderStage: () => ShaderStage,
  ShapePath: () => ShapePath,
  SharedRenderPipes: () => SharedRenderPipes,
  SharedSystems: () => SharedSystems,
  SoftLightBlend: () => SoftLightBlend,
  Sprite: () => Sprite,
  SpritePipe: () => SpritePipe,
  Spritesheet: () => Spritesheet,
  State: () => State,
  StencilMask: () => StencilMask,
  StencilMaskPipe: () => StencilMaskPipe,
  SubtractBlend: () => SubtractBlend,
  SystemRunner: () => SystemRunner,
  TEXTURE_FORMAT_BLOCK_SIZE: () => TEXTURE_FORMAT_BLOCK_SIZE,
  Text: () => Text,
  TextStyle: () => TextStyle,
  Texture: () => Texture,
  TextureGCSystem: () => TextureGCSystem,
  TextureMatrix: () => TextureMatrix,
  TexturePool: () => TexturePool,
  TexturePoolClass: () => TexturePoolClass,
  TextureSource: () => TextureSource,
  TextureStyle: () => TextureStyle,
  TextureUvs: () => TextureUvs,
  Ticker: () => Ticker,
  TickerListener: () => TickerListener,
  TickerPlugin: () => TickerPlugin,
  TilingSprite: () => TilingSprite,
  TilingSpritePipe: () => TilingSpritePipe,
  TilingSpriteShader: () => TilingSpriteShader,
  Transform: () => Transform,
  Triangle: () => Triangle,
  UNIFORM_TO_ARRAY_SETTERS: () => UNIFORM_TO_ARRAY_SETTERS,
  UNIFORM_TO_SINGLE_SETTERS: () => UNIFORM_TO_SINGLE_SETTERS,
  UNIFORM_TYPES_MAP: () => UNIFORM_TYPES_MAP,
  UNIFORM_TYPES_VALUES: () => UNIFORM_TYPES_VALUES,
  UPDATE_BLEND: () => UPDATE_BLEND,
  UPDATE_COLOR: () => UPDATE_COLOR,
  UPDATE_PRIORITY: () => UPDATE_PRIORITY,
  UPDATE_TRANSFORM: () => UPDATE_TRANSFORM,
  UPDATE_VISIBLE: () => UPDATE_VISIBLE,
  UboBatch: () => UboBatch,
  UboSystem: () => UboSystem,
  UniformGroup: () => UniformGroup,
  VERSION: () => VERSION,
  VideoSource: () => VideoSource,
  ViewContainer: () => ViewContainer,
  ViewSystem: () => ViewSystem,
  ViewableBuffer: () => ViewableBuffer,
  VividLightBlend: () => VividLightBlend,
  WGSL_ALIGN_SIZE_DATA: () => WGSL_ALIGN_SIZE_DATA,
  WGSL_TO_STD40_SIZE: () => WGSL_TO_STD40_SIZE,
  WRAP_MODES: () => WRAP_MODES,
  WebGLRenderer: () => WebGLRenderer,
  WebGPURenderer: () => WebGPURenderer,
  WebWorkerAdapter: () => WebWorkerAdapter,
  WorkerManager: () => WorkerManager,
  _getGlobalBounds: () => _getGlobalBounds,
  accessibilityTarget: () => accessibilityTarget,
  addBits: () => addBits,
  addMaskBounds: () => addMaskBounds,
  addMaskLocalBounds: () => addMaskLocalBounds,
  addProgramDefines: () => addProgramDefines,
  alphaFrag: () => fragment3,
  alphaWgsl: () => source2,
  applyMatrix: () => applyMatrix,
  applyProjectiveTransformationToPlane: () => applyProjectiveTransformationToPlane,
  applyStyleParams: () => applyStyleParams,
  assignWithIgnore: () => assignWithIgnore,
  autoDetectEnvironment: () => autoDetectEnvironment,
  autoDetectRenderer: () => autoDetectRenderer,
  autoDetectSource: () => autoDetectSource,
  basisTranscoderUrls: () => basisTranscoderUrls,
  bgr2rgb: () => bgr2rgb,
  bitmapFontCachePlugin: () => bitmapFontCachePlugin,
  bitmapFontTextParser: () => bitmapFontTextParser,
  bitmapFontXMLParser: () => bitmapFontXMLParser,
  bitmapFontXMLStringParser: () => bitmapFontXMLStringParser,
  blendTemplateFrag: () => blendTemplateFrag,
  blendTemplateVert: () => blendTemplateVert,
  blendTemplateWgsl: () => blendTemplate,
  blockDataMap: () => blockDataMap,
  blurTemplateWgsl: () => source3,
  boundsPool: () => boundsPool,
  browserExt: () => browserExt,
  buildAdaptiveBezier: () => buildAdaptiveBezier,
  buildAdaptiveQuadratic: () => buildAdaptiveQuadratic,
  buildArc: () => buildArc,
  buildArcTo: () => buildArcTo,
  buildArcToSvg: () => buildArcToSvg,
  buildCircle: () => buildCircle,
  buildContextBatches: () => buildContextBatches,
  buildEllipse: () => buildEllipse,
  buildGeometryFromPath: () => buildGeometryFromPath,
  buildLine: () => buildLine,
  buildPixelLine: () => buildPixelLine,
  buildPolygon: () => buildPolygon,
  buildRectangle: () => buildRectangle,
  buildRoundedRectangle: () => buildRoundedRectangle,
  buildSimpleUvs: () => buildSimpleUvs,
  buildTriangle: () => buildTriangle,
  buildUvs: () => buildUvs,
  cacheAsTextureMixin: () => cacheAsTextureMixin,
  cacheTextureArray: () => cacheTextureArray,
  calculateProjection: () => calculateProjection,
  checkChildrenDidChange: () => checkChildrenDidChange,
  checkDataUrl: () => checkDataUrl,
  checkExtension: () => checkExtension,
  checkMaxIfStatementsInShader: () => checkMaxIfStatementsInShader,
  childrenHelperMixin: () => childrenHelperMixin,
  cleanArray: () => cleanArray,
  cleanHash: () => cleanHash,
  clearList: () => clearList,
  closePointEps: () => closePointEps,
  collectAllRenderables: () => collectAllRenderables,
  collectRenderablesMixin: () => collectRenderablesMixin,
  color32BitToUniform: () => color32BitToUniform,
  colorBit: () => colorBit,
  colorBitGl: () => colorBitGl,
  colorMatrixFilterFrag: () => fragment4,
  colorMatrixFilterWgsl: () => source4,
  colorToUniform: () => colorToUniform,
  compareModeToGlCompare: () => compareModeToGlCompare,
  compileHighShader: () => compileHighShader,
  compileHighShaderGl: () => compileHighShaderGl,
  compileHighShaderGlProgram: () => compileHighShaderGlProgram,
  compileHighShaderGpuProgram: () => compileHighShaderGpuProgram,
  compileHooks: () => compileHooks,
  compileInputs: () => compileInputs,
  compileOutputs: () => compileOutputs,
  compileShader: () => compileShader,
  compute2DProjection: () => compute2DProjection,
  convertFormatIfRequired: () => convertFormatIfRequired,
  convertToList: () => convertToList,
  copySearchParams: () => copySearchParams,
  createIdFromString: () => createIdFromString,
  createIndicesForQuads: () => createIndicesForQuads,
  createLevelBuffers: () => createLevelBuffers,
  createLevelBuffersFromKTX: () => createLevelBuffersFromKTX,
  createStringVariations: () => createStringVariations,
  createTexture: () => createTexture,
  createUboElementsSTD40: () => createUboElementsSTD40,
  createUboElementsWGSL: () => createUboElementsWGSL,
  createUboSyncFunction: () => createUboSyncFunction,
  createUboSyncFunctionSTD40: () => createUboSyncFunctionSTD40,
  createUboSyncFunctionWGSL: () => createUboSyncFunctionWGSL,
  crossOrigin: () => crossOrigin,
  cullingMixin: () => cullingMixin,
  curveEps: () => curveEps,
  defaultFilterVert: () => vertex3,
  defaultValue: () => defaultValue,
  definedProps: () => definedProps,
  deprecation: () => deprecation,
  detectAvif: () => detectAvif,
  detectBasis: () => detectBasis,
  detectCompressed: () => detectCompressed,
  detectDefaults: () => detectDefaults,
  detectMp4: () => detectMp4,
  detectOgv: () => detectOgv,
  detectVideoAlphaMode: () => detectVideoAlphaMode,
  detectWebm: () => detectWebm,
  detectWebp: () => detectWebp,
  determineCrossOrigin: () => determineCrossOrigin,
  displacementFrag: () => fragment5,
  displacementVert: () => vertex4,
  displacementWgsl: () => source5,
  earcut: () => import_earcut2.default,
  effectsMixin: () => effectsMixin,
  ensureAttributes: () => ensureAttributes,
  ensureIsBuffer: () => ensureIsBuffer,
  ensurePrecision: () => ensurePrecision,
  ensureTextOptions: () => ensureTextOptions,
  ensureTextStyle: () => ensureTextStyle,
  executeInstructions: () => executeInstructions,
  extensions: () => extensions,
  extractAttributesFromGlProgram: () => extractAttributesFromGlProgram,
  extractAttributesFromGpuProgram: () => extractAttributesFromGpuProgram,
  extractFontFamilies: () => extractFontFamilies,
  extractStructAndGroups: () => extractStructAndGroups,
  extractSvgUrlId: () => extractSvgUrlId,
  fastCopy: () => fastCopy,
  findHooksRx: () => findHooksRx,
  findMixin: () => findMixin,
  fontStringFromTextStyle: () => fontStringFromTextStyle,
  formatShader: () => formatShader,
  fragmentGPUTemplate: () => fragmentGPUTemplate,
  fragmentGlTemplate: () => fragmentGlTemplate,
  generateArraySyncSTD40: () => generateArraySyncSTD40,
  generateArraySyncWGSL: () => generateArraySyncWGSL,
  generateBlurFragSource: () => generateBlurFragSource,
  generateBlurGlProgram: () => generateBlurGlProgram,
  generateBlurProgram: () => generateBlurProgram,
  generateBlurVertSource: () => generateBlurVertSource,
  generateGPULayout: () => generateGPULayout,
  generateGpuLayoutGroups: () => generateGpuLayoutGroups,
  generateLayout: () => generateLayout,
  generateLayoutHash: () => generateLayoutHash,
  generateParticleUpdateFunction: () => generateParticleUpdateFunction,
  generateProgram: () => generateProgram,
  generateShaderSyncCode: () => generateShaderSyncCode,
  generateTextStyleKey: () => generateTextStyleKey,
  generateTextureBatchBit: () => generateTextureBatchBit,
  generateTextureBatchBitGl: () => generateTextureBatchBitGl,
  generateTextureMatrix: () => generateTextureMatrix,
  generateUID: () => generateUID,
  generateUniformsSync: () => generateUniformsSync,
  getAdjustedBlendModeBlend: () => getAdjustedBlendModeBlend,
  getAttributeInfoFromFormat: () => getAttributeInfoFromFormat,
  getBatchSamplersUniformGroup: () => getBatchSamplersUniformGroup,
  getBitmapTextLayout: () => getBitmapTextLayout,
  getCanvasBoundingBox: () => getCanvasBoundingBox,
  getCanvasFillStyle: () => getCanvasFillStyle,
  getCanvasTexture: () => getCanvasTexture,
  getDefaultUniformValue: () => getDefaultUniformValue,
  getFastGlobalBounds: () => getFastGlobalBounds,
  getFastGlobalBoundsMixin: () => getFastGlobalBoundsMixin,
  getFontCss: () => getFontCss,
  getFontFamilyName: () => getFontFamilyName,
  getGeometryBounds: () => getGeometryBounds,
  getGlTypeFromFormat: () => getGlTypeFromFormat,
  getGlobalBounds: () => getGlobalBounds,
  getGlobalMixin: () => getGlobalMixin,
  getGlobalRenderableBounds: () => getGlobalRenderableBounds,
  getLocalBounds: () => getLocalBounds,
  getMatrixRelativeToParent: () => getMatrixRelativeToParent,
  getMaxFragmentPrecision: () => getMaxFragmentPrecision,
  getMaxTexturesPerBatch: () => getMaxTexturesPerBatch,
  getOrientationOfPoints: () => getOrientationOfPoints,
  getParent: () => getParent,
  getPo2TextureFromSource: () => getPo2TextureFromSource,
  getResolutionOfUrl: () => getResolutionOfUrl,
  getSVGUrl: () => getSVGUrl,
  getSupportedCompressedTextureFormats: () => getSupportedCompressedTextureFormats,
  getSupportedGPUCompressedTextureFormats: () => getSupportedGPUCompressedTextureFormats,
  getSupportedGlCompressedTextureFormats: () => getSupportedGlCompressedTextureFormats,
  getSupportedTextureFormats: () => getSupportedTextureFormats,
  getTemporaryCanvasFromImage: () => getTemporaryCanvasFromImage,
  getTestContext: () => getTestContext,
  getTextureBatchBindGroup: () => getTextureBatchBindGroup,
  getTextureDefaultMatrix: () => getTextureDefaultMatrix,
  getTextureFormatFromKTXTexture: () => getTextureFormatFromKTXTexture,
  getUboData: () => getUboData,
  getUniformData: () => getUniformData,
  getUrlExtension: () => getUrlExtension,
  glFormatToGPUFormat: () => glFormatToGPUFormat,
  glUploadBufferImageResource: () => glUploadBufferImageResource,
  glUploadCompressedTextureResource: () => glUploadCompressedTextureResource,
  glUploadImageResource: () => glUploadImageResource,
  glUploadVideoResource: () => glUploadVideoResource,
  globalUniformsBit: () => globalUniformsBit,
  globalUniformsBitGl: () => globalUniformsBitGl,
  globalUniformsUBOBitGl: () => globalUniformsUBOBitGl,
  gpuFormatToBasisTranscoderFormat: () => gpuFormatToBasisTranscoderFormat,
  gpuFormatToKTXBasisTranscoderFormat: () => gpuFormatToKTXBasisTranscoderFormat,
  gpuUploadBufferImageResource: () => gpuUploadBufferImageResource,
  gpuUploadCompressedTextureResource: () => gpuUploadCompressedTextureResource,
  gpuUploadImageResource: () => gpuUploadImageResource,
  gpuUploadVideoResource: () => gpuUploadVideoResource,
  groupD8: () => groupD8,
  hasCachedCanvasTexture: () => hasCachedCanvasTexture,
  hslWgsl: () => hsl,
  hslgl: () => hslgl,
  hslgpu: () => hslgpu,
  injectBits: () => injectBits,
  insertVersion: () => insertVersion,
  isMobile: () => isMobile2,
  isPow2: () => isPow2,
  isRenderingToScreen: () => isRenderingToScreen,
  isSafari: () => isSafari,
  isSingleItem: () => isSingleItem,
  isWebGLSupported: () => isWebGLSupported,
  isWebGPUSupported: () => isWebGPUSupported,
  ktxTranscoderUrls: () => ktxTranscoderUrls,
  loadBasis: () => loadBasis,
  loadBasisOnWorker: () => loadBasisOnWorker,
  loadBitmapFont: () => loadBitmapFont,
  loadDDS: () => loadDDS,
  loadEnvironmentExtensions: () => loadEnvironmentExtensions,
  loadFontAsBase64: () => loadFontAsBase64,
  loadFontCSS: () => loadFontCSS,
  loadImageBitmap: () => loadImageBitmap,
  loadJson: () => loadJson,
  loadKTX: () => loadKTX,
  loadKTX2: () => loadKTX2,
  loadKTX2onWorker: () => loadKTX2onWorker,
  loadSVGImage: () => loadSVGImage,
  loadSvg: () => loadSvg,
  loadTextures: () => loadTextures,
  loadTxt: () => loadTxt,
  loadVideoTextures: () => loadVideoTextures,
  loadWebFont: () => loadWebFont,
  localUniformBit: () => localUniformBit,
  localUniformBitGl: () => localUniformBitGl,
  localUniformBitGroup2: () => localUniformBitGroup2,
  localUniformMSDFBit: () => localUniformMSDFBit,
  localUniformMSDFBitGl: () => localUniformMSDFBitGl,
  log2: () => log2,
  logDebugTexture: () => logDebugTexture,
  logProgramError: () => logProgramError,
  logRenderGroupScene: () => logRenderGroupScene,
  logScene: () => logScene,
  mSDFBit: () => mSDFBit,
  mSDFBitGl: () => mSDFBitGl,
  mapFormatToGlFormat: () => mapFormatToGlFormat,
  mapFormatToGlInternalFormat: () => mapFormatToGlInternalFormat,
  mapFormatToGlType: () => mapFormatToGlType,
  mapGlToVertexFormat: () => mapGlToVertexFormat,
  mapSize: () => mapSize,
  mapType: () => mapType,
  mapWebGLBlendModesToPixi: () => mapWebGLBlendModesToPixi,
  maskFrag: () => fragment2,
  maskVert: () => vertex2,
  maskWgsl: () => source,
  matrixPool: () => matrixPool,
  measureHtmlText: () => measureHtmlText,
  measureMixin: () => measureMixin,
  migrateFragmentFromV7toV8: () => migrateFragmentFromV7toV8,
  mipmapScaleModeToGlFilter: () => mipmapScaleModeToGlFilter,
  mixHexColors: () => mixHexColors,
  multiplyColors: () => multiplyColors,
  multiplyHexColors: () => multiplyHexColors,
  nextPow2: () => nextPow2,
  noiseFrag: () => fragment6,
  noiseWgsl: () => source6,
  nonCompressedFormats: () => nonCompressedFormats,
  normalizeExtensionPriority: () => normalizeExtensionPriority,
  nssvg: () => nssvg,
  nsxhtml: () => nsxhtml,
  onRenderMixin: () => onRenderMixin,
  parseAttribute: () => parseAttribute,
  parseDDS: () => parseDDS,
  parseFunctionBody: () => parseFunctionBody,
  parseKTX: () => parseKTX,
  parseSVGDefinitions: () => parseSVGDefinitions,
  parseSVGFloatAttribute: () => parseSVGFloatAttribute,
  parseSVGPath: () => parseSVGPath,
  parseSVGStyle: () => parseSVGStyle,
  particleData: () => particleData,
  particlesFrag: () => fragment,
  particlesVert: () => vertex,
  particlesWgsl: () => wgsl,
  path: () => path,
  pointInTriangle: () => pointInTriangle,
  preloadVideo: () => preloadVideo,
  removeItems: () => removeItems,
  removeStructAndGroupDuplicates: () => removeStructAndGroupDuplicates,
  resetUids: () => resetUids,
  resolveCharacters: () => resolveCharacters,
  resolveCompressedTextureUrl: () => resolveCompressedTextureUrl,
  resolveJsonUrl: () => resolveJsonUrl,
  resolveTextureUrl: () => resolveTextureUrl,
  resourceToTexture: () => resourceToTexture,
  roundPixelsBit: () => roundPixelsBit,
  roundPixelsBitGl: () => roundPixelsBitGl,
  roundedShapeArc: () => roundedShapeArc,
  roundedShapeQuadraticCurve: () => roundedShapeQuadraticCurve,
  sayHello: () => sayHello,
  scaleModeToGlFilter: () => scaleModeToGlFilter,
  setBasisTranscoderPath: () => setBasisTranscoderPath,
  setKTXTranscoderPath: () => setKTXTranscoderPath,
  setPositions: () => setPositions,
  setProgramName: () => setProgramName,
  setUvs: () => setUvs,
  shapeBuilders: () => shapeBuilders,
  sortMixin: () => sortMixin,
  spritesheetAsset: () => spritesheetAsset,
  squaredDistanceToLineSegment: () => squaredDistanceToLineSegment,
  stripVersion: () => stripVersion,
  styleAttributes: () => styleAttributes,
  testImageFormat: () => testImageFormat,
  testVideoFormat: () => testVideoFormat,
  textStyleToCSS: () => textStyleToCSS,
  textureBit: () => textureBit,
  textureBitGl: () => textureBitGl,
  textureFrom: () => textureFrom,
  tilingBit: () => tilingBit,
  tilingBitGl: () => tilingBitGl,
  toFillStyle: () => toFillStyle,
  toLocalGlobalMixin: () => toLocalGlobalMixin,
  toStrokeStyle: () => toStrokeStyle,
  transformVertices: () => transformVertices,
  triangulateWithHoles: () => triangulateWithHoles,
  uboSyncFunctionsSTD40: () => uboSyncFunctionsSTD40,
  uboSyncFunctionsWGSL: () => uboSyncFunctionsWGSL,
  uid: () => uid,
  uniformParsers: () => uniformParsers,
  unpremultiplyAlpha: () => unpremultiplyAlpha2,
  unsafeEvalSupported: () => unsafeEvalSupported,
  updateLocalTransform: () => updateLocalTransform,
  updateQuadBounds: () => updateQuadBounds,
  updateRenderGroupTransform: () => updateRenderGroupTransform,
  updateRenderGroupTransforms: () => updateRenderGroupTransforms,
  updateTextBounds: () => updateTextBounds,
  updateTransformAndChildren: () => updateTransformAndChildren,
  updateTransformBackwards: () => updateTransformBackwards,
  updateWorldTransform: () => updateWorldTransform,
  v8_0_0: () => v8_0_0,
  v8_3_4: () => v8_3_4,
  validFormats: () => validFormats,
  validateRenderables: () => validateRenderables,
  vertexGPUTemplate: () => vertexGPUTemplate,
  vertexGlTemplate: () => vertexGlTemplate,
  viewportFromFrame: () => viewportFromFrame,
  vkFormatToGPUFormat: () => vkFormatToGPUFormat,
  warn: () => warn,
  webworkerExt: () => webworkerExt,
  wrapModeToGlAddress: () => wrapModeToGlAddress
});
var import_earcut2;
var init_lib = __esm({
  "node_modules/pixi.js/lib/index.mjs"() {
    init_define_AnParams();
    init_browserExt();
    init_webworkerExt();
    init_Extensions();
    init_Extensions();
    init_init6();
    init_init5();
    init_AccessibilitySystem();
    init_accessibilityTarget();
    init_ColorBlend();
    init_ColorBurnBlend();
    init_ColorDodgeBlend();
    init_DarkenBlend();
    init_DifferenceBlend();
    init_DivideBlend();
    init_ExclusionBlend();
    init_HardLightBlend();
    init_HardMixBlend();
    init_LightenBlend();
    init_LinearBurnBlend();
    init_LinearDodgeBlend();
    init_LinearLightBlend();
    init_LuminosityBlend();
    init_NegationBlend();
    init_OverlayBlend();
    init_PinLightBlend();
    init_SaturationBlend();
    init_SoftLightBlend();
    init_SubtractBlend();
    init_VividLightBlend();
    init_Application();
    init_ResizePlugin();
    init_TickerPlugin();
    init_Assets();
    init_BackgroundLoader();
    init_Cache();
    init_cacheTextureArray();
    init_detectAvif();
    init_detectDefaults();
    init_detectMp4();
    init_detectOgv();
    init_detectWebm();
    init_detectWebp();
    init_testImageFormat();
    init_testVideoFormat();
    init_Loader();
    init_LoaderParser();
    init_loadJson();
    init_loadTxt();
    init_loadWebFont();
    init_loadSVG();
    init_loadTextures();
    init_loadVideoTextures();
    init_createTexture();
    init_WorkerManager();
    init_resolveJsonUrl();
    init_resolveTextureUrl();
    init_Resolver();
    init_checkDataUrl();
    init_checkExtension();
    init_convertToList();
    init_copySearchParams();
    init_createStringVariations();
    init_isSingleItem();
    init_Color();
    init_detectBasis();
    init_loadBasis();
    init_createLevelBuffers();
    init_gpuFormatToBasisTranscoderFormat();
    init_setBasisTranscoderPath();
    init_loadBasisOnWorker();
    init_const11();
    init_loadDDS();
    init_parseDDS();
    init_loadKTX();
    init_parseKTX();
    init_const12();
    init_loadKTX2();
    init_convertFormatIfRequired();
    init_createLevelBuffersFromKTX();
    init_getTextureFormatFromKTXTexture();
    init_glFormatToGPUFormat();
    init_gpuFormatToKTXBasisTranscoderFormat();
    init_setKTXTranscoderPath();
    init_vkFormatToGPUFormat();
    init_loadKTX2onWorker();
    init_detectCompressed();
    init_resolveCompressedTextureUrl();
    init_Culler();
    init_CullerPlugin();
    init_cullingMixin();
    init_DOMContainer();
    init_DOMPipe();
    init_adapter();
    init_autoDetectEnvironment();
    init_BrowserAdapter();
    init_WebWorkerAdapter();
    init_EventBoundary();
    init_EventSystem();
    init_EventTicker();
    init_FederatedEvent();
    init_FederatedEventTarget();
    init_FederatedMouseEvent();
    init_FederatedPointerEvent();
    init_FederatedWheelEvent();
    init_blend_template_frag();
    init_blend_template_vert();
    init_blend_template_wgsl();
    init_hsl_wgsl();
    init_alpha_frag();
    init_alpha_wgsl();
    init_blur_template_wgsl();
    init_colorMatrixFilter_frag();
    init_colorMatrixFilter_wgsl();
    init_defaultFilter_vert();
    init_displacement_frag();
    init_displacement_vert();
    init_displacement_wgsl();
    init_noise_frag();
    init_noise_wgsl();
    init_mask_frag();
    init_mask_vert();
    init_mask_wgsl();
    init_BlendModeFilter();
    init_GLhls();
    init_GPUhls();
    init_AlphaFilter();
    init_BlurFilter();
    init_BlurFilterPass();
    init_const13();
    init_generateBlurFragSource();
    init_generateBlurGlProgram();
    init_generateBlurVertSource();
    init_generateBlurProgram();
    init_ColorMatrixFilter();
    init_DisplacementFilter();
    init_NoiseFilter();
    init_Filter();
    init_FilterEffect();
    init_FilterPipe();
    init_FilterSystem();
    init_MaskFilter();
    init_groupD8();
    init_Matrix();
    init_const();
    init_pow2();
    init_squaredDistanceToLineSegment();
    init_ObservablePoint();
    init_Point();
    init_pointInTriangle();
    init_Circle();
    init_Ellipse();
    init_Polygon();
    init_Rectangle();
    init_RoundedRectangle();
    init_Triangle();
    init_PrepareBase();
    init_PrepareQueue();
    init_PrepareSystem();
    init_PrepareUpload();
    init_GlBatchAdaptor();
    init_checkMaxIfStatementsInShader();
    init_maxRecommendedTextures();
    init_generateGPULayout();
    init_generateLayout();
    init_getTextureBatchBindGroup();
    init_GpuBatchAdaptor();
    init_Batcher();
    init_BatcherPipe();
    init_BatchGeometry();
    init_BatchTextureArray();
    init_DefaultBatcher();
    init_DefaultShader();
    init_compileHighShaderToProgram();
    init_compileHighShader();
    init_addBits();
    init_compileHooks();
    init_compileInputs();
    init_compileOutputs();
    init_formatShader();
    init_injectBits();
    init_defaultProgramTemplate();
    init_colorBit();
    init_generateTextureBatchBit();
    init_globalUniformsBit();
    init_localUniformBit();
    init_roundPixelsBit();
    init_textureBit();
    init_AlphaMask();
    init_AlphaMaskPipe();
    init_ColorMask();
    init_ColorMaskPipe();
    init_MaskEffectManager();
    init_ScissorMask();
    init_StencilMask();
    init_StencilMaskPipe();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    init_autoDetectRenderer();
    init_const9();
    init_GlBuffer();
    init_GlBufferSystem();
    init_const7();
    init_GlContextSystem();
    init_GlGeometrySystem();
    init_getGlTypeFromFormat();
    init_GlBackBufferSystem();
    init_GlColorMaskSystem();
    init_GlEncoderSystem();
    init_GlRenderTarget();
    init_GlStencilSystem();
    init_GlUboSystem();
    init_GlRenderTargetAdaptor();
    init_GlRenderTargetSystem();
    init_GenerateShaderSyncCode();
    init_getBatchSamplersUniformGroup();
    init_GlProgram();
    init_GlProgramData();
    init_GlShaderSystem();
    init_GlUniformGroupSystem();
    init_migrateFragmentFromV7toV8();
    init_compileShader();
    init_defaultValue();
    init_ensureAttributes();
    init_extractAttributesFromGlProgram();
    init_generateProgram();
    init_getMaxFragmentPrecision();
    init_getTestContext();
    init_getUboData();
    init_getUniformData();
    init_logProgramError();
    init_mapSize();
    init_mapType();
    init_addProgramDefines();
    init_ensurePrecision();
    init_insertVersion();
    init_setProgramName();
    init_stripVersion();
    init_createUboElementsSTD40();
    init_createUboSyncSTD40();
    init_generateArraySyncSTD40();
    init_generateUniformsSync();
    init_generateUniformsSyncTypes();
    init_GlStateSystem();
    init_mapWebGLBlendModesToPixi();
    init_const10();
    init_GlTexture();
    init_GlTextureSystem();
    init_glUploadBufferImageResource();
    init_glUploadCompressedTextureResource();
    init_glUploadImageResource();
    init_glUploadVideoResource();
    init_applyStyleParams();
    init_getSupportedGlCompressedTextureFormats();
    init_mapFormatToGlFormat();
    init_mapFormatToGlInternalFormat();
    init_mapFormatToGlType();
    init_pixiToGlMaps();
    init_unpremultiplyAlpha();
    init_WebGLRenderer();
    init_BindGroupSystem();
    init_GpuBufferSystem();
    init_GpuReadBuffer();
    init_UboBatch();
    init_GpuColorMaskSystem();
    init_GpuDeviceSystem();
    init_GpuEncoderSystem();
    init_GpuStencilSystem();
    init_GpuUboSystem();
    init_GpuUniformBatchPipe();
    init_PipelineSystem();
    init_calculateProjection();
    init_GpuRenderTarget();
    init_GpuRenderTargetAdaptor();
    init_GpuRenderTargetSystem();
    init_BindGroup();
    init_GpuProgram();
    init_GpuShaderSystem();
    init_createUboElementsWGSL();
    init_createUboSyncFunctionWGSL();
    init_extractAttributesFromGpuProgram();
    init_extractStructAndGroups();
    init_generateArraySyncWGSL();
    init_generateGpuLayoutGroups();
    init_generateLayoutHash();
    init_removeStructAndGroupDuplicates();
    init_GpuBlendModesToPixi();
    init_GpuStateSystem();
    init_GpuStencilModesToPixi();
    init_GpuTextureSystem();
    init_gpuUploadBufferImageResource();
    init_gpuUploadCompressedTextureResource();
    init_gpuUploadImageSource();
    init_gpuUploadVideoSource();
    init_getSupportedGPUCompressedTextureFormats();
    init_GpuMipmapGenerator();
    init_WebGPURenderer();
    init_BackgroundSystem();
    init_BlendModePipe();
    init_Buffer();
    init_BufferResource();
    init_const4();
    init_fastCopy();
    init_ExtractSystem();
    init_GenerateTextureSystem();
    init_const14();
    init_Geometry();
    init_buildUvs();
    init_ensureIsBuffer();
    init_getAttributeInfoFromFormat();
    init_getGeometryBounds();
    init_transformVertices();
    init_InstructionSet();
    init_GlobalUniformSystem();
    init_isRenderingToScreen();
    init_RenderTarget();
    init_RenderTargetSystem();
    init_viewportFromFrame();
    init_SchedulerSystem();
    init_const5();
    init_Shader();
    init_types();
    init_UboSystem();
    init_UniformGroup();
    init_createUboSyncFunction();
    init_getDefaultUniformValue();
    init_uboSyncFunctions();
    init_uniformParsers();
    init_HelloSystem();
    init_const3();
    init_getAdjustedBlendModeBlend();
    init_State();
    init_AbstractRenderer();
    init_SharedSystems();
    init_SystemRunner();
    init_CanvasPool();
    init_const15();
    init_RenderableGCSystem();
    init_RenderTexture();
    init_BufferImageSource();
    init_CanvasSource();
    init_CompressedSource();
    init_ImageSource();
    init_TextureSource();
    init_VideoSource();
    init_Texture();
    init_TextureGCSystem();
    init_TextureMatrix();
    init_TexturePool();
    init_TextureStyle();
    init_TextureUvs();
    init_generateUID();
    init_getCanvasTexture();
    init_getSupportedCompressedTextureFormats();
    init_getSupportedTextureFormats();
    init_textureFrom();
    init_createIdFromString();
    init_parseFunctionBody();
    init_ViewSystem();
    init_types2();
    init_particles_frag();
    init_particles_vert();
    init_particles_wgsl();
    init_Bounds();
    init_getFastGlobalBounds();
    init_getGlobalBounds();
    init_getLocalBounds();
    init_getRenderableBounds();
    init_matrixAndBoundsPool();
    init_cacheAsTextureMixin();
    init_childrenHelperMixin();
    init_collectRenderablesMixin();
    init_effectsMixin();
    init_findMixin();
    init_getFastGlobalBoundsMixin();
    init_getGlobalMixin();
    init_measureMixin();
    init_onRenderMixin();
    init_sortMixin();
    init_toLocalGlobalMixin();
    init_Container();
    init_CustomRenderPipe();
    init_RenderContainer();
    init_RenderGroup();
    init_RenderGroupPipe();
    init_RenderGroupSystem();
    init_assignWithIgnore();
    init_checkChildrenDidChange();
    init_clearList();
    init_collectAllRenderables();
    init_definedProps();
    init_executeInstructions();
    init_mixHexColors();
    init_multiplyColors();
    init_multiplyHexColors();
    init_updateLocalTransform();
    init_updateRenderGroupTransforms();
    init_updateWorldTransform();
    init_validateRenderables();
    init_GlGraphicsAdaptor();
    init_colorToUniform();
    init_GpuGraphicsAdaptor();
    init_BatchableGraphics();
    init_buildAdaptiveBezier();
    init_buildAdaptiveQuadratic();
    init_buildArc();
    init_buildArcTo();
    init_buildArcToSvg();
    init_buildCircle();
    init_buildLine();
    init_buildPixelLine();
    init_buildPolygon();
    init_buildRectangle();
    init_buildTriangle();
    init_const6();
    init_FillGradient();
    init_FillPattern();
    init_Graphics();
    init_GraphicsContext();
    init_GraphicsContextSystem();
    init_GraphicsPipe();
    init_GraphicsPath();
    init_roundShape();
    init_ShapePath();
    init_parseSVGDefinitions();
    init_parseSVGFloatAttribute();
    init_parseSVGPath();
    init_parseSVGStyle();
    init_SVGParser();
    init_extractSvgUrlId();
    init_buildContextBatches();
    init_buildGeometryFromPath();
    init_convertFillInputToFillStyle();
    init_generateTextureFillMatrix();
    init_getOrientationOfPoints();
    init_triangulateWithHoles();
    init_RenderLayer();
    init_PerspectiveMesh();
    init_PerspectivePlaneGeometry();
    init_applyProjectiveTransformationToPlane();
    init_compute2DProjections();
    init_MeshPlane();
    init_PlaneGeometry();
    init_MeshRope();
    init_MeshSimple();
    init_RopeGeometry();
    init_GlMeshAdaptor();
    init_GpuMeshAdapter();
    init_BatchableMesh();
    init_getTextureDefaultMatrix();
    init_Mesh();
    init_MeshGeometry();
    init_MeshPipe();
    init_GlParticleContainerAdaptor();
    init_GpuParticleContainerAdaptor();
    init_GlParticleContainerPipe();
    init_GpuParticleContainerPipe();
    init_Particle();
    init_ParticleBuffer();
    init_ParticleContainer();
    init_ParticleContainerPipe();
    init_particleData();
    init_ParticleShader();
    init_createIndicesForQuads();
    init_generateParticleUpdateFunction();
    init_AnimatedSprite();
    init_NineSliceGeometry();
    init_NineSliceSprite();
    init_NineSliceSpritePipe();
    init_tilingBit();
    init_TilingSpriteShader();
    init_TilingSprite();
    init_TilingSpritePipe();
    init_applyMatrix();
    init_QuadGeometry();
    init_setPositions();
    init_setUvs();
    init_BatchableSprite();
    init_Sprite();
    init_SpritePipe();
    init_AbstractBitmapFont();
    init_bitmapFontTextParser();
    init_bitmapFontXMLParser();
    init_bitmapFontXMLStringParser();
    init_loadBitmapFont();
    init_BitmapFont();
    init_BitmapFontManager();
    init_BitmapText();
    init_BitmapTextPipe();
    init_DynamicBitmapFont();
    init_getBitmapTextLayout();
    init_resolveCharacters();
    init_HTMLText();
    init_HTMLTextPipe();
    init_HTMLTextRenderData();
    init_HTMLTextStyle();
    init_HTMLTextSystem();
    init_extractFontFamilies();
    init_getFontCss();
    init_getSVGUrl();
    init_getTemporaryCanvasFromImage();
    init_loadFontAsBase64();
    init_loadFontCSS();
    init_loadSVGImage();
    init_measureHtmlText();
    init_textStyleToCSS();
    init_AbstractText();
    init_CanvasTextMetrics();
    init_CanvasTextPipe();
    init_CanvasTextSystem();
    init_fontStringFromTextStyle();
    init_getCanvasFillStyle();
    init_SdfShader();
    init_localUniformMSDFBit();
    init_mSDFBit();
    init_Text();
    init_TextStyle();
    init_ensureTextStyle();
    init_generateTextStyleKey();
    init_getPo2TextureFromSource();
    init_updateTextBounds();
    init_ViewContainer();
    init_Spritesheet();
    init_spritesheetAsset();
    init_const2();
    init_Ticker();
    init_TickerListener();
    init_detectVideoAlphaMode();
    init_isMobile2();
    init_isSafari();
    init_isWebGLSupported();
    init_isWebGPUSupported();
    init_unsafeEvalSupported();
    init_getCanvasBoundingBox();
    init_const8();
    init_eventemitter3();
    init_clean();
    init_removeItems();
    init_uid();
    init_updateQuadBounds();
    init_ViewableBuffer();
    init_globalHooks();
    init_deprecation();
    init_logDebugTexture();
    init_logScene();
    init_warn();
    init_NOOP();
    init_Transform();
    init_getResolutionOfUrl();
    init_path();
    init_Pool();
    init_PoolGroup();
    init_sayHello();
    import_earcut2 = __toESM(require_earcut(), 1);
    extensions.add(browserExt, webworkerExt);
  }
});

// node_modules/howler/dist/howler.js
var require_howler = __commonJS({
  "node_modules/howler/dist/howler.js"(exports) {
    init_define_AnParams();
    /*!
     *  howler.js v2.2.4
     *  howlerjs.com
     *
     *  (c) 2013-2020, James Simpson of GoldFire Studios
     *  goldfirestudios.com
     *
     *  MIT License
     */
    (function() {
      "use strict";
      var HowlerGlobal2 = function() {
        this.init();
      };
      HowlerGlobal2.prototype = {
        /**
         * Initialize the global Howler object.
         * @return {Howler}
         */
        init: function() {
          var self2 = this || Howler2;
          self2._counter = 1e3;
          self2._html5AudioPool = [];
          self2.html5PoolSize = 10;
          self2._codecs = {};
          self2._howls = [];
          self2._muted = false;
          self2._volume = 1;
          self2._canPlayEvent = "canplaythrough";
          self2._navigator = typeof window !== "undefined" && window.navigator ? window.navigator : null;
          self2.masterGain = null;
          self2.noAudio = false;
          self2.usingWebAudio = true;
          self2.autoSuspend = true;
          self2.ctx = null;
          self2.autoUnlock = true;
          self2._setup();
          return self2;
        },
        /**
         * Get/set the global volume for all sounds.
         * @param  {Float} vol Volume from 0.0 to 1.0.
         * @return {Howler/Float}     Returns self or current volume.
         */
        volume: function(vol) {
          var self2 = this || Howler2;
          vol = parseFloat(vol);
          if (!self2.ctx) {
            setupAudioContext();
          }
          if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
            self2._volume = vol;
            if (self2._muted) {
              return self2;
            }
            if (self2.usingWebAudio) {
              self2.masterGain.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
            }
            for (var i3 = 0; i3 < self2._howls.length; i3++) {
              if (!self2._howls[i3]._webAudio) {
                var ids = self2._howls[i3]._getSoundIds();
                for (var j2 = 0; j2 < ids.length; j2++) {
                  var sound = self2._howls[i3]._soundById(ids[j2]);
                  if (sound && sound._node) {
                    sound._node.volume = sound._volume * vol;
                  }
                }
              }
            }
            return self2;
          }
          return self2._volume;
        },
        /**
         * Handle muting and unmuting globally.
         * @param  {Boolean} muted Is muted or not.
         */
        mute: function(muted) {
          var self2 = this || Howler2;
          if (!self2.ctx) {
            setupAudioContext();
          }
          self2._muted = muted;
          if (self2.usingWebAudio) {
            self2.masterGain.gain.setValueAtTime(muted ? 0 : self2._volume, Howler2.ctx.currentTime);
          }
          for (var i3 = 0; i3 < self2._howls.length; i3++) {
            if (!self2._howls[i3]._webAudio) {
              var ids = self2._howls[i3]._getSoundIds();
              for (var j2 = 0; j2 < ids.length; j2++) {
                var sound = self2._howls[i3]._soundById(ids[j2]);
                if (sound && sound._node) {
                  sound._node.muted = muted ? true : sound._muted;
                }
              }
            }
          }
          return self2;
        },
        /**
         * Handle stopping all sounds globally.
         */
        stop: function() {
          var self2 = this || Howler2;
          for (var i3 = 0; i3 < self2._howls.length; i3++) {
            self2._howls[i3].stop();
          }
          return self2;
        },
        /**
         * Unload and destroy all currently loaded Howl objects.
         * @return {Howler}
         */
        unload: function() {
          var self2 = this || Howler2;
          for (var i3 = self2._howls.length - 1; i3 >= 0; i3--) {
            self2._howls[i3].unload();
          }
          if (self2.usingWebAudio && self2.ctx && typeof self2.ctx.close !== "undefined") {
            self2.ctx.close();
            self2.ctx = null;
            setupAudioContext();
          }
          return self2;
        },
        /**
         * Check for codec support of specific extension.
         * @param  {String} ext Audio file extention.
         * @return {Boolean}
         */
        codecs: function(ext) {
          return (this || Howler2)._codecs[ext.replace(/^x-/, "")];
        },
        /**
         * Setup various state values for global tracking.
         * @return {Howler}
         */
        _setup: function() {
          var self2 = this || Howler2;
          self2.state = self2.ctx ? self2.ctx.state || "suspended" : "suspended";
          self2._autoSuspend();
          if (!self2.usingWebAudio) {
            if (typeof Audio !== "undefined") {
              try {
                var test = new Audio();
                if (typeof test.oncanplaythrough === "undefined") {
                  self2._canPlayEvent = "canplay";
                }
              } catch (e2) {
                self2.noAudio = true;
              }
            } else {
              self2.noAudio = true;
            }
          }
          try {
            var test = new Audio();
            if (test.muted) {
              self2.noAudio = true;
            }
          } catch (e2) {
          }
          if (!self2.noAudio) {
            self2._setupCodecs();
          }
          return self2;
        },
        /**
         * Check for browser support for various codecs and cache the results.
         * @return {Howler}
         */
        _setupCodecs: function() {
          var self2 = this || Howler2;
          var audioTest = null;
          try {
            audioTest = typeof Audio !== "undefined" ? new Audio() : null;
          } catch (err2) {
            return self2;
          }
          if (!audioTest || typeof audioTest.canPlayType !== "function") {
            return self2;
          }
          var mpegTest = audioTest.canPlayType("audio/mpeg;").replace(/^no$/, "");
          var ua = self2._navigator ? self2._navigator.userAgent : "";
          var checkOpera = ua.match(/OPR\/(\d+)/g);
          var isOldOpera = checkOpera && parseInt(checkOpera[0].split("/")[1], 10) < 33;
          var checkSafari = ua.indexOf("Safari") !== -1 && ua.indexOf("Chrome") === -1;
          var safariVersion = ua.match(/Version\/(.*?) /);
          var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;
          self2._codecs = {
            mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))),
            mpeg: !!mpegTest,
            opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
            ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType("audio/wav")).replace(/^no$/, ""),
            aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
            caf: !!audioTest.canPlayType("audio/x-caf;").replace(/^no$/, ""),
            m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            m4b: !!(audioTest.canPlayType("audio/x-m4b;") || audioTest.canPlayType("audio/m4b;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
            flac: !!(audioTest.canPlayType("audio/x-flac;") || audioTest.canPlayType("audio/flac;")).replace(/^no$/, "")
          };
          return self2;
        },
        /**
         * Some browsers/devices will only allow audio to be played after a user interaction.
         * Attempt to automatically unlock audio on the first user interaction.
         * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
         * @return {Howler}
         */
        _unlockAudio: function() {
          var self2 = this || Howler2;
          if (self2._audioUnlocked || !self2.ctx) {
            return;
          }
          self2._audioUnlocked = false;
          self2.autoUnlock = false;
          if (!self2._mobileUnloaded && self2.ctx.sampleRate !== 44100) {
            self2._mobileUnloaded = true;
            self2.unload();
          }
          self2._scratchBuffer = self2.ctx.createBuffer(1, 1, 22050);
          var unlock = function(e2) {
            while (self2._html5AudioPool.length < self2.html5PoolSize) {
              try {
                var audioNode = new Audio();
                audioNode._unlocked = true;
                self2._releaseHtml5Audio(audioNode);
              } catch (e3) {
                self2.noAudio = true;
                break;
              }
            }
            for (var i3 = 0; i3 < self2._howls.length; i3++) {
              if (!self2._howls[i3]._webAudio) {
                var ids = self2._howls[i3]._getSoundIds();
                for (var j2 = 0; j2 < ids.length; j2++) {
                  var sound = self2._howls[i3]._soundById(ids[j2]);
                  if (sound && sound._node && !sound._node._unlocked) {
                    sound._node._unlocked = true;
                    sound._node.load();
                  }
                }
              }
            }
            self2._autoResume();
            var source9 = self2.ctx.createBufferSource();
            source9.buffer = self2._scratchBuffer;
            source9.connect(self2.ctx.destination);
            if (typeof source9.start === "undefined") {
              source9.noteOn(0);
            } else {
              source9.start(0);
            }
            if (typeof self2.ctx.resume === "function") {
              self2.ctx.resume();
            }
            source9.onended = function() {
              source9.disconnect(0);
              self2._audioUnlocked = true;
              document.removeEventListener("touchstart", unlock, true);
              document.removeEventListener("touchend", unlock, true);
              document.removeEventListener("click", unlock, true);
              document.removeEventListener("keydown", unlock, true);
              for (var i4 = 0; i4 < self2._howls.length; i4++) {
                self2._howls[i4]._emit("unlock");
              }
            };
          };
          document.addEventListener("touchstart", unlock, true);
          document.addEventListener("touchend", unlock, true);
          document.addEventListener("click", unlock, true);
          document.addEventListener("keydown", unlock, true);
          return self2;
        },
        /**
         * Get an unlocked HTML5 Audio object from the pool. If none are left,
         * return a new Audio object and throw a warning.
         * @return {Audio} HTML5 Audio object.
         */
        _obtainHtml5Audio: function() {
          var self2 = this || Howler2;
          if (self2._html5AudioPool.length) {
            return self2._html5AudioPool.pop();
          }
          var testPlay = new Audio().play();
          if (testPlay && typeof Promise !== "undefined" && (testPlay instanceof Promise || typeof testPlay.then === "function")) {
            testPlay.catch(function() {
              console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
            });
          }
          return new Audio();
        },
        /**
         * Return an activated HTML5 Audio object to the pool.
         * @return {Howler}
         */
        _releaseHtml5Audio: function(audio) {
          var self2 = this || Howler2;
          if (audio._unlocked) {
            self2._html5AudioPool.push(audio);
          }
          return self2;
        },
        /**
         * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
         * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
         * @return {Howler}
         */
        _autoSuspend: function() {
          var self2 = this;
          if (!self2.autoSuspend || !self2.ctx || typeof self2.ctx.suspend === "undefined" || !Howler2.usingWebAudio) {
            return;
          }
          for (var i3 = 0; i3 < self2._howls.length; i3++) {
            if (self2._howls[i3]._webAudio) {
              for (var j2 = 0; j2 < self2._howls[i3]._sounds.length; j2++) {
                if (!self2._howls[i3]._sounds[j2]._paused) {
                  return self2;
                }
              }
            }
          }
          if (self2._suspendTimer) {
            clearTimeout(self2._suspendTimer);
          }
          self2._suspendTimer = setTimeout(function() {
            if (!self2.autoSuspend) {
              return;
            }
            self2._suspendTimer = null;
            self2.state = "suspending";
            var handleSuspension = function() {
              self2.state = "suspended";
              if (self2._resumeAfterSuspend) {
                delete self2._resumeAfterSuspend;
                self2._autoResume();
              }
            };
            self2.ctx.suspend().then(handleSuspension, handleSuspension);
          }, 3e4);
          return self2;
        },
        /**
         * Automatically resume the Web Audio AudioContext when a new sound is played.
         * @return {Howler}
         */
        _autoResume: function() {
          var self2 = this;
          if (!self2.ctx || typeof self2.ctx.resume === "undefined" || !Howler2.usingWebAudio) {
            return;
          }
          if (self2.state === "running" && self2.ctx.state !== "interrupted" && self2._suspendTimer) {
            clearTimeout(self2._suspendTimer);
            self2._suspendTimer = null;
          } else if (self2.state === "suspended" || self2.state === "running" && self2.ctx.state === "interrupted") {
            self2.ctx.resume().then(function() {
              self2.state = "running";
              for (var i3 = 0; i3 < self2._howls.length; i3++) {
                self2._howls[i3]._emit("resume");
              }
            });
            if (self2._suspendTimer) {
              clearTimeout(self2._suspendTimer);
              self2._suspendTimer = null;
            }
          } else if (self2.state === "suspending") {
            self2._resumeAfterSuspend = true;
          }
          return self2;
        }
      };
      var Howler2 = new HowlerGlobal2();
      var Howl4 = function(o2) {
        var self2 = this;
        if (!o2.src || o2.src.length === 0) {
          console.error("An array of source files must be passed with any new Howl.");
          return;
        }
        self2.init(o2);
      };
      Howl4.prototype = {
        /**
         * Initialize a new Howl group object.
         * @param  {Object} o Passed in properties for this group.
         * @return {Howl}
         */
        init: function(o2) {
          var self2 = this;
          if (!Howler2.ctx) {
            setupAudioContext();
          }
          self2._autoplay = o2.autoplay || false;
          self2._format = typeof o2.format !== "string" ? o2.format : [o2.format];
          self2._html5 = o2.html5 || false;
          self2._muted = o2.mute || false;
          self2._loop = o2.loop || false;
          self2._pool = o2.pool || 5;
          self2._preload = typeof o2.preload === "boolean" || o2.preload === "metadata" ? o2.preload : true;
          self2._rate = o2.rate || 1;
          self2._sprite = o2.sprite || {};
          self2._src = typeof o2.src !== "string" ? o2.src : [o2.src];
          self2._volume = o2.volume !== void 0 ? o2.volume : 1;
          self2._xhr = {
            method: o2.xhr && o2.xhr.method ? o2.xhr.method : "GET",
            headers: o2.xhr && o2.xhr.headers ? o2.xhr.headers : null,
            withCredentials: o2.xhr && o2.xhr.withCredentials ? o2.xhr.withCredentials : false
          };
          self2._duration = 0;
          self2._state = "unloaded";
          self2._sounds = [];
          self2._endTimers = {};
          self2._queue = [];
          self2._playLock = false;
          self2._onend = o2.onend ? [{ fn: o2.onend }] : [];
          self2._onfade = o2.onfade ? [{ fn: o2.onfade }] : [];
          self2._onload = o2.onload ? [{ fn: o2.onload }] : [];
          self2._onloaderror = o2.onloaderror ? [{ fn: o2.onloaderror }] : [];
          self2._onplayerror = o2.onplayerror ? [{ fn: o2.onplayerror }] : [];
          self2._onpause = o2.onpause ? [{ fn: o2.onpause }] : [];
          self2._onplay = o2.onplay ? [{ fn: o2.onplay }] : [];
          self2._onstop = o2.onstop ? [{ fn: o2.onstop }] : [];
          self2._onmute = o2.onmute ? [{ fn: o2.onmute }] : [];
          self2._onvolume = o2.onvolume ? [{ fn: o2.onvolume }] : [];
          self2._onrate = o2.onrate ? [{ fn: o2.onrate }] : [];
          self2._onseek = o2.onseek ? [{ fn: o2.onseek }] : [];
          self2._onunlock = o2.onunlock ? [{ fn: o2.onunlock }] : [];
          self2._onresume = [];
          self2._webAudio = Howler2.usingWebAudio && !self2._html5;
          if (typeof Howler2.ctx !== "undefined" && Howler2.ctx && Howler2.autoUnlock) {
            Howler2._unlockAudio();
          }
          Howler2._howls.push(self2);
          if (self2._autoplay) {
            self2._queue.push({
              event: "play",
              action: function() {
                self2.play();
              }
            });
          }
          if (self2._preload && self2._preload !== "none") {
            self2.load();
          }
          return self2;
        },
        /**
         * Load the audio file.
         * @return {Howler}
         */
        load: function() {
          var self2 = this;
          var url = null;
          if (Howler2.noAudio) {
            self2._emit("loaderror", null, "No audio support.");
            return;
          }
          if (typeof self2._src === "string") {
            self2._src = [self2._src];
          }
          for (var i3 = 0; i3 < self2._src.length; i3++) {
            var ext, str;
            if (self2._format && self2._format[i3]) {
              ext = self2._format[i3];
            } else {
              str = self2._src[i3];
              if (typeof str !== "string") {
                self2._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                continue;
              }
              ext = /^data:audio\/([^;,]+);/i.exec(str);
              if (!ext) {
                ext = /\.([^.]+)$/.exec(str.split("?", 1)[0]);
              }
              if (ext) {
                ext = ext[1].toLowerCase();
              }
            }
            if (!ext) {
              console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
            }
            if (ext && Howler2.codecs(ext)) {
              url = self2._src[i3];
              break;
            }
          }
          if (!url) {
            self2._emit("loaderror", null, "No codec support for selected audio sources.");
            return;
          }
          self2._src = url;
          self2._state = "loading";
          if (window.location.protocol === "https:" && url.slice(0, 5) === "http:") {
            self2._html5 = true;
            self2._webAudio = false;
          }
          new Sound2(self2);
          if (self2._webAudio) {
            loadBuffer(self2);
          }
          return self2;
        },
        /**
         * Play a sound or resume previous playback.
         * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Number}          Sound ID.
         */
        play: function(sprite, internal) {
          var self2 = this;
          var id = null;
          if (typeof sprite === "number") {
            id = sprite;
            sprite = null;
          } else if (typeof sprite === "string" && self2._state === "loaded" && !self2._sprite[sprite]) {
            return null;
          } else if (typeof sprite === "undefined") {
            sprite = "__default";
            if (!self2._playLock) {
              var num = 0;
              for (var i3 = 0; i3 < self2._sounds.length; i3++) {
                if (self2._sounds[i3]._paused && !self2._sounds[i3]._ended) {
                  num++;
                  id = self2._sounds[i3]._id;
                }
              }
              if (num === 1) {
                sprite = null;
              } else {
                id = null;
              }
            }
          }
          var sound = id ? self2._soundById(id) : self2._inactiveSound();
          if (!sound) {
            return null;
          }
          if (id && !sprite) {
            sprite = sound._sprite || "__default";
          }
          if (self2._state !== "loaded") {
            sound._sprite = sprite;
            sound._ended = false;
            var soundId = sound._id;
            self2._queue.push({
              event: "play",
              action: function() {
                self2.play(soundId);
              }
            });
            return soundId;
          }
          if (id && !sound._paused) {
            if (!internal) {
              self2._loadQueue("play");
            }
            return sound._id;
          }
          if (self2._webAudio) {
            Howler2._autoResume();
          }
          var seek = Math.max(0, sound._seek > 0 ? sound._seek : self2._sprite[sprite][0] / 1e3);
          var duration = Math.max(0, (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3 - seek);
          var timeout = duration * 1e3 / Math.abs(sound._rate);
          var start = self2._sprite[sprite][0] / 1e3;
          var stop = (self2._sprite[sprite][0] + self2._sprite[sprite][1]) / 1e3;
          sound._sprite = sprite;
          sound._ended = false;
          var setParams = function() {
            sound._paused = false;
            sound._seek = seek;
            sound._start = start;
            sound._stop = stop;
            sound._loop = !!(sound._loop || self2._sprite[sprite][2]);
          };
          if (seek >= stop) {
            self2._ended(sound);
            return;
          }
          var node = sound._node;
          if (self2._webAudio) {
            var playWebAudio = function() {
              self2._playLock = false;
              setParams();
              self2._refreshBuffer(sound);
              var vol = sound._muted || self2._muted ? 0 : sound._volume;
              node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
              sound._playStart = Howler2.ctx.currentTime;
              if (typeof node.bufferSource.start === "undefined") {
                sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
              } else {
                sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
              }
              if (timeout !== Infinity) {
                self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
              }
              if (!internal) {
                setTimeout(function() {
                  self2._emit("play", sound._id);
                  self2._loadQueue();
                }, 0);
              }
            };
            if (Howler2.state === "running" && Howler2.ctx.state !== "interrupted") {
              playWebAudio();
            } else {
              self2._playLock = true;
              self2.once("resume", playWebAudio);
              self2._clearTimer(sound._id);
            }
          } else {
            var playHtml5 = function() {
              node.currentTime = seek;
              node.muted = sound._muted || self2._muted || Howler2._muted || node.muted;
              node.volume = sound._volume * Howler2.volume();
              node.playbackRate = sound._rate;
              try {
                var play = node.play();
                if (play && typeof Promise !== "undefined" && (play instanceof Promise || typeof play.then === "function")) {
                  self2._playLock = true;
                  setParams();
                  play.then(function() {
                    self2._playLock = false;
                    node._unlocked = true;
                    if (!internal) {
                      self2._emit("play", sound._id);
                    } else {
                      self2._loadQueue();
                    }
                  }).catch(function() {
                    self2._playLock = false;
                    self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                    sound._ended = true;
                    sound._paused = true;
                  });
                } else if (!internal) {
                  self2._playLock = false;
                  setParams();
                  self2._emit("play", sound._id);
                }
                node.playbackRate = sound._rate;
                if (node.paused) {
                  self2._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                  return;
                }
                if (sprite !== "__default" || sound._loop) {
                  self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
                } else {
                  self2._endTimers[sound._id] = function() {
                    self2._ended(sound);
                    node.removeEventListener("ended", self2._endTimers[sound._id], false);
                  };
                  node.addEventListener("ended", self2._endTimers[sound._id], false);
                }
              } catch (err2) {
                self2._emit("playerror", sound._id, err2);
              }
            };
            if (node.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") {
              node.src = self2._src;
              node.load();
            }
            var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler2._navigator.isCocoonJS;
            if (node.readyState >= 3 || loadedNoReadyState) {
              playHtml5();
            } else {
              self2._playLock = true;
              self2._state = "loading";
              var listener = function() {
                self2._state = "loaded";
                playHtml5();
                node.removeEventListener(Howler2._canPlayEvent, listener, false);
              };
              node.addEventListener(Howler2._canPlayEvent, listener, false);
              self2._clearTimer(sound._id);
            }
          }
          return sound._id;
        },
        /**
         * Pause playback and save current position.
         * @param  {Number} id The sound ID (empty to pause all in group).
         * @return {Howl}
         */
        pause: function(id) {
          var self2 = this;
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "pause",
              action: function() {
                self2.pause(id);
              }
            });
            return self2;
          }
          var ids = self2._getSoundIds(id);
          for (var i3 = 0; i3 < ids.length; i3++) {
            self2._clearTimer(ids[i3]);
            var sound = self2._soundById(ids[i3]);
            if (sound && !sound._paused) {
              sound._seek = self2.seek(ids[i3]);
              sound._rateSeek = 0;
              sound._paused = true;
              self2._stopFade(ids[i3]);
              if (sound._node) {
                if (self2._webAudio) {
                  if (!sound._node.bufferSource) {
                    continue;
                  }
                  if (typeof sound._node.bufferSource.stop === "undefined") {
                    sound._node.bufferSource.noteOff(0);
                  } else {
                    sound._node.bufferSource.stop(0);
                  }
                  self2._cleanBuffer(sound._node);
                } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                  sound._node.pause();
                }
              }
            }
            if (!arguments[1]) {
              self2._emit("pause", sound ? sound._id : null);
            }
          }
          return self2;
        },
        /**
         * Stop playback and reset to start.
         * @param  {Number} id The sound ID (empty to stop all in group).
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Howl}
         */
        stop: function(id, internal) {
          var self2 = this;
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "stop",
              action: function() {
                self2.stop(id);
              }
            });
            return self2;
          }
          var ids = self2._getSoundIds(id);
          for (var i3 = 0; i3 < ids.length; i3++) {
            self2._clearTimer(ids[i3]);
            var sound = self2._soundById(ids[i3]);
            if (sound) {
              sound._seek = sound._start || 0;
              sound._rateSeek = 0;
              sound._paused = true;
              sound._ended = true;
              self2._stopFade(ids[i3]);
              if (sound._node) {
                if (self2._webAudio) {
                  if (sound._node.bufferSource) {
                    if (typeof sound._node.bufferSource.stop === "undefined") {
                      sound._node.bufferSource.noteOff(0);
                    } else {
                      sound._node.bufferSource.stop(0);
                    }
                    self2._cleanBuffer(sound._node);
                  }
                } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                  sound._node.currentTime = sound._start || 0;
                  sound._node.pause();
                  if (sound._node.duration === Infinity) {
                    self2._clearSound(sound._node);
                  }
                }
              }
              if (!internal) {
                self2._emit("stop", sound._id);
              }
            }
          }
          return self2;
        },
        /**
         * Mute/unmute a single sound or all sounds in this Howl group.
         * @param  {Boolean} muted Set to true to mute and false to unmute.
         * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
         * @return {Howl}
         */
        mute: function(muted, id) {
          var self2 = this;
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "mute",
              action: function() {
                self2.mute(muted, id);
              }
            });
            return self2;
          }
          if (typeof id === "undefined") {
            if (typeof muted === "boolean") {
              self2._muted = muted;
            } else {
              return self2._muted;
            }
          }
          var ids = self2._getSoundIds(id);
          for (var i3 = 0; i3 < ids.length; i3++) {
            var sound = self2._soundById(ids[i3]);
            if (sound) {
              sound._muted = muted;
              if (sound._interval) {
                self2._stopFade(sound._id);
              }
              if (self2._webAudio && sound._node) {
                sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler2.ctx.currentTime);
              } else if (sound._node) {
                sound._node.muted = Howler2._muted ? true : muted;
              }
              self2._emit("mute", sound._id);
            }
          }
          return self2;
        },
        /**
         * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
         *   volume() -> Returns the group's volume value.
         *   volume(id) -> Returns the sound id's current volume.
         *   volume(vol) -> Sets the volume of all sounds in this Howl group.
         *   volume(vol, id) -> Sets the volume of passed sound id.
         * @return {Howl/Number} Returns self or current volume.
         */
        volume: function() {
          var self2 = this;
          var args = arguments;
          var vol, id;
          if (args.length === 0) {
            return self2._volume;
          } else if (args.length === 1 || args.length === 2 && typeof args[1] === "undefined") {
            var ids = self2._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else {
              vol = parseFloat(args[0]);
            }
          } else if (args.length >= 2) {
            vol = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          var sound;
          if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
            if (self2._state !== "loaded" || self2._playLock) {
              self2._queue.push({
                event: "volume",
                action: function() {
                  self2.volume.apply(self2, args);
                }
              });
              return self2;
            }
            if (typeof id === "undefined") {
              self2._volume = vol;
            }
            id = self2._getSoundIds(id);
            for (var i3 = 0; i3 < id.length; i3++) {
              sound = self2._soundById(id[i3]);
              if (sound) {
                sound._volume = vol;
                if (!args[2]) {
                  self2._stopFade(id[i3]);
                }
                if (self2._webAudio && sound._node && !sound._muted) {
                  sound._node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
                } else if (sound._node && !sound._muted) {
                  sound._node.volume = vol * Howler2.volume();
                }
                self2._emit("volume", sound._id);
              }
            }
          } else {
            sound = id ? self2._soundById(id) : self2._sounds[0];
            return sound ? sound._volume : 0;
          }
          return self2;
        },
        /**
         * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id (omit to fade all sounds).
         * @return {Howl}
         */
        fade: function(from, to, len, id) {
          var self2 = this;
          if (self2._state !== "loaded" || self2._playLock) {
            self2._queue.push({
              event: "fade",
              action: function() {
                self2.fade(from, to, len, id);
              }
            });
            return self2;
          }
          from = Math.min(Math.max(0, parseFloat(from)), 1);
          to = Math.min(Math.max(0, parseFloat(to)), 1);
          len = parseFloat(len);
          self2.volume(from, id);
          var ids = self2._getSoundIds(id);
          for (var i3 = 0; i3 < ids.length; i3++) {
            var sound = self2._soundById(ids[i3]);
            if (sound) {
              if (!id) {
                self2._stopFade(ids[i3]);
              }
              if (self2._webAudio && !sound._muted) {
                var currentTime = Howler2.ctx.currentTime;
                var end = currentTime + len / 1e3;
                sound._volume = from;
                sound._node.gain.setValueAtTime(from, currentTime);
                sound._node.gain.linearRampToValueAtTime(to, end);
              }
              self2._startFadeInterval(sound, from, to, len, ids[i3], typeof id === "undefined");
            }
          }
          return self2;
        },
        /**
         * Starts the internal interval to fade a sound.
         * @param  {Object} sound Reference to sound to fade.
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id to fade.
         * @param  {Boolean} isGroup   If true, set the volume on the group.
         */
        _startFadeInterval: function(sound, from, to, len, id, isGroup) {
          var self2 = this;
          var vol = from;
          var diff = to - from;
          var steps = Math.abs(diff / 0.01);
          var stepLen = Math.max(4, steps > 0 ? len / steps : len);
          var lastTick = Date.now();
          sound._fadeTo = to;
          sound._interval = setInterval(function() {
            var tick = (Date.now() - lastTick) / len;
            lastTick = Date.now();
            vol += diff * tick;
            vol = Math.round(vol * 100) / 100;
            if (diff < 0) {
              vol = Math.max(to, vol);
            } else {
              vol = Math.min(to, vol);
            }
            if (self2._webAudio) {
              sound._volume = vol;
            } else {
              self2.volume(vol, sound._id, true);
            }
            if (isGroup) {
              self2._volume = vol;
            }
            if (to < from && vol <= to || to > from && vol >= to) {
              clearInterval(sound._interval);
              sound._interval = null;
              sound._fadeTo = null;
              self2.volume(to, sound._id);
              self2._emit("fade", sound._id);
            }
          }, stepLen);
        },
        /**
         * Internal method that stops the currently playing fade when
         * a new fade starts, volume is changed or the sound is stopped.
         * @param  {Number} id The sound id.
         * @return {Howl}
         */
        _stopFade: function(id) {
          var self2 = this;
          var sound = self2._soundById(id);
          if (sound && sound._interval) {
            if (self2._webAudio) {
              sound._node.gain.cancelScheduledValues(Howler2.ctx.currentTime);
            }
            clearInterval(sound._interval);
            sound._interval = null;
            self2.volume(sound._fadeTo, id);
            sound._fadeTo = null;
            self2._emit("fade", id);
          }
          return self2;
        },
        /**
         * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
         *   loop() -> Returns the group's loop value.
         *   loop(id) -> Returns the sound id's loop value.
         *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
         *   loop(loop, id) -> Sets the loop value of passed sound id.
         * @return {Howl/Boolean} Returns self or current loop value.
         */
        loop: function() {
          var self2 = this;
          var args = arguments;
          var loop, id, sound;
          if (args.length === 0) {
            return self2._loop;
          } else if (args.length === 1) {
            if (typeof args[0] === "boolean") {
              loop = args[0];
              self2._loop = loop;
            } else {
              sound = self2._soundById(parseInt(args[0], 10));
              return sound ? sound._loop : false;
            }
          } else if (args.length === 2) {
            loop = args[0];
            id = parseInt(args[1], 10);
          }
          var ids = self2._getSoundIds(id);
          for (var i3 = 0; i3 < ids.length; i3++) {
            sound = self2._soundById(ids[i3]);
            if (sound) {
              sound._loop = loop;
              if (self2._webAudio && sound._node && sound._node.bufferSource) {
                sound._node.bufferSource.loop = loop;
                if (loop) {
                  sound._node.bufferSource.loopStart = sound._start || 0;
                  sound._node.bufferSource.loopEnd = sound._stop;
                  if (self2.playing(ids[i3])) {
                    self2.pause(ids[i3], true);
                    self2.play(ids[i3], true);
                  }
                }
              }
            }
          }
          return self2;
        },
        /**
         * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   rate() -> Returns the first sound node's current playback rate.
         *   rate(id) -> Returns the sound id's current playback rate.
         *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
         *   rate(rate, id) -> Sets the playback rate of passed sound id.
         * @return {Howl/Number} Returns self or the current playback rate.
         */
        rate: function() {
          var self2 = this;
          var args = arguments;
          var rate, id;
          if (args.length === 0) {
            id = self2._sounds[0]._id;
          } else if (args.length === 1) {
            var ids = self2._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else {
              rate = parseFloat(args[0]);
            }
          } else if (args.length === 2) {
            rate = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          var sound;
          if (typeof rate === "number") {
            if (self2._state !== "loaded" || self2._playLock) {
              self2._queue.push({
                event: "rate",
                action: function() {
                  self2.rate.apply(self2, args);
                }
              });
              return self2;
            }
            if (typeof id === "undefined") {
              self2._rate = rate;
            }
            id = self2._getSoundIds(id);
            for (var i3 = 0; i3 < id.length; i3++) {
              sound = self2._soundById(id[i3]);
              if (sound) {
                if (self2.playing(id[i3])) {
                  sound._rateSeek = self2.seek(id[i3]);
                  sound._playStart = self2._webAudio ? Howler2.ctx.currentTime : sound._playStart;
                }
                sound._rate = rate;
                if (self2._webAudio && sound._node && sound._node.bufferSource) {
                  sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler2.ctx.currentTime);
                } else if (sound._node) {
                  sound._node.playbackRate = rate;
                }
                var seek = self2.seek(id[i3]);
                var duration = (self2._sprite[sound._sprite][0] + self2._sprite[sound._sprite][1]) / 1e3 - seek;
                var timeout = duration * 1e3 / Math.abs(sound._rate);
                if (self2._endTimers[id[i3]] || !sound._paused) {
                  self2._clearTimer(id[i3]);
                  self2._endTimers[id[i3]] = setTimeout(self2._ended.bind(self2, sound), timeout);
                }
                self2._emit("rate", sound._id);
              }
            }
          } else {
            sound = self2._soundById(id);
            return sound ? sound._rate : self2._rate;
          }
          return self2;
        },
        /**
         * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   seek() -> Returns the first sound node's current seek position.
         *   seek(id) -> Returns the sound id's current seek position.
         *   seek(seek) -> Sets the seek position of the first sound node.
         *   seek(seek, id) -> Sets the seek position of passed sound id.
         * @return {Howl/Number} Returns self or the current seek position.
         */
        seek: function() {
          var self2 = this;
          var args = arguments;
          var seek, id;
          if (args.length === 0) {
            if (self2._sounds.length) {
              id = self2._sounds[0]._id;
            }
          } else if (args.length === 1) {
            var ids = self2._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else if (self2._sounds.length) {
              id = self2._sounds[0]._id;
              seek = parseFloat(args[0]);
            }
          } else if (args.length === 2) {
            seek = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          if (typeof id === "undefined") {
            return 0;
          }
          if (typeof seek === "number" && (self2._state !== "loaded" || self2._playLock)) {
            self2._queue.push({
              event: "seek",
              action: function() {
                self2.seek.apply(self2, args);
              }
            });
            return self2;
          }
          var sound = self2._soundById(id);
          if (sound) {
            if (typeof seek === "number" && seek >= 0) {
              var playing = self2.playing(id);
              if (playing) {
                self2.pause(id, true);
              }
              sound._seek = seek;
              sound._ended = false;
              self2._clearTimer(id);
              if (!self2._webAudio && sound._node && !isNaN(sound._node.duration)) {
                sound._node.currentTime = seek;
              }
              var seekAndEmit = function() {
                if (playing) {
                  self2.play(id, true);
                }
                self2._emit("seek", id);
              };
              if (playing && !self2._webAudio) {
                var emitSeek = function() {
                  if (!self2._playLock) {
                    seekAndEmit();
                  } else {
                    setTimeout(emitSeek, 0);
                  }
                };
                setTimeout(emitSeek, 0);
              } else {
                seekAndEmit();
              }
            } else {
              if (self2._webAudio) {
                var realTime = self2.playing(id) ? Howler2.ctx.currentTime - sound._playStart : 0;
                var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
                return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
              } else {
                return sound._node.currentTime;
              }
            }
          }
          return self2;
        },
        /**
         * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
         * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
         * @return {Boolean} True if playing and false if not.
         */
        playing: function(id) {
          var self2 = this;
          if (typeof id === "number") {
            var sound = self2._soundById(id);
            return sound ? !sound._paused : false;
          }
          for (var i3 = 0; i3 < self2._sounds.length; i3++) {
            if (!self2._sounds[i3]._paused) {
              return true;
            }
          }
          return false;
        },
        /**
         * Get the duration of this sound. Passing a sound id will return the sprite duration.
         * @param  {Number} id The sound id to check. If none is passed, return full source duration.
         * @return {Number} Audio duration in seconds.
         */
        duration: function(id) {
          var self2 = this;
          var duration = self2._duration;
          var sound = self2._soundById(id);
          if (sound) {
            duration = self2._sprite[sound._sprite][1] / 1e3;
          }
          return duration;
        },
        /**
         * Returns the current loaded state of this Howl.
         * @return {String} 'unloaded', 'loading', 'loaded'
         */
        state: function() {
          return this._state;
        },
        /**
         * Unload and destroy the current Howl object.
         * This will immediately stop all sound instances attached to this group.
         */
        unload: function() {
          var self2 = this;
          var sounds = self2._sounds;
          for (var i3 = 0; i3 < sounds.length; i3++) {
            if (!sounds[i3]._paused) {
              self2.stop(sounds[i3]._id);
            }
            if (!self2._webAudio) {
              self2._clearSound(sounds[i3]._node);
              sounds[i3]._node.removeEventListener("error", sounds[i3]._errorFn, false);
              sounds[i3]._node.removeEventListener(Howler2._canPlayEvent, sounds[i3]._loadFn, false);
              sounds[i3]._node.removeEventListener("ended", sounds[i3]._endFn, false);
              Howler2._releaseHtml5Audio(sounds[i3]._node);
            }
            delete sounds[i3]._node;
            self2._clearTimer(sounds[i3]._id);
          }
          var index = Howler2._howls.indexOf(self2);
          if (index >= 0) {
            Howler2._howls.splice(index, 1);
          }
          var remCache = true;
          for (i3 = 0; i3 < Howler2._howls.length; i3++) {
            if (Howler2._howls[i3]._src === self2._src || self2._src.indexOf(Howler2._howls[i3]._src) >= 0) {
              remCache = false;
              break;
            }
          }
          if (cache && remCache) {
            delete cache[self2._src];
          }
          Howler2.noAudio = false;
          self2._state = "unloaded";
          self2._sounds = [];
          self2 = null;
          return null;
        },
        /**
         * Listen to a custom event.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
         * @return {Howl}
         */
        on: function(event, fn, id, once) {
          var self2 = this;
          var events = self2["_on" + event];
          if (typeof fn === "function") {
            events.push(once ? { id, fn, once } : { id, fn });
          }
          return self2;
        },
        /**
         * Remove a custom event. Call without parameters to remove all events.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to remove. Leave empty to remove all.
         * @param  {Number}   id    (optional) Only remove events for this sound.
         * @return {Howl}
         */
        off: function(event, fn, id) {
          var self2 = this;
          var events = self2["_on" + event];
          var i3 = 0;
          if (typeof fn === "number") {
            id = fn;
            fn = null;
          }
          if (fn || id) {
            for (i3 = 0; i3 < events.length; i3++) {
              var isId = id === events[i3].id;
              if (fn === events[i3].fn && isId || !fn && isId) {
                events.splice(i3, 1);
                break;
              }
            }
          } else if (event) {
            self2["_on" + event] = [];
          } else {
            var keys = Object.keys(self2);
            for (i3 = 0; i3 < keys.length; i3++) {
              if (keys[i3].indexOf("_on") === 0 && Array.isArray(self2[keys[i3]])) {
                self2[keys[i3]] = [];
              }
            }
          }
          return self2;
        },
        /**
         * Listen to a custom event and remove it once fired.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @return {Howl}
         */
        once: function(event, fn, id) {
          var self2 = this;
          self2.on(event, fn, id, 1);
          return self2;
        },
        /**
         * Emit all events of a specific type and pass the sound id.
         * @param  {String} event Event name.
         * @param  {Number} id    Sound ID.
         * @param  {Number} msg   Message to go with event.
         * @return {Howl}
         */
        _emit: function(event, id, msg) {
          var self2 = this;
          var events = self2["_on" + event];
          for (var i3 = events.length - 1; i3 >= 0; i3--) {
            if (!events[i3].id || events[i3].id === id || event === "load") {
              setTimeout(function(fn) {
                fn.call(this, id, msg);
              }.bind(self2, events[i3].fn), 0);
              if (events[i3].once) {
                self2.off(event, events[i3].fn, events[i3].id);
              }
            }
          }
          self2._loadQueue(event);
          return self2;
        },
        /**
         * Queue of actions initiated before the sound has loaded.
         * These will be called in sequence, with the next only firing
         * after the previous has finished executing (even if async like play).
         * @return {Howl}
         */
        _loadQueue: function(event) {
          var self2 = this;
          if (self2._queue.length > 0) {
            var task = self2._queue[0];
            if (task.event === event) {
              self2._queue.shift();
              self2._loadQueue();
            }
            if (!event) {
              task.action();
            }
          }
          return self2;
        },
        /**
         * Fired when playback ends at the end of the duration.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _ended: function(sound) {
          var self2 = this;
          var sprite = sound._sprite;
          if (!self2._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
            setTimeout(self2._ended.bind(self2, sound), 100);
            return self2;
          }
          var loop = !!(sound._loop || self2._sprite[sprite][2]);
          self2._emit("end", sound._id);
          if (!self2._webAudio && loop) {
            self2.stop(sound._id, true).play(sound._id);
          }
          if (self2._webAudio && loop) {
            self2._emit("play", sound._id);
            sound._seek = sound._start || 0;
            sound._rateSeek = 0;
            sound._playStart = Howler2.ctx.currentTime;
            var timeout = (sound._stop - sound._start) * 1e3 / Math.abs(sound._rate);
            self2._endTimers[sound._id] = setTimeout(self2._ended.bind(self2, sound), timeout);
          }
          if (self2._webAudio && !loop) {
            sound._paused = true;
            sound._ended = true;
            sound._seek = sound._start || 0;
            sound._rateSeek = 0;
            self2._clearTimer(sound._id);
            self2._cleanBuffer(sound._node);
            Howler2._autoSuspend();
          }
          if (!self2._webAudio && !loop) {
            self2.stop(sound._id, true);
          }
          return self2;
        },
        /**
         * Clear the end timer for a sound playback.
         * @param  {Number} id The sound ID.
         * @return {Howl}
         */
        _clearTimer: function(id) {
          var self2 = this;
          if (self2._endTimers[id]) {
            if (typeof self2._endTimers[id] !== "function") {
              clearTimeout(self2._endTimers[id]);
            } else {
              var sound = self2._soundById(id);
              if (sound && sound._node) {
                sound._node.removeEventListener("ended", self2._endTimers[id], false);
              }
            }
            delete self2._endTimers[id];
          }
          return self2;
        },
        /**
         * Return the sound identified by this ID, or return null.
         * @param  {Number} id Sound ID
         * @return {Object}    Sound object or null.
         */
        _soundById: function(id) {
          var self2 = this;
          for (var i3 = 0; i3 < self2._sounds.length; i3++) {
            if (id === self2._sounds[i3]._id) {
              return self2._sounds[i3];
            }
          }
          return null;
        },
        /**
         * Return an inactive sound from the pool or create a new one.
         * @return {Sound} Sound playback object.
         */
        _inactiveSound: function() {
          var self2 = this;
          self2._drain();
          for (var i3 = 0; i3 < self2._sounds.length; i3++) {
            if (self2._sounds[i3]._ended) {
              return self2._sounds[i3].reset();
            }
          }
          return new Sound2(self2);
        },
        /**
         * Drain excess inactive sounds from the pool.
         */
        _drain: function() {
          var self2 = this;
          var limit = self2._pool;
          var cnt = 0;
          var i3 = 0;
          if (self2._sounds.length < limit) {
            return;
          }
          for (i3 = 0; i3 < self2._sounds.length; i3++) {
            if (self2._sounds[i3]._ended) {
              cnt++;
            }
          }
          for (i3 = self2._sounds.length - 1; i3 >= 0; i3--) {
            if (cnt <= limit) {
              return;
            }
            if (self2._sounds[i3]._ended) {
              if (self2._webAudio && self2._sounds[i3]._node) {
                self2._sounds[i3]._node.disconnect(0);
              }
              self2._sounds.splice(i3, 1);
              cnt--;
            }
          }
        },
        /**
         * Get all ID's from the sounds pool.
         * @param  {Number} id Only return one ID if one is passed.
         * @return {Array}    Array of IDs.
         */
        _getSoundIds: function(id) {
          var self2 = this;
          if (typeof id === "undefined") {
            var ids = [];
            for (var i3 = 0; i3 < self2._sounds.length; i3++) {
              ids.push(self2._sounds[i3]._id);
            }
            return ids;
          } else {
            return [id];
          }
        },
        /**
         * Load the sound back into the buffer source.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _refreshBuffer: function(sound) {
          var self2 = this;
          sound._node.bufferSource = Howler2.ctx.createBufferSource();
          sound._node.bufferSource.buffer = cache[self2._src];
          if (sound._panner) {
            sound._node.bufferSource.connect(sound._panner);
          } else {
            sound._node.bufferSource.connect(sound._node);
          }
          sound._node.bufferSource.loop = sound._loop;
          if (sound._loop) {
            sound._node.bufferSource.loopStart = sound._start || 0;
            sound._node.bufferSource.loopEnd = sound._stop || 0;
          }
          sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler2.ctx.currentTime);
          return self2;
        },
        /**
         * Prevent memory leaks by cleaning up the buffer source after playback.
         * @param  {Object} node Sound's audio node containing the buffer source.
         * @return {Howl}
         */
        _cleanBuffer: function(node) {
          var self2 = this;
          var isIOS = Howler2._navigator && Howler2._navigator.vendor.indexOf("Apple") >= 0;
          if (!node.bufferSource) {
            return self2;
          }
          if (Howler2._scratchBuffer && node.bufferSource) {
            node.bufferSource.onended = null;
            node.bufferSource.disconnect(0);
            if (isIOS) {
              try {
                node.bufferSource.buffer = Howler2._scratchBuffer;
              } catch (e2) {
              }
            }
          }
          node.bufferSource = null;
          return self2;
        },
        /**
         * Set the source to a 0-second silence to stop any downloading (except in IE).
         * @param  {Object} node Audio node to clear.
         */
        _clearSound: function(node) {
          var checkIE = /MSIE |Trident\//.test(Howler2._navigator && Howler2._navigator.userAgent);
          if (!checkIE) {
            node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
          }
        }
      };
      var Sound2 = function(howl) {
        this._parent = howl;
        this.init();
      };
      Sound2.prototype = {
        /**
         * Initialize a new Sound object.
         * @return {Sound}
         */
        init: function() {
          var self2 = this;
          var parent2 = self2._parent;
          self2._muted = parent2._muted;
          self2._loop = parent2._loop;
          self2._volume = parent2._volume;
          self2._rate = parent2._rate;
          self2._seek = 0;
          self2._paused = true;
          self2._ended = true;
          self2._sprite = "__default";
          self2._id = ++Howler2._counter;
          parent2._sounds.push(self2);
          self2.create();
          return self2;
        },
        /**
         * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
         * @return {Sound}
         */
        create: function() {
          var self2 = this;
          var parent2 = self2._parent;
          var volume = Howler2._muted || self2._muted || self2._parent._muted ? 0 : self2._volume;
          if (parent2._webAudio) {
            self2._node = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
            self2._node.gain.setValueAtTime(volume, Howler2.ctx.currentTime);
            self2._node.paused = true;
            self2._node.connect(Howler2.masterGain);
          } else if (!Howler2.noAudio) {
            self2._node = Howler2._obtainHtml5Audio();
            self2._errorFn = self2._errorListener.bind(self2);
            self2._node.addEventListener("error", self2._errorFn, false);
            self2._loadFn = self2._loadListener.bind(self2);
            self2._node.addEventListener(Howler2._canPlayEvent, self2._loadFn, false);
            self2._endFn = self2._endListener.bind(self2);
            self2._node.addEventListener("ended", self2._endFn, false);
            self2._node.src = parent2._src;
            self2._node.preload = parent2._preload === true ? "auto" : parent2._preload;
            self2._node.volume = volume * Howler2.volume();
            self2._node.load();
          }
          return self2;
        },
        /**
         * Reset the parameters of this sound to the original state (for recycle).
         * @return {Sound}
         */
        reset: function() {
          var self2 = this;
          var parent2 = self2._parent;
          self2._muted = parent2._muted;
          self2._loop = parent2._loop;
          self2._volume = parent2._volume;
          self2._rate = parent2._rate;
          self2._seek = 0;
          self2._rateSeek = 0;
          self2._paused = true;
          self2._ended = true;
          self2._sprite = "__default";
          self2._id = ++Howler2._counter;
          return self2;
        },
        /**
         * HTML5 Audio error listener callback.
         */
        _errorListener: function() {
          var self2 = this;
          self2._parent._emit("loaderror", self2._id, self2._node.error ? self2._node.error.code : 0);
          self2._node.removeEventListener("error", self2._errorFn, false);
        },
        /**
         * HTML5 Audio canplaythrough listener callback.
         */
        _loadListener: function() {
          var self2 = this;
          var parent2 = self2._parent;
          parent2._duration = Math.ceil(self2._node.duration * 10) / 10;
          if (Object.keys(parent2._sprite).length === 0) {
            parent2._sprite = { __default: [0, parent2._duration * 1e3] };
          }
          if (parent2._state !== "loaded") {
            parent2._state = "loaded";
            parent2._emit("load");
            parent2._loadQueue();
          }
          self2._node.removeEventListener(Howler2._canPlayEvent, self2._loadFn, false);
        },
        /**
         * HTML5 Audio ended listener callback.
         */
        _endListener: function() {
          var self2 = this;
          var parent2 = self2._parent;
          if (parent2._duration === Infinity) {
            parent2._duration = Math.ceil(self2._node.duration * 10) / 10;
            if (parent2._sprite.__default[1] === Infinity) {
              parent2._sprite.__default[1] = parent2._duration * 1e3;
            }
            parent2._ended(self2);
          }
          self2._node.removeEventListener("ended", self2._endFn, false);
        }
      };
      var cache = {};
      var loadBuffer = function(self2) {
        var url = self2._src;
        if (cache[url]) {
          self2._duration = cache[url].duration;
          loadSound(self2);
          return;
        }
        if (/^data:[^;]+;base64,/.test(url)) {
          var data = atob(url.split(",")[1]);
          var dataView = new Uint8Array(data.length);
          for (var i3 = 0; i3 < data.length; ++i3) {
            dataView[i3] = data.charCodeAt(i3);
          }
          decodeAudioData(dataView.buffer, self2);
        } else {
          var xhr = new XMLHttpRequest();
          xhr.open(self2._xhr.method, url, true);
          xhr.withCredentials = self2._xhr.withCredentials;
          xhr.responseType = "arraybuffer";
          if (self2._xhr.headers) {
            Object.keys(self2._xhr.headers).forEach(function(key) {
              xhr.setRequestHeader(key, self2._xhr.headers[key]);
            });
          }
          xhr.onload = function() {
            var code = (xhr.status + "")[0];
            if (code !== "0" && code !== "2" && code !== "3") {
              self2._emit("loaderror", null, "Failed loading audio file with status: " + xhr.status + ".");
              return;
            }
            decodeAudioData(xhr.response, self2);
          };
          xhr.onerror = function() {
            if (self2._webAudio) {
              self2._html5 = true;
              self2._webAudio = false;
              self2._sounds = [];
              delete cache[url];
              self2.load();
            }
          };
          safeXhrSend(xhr);
        }
      };
      var safeXhrSend = function(xhr) {
        try {
          xhr.send();
        } catch (e2) {
          xhr.onerror();
        }
      };
      var decodeAudioData = function(arraybuffer, self2) {
        var error = function() {
          self2._emit("loaderror", null, "Decoding audio data failed.");
        };
        var success = function(buffer) {
          if (buffer && self2._sounds.length > 0) {
            cache[self2._src] = buffer;
            loadSound(self2, buffer);
          } else {
            error();
          }
        };
        if (typeof Promise !== "undefined" && Howler2.ctx.decodeAudioData.length === 1) {
          Howler2.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
        } else {
          Howler2.ctx.decodeAudioData(arraybuffer, success, error);
        }
      };
      var loadSound = function(self2, buffer) {
        if (buffer && !self2._duration) {
          self2._duration = buffer.duration;
        }
        if (Object.keys(self2._sprite).length === 0) {
          self2._sprite = { __default: [0, self2._duration * 1e3] };
        }
        if (self2._state !== "loaded") {
          self2._state = "loaded";
          self2._emit("load");
          self2._loadQueue();
        }
      };
      var setupAudioContext = function() {
        if (!Howler2.usingWebAudio) {
          return;
        }
        try {
          if (typeof AudioContext !== "undefined") {
            Howler2.ctx = new AudioContext();
          } else if (typeof webkitAudioContext !== "undefined") {
            Howler2.ctx = new webkitAudioContext();
          } else {
            Howler2.usingWebAudio = false;
          }
        } catch (e2) {
          Howler2.usingWebAudio = false;
        }
        if (!Howler2.ctx) {
          Howler2.usingWebAudio = false;
        }
        var iOS = /iP(hone|od|ad)/.test(Howler2._navigator && Howler2._navigator.platform);
        var appVersion = Howler2._navigator && Howler2._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
        var version = appVersion ? parseInt(appVersion[1], 10) : null;
        if (iOS && version && version < 9) {
          var safari = /safari/.test(Howler2._navigator && Howler2._navigator.userAgent.toLowerCase());
          if (Howler2._navigator && !safari) {
            Howler2.usingWebAudio = false;
          }
        }
        if (Howler2.usingWebAudio) {
          Howler2.masterGain = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
          Howler2.masterGain.gain.setValueAtTime(Howler2._muted ? 0 : Howler2._volume, Howler2.ctx.currentTime);
          Howler2.masterGain.connect(Howler2.ctx.destination);
        }
        Howler2._setup();
      };
      if (typeof define === "function" && define.amd) {
        define([], function() {
          return {
            Howler: Howler2,
            Howl: Howl4
          };
        });
      }
      if (typeof exports !== "undefined") {
        exports.Howler = Howler2;
        exports.Howl = Howl4;
      }
      if (typeof global !== "undefined") {
        global.HowlerGlobal = HowlerGlobal2;
        global.Howler = Howler2;
        global.Howl = Howl4;
        global.Sound = Sound2;
      } else if (typeof window !== "undefined") {
        window.HowlerGlobal = HowlerGlobal2;
        window.Howler = Howler2;
        window.Howl = Howl4;
        window.Sound = Sound2;
      }
    })();
    /*!
     *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
     *  
     *  howler.js v2.2.4
     *  howlerjs.com
     *
     *  (c) 2013-2020, James Simpson of GoldFire Studios
     *  goldfirestudios.com
     *
     *  MIT License
     */
    (function() {
      "use strict";
      HowlerGlobal.prototype._pos = [0, 0, 0];
      HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
      HowlerGlobal.prototype.stereo = function(pan) {
        var self2 = this;
        if (!self2.ctx || !self2.ctx.listener) {
          return self2;
        }
        for (var i3 = self2._howls.length - 1; i3 >= 0; i3--) {
          self2._howls[i3].stereo(pan);
        }
        return self2;
      };
      HowlerGlobal.prototype.pos = function(x2, y2, z) {
        var self2 = this;
        if (!self2.ctx || !self2.ctx.listener) {
          return self2;
        }
        y2 = typeof y2 !== "number" ? self2._pos[1] : y2;
        z = typeof z !== "number" ? self2._pos[2] : z;
        if (typeof x2 === "number") {
          self2._pos = [x2, y2, z];
          if (typeof self2.ctx.listener.positionX !== "undefined") {
            self2.ctx.listener.positionX.setTargetAtTime(self2._pos[0], Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.positionY.setTargetAtTime(self2._pos[1], Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.positionZ.setTargetAtTime(self2._pos[2], Howler.ctx.currentTime, 0.1);
          } else {
            self2.ctx.listener.setPosition(self2._pos[0], self2._pos[1], self2._pos[2]);
          }
        } else {
          return self2._pos;
        }
        return self2;
      };
      HowlerGlobal.prototype.orientation = function(x2, y2, z, xUp, yUp, zUp) {
        var self2 = this;
        if (!self2.ctx || !self2.ctx.listener) {
          return self2;
        }
        var or = self2._orientation;
        y2 = typeof y2 !== "number" ? or[1] : y2;
        z = typeof z !== "number" ? or[2] : z;
        xUp = typeof xUp !== "number" ? or[3] : xUp;
        yUp = typeof yUp !== "number" ? or[4] : yUp;
        zUp = typeof zUp !== "number" ? or[5] : zUp;
        if (typeof x2 === "number") {
          self2._orientation = [x2, y2, z, xUp, yUp, zUp];
          if (typeof self2.ctx.listener.forwardX !== "undefined") {
            self2.ctx.listener.forwardX.setTargetAtTime(x2, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.forwardY.setTargetAtTime(y2, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
            self2.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
          } else {
            self2.ctx.listener.setOrientation(x2, y2, z, xUp, yUp, zUp);
          }
        } else {
          return or;
        }
        return self2;
      };
      Howl.prototype.init = /* @__PURE__ */ function(_super) {
        return function(o2) {
          var self2 = this;
          self2._orientation = o2.orientation || [1, 0, 0];
          self2._stereo = o2.stereo || null;
          self2._pos = o2.pos || null;
          self2._pannerAttr = {
            coneInnerAngle: typeof o2.coneInnerAngle !== "undefined" ? o2.coneInnerAngle : 360,
            coneOuterAngle: typeof o2.coneOuterAngle !== "undefined" ? o2.coneOuterAngle : 360,
            coneOuterGain: typeof o2.coneOuterGain !== "undefined" ? o2.coneOuterGain : 0,
            distanceModel: typeof o2.distanceModel !== "undefined" ? o2.distanceModel : "inverse",
            maxDistance: typeof o2.maxDistance !== "undefined" ? o2.maxDistance : 1e4,
            panningModel: typeof o2.panningModel !== "undefined" ? o2.panningModel : "HRTF",
            refDistance: typeof o2.refDistance !== "undefined" ? o2.refDistance : 1,
            rolloffFactor: typeof o2.rolloffFactor !== "undefined" ? o2.rolloffFactor : 1
          };
          self2._onstereo = o2.onstereo ? [{ fn: o2.onstereo }] : [];
          self2._onpos = o2.onpos ? [{ fn: o2.onpos }] : [];
          self2._onorientation = o2.onorientation ? [{ fn: o2.onorientation }] : [];
          return _super.call(this, o2);
        };
      }(Howl.prototype.init);
      Howl.prototype.stereo = function(pan, id) {
        var self2 = this;
        if (!self2._webAudio) {
          return self2;
        }
        if (self2._state !== "loaded") {
          self2._queue.push({
            event: "stereo",
            action: function() {
              self2.stereo(pan, id);
            }
          });
          return self2;
        }
        var pannerType = typeof Howler.ctx.createStereoPanner === "undefined" ? "spatial" : "stereo";
        if (typeof id === "undefined") {
          if (typeof pan === "number") {
            self2._stereo = pan;
            self2._pos = [pan, 0, 0];
          } else {
            return self2._stereo;
          }
        }
        var ids = self2._getSoundIds(id);
        for (var i3 = 0; i3 < ids.length; i3++) {
          var sound = self2._soundById(ids[i3]);
          if (sound) {
            if (typeof pan === "number") {
              sound._stereo = pan;
              sound._pos = [pan, 0, 0];
              if (sound._node) {
                sound._pannerAttr.panningModel = "equalpower";
                if (!sound._panner || !sound._panner.pan) {
                  setupPanner(sound, pannerType);
                }
                if (pannerType === "spatial") {
                  if (typeof sound._panner.positionX !== "undefined") {
                    sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                    sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                    sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
                  } else {
                    sound._panner.setPosition(pan, 0, 0);
                  }
                } else {
                  sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
                }
              }
              self2._emit("stereo", sound._id);
            } else {
              return sound._stereo;
            }
          }
        }
        return self2;
      };
      Howl.prototype.pos = function(x2, y2, z, id) {
        var self2 = this;
        if (!self2._webAudio) {
          return self2;
        }
        if (self2._state !== "loaded") {
          self2._queue.push({
            event: "pos",
            action: function() {
              self2.pos(x2, y2, z, id);
            }
          });
          return self2;
        }
        y2 = typeof y2 !== "number" ? 0 : y2;
        z = typeof z !== "number" ? -0.5 : z;
        if (typeof id === "undefined") {
          if (typeof x2 === "number") {
            self2._pos = [x2, y2, z];
          } else {
            return self2._pos;
          }
        }
        var ids = self2._getSoundIds(id);
        for (var i3 = 0; i3 < ids.length; i3++) {
          var sound = self2._soundById(ids[i3]);
          if (sound) {
            if (typeof x2 === "number") {
              sound._pos = [x2, y2, z];
              if (sound._node) {
                if (!sound._panner || sound._panner.pan) {
                  setupPanner(sound, "spatial");
                }
                if (typeof sound._panner.positionX !== "undefined") {
                  sound._panner.positionX.setValueAtTime(x2, Howler.ctx.currentTime);
                  sound._panner.positionY.setValueAtTime(y2, Howler.ctx.currentTime);
                  sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
                } else {
                  sound._panner.setPosition(x2, y2, z);
                }
              }
              self2._emit("pos", sound._id);
            } else {
              return sound._pos;
            }
          }
        }
        return self2;
      };
      Howl.prototype.orientation = function(x2, y2, z, id) {
        var self2 = this;
        if (!self2._webAudio) {
          return self2;
        }
        if (self2._state !== "loaded") {
          self2._queue.push({
            event: "orientation",
            action: function() {
              self2.orientation(x2, y2, z, id);
            }
          });
          return self2;
        }
        y2 = typeof y2 !== "number" ? self2._orientation[1] : y2;
        z = typeof z !== "number" ? self2._orientation[2] : z;
        if (typeof id === "undefined") {
          if (typeof x2 === "number") {
            self2._orientation = [x2, y2, z];
          } else {
            return self2._orientation;
          }
        }
        var ids = self2._getSoundIds(id);
        for (var i3 = 0; i3 < ids.length; i3++) {
          var sound = self2._soundById(ids[i3]);
          if (sound) {
            if (typeof x2 === "number") {
              sound._orientation = [x2, y2, z];
              if (sound._node) {
                if (!sound._panner) {
                  if (!sound._pos) {
                    sound._pos = self2._pos || [0, 0, -0.5];
                  }
                  setupPanner(sound, "spatial");
                }
                if (typeof sound._panner.orientationX !== "undefined") {
                  sound._panner.orientationX.setValueAtTime(x2, Howler.ctx.currentTime);
                  sound._panner.orientationY.setValueAtTime(y2, Howler.ctx.currentTime);
                  sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
                } else {
                  sound._panner.setOrientation(x2, y2, z);
                }
              }
              self2._emit("orientation", sound._id);
            } else {
              return sound._orientation;
            }
          }
        }
        return self2;
      };
      Howl.prototype.pannerAttr = function() {
        var self2 = this;
        var args = arguments;
        var o2, id, sound;
        if (!self2._webAudio) {
          return self2;
        }
        if (args.length === 0) {
          return self2._pannerAttr;
        } else if (args.length === 1) {
          if (typeof args[0] === "object") {
            o2 = args[0];
            if (typeof id === "undefined") {
              if (!o2.pannerAttr) {
                o2.pannerAttr = {
                  coneInnerAngle: o2.coneInnerAngle,
                  coneOuterAngle: o2.coneOuterAngle,
                  coneOuterGain: o2.coneOuterGain,
                  distanceModel: o2.distanceModel,
                  maxDistance: o2.maxDistance,
                  refDistance: o2.refDistance,
                  rolloffFactor: o2.rolloffFactor,
                  panningModel: o2.panningModel
                };
              }
              self2._pannerAttr = {
                coneInnerAngle: typeof o2.pannerAttr.coneInnerAngle !== "undefined" ? o2.pannerAttr.coneInnerAngle : self2._coneInnerAngle,
                coneOuterAngle: typeof o2.pannerAttr.coneOuterAngle !== "undefined" ? o2.pannerAttr.coneOuterAngle : self2._coneOuterAngle,
                coneOuterGain: typeof o2.pannerAttr.coneOuterGain !== "undefined" ? o2.pannerAttr.coneOuterGain : self2._coneOuterGain,
                distanceModel: typeof o2.pannerAttr.distanceModel !== "undefined" ? o2.pannerAttr.distanceModel : self2._distanceModel,
                maxDistance: typeof o2.pannerAttr.maxDistance !== "undefined" ? o2.pannerAttr.maxDistance : self2._maxDistance,
                refDistance: typeof o2.pannerAttr.refDistance !== "undefined" ? o2.pannerAttr.refDistance : self2._refDistance,
                rolloffFactor: typeof o2.pannerAttr.rolloffFactor !== "undefined" ? o2.pannerAttr.rolloffFactor : self2._rolloffFactor,
                panningModel: typeof o2.pannerAttr.panningModel !== "undefined" ? o2.pannerAttr.panningModel : self2._panningModel
              };
            }
          } else {
            sound = self2._soundById(parseInt(args[0], 10));
            return sound ? sound._pannerAttr : self2._pannerAttr;
          }
        } else if (args.length === 2) {
          o2 = args[0];
          id = parseInt(args[1], 10);
        }
        var ids = self2._getSoundIds(id);
        for (var i3 = 0; i3 < ids.length; i3++) {
          sound = self2._soundById(ids[i3]);
          if (sound) {
            var pa = sound._pannerAttr;
            pa = {
              coneInnerAngle: typeof o2.coneInnerAngle !== "undefined" ? o2.coneInnerAngle : pa.coneInnerAngle,
              coneOuterAngle: typeof o2.coneOuterAngle !== "undefined" ? o2.coneOuterAngle : pa.coneOuterAngle,
              coneOuterGain: typeof o2.coneOuterGain !== "undefined" ? o2.coneOuterGain : pa.coneOuterGain,
              distanceModel: typeof o2.distanceModel !== "undefined" ? o2.distanceModel : pa.distanceModel,
              maxDistance: typeof o2.maxDistance !== "undefined" ? o2.maxDistance : pa.maxDistance,
              refDistance: typeof o2.refDistance !== "undefined" ? o2.refDistance : pa.refDistance,
              rolloffFactor: typeof o2.rolloffFactor !== "undefined" ? o2.rolloffFactor : pa.rolloffFactor,
              panningModel: typeof o2.panningModel !== "undefined" ? o2.panningModel : pa.panningModel
            };
            var panner = sound._panner;
            if (!panner) {
              if (!sound._pos) {
                sound._pos = self2._pos || [0, 0, -0.5];
              }
              setupPanner(sound, "spatial");
              panner = sound._panner;
            }
            panner.coneInnerAngle = pa.coneInnerAngle;
            panner.coneOuterAngle = pa.coneOuterAngle;
            panner.coneOuterGain = pa.coneOuterGain;
            panner.distanceModel = pa.distanceModel;
            panner.maxDistance = pa.maxDistance;
            panner.refDistance = pa.refDistance;
            panner.rolloffFactor = pa.rolloffFactor;
            panner.panningModel = pa.panningModel;
          }
        }
        return self2;
      };
      Sound.prototype.init = /* @__PURE__ */ function(_super) {
        return function() {
          var self2 = this;
          var parent2 = self2._parent;
          self2._orientation = parent2._orientation;
          self2._stereo = parent2._stereo;
          self2._pos = parent2._pos;
          self2._pannerAttr = parent2._pannerAttr;
          _super.call(this);
          if (self2._stereo) {
            parent2.stereo(self2._stereo);
          } else if (self2._pos) {
            parent2.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
          }
        };
      }(Sound.prototype.init);
      Sound.prototype.reset = /* @__PURE__ */ function(_super) {
        return function() {
          var self2 = this;
          var parent2 = self2._parent;
          self2._orientation = parent2._orientation;
          self2._stereo = parent2._stereo;
          self2._pos = parent2._pos;
          self2._pannerAttr = parent2._pannerAttr;
          if (self2._stereo) {
            parent2.stereo(self2._stereo);
          } else if (self2._pos) {
            parent2.pos(self2._pos[0], self2._pos[1], self2._pos[2], self2._id);
          } else if (self2._panner) {
            self2._panner.disconnect(0);
            self2._panner = void 0;
            parent2._refreshBuffer(self2);
          }
          return _super.call(this);
        };
      }(Sound.prototype.reset);
      var setupPanner = function(sound, type) {
        type = type || "spatial";
        if (type === "spatial") {
          sound._panner = Howler.ctx.createPanner();
          sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
          sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
          sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
          sound._panner.distanceModel = sound._pannerAttr.distanceModel;
          sound._panner.maxDistance = sound._pannerAttr.maxDistance;
          sound._panner.refDistance = sound._pannerAttr.refDistance;
          sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
          sound._panner.panningModel = sound._pannerAttr.panningModel;
          if (typeof sound._panner.positionX !== "undefined") {
            sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
            sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
            sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
          } else {
            sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
          }
          if (typeof sound._panner.orientationX !== "undefined") {
            sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
            sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
            sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
          } else {
            sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
          }
        } else {
          sound._panner = Howler.ctx.createStereoPanner();
          sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
        }
        sound._panner.connect(sound._node);
        if (!sound._paused) {
          sound._parent.pause(sound._id, true).play(sound._id, true);
        }
      };
    })();
  }
});

// node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS({
  "node_modules/seedrandom/lib/alea.js"(exports, module) {
    init_define_AnParams();
    (function(global2, module2, define2) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t2 = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t2 - (me.c = t2 | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy(f2, t2) {
        t2.c = f2.c;
        t2.s0 = f2.s0;
        t2.s1 = f2.s1;
        t2.s2 = f2.s2;
        return t2;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n2 = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i3 = 0; i3 < data.length; i3++) {
            n2 += data.charCodeAt(i3);
            var h2 = 0.02519603282416938 * n2;
            n2 = h2 >>> 0;
            h2 -= n2;
            h2 *= n2;
            n2 = h2 >>> 0;
            h2 -= n2;
            n2 += h2 * 4294967296;
          }
          return (n2 >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS({
  "node_modules/seedrandom/lib/xor128.js"(exports, module) {
    init_define_AnParams();
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t2 = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t2 ^ t2 >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k2 = 0; k2 < strseed.length + 64; k2++) {
          me.x ^= strseed.charCodeAt(k2) | 0;
          me.next();
        }
      }
      function copy(f2, t2) {
        t2.x = f2.x;
        t2.y = f2.y;
        t2.z = f2.z;
        t2.w = f2.w;
        return t2;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS({
  "node_modules/seedrandom/lib/xorwow.js"(exports, module) {
    init_define_AnParams();
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t2 = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t2 ^ t2 << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k2 = 0; k2 < strseed.length + 64; k2++) {
          me.x ^= strseed.charCodeAt(k2) | 0;
          if (k2 == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy(f2, t2) {
        t2.x = f2.x;
        t2.y = f2.y;
        t2.z = f2.z;
        t2.w = f2.w;
        t2.v = f2.v;
        t2.d = f2.d;
        return t2;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS({
  "node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
    init_define_AnParams();
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X = me.x, i3 = me.i, t2, v2, w2;
          t2 = X[i3];
          t2 ^= t2 >>> 7;
          v2 = t2 ^ t2 << 24;
          t2 = X[i3 + 1 & 7];
          v2 ^= t2 ^ t2 >>> 10;
          t2 = X[i3 + 3 & 7];
          v2 ^= t2 ^ t2 >>> 3;
          t2 = X[i3 + 4 & 7];
          v2 ^= t2 ^ t2 << 7;
          t2 = X[i3 + 7 & 7];
          t2 = t2 ^ t2 << 13;
          v2 ^= t2 ^ t2 << 9;
          X[i3] = v2;
          me.i = i3 + 1 & 7;
          return v2;
        };
        function init2(me2, seed2) {
          var j2, w2, X = [];
          if (seed2 === (seed2 | 0)) {
            w2 = X[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j2 = 0; j2 < seed2.length; ++j2) {
              X[j2 & 7] = X[j2 & 7] << 15 ^ seed2.charCodeAt(j2) + X[j2 + 1 & 7] << 13;
            }
          }
          while (X.length < 8) X.push(0);
          for (j2 = 0; j2 < 8 && X[j2] === 0; ++j2) ;
          if (j2 == 8) w2 = X[7] = -1;
          else w2 = X[j2];
          me2.x = X;
          me2.i = 0;
          for (j2 = 256; j2 > 0; --j2) {
            me2.next();
          }
        }
        init2(me, seed);
      }
      function copy(f2, t2) {
        t2.x = f2.x.slice();
        t2.i = f2.i;
        return t2;
      }
      function impl(seed, opts) {
        if (seed == null) seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x) copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS({
  "node_modules/seedrandom/lib/xor4096.js"(exports, module) {
    init_define_AnParams();
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w2 = me.w, X = me.X, i3 = me.i, t2, v2;
          me.w = w2 = w2 + 1640531527 | 0;
          v2 = X[i3 + 34 & 127];
          t2 = X[i3 = i3 + 1 & 127];
          v2 ^= v2 << 13;
          t2 ^= t2 << 17;
          v2 ^= v2 >>> 15;
          t2 ^= t2 >>> 12;
          v2 = X[i3] = v2 ^ t2;
          me.i = i3;
          return v2 + (w2 ^ w2 >>> 16) | 0;
        };
        function init2(me2, seed2) {
          var t2, v2, i3, j2, w2, X = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v2 = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v2 = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i3 = 0, j2 = -32; j2 < limit; ++j2) {
            if (seed2) v2 ^= seed2.charCodeAt((j2 + 32) % seed2.length);
            if (j2 === 0) w2 = v2;
            v2 ^= v2 << 10;
            v2 ^= v2 >>> 15;
            v2 ^= v2 << 4;
            v2 ^= v2 >>> 13;
            if (j2 >= 0) {
              w2 = w2 + 1640531527 | 0;
              t2 = X[j2 & 127] ^= v2 + w2;
              i3 = 0 == t2 ? i3 + 1 : 0;
            }
          }
          if (i3 >= 128) {
            X[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i3 = 127;
          for (j2 = 4 * 128; j2 > 0; --j2) {
            v2 = X[i3 + 34 & 127];
            t2 = X[i3 = i3 + 1 & 127];
            v2 ^= v2 << 13;
            t2 ^= t2 << 17;
            v2 ^= v2 >>> 15;
            t2 ^= t2 >>> 12;
            X[i3] = v2 ^ t2;
          }
          me2.w = w2;
          me2.X = X;
          me2.i = i3;
        }
        init2(me, seed);
      }
      function copy(f2, t2) {
        t2.i = f2.i;
        t2.w = f2.w;
        t2.X = f2.X.slice();
        return t2;
      }
      ;
      function impl(seed, opts) {
        if (seed == null) seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X) copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(
      exports,
      // window object or global
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS({
  "node_modules/seedrandom/lib/tychei.js"(exports, module) {
    init_define_AnParams();
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b3 = me.b, c2 = me.c, d2 = me.d, a2 = me.a;
          b3 = b3 << 25 ^ b3 >>> 7 ^ c2;
          c2 = c2 - d2 | 0;
          d2 = d2 << 24 ^ d2 >>> 8 ^ a2;
          a2 = a2 - b3 | 0;
          me.b = b3 = b3 << 20 ^ b3 >>> 12 ^ c2;
          me.c = c2 = c2 - d2 | 0;
          me.d = d2 << 16 ^ c2 >>> 16 ^ a2;
          return me.a = a2 - b3 | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k2 = 0; k2 < strseed.length + 20; k2++) {
          me.b ^= strseed.charCodeAt(k2) | 0;
          me.next();
        }
      }
      function copy(f2, t2) {
        t2.a = f2.a;
        t2.b = f2.b;
        t2.c = f2.c;
        t2.d = f2.d;
        return t2;
      }
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
    init_define_AnParams();
  }
});

// node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS({
  "node_modules/seedrandom/seedrandom.js"(exports, module) {
    init_define_AnParams();
    (function(global2, pool, math) {
      var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom2(seed, options, callback) {
        var key = [];
        options = options == true ? { entropy: true } : options || {};
        var shortseed = mixkey(flatten(
          options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
          3
        ), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n2 = arc4.g(chunks), d2 = startdenom, x2 = 0;
          while (n2 < significance) {
            n2 = (n2 + x2) * width;
            d2 *= width;
            x2 = arc4.g(1);
          }
          while (n2 >= overflow) {
            n2 /= 2;
            d2 /= 2;
            x2 >>>= 1;
          }
          return (n2 + x2) / d2;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math[rngname] = prng2;
            return seed2;
          } else return prng2;
        })(
          prng,
          shortseed,
          "global" in options ? options.global : this == math,
          options.state
        );
      }
      function ARC4(key) {
        var t2, keylen = key.length, me = this, i3 = 0, j2 = me.i = me.j = 0, s2 = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i3 < width) {
          s2[i3] = i3++;
        }
        for (i3 = 0; i3 < width; i3++) {
          s2[i3] = s2[j2 = mask & j2 + key[i3 % keylen] + (t2 = s2[i3])];
          s2[j2] = t2;
        }
        (me.g = function(count2) {
          var t3, r2 = 0, i4 = me.i, j3 = me.j, s3 = me.S;
          while (count2--) {
            t3 = s3[i4 = mask & i4 + 1];
            r2 = r2 * width + s3[mask & (s3[i4] = s3[j3 = mask & j3 + t3]) + (s3[j3] = t3)];
          }
          me.i = i4;
          me.j = j3;
          return r2;
        })(width);
      }
      function copy(f2, t2) {
        t2.i = f2.i;
        t2.j = f2.j;
        t2.S = f2.S.slice();
        return t2;
      }
      ;
      function flatten(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten(obj[prop], depth - 1));
            } catch (e2) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j2 = 0;
        while (j2 < stringseed.length) {
          key[mask & j2] = mask & (smear ^= key[mask & j2] * 19) + stringseed.charCodeAt(j2++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out2;
          if (nodecrypto && (out2 = nodecrypto.randomBytes)) {
            out2 = out2(width);
          } else {
            out2 = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out2);
          }
          return tostring(out2);
        } catch (e2) {
          var browser = global2.navigator, plugins = browser && browser.plugins;
          return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool)];
        }
      }
      function tostring(a2) {
        return String.fromCharCode.apply(0, a2);
      }
      mixkey(math.random(), pool);
      if (typeof module == "object" && module.exports) {
        module.exports = seedrandom2;
        try {
          nodecrypto = require_crypto();
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom2;
        });
      } else {
        math["seed" + rngname] = seedrandom2;
      }
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      typeof self !== "undefined" ? self : exports,
      [],
      // pool: entropy pool starts empty
      Math
      // math: package containing random, pow, and seedrandom
    );
  }
});

// node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS({
  "node_modules/seedrandom/index.js"(exports, module) {
    init_define_AnParams();
    var alea = require_alea();
    var xor128 = require_xor128();
    var xorwow = require_xorwow();
    var xorshift7 = require_xorshift7();
    var xor4096 = require_xor4096();
    var tychei = require_tychei();
    var sr = require_seedrandom();
    sr.alea = alea;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module.exports = sr;
  }
});

// node_modules/gameanalytics/dist/GameAnalytics.node.js
var require_GameAnalytics_node = __commonJS({
  "node_modules/gameanalytics/dist/GameAnalytics.node.js"(exports, module) {
    "use strict";
    init_define_AnParams();
    var CryptoJS = CryptoJS || function(h2, s2) {
      var f2 = {}, g2 = f2.lib = {}, q = function() {
      }, m2 = g2.Base = {
        extend: function(a2) {
          q.prototype = this;
          var c2 = new q();
          a2 && c2.mixIn(a2);
          c2.hasOwnProperty("init") || (c2.init = function() {
            c2.$super.init.apply(this, arguments);
          });
          c2.init.prototype = c2;
          c2.$super = this;
          return c2;
        },
        create: function() {
          var a2 = this.extend();
          a2.init.apply(a2, arguments);
          return a2;
        },
        init: function() {
        },
        mixIn: function(a2) {
          for (var c2 in a2) a2.hasOwnProperty(c2) && (this[c2] = a2[c2]);
          a2.hasOwnProperty("toString") && (this.toString = a2.toString);
        },
        clone: function() {
          return this.init.prototype.extend(this);
        }
      }, r2 = g2.WordArray = m2.extend({
        init: function(a2, c2) {
          a2 = this.words = a2 || [];
          this.sigBytes = c2 != s2 ? c2 : 4 * a2.length;
        },
        toString: function(a2) {
          return (a2 || k2).stringify(this);
        },
        concat: function(a2) {
          var c2 = this.words, d2 = a2.words, b3 = this.sigBytes;
          a2 = a2.sigBytes;
          this.clamp();
          if (b3 % 4)
            for (var e2 = 0; e2 < a2; e2++) c2[b3 + e2 >>> 2] |= (d2[e2 >>> 2] >>> 24 - 8 * (e2 % 4) & 255) << 24 - 8 * ((b3 + e2) % 4);
          else if (65535 < d2.length)
            for (e2 = 0; e2 < a2; e2 += 4) c2[b3 + e2 >>> 2] = d2[e2 >>> 2];
          else c2.push.apply(c2, d2);
          this.sigBytes += a2;
          return this;
        },
        clamp: function() {
          var a2 = this.words, c2 = this.sigBytes;
          a2[c2 >>> 2] &= 4294967295 << 32 - 8 * (c2 % 4);
          a2.length = h2.ceil(c2 / 4);
        },
        clone: function() {
          var a2 = m2.clone.call(this);
          a2.words = this.words.slice(0);
          return a2;
        },
        random: function(a2) {
          for (var c2 = [], d2 = 0; d2 < a2; d2 += 4) c2.push(4294967296 * h2.random() | 0);
          return new r2.init(c2, a2);
        }
      }), l2 = f2.enc = {}, k2 = l2.Hex = {
        stringify: function(a2) {
          var c2 = a2.words;
          a2 = a2.sigBytes;
          for (var d2 = [], b3 = 0; b3 < a2; b3++) {
            var e2 = c2[b3 >>> 2] >>> 24 - 8 * (b3 % 4) & 255;
            d2.push((e2 >>> 4).toString(16));
            d2.push((e2 & 15).toString(16));
          }
          return d2.join("");
        },
        parse: function(a2) {
          for (var c2 = a2.length, d2 = [], b3 = 0; b3 < c2; b3 += 2) d2[b3 >>> 3] |= parseInt(a2.substr(
            b3,
            2
          ), 16) << 24 - 4 * (b3 % 8);
          return new r2.init(d2, c2 / 2);
        }
      }, n2 = l2.Latin1 = {
        stringify: function(a2) {
          var c2 = a2.words;
          a2 = a2.sigBytes;
          for (var d2 = [], b3 = 0; b3 < a2; b3++) d2.push(String.fromCharCode(c2[b3 >>> 2] >>> 24 - 8 * (b3 % 4) & 255));
          return d2.join("");
        },
        parse: function(a2) {
          for (var c2 = a2.length, d2 = [], b3 = 0; b3 < c2; b3++) d2[b3 >>> 2] |= (a2.charCodeAt(b3) & 255) << 24 - 8 * (b3 % 4);
          return new r2.init(d2, c2);
        }
      }, j2 = l2.Utf8 = {
        stringify: function(a2) {
          try {
            return decodeURIComponent(escape(n2.stringify(a2)));
          } catch (c2) {
            throw Error("Malformed UTF-8 data");
          }
        },
        parse: function(a2) {
          return n2.parse(unescape(encodeURIComponent(a2)));
        }
      }, u2 = g2.BufferedBlockAlgorithm = m2.extend({
        reset: function() {
          this._data = new r2.init();
          this._nDataBytes = 0;
        },
        _append: function(a2) {
          "string" == typeof a2 && (a2 = j2.parse(a2));
          this._data.concat(a2);
          this._nDataBytes += a2.sigBytes;
        },
        _process: function(a2) {
          var c2 = this._data, d2 = c2.words, b3 = c2.sigBytes, e2 = this.blockSize, f3 = b3 / (4 * e2), f3 = a2 ? h2.ceil(f3) : h2.max((f3 | 0) - this._minBufferSize, 0);
          a2 = f3 * e2;
          b3 = h2.min(4 * a2, b3);
          if (a2) {
            for (var g3 = 0; g3 < a2; g3 += e2) this._doProcessBlock(d2, g3);
            g3 = d2.splice(0, a2);
            c2.sigBytes -= b3;
          }
          return new r2.init(g3, b3);
        },
        clone: function() {
          var a2 = m2.clone.call(this);
          a2._data = this._data.clone();
          return a2;
        },
        _minBufferSize: 0
      });
      g2.Hasher = u2.extend({
        cfg: m2.extend(),
        init: function(a2) {
          this.cfg = this.cfg.extend(a2);
          this.reset();
        },
        reset: function() {
          u2.reset.call(this);
          this._doReset();
        },
        update: function(a2) {
          this._append(a2);
          this._process();
          return this;
        },
        finalize: function(a2) {
          a2 && this._append(a2);
          return this._doFinalize();
        },
        blockSize: 16,
        _createHelper: function(a2) {
          return function(c2, d2) {
            return new a2.init(d2).finalize(c2);
          };
        },
        _createHmacHelper: function(a2) {
          return function(c2, d2) {
            return new t2.HMAC.init(
              a2,
              d2
            ).finalize(c2);
          };
        }
      });
      var t2 = f2.algo = {};
      return f2;
    }(Math);
    (function(h2) {
      for (var s2 = CryptoJS, f2 = s2.lib, g2 = f2.WordArray, q = f2.Hasher, f2 = s2.algo, m2 = [], r2 = [], l2 = function(a3) {
        return 4294967296 * (a3 - (a3 | 0)) | 0;
      }, k2 = 2, n2 = 0; 64 > n2; ) {
        var j2;
        a: {
          j2 = k2;
          for (var u2 = h2.sqrt(j2), t2 = 2; t2 <= u2; t2++)
            if (!(j2 % t2)) {
              j2 = false;
              break a;
            }
          j2 = true;
        }
        j2 && (8 > n2 && (m2[n2] = l2(h2.pow(k2, 0.5))), r2[n2] = l2(h2.pow(k2, 1 / 3)), n2++);
        k2++;
      }
      var a2 = [], f2 = f2.SHA256 = q.extend({
        _doReset: function() {
          this._hash = new g2.init(m2.slice(0));
        },
        _doProcessBlock: function(c2, d2) {
          for (var b3 = this._hash.words, e2 = b3[0], f3 = b3[1], g3 = b3[2], j3 = b3[3], h3 = b3[4], m3 = b3[5], n3 = b3[6], q2 = b3[7], p2 = 0; 64 > p2; p2++) {
            if (16 > p2) a2[p2] = c2[d2 + p2] | 0;
            else {
              var k3 = a2[p2 - 15], l3 = a2[p2 - 2];
              a2[p2] = ((k3 << 25 | k3 >>> 7) ^ (k3 << 14 | k3 >>> 18) ^ k3 >>> 3) + a2[p2 - 7] + ((l3 << 15 | l3 >>> 17) ^ (l3 << 13 | l3 >>> 19) ^ l3 >>> 10) + a2[p2 - 16];
            }
            k3 = q2 + ((h3 << 26 | h3 >>> 6) ^ (h3 << 21 | h3 >>> 11) ^ (h3 << 7 | h3 >>> 25)) + (h3 & m3 ^ ~h3 & n3) + r2[p2] + a2[p2];
            l3 = ((e2 << 30 | e2 >>> 2) ^ (e2 << 19 | e2 >>> 13) ^ (e2 << 10 | e2 >>> 22)) + (e2 & f3 ^ e2 & g3 ^ f3 & g3);
            q2 = n3;
            n3 = m3;
            m3 = h3;
            h3 = j3 + k3 | 0;
            j3 = g3;
            g3 = f3;
            f3 = e2;
            e2 = k3 + l3 | 0;
          }
          b3[0] = b3[0] + e2 | 0;
          b3[1] = b3[1] + f3 | 0;
          b3[2] = b3[2] + g3 | 0;
          b3[3] = b3[3] + j3 | 0;
          b3[4] = b3[4] + h3 | 0;
          b3[5] = b3[5] + m3 | 0;
          b3[6] = b3[6] + n3 | 0;
          b3[7] = b3[7] + q2 | 0;
        },
        _doFinalize: function() {
          var a3 = this._data, d2 = a3.words, b3 = 8 * this._nDataBytes, e2 = 8 * a3.sigBytes;
          d2[e2 >>> 5] |= 128 << 24 - e2 % 32;
          d2[(e2 + 64 >>> 9 << 4) + 14] = h2.floor(b3 / 4294967296);
          d2[(e2 + 64 >>> 9 << 4) + 15] = b3;
          a3.sigBytes = 4 * d2.length;
          this._process();
          return this._hash;
        },
        clone: function() {
          var a3 = q.clone.call(this);
          a3._hash = this._hash.clone();
          return a3;
        }
      });
      s2.SHA256 = q._createHelper(f2);
      s2.HmacSHA256 = q._createHmacHelper(f2);
    })(Math);
    (function() {
      var h2 = CryptoJS, s2 = h2.enc.Utf8;
      h2.algo.HMAC = h2.lib.Base.extend({
        init: function(f2, g2) {
          f2 = this._hasher = new f2.init();
          "string" == typeof g2 && (g2 = s2.parse(g2));
          var h3 = f2.blockSize, m2 = 4 * h3;
          g2.sigBytes > m2 && (g2 = f2.finalize(g2));
          g2.clamp();
          for (var r2 = this._oKey = g2.clone(), l2 = this._iKey = g2.clone(), k2 = r2.words, n2 = l2.words, j2 = 0; j2 < h3; j2++) k2[j2] ^= 1549556828, n2[j2] ^= 909522486;
          r2.sigBytes = l2.sigBytes = m2;
          this.reset();
        },
        reset: function() {
          var f2 = this._hasher;
          f2.reset();
          f2.update(this._iKey);
        },
        update: function(f2) {
          this._hasher.update(f2);
          return this;
        },
        finalize: function(f2) {
          var g2 = this._hasher;
          f2 = g2.finalize(f2);
          g2.reset();
          return g2.finalize(this._oKey.clone().concat(f2));
        }
      });
    })();
    (function() {
      var h2 = CryptoJS, j2 = h2.lib.WordArray;
      h2.enc.Base64 = {
        stringify: function(b3) {
          var e2 = b3.words, f2 = b3.sigBytes, c2 = this._map;
          b3.clamp();
          b3 = [];
          for (var a2 = 0; a2 < f2; a2 += 3)
            for (var d2 = (e2[a2 >>> 2] >>> 24 - 8 * (a2 % 4) & 255) << 16 | (e2[a2 + 1 >>> 2] >>> 24 - 8 * ((a2 + 1) % 4) & 255) << 8 | e2[a2 + 2 >>> 2] >>> 24 - 8 * ((a2 + 2) % 4) & 255, g2 = 0; 4 > g2 && a2 + 0.75 * g2 < f2; g2++) b3.push(c2.charAt(d2 >>> 6 * (3 - g2) & 63));
          if (e2 = c2.charAt(64))
            for (; b3.length % 4; ) b3.push(e2);
          return b3.join("");
        },
        parse: function(b3) {
          var e2 = b3.length, f2 = this._map, c2 = f2.charAt(64);
          c2 && (c2 = b3.indexOf(c2), -1 != c2 && (e2 = c2));
          for (var c2 = [], a2 = 0, d2 = 0; d2 < e2; d2++)
            if (d2 % 4) {
              var g2 = f2.indexOf(b3.charAt(d2 - 1)) << 2 * (d2 % 4), h3 = f2.indexOf(b3.charAt(d2)) >>> 6 - 2 * (d2 % 4);
              c2[a2 >>> 2] |= (g2 | h3) << 24 - 8 * (a2 % 4);
              a2++;
            }
          return j2.create(c2, a2);
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
      };
    })();
    var gameanalytics;
    (function(gameanalytics2) {
      var EGAErrorSeverity;
      (function(EGAErrorSeverity2) {
        EGAErrorSeverity2[EGAErrorSeverity2["Undefined"] = 0] = "Undefined";
        EGAErrorSeverity2[EGAErrorSeverity2["Debug"] = 1] = "Debug";
        EGAErrorSeverity2[EGAErrorSeverity2["Info"] = 2] = "Info";
        EGAErrorSeverity2[EGAErrorSeverity2["Warning"] = 3] = "Warning";
        EGAErrorSeverity2[EGAErrorSeverity2["Error"] = 4] = "Error";
        EGAErrorSeverity2[EGAErrorSeverity2["Critical"] = 5] = "Critical";
      })(EGAErrorSeverity = gameanalytics2.EGAErrorSeverity || (gameanalytics2.EGAErrorSeverity = {}));
      var EGAProgressionStatus;
      (function(EGAProgressionStatus2) {
        EGAProgressionStatus2[EGAProgressionStatus2["Undefined"] = 0] = "Undefined";
        EGAProgressionStatus2[EGAProgressionStatus2["Start"] = 1] = "Start";
        EGAProgressionStatus2[EGAProgressionStatus2["Complete"] = 2] = "Complete";
        EGAProgressionStatus2[EGAProgressionStatus2["Fail"] = 3] = "Fail";
      })(EGAProgressionStatus = gameanalytics2.EGAProgressionStatus || (gameanalytics2.EGAProgressionStatus = {}));
      var EGAResourceFlowType;
      (function(EGAResourceFlowType2) {
        EGAResourceFlowType2[EGAResourceFlowType2["Undefined"] = 0] = "Undefined";
        EGAResourceFlowType2[EGAResourceFlowType2["Source"] = 1] = "Source";
        EGAResourceFlowType2[EGAResourceFlowType2["Sink"] = 2] = "Sink";
      })(EGAResourceFlowType = gameanalytics2.EGAResourceFlowType || (gameanalytics2.EGAResourceFlowType = {}));
      var EGAAdAction;
      (function(EGAAdAction2) {
        EGAAdAction2[EGAAdAction2["Undefined"] = 0] = "Undefined";
        EGAAdAction2[EGAAdAction2["Clicked"] = 1] = "Clicked";
        EGAAdAction2[EGAAdAction2["Show"] = 2] = "Show";
        EGAAdAction2[EGAAdAction2["FailedShow"] = 3] = "FailedShow";
        EGAAdAction2[EGAAdAction2["RewardReceived"] = 4] = "RewardReceived";
      })(EGAAdAction = gameanalytics2.EGAAdAction || (gameanalytics2.EGAAdAction = {}));
      var EGAAdError;
      (function(EGAAdError2) {
        EGAAdError2[EGAAdError2["Undefined"] = 0] = "Undefined";
        EGAAdError2[EGAAdError2["Unknown"] = 1] = "Unknown";
        EGAAdError2[EGAAdError2["Offline"] = 2] = "Offline";
        EGAAdError2[EGAAdError2["NoFill"] = 3] = "NoFill";
        EGAAdError2[EGAAdError2["InternalError"] = 4] = "InternalError";
        EGAAdError2[EGAAdError2["InvalidRequest"] = 5] = "InvalidRequest";
        EGAAdError2[EGAAdError2["UnableToPrecache"] = 6] = "UnableToPrecache";
      })(EGAAdError = gameanalytics2.EGAAdError || (gameanalytics2.EGAAdError = {}));
      var EGAAdType;
      (function(EGAAdType2) {
        EGAAdType2[EGAAdType2["Undefined"] = 0] = "Undefined";
        EGAAdType2[EGAAdType2["Video"] = 1] = "Video";
        EGAAdType2[EGAAdType2["RewardedVideo"] = 2] = "RewardedVideo";
        EGAAdType2[EGAAdType2["Playable"] = 3] = "Playable";
        EGAAdType2[EGAAdType2["Interstitial"] = 4] = "Interstitial";
        EGAAdType2[EGAAdType2["OfferWall"] = 5] = "OfferWall";
        EGAAdType2[EGAAdType2["Banner"] = 6] = "Banner";
      })(EGAAdType = gameanalytics2.EGAAdType || (gameanalytics2.EGAAdType = {}));
      var http;
      (function(http2) {
        var EGAHTTPApiResponse;
        (function(EGAHTTPApiResponse2) {
          EGAHTTPApiResponse2[EGAHTTPApiResponse2["NoResponse"] = 0] = "NoResponse";
          EGAHTTPApiResponse2[EGAHTTPApiResponse2["BadResponse"] = 1] = "BadResponse";
          EGAHTTPApiResponse2[EGAHTTPApiResponse2["RequestTimeout"] = 2] = "RequestTimeout";
          EGAHTTPApiResponse2[EGAHTTPApiResponse2["JsonEncodeFailed"] = 3] = "JsonEncodeFailed";
          EGAHTTPApiResponse2[EGAHTTPApiResponse2["JsonDecodeFailed"] = 4] = "JsonDecodeFailed";
          EGAHTTPApiResponse2[EGAHTTPApiResponse2["InternalServerError"] = 5] = "InternalServerError";
          EGAHTTPApiResponse2[EGAHTTPApiResponse2["BadRequest"] = 6] = "BadRequest";
          EGAHTTPApiResponse2[EGAHTTPApiResponse2["Unauthorized"] = 7] = "Unauthorized";
          EGAHTTPApiResponse2[EGAHTTPApiResponse2["UnknownResponseCode"] = 8] = "UnknownResponseCode";
          EGAHTTPApiResponse2[EGAHTTPApiResponse2["Ok"] = 9] = "Ok";
          EGAHTTPApiResponse2[EGAHTTPApiResponse2["Created"] = 10] = "Created";
        })(EGAHTTPApiResponse = http2.EGAHTTPApiResponse || (http2.EGAHTTPApiResponse = {}));
      })(http = gameanalytics2.http || (gameanalytics2.http = {}));
      var events;
      (function(events2) {
        var EGASdkErrorCategory;
        (function(EGASdkErrorCategory2) {
          EGASdkErrorCategory2[EGASdkErrorCategory2["Undefined"] = 0] = "Undefined";
          EGASdkErrorCategory2[EGASdkErrorCategory2["EventValidation"] = 1] = "EventValidation";
          EGASdkErrorCategory2[EGASdkErrorCategory2["Database"] = 2] = "Database";
          EGASdkErrorCategory2[EGASdkErrorCategory2["Init"] = 3] = "Init";
          EGASdkErrorCategory2[EGASdkErrorCategory2["Http"] = 4] = "Http";
          EGASdkErrorCategory2[EGASdkErrorCategory2["Json"] = 5] = "Json";
        })(EGASdkErrorCategory = events2.EGASdkErrorCategory || (events2.EGASdkErrorCategory = {}));
        var EGASdkErrorArea;
        (function(EGASdkErrorArea2) {
          EGASdkErrorArea2[EGASdkErrorArea2["Undefined"] = 0] = "Undefined";
          EGASdkErrorArea2[EGASdkErrorArea2["BusinessEvent"] = 1] = "BusinessEvent";
          EGASdkErrorArea2[EGASdkErrorArea2["ResourceEvent"] = 2] = "ResourceEvent";
          EGASdkErrorArea2[EGASdkErrorArea2["ProgressionEvent"] = 3] = "ProgressionEvent";
          EGASdkErrorArea2[EGASdkErrorArea2["DesignEvent"] = 4] = "DesignEvent";
          EGASdkErrorArea2[EGASdkErrorArea2["ErrorEvent"] = 5] = "ErrorEvent";
          EGASdkErrorArea2[EGASdkErrorArea2["InitHttp"] = 9] = "InitHttp";
          EGASdkErrorArea2[EGASdkErrorArea2["EventsHttp"] = 10] = "EventsHttp";
          EGASdkErrorArea2[EGASdkErrorArea2["ProcessEvents"] = 11] = "ProcessEvents";
          EGASdkErrorArea2[EGASdkErrorArea2["AddEventsToStore"] = 12] = "AddEventsToStore";
          EGASdkErrorArea2[EGASdkErrorArea2["AdEvent"] = 20] = "AdEvent";
        })(EGASdkErrorArea = events2.EGASdkErrorArea || (events2.EGASdkErrorArea = {}));
        var EGASdkErrorAction;
        (function(EGASdkErrorAction2) {
          EGASdkErrorAction2[EGASdkErrorAction2["Undefined"] = 0] = "Undefined";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidCurrency"] = 1] = "InvalidCurrency";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidShortString"] = 2] = "InvalidShortString";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidEventPartLength"] = 3] = "InvalidEventPartLength";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidEventPartCharacters"] = 4] = "InvalidEventPartCharacters";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidStore"] = 5] = "InvalidStore";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidFlowType"] = 6] = "InvalidFlowType";
          EGASdkErrorAction2[EGASdkErrorAction2["StringEmptyOrNull"] = 7] = "StringEmptyOrNull";
          EGASdkErrorAction2[EGASdkErrorAction2["NotFoundInAvailableCurrencies"] = 8] = "NotFoundInAvailableCurrencies";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidAmount"] = 9] = "InvalidAmount";
          EGASdkErrorAction2[EGASdkErrorAction2["NotFoundInAvailableItemTypes"] = 10] = "NotFoundInAvailableItemTypes";
          EGASdkErrorAction2[EGASdkErrorAction2["WrongProgressionOrder"] = 11] = "WrongProgressionOrder";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidEventIdLength"] = 12] = "InvalidEventIdLength";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidEventIdCharacters"] = 13] = "InvalidEventIdCharacters";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidProgressionStatus"] = 15] = "InvalidProgressionStatus";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidSeverity"] = 16] = "InvalidSeverity";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidLongString"] = 17] = "InvalidLongString";
          EGASdkErrorAction2[EGASdkErrorAction2["DatabaseTooLarge"] = 18] = "DatabaseTooLarge";
          EGASdkErrorAction2[EGASdkErrorAction2["DatabaseOpenOrCreate"] = 19] = "DatabaseOpenOrCreate";
          EGASdkErrorAction2[EGASdkErrorAction2["JsonError"] = 25] = "JsonError";
          EGASdkErrorAction2[EGASdkErrorAction2["FailHttpJsonDecode"] = 29] = "FailHttpJsonDecode";
          EGASdkErrorAction2[EGASdkErrorAction2["FailHttpJsonEncode"] = 30] = "FailHttpJsonEncode";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidAdAction"] = 31] = "InvalidAdAction";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidAdType"] = 32] = "InvalidAdType";
          EGASdkErrorAction2[EGASdkErrorAction2["InvalidString"] = 33] = "InvalidString";
        })(EGASdkErrorAction = events2.EGASdkErrorAction || (events2.EGASdkErrorAction = {}));
        var EGASdkErrorParameter;
        (function(EGASdkErrorParameter2) {
          EGASdkErrorParameter2[EGASdkErrorParameter2["Undefined"] = 0] = "Undefined";
          EGASdkErrorParameter2[EGASdkErrorParameter2["Currency"] = 1] = "Currency";
          EGASdkErrorParameter2[EGASdkErrorParameter2["CartType"] = 2] = "CartType";
          EGASdkErrorParameter2[EGASdkErrorParameter2["ItemType"] = 3] = "ItemType";
          EGASdkErrorParameter2[EGASdkErrorParameter2["ItemId"] = 4] = "ItemId";
          EGASdkErrorParameter2[EGASdkErrorParameter2["Store"] = 5] = "Store";
          EGASdkErrorParameter2[EGASdkErrorParameter2["FlowType"] = 6] = "FlowType";
          EGASdkErrorParameter2[EGASdkErrorParameter2["Amount"] = 7] = "Amount";
          EGASdkErrorParameter2[EGASdkErrorParameter2["Progression01"] = 8] = "Progression01";
          EGASdkErrorParameter2[EGASdkErrorParameter2["Progression02"] = 9] = "Progression02";
          EGASdkErrorParameter2[EGASdkErrorParameter2["Progression03"] = 10] = "Progression03";
          EGASdkErrorParameter2[EGASdkErrorParameter2["EventId"] = 11] = "EventId";
          EGASdkErrorParameter2[EGASdkErrorParameter2["ProgressionStatus"] = 12] = "ProgressionStatus";
          EGASdkErrorParameter2[EGASdkErrorParameter2["Severity"] = 13] = "Severity";
          EGASdkErrorParameter2[EGASdkErrorParameter2["Message"] = 14] = "Message";
          EGASdkErrorParameter2[EGASdkErrorParameter2["AdAction"] = 15] = "AdAction";
          EGASdkErrorParameter2[EGASdkErrorParameter2["AdType"] = 16] = "AdType";
          EGASdkErrorParameter2[EGASdkErrorParameter2["AdSdkName"] = 17] = "AdSdkName";
          EGASdkErrorParameter2[EGASdkErrorParameter2["AdPlacement"] = 18] = "AdPlacement";
        })(EGASdkErrorParameter = events2.EGASdkErrorParameter || (events2.EGASdkErrorParameter = {}));
      })(events = gameanalytics2.events || (gameanalytics2.events = {}));
    })(gameanalytics || (gameanalytics = {}));
    var public_enums;
    (function(public_enums2) {
      var EGAErrorSeverity;
      (function(EGAErrorSeverity2) {
        EGAErrorSeverity2[EGAErrorSeverity2["Undefined"] = 0] = "Undefined";
        EGAErrorSeverity2[EGAErrorSeverity2["Debug"] = 1] = "Debug";
        EGAErrorSeverity2[EGAErrorSeverity2["Info"] = 2] = "Info";
        EGAErrorSeverity2[EGAErrorSeverity2["Warning"] = 3] = "Warning";
        EGAErrorSeverity2[EGAErrorSeverity2["Error"] = 4] = "Error";
        EGAErrorSeverity2[EGAErrorSeverity2["Critical"] = 5] = "Critical";
      })(EGAErrorSeverity = public_enums2.EGAErrorSeverity || (public_enums2.EGAErrorSeverity = {}));
      var EGAProgressionStatus;
      (function(EGAProgressionStatus2) {
        EGAProgressionStatus2[EGAProgressionStatus2["Undefined"] = 0] = "Undefined";
        EGAProgressionStatus2[EGAProgressionStatus2["Start"] = 1] = "Start";
        EGAProgressionStatus2[EGAProgressionStatus2["Complete"] = 2] = "Complete";
        EGAProgressionStatus2[EGAProgressionStatus2["Fail"] = 3] = "Fail";
      })(EGAProgressionStatus = public_enums2.EGAProgressionStatus || (public_enums2.EGAProgressionStatus = {}));
      var EGAResourceFlowType;
      (function(EGAResourceFlowType2) {
        EGAResourceFlowType2[EGAResourceFlowType2["Undefined"] = 0] = "Undefined";
        EGAResourceFlowType2[EGAResourceFlowType2["Source"] = 1] = "Source";
        EGAResourceFlowType2[EGAResourceFlowType2["Sink"] = 2] = "Sink";
      })(EGAResourceFlowType = public_enums2.EGAResourceFlowType || (public_enums2.EGAResourceFlowType = {}));
      var EGAAdAction;
      (function(EGAAdAction2) {
        EGAAdAction2[EGAAdAction2["Undefined"] = 0] = "Undefined";
        EGAAdAction2[EGAAdAction2["Clicked"] = 1] = "Clicked";
        EGAAdAction2[EGAAdAction2["Show"] = 2] = "Show";
        EGAAdAction2[EGAAdAction2["FailedShow"] = 3] = "FailedShow";
        EGAAdAction2[EGAAdAction2["RewardReceived"] = 4] = "RewardReceived";
      })(EGAAdAction = public_enums2.EGAAdAction || (public_enums2.EGAAdAction = {}));
      var EGAAdError;
      (function(EGAAdError2) {
        EGAAdError2[EGAAdError2["Undefined"] = 0] = "Undefined";
        EGAAdError2[EGAAdError2["Unknown"] = 1] = "Unknown";
        EGAAdError2[EGAAdError2["Offline"] = 2] = "Offline";
        EGAAdError2[EGAAdError2["NoFill"] = 3] = "NoFill";
        EGAAdError2[EGAAdError2["InternalError"] = 4] = "InternalError";
        EGAAdError2[EGAAdError2["InvalidRequest"] = 5] = "InvalidRequest";
        EGAAdError2[EGAAdError2["UnableToPrecache"] = 6] = "UnableToPrecache";
      })(EGAAdError = public_enums2.EGAAdError || (public_enums2.EGAAdError = {}));
      var EGAAdType;
      (function(EGAAdType2) {
        EGAAdType2[EGAAdType2["Undefined"] = 0] = "Undefined";
        EGAAdType2[EGAAdType2["Video"] = 1] = "Video";
        EGAAdType2[EGAAdType2["RewardedVideo"] = 2] = "RewardedVideo";
        EGAAdType2[EGAAdType2["Playable"] = 3] = "Playable";
        EGAAdType2[EGAAdType2["Interstitial"] = 4] = "Interstitial";
        EGAAdType2[EGAAdType2["OfferWall"] = 5] = "OfferWall";
        EGAAdType2[EGAAdType2["Banner"] = 6] = "Banner";
      })(EGAAdType = public_enums2.EGAAdType || (public_enums2.EGAAdType = {}));
    })(public_enums || (public_enums = {}));
    var gameanalytics;
    (function(gameanalytics2) {
      var logging;
      (function(logging2) {
        var EGALoggerMessageType;
        (function(EGALoggerMessageType2) {
          EGALoggerMessageType2[EGALoggerMessageType2["Error"] = 0] = "Error";
          EGALoggerMessageType2[EGALoggerMessageType2["Warning"] = 1] = "Warning";
          EGALoggerMessageType2[EGALoggerMessageType2["Info"] = 2] = "Info";
          EGALoggerMessageType2[EGALoggerMessageType2["Debug"] = 3] = "Debug";
        })(EGALoggerMessageType || (EGALoggerMessageType = {}));
        var GALogger = function() {
          function GALogger2() {
            GALogger2.debugEnabled = false;
          }
          GALogger2.setInfoLog = function(value) {
            GALogger2.instance.infoLogEnabled = value;
          };
          GALogger2.setVerboseLog = function(value) {
            GALogger2.instance.infoLogVerboseEnabled = value;
          };
          GALogger2.i = function(format) {
            if (!GALogger2.instance.infoLogEnabled) {
              return;
            }
            var message = "Info/" + GALogger2.Tag + ": " + format;
            GALogger2.instance.sendNotificationMessage(message, EGALoggerMessageType.Info);
          };
          GALogger2.w = function(format) {
            var message = "Warning/" + GALogger2.Tag + ": " + format;
            GALogger2.instance.sendNotificationMessage(message, EGALoggerMessageType.Warning);
          };
          GALogger2.e = function(format) {
            var message = "Error/" + GALogger2.Tag + ": " + format;
            GALogger2.instance.sendNotificationMessage(message, EGALoggerMessageType.Error);
          };
          GALogger2.ii = function(format) {
            if (!GALogger2.instance.infoLogVerboseEnabled) {
              return;
            }
            var message = "Verbose/" + GALogger2.Tag + ": " + format;
            GALogger2.instance.sendNotificationMessage(message, EGALoggerMessageType.Info);
          };
          GALogger2.d = function(format) {
            if (!GALogger2.debugEnabled) {
              return;
            }
            var message = "Debug/" + GALogger2.Tag + ": " + format;
            GALogger2.instance.sendNotificationMessage(message, EGALoggerMessageType.Debug);
          };
          GALogger2.prototype.sendNotificationMessage = function(message, type) {
            switch (type) {
              case EGALoggerMessageType.Error:
                {
                  console.error(message);
                }
                break;
              case EGALoggerMessageType.Warning:
                {
                  console.warn(message);
                }
                break;
              case EGALoggerMessageType.Debug:
                {
                  if (typeof console.debug === "function") {
                    console.debug(message);
                  } else {
                    console.log(message);
                  }
                }
                break;
              case EGALoggerMessageType.Info:
                {
                  console.log(message);
                }
                break;
            }
          };
          GALogger2.instance = new GALogger2();
          GALogger2.Tag = "GameAnalytics";
          return GALogger2;
        }();
        logging2.GALogger = GALogger;
      })(logging = gameanalytics2.logging || (gameanalytics2.logging = {}));
    })(gameanalytics || (gameanalytics = {}));
    var gameanalytics;
    (function(gameanalytics2) {
      var utilities;
      (function(utilities2) {
        var GALogger = gameanalytics2.logging.GALogger;
        var GAUtilities = function() {
          function GAUtilities2() {
          }
          GAUtilities2.getHmac = function(key, data) {
            var encryptedMessage = CryptoJS.HmacSHA256(data, key);
            return CryptoJS.enc.Base64.stringify(encryptedMessage);
          };
          GAUtilities2.stringMatch = function(s2, pattern) {
            if (!s2 || !pattern) {
              return false;
            }
            return pattern.test(s2);
          };
          GAUtilities2.joinStringArray = function(v2, delimiter) {
            var result = "";
            for (var i3 = 0, il = v2.length; i3 < il; i3++) {
              if (i3 > 0) {
                result += delimiter;
              }
              result += v2[i3];
            }
            return result;
          };
          GAUtilities2.stringArrayContainsString = function(array, search) {
            if (array.length === 0) {
              return false;
            }
            for (var s2 in array) {
              if (array[s2] === search) {
                return true;
              }
            }
            return false;
          };
          GAUtilities2.encode64 = function(input) {
            input = encodeURI(input);
            var output = "";
            var chr1, chr2, chr3 = 0;
            var enc1, enc2, enc3, enc4 = 0;
            var i3 = 0;
            do {
              chr1 = input.charCodeAt(i3++);
              chr2 = input.charCodeAt(i3++);
              chr3 = input.charCodeAt(i3++);
              enc1 = chr1 >> 2;
              enc2 = (chr1 & 3) << 4 | chr2 >> 4;
              enc3 = (chr2 & 15) << 2 | chr3 >> 6;
              enc4 = chr3 & 63;
              if (isNaN(chr2)) {
                enc3 = enc4 = 64;
              } else if (isNaN(chr3)) {
                enc4 = 64;
              }
              output = output + GAUtilities2.keyStr.charAt(enc1) + GAUtilities2.keyStr.charAt(enc2) + GAUtilities2.keyStr.charAt(enc3) + GAUtilities2.keyStr.charAt(enc4);
              chr1 = chr2 = chr3 = 0;
              enc1 = enc2 = enc3 = enc4 = 0;
            } while (i3 < input.length);
            return output;
          };
          GAUtilities2.decode64 = function(input) {
            var output = "";
            var chr1, chr2, chr3 = 0;
            var enc1, enc2, enc3, enc4 = 0;
            var i3 = 0;
            var base64test = /[^A-Za-z0-9\+\/\=]/g;
            if (base64test.exec(input)) {
              GALogger.w("There were invalid base64 characters in the input text. Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='. Expect errors in decoding.");
            }
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            do {
              enc1 = GAUtilities2.keyStr.indexOf(input.charAt(i3++));
              enc2 = GAUtilities2.keyStr.indexOf(input.charAt(i3++));
              enc3 = GAUtilities2.keyStr.indexOf(input.charAt(i3++));
              enc4 = GAUtilities2.keyStr.indexOf(input.charAt(i3++));
              chr1 = enc1 << 2 | enc2 >> 4;
              chr2 = (enc2 & 15) << 4 | enc3 >> 2;
              chr3 = (enc3 & 3) << 6 | enc4;
              output = output + String.fromCharCode(chr1);
              if (enc3 != 64) {
                output = output + String.fromCharCode(chr2);
              }
              if (enc4 != 64) {
                output = output + String.fromCharCode(chr3);
              }
              chr1 = chr2 = chr3 = 0;
              enc1 = enc2 = enc3 = enc4 = 0;
            } while (i3 < input.length);
            return decodeURI(output);
          };
          GAUtilities2.timeIntervalSince1970 = function() {
            var date = /* @__PURE__ */ new Date();
            return Math.round(date.getTime() / 1e3);
          };
          GAUtilities2.createGuid = function() {
            return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, function(c2) {
              return (+c2 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> +c2 / 4).toString(16);
            });
          };
          GAUtilities2.keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          return GAUtilities2;
        }();
        utilities2.GAUtilities = GAUtilities;
      })(utilities = gameanalytics2.utilities || (gameanalytics2.utilities = {}));
    })(gameanalytics || (gameanalytics = {}));
    var gameanalytics;
    (function(gameanalytics2) {
      var validators;
      (function(validators2) {
        var GALogger = gameanalytics2.logging.GALogger;
        var GAUtilities = gameanalytics2.utilities.GAUtilities;
        var EGASdkErrorCategory = gameanalytics2.events.EGASdkErrorCategory;
        var EGASdkErrorArea = gameanalytics2.events.EGASdkErrorArea;
        var EGASdkErrorAction = gameanalytics2.events.EGASdkErrorAction;
        var EGASdkErrorParameter = gameanalytics2.events.EGASdkErrorParameter;
        var ValidationResult = /* @__PURE__ */ function() {
          function ValidationResult2(category, area, action, parameter, reason) {
            this.category = category;
            this.area = area;
            this.action = action;
            this.parameter = parameter;
            this.reason = reason;
          }
          return ValidationResult2;
        }();
        validators2.ValidationResult = ValidationResult;
        var GAValidator = function() {
          function GAValidator2() {
          }
          GAValidator2.validateBusinessEvent = function(currency, amount, cartType, itemType, itemId) {
            if (!GAValidator2.validateCurrency(currency)) {
              GALogger.w("Validation fail - business event - currency: Cannot be (null) and need to be A-Z, 3 characters and in the standard at openexchangerates.org. Failed currency: " + currency);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.BusinessEvent, EGASdkErrorAction.InvalidCurrency, EGASdkErrorParameter.Currency, currency);
            }
            if (amount < 0) {
              GALogger.w("Validation fail - business event - amount. Cannot be less than 0. Failed amount: " + amount);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.BusinessEvent, EGASdkErrorAction.InvalidAmount, EGASdkErrorParameter.Amount, amount + "");
            }
            if (!GAValidator2.validateShortString(cartType, true)) {
              GALogger.w("Validation fail - business event - cartType. Cannot be above 32 length. String: " + cartType);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.BusinessEvent, EGASdkErrorAction.InvalidShortString, EGASdkErrorParameter.CartType, cartType);
            }
            if (!GAValidator2.validateEventPartLength(itemType, false)) {
              GALogger.w("Validation fail - business event - itemType: Cannot be (null), empty or above 64 characters. String: " + itemType);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.BusinessEvent, EGASdkErrorAction.InvalidEventPartLength, EGASdkErrorParameter.ItemType, itemType);
            }
            if (!GAValidator2.validateEventPartCharacters(itemType)) {
              GALogger.w("Validation fail - business event - itemType: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " + itemType);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.BusinessEvent, EGASdkErrorAction.InvalidEventPartCharacters, EGASdkErrorParameter.ItemType, itemType);
            }
            if (!GAValidator2.validateEventPartLength(itemId, false)) {
              GALogger.w("Validation fail - business event - itemId. Cannot be (null), empty or above 64 characters. String: " + itemId);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.BusinessEvent, EGASdkErrorAction.InvalidEventPartLength, EGASdkErrorParameter.ItemId, itemId);
            }
            if (!GAValidator2.validateEventPartCharacters(itemId)) {
              GALogger.w("Validation fail - business event - itemId: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " + itemId);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.BusinessEvent, EGASdkErrorAction.InvalidEventPartCharacters, EGASdkErrorParameter.ItemId, itemId);
            }
            return null;
          };
          GAValidator2.validateResourceEvent = function(flowType, currency, amount, itemType, itemId, availableCurrencies, availableItemTypes) {
            if (flowType == gameanalytics2.EGAResourceFlowType.Undefined) {
              GALogger.w("Validation fail - resource event - flowType: Invalid flow type.");
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ResourceEvent, EGASdkErrorAction.InvalidFlowType, EGASdkErrorParameter.FlowType, "");
            }
            if (!currency) {
              GALogger.w("Validation fail - resource event - currency: Cannot be (null)");
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ResourceEvent, EGASdkErrorAction.StringEmptyOrNull, EGASdkErrorParameter.Currency, "");
            }
            if (!GAUtilities.stringArrayContainsString(availableCurrencies, currency)) {
              GALogger.w("Validation fail - resource event - currency: Not found in list of pre-defined available resource currencies. String: " + currency);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ResourceEvent, EGASdkErrorAction.NotFoundInAvailableCurrencies, EGASdkErrorParameter.Currency, currency);
            }
            if (!(amount > 0)) {
              GALogger.w("Validation fail - resource event - amount: Float amount cannot be 0 or negative. Value: " + amount);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ResourceEvent, EGASdkErrorAction.InvalidAmount, EGASdkErrorParameter.Amount, amount + "");
            }
            if (!itemType) {
              GALogger.w("Validation fail - resource event - itemType: Cannot be (null)");
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ResourceEvent, EGASdkErrorAction.StringEmptyOrNull, EGASdkErrorParameter.ItemType, "");
            }
            if (!GAValidator2.validateEventPartLength(itemType, false)) {
              GALogger.w("Validation fail - resource event - itemType: Cannot be (null), empty or above 64 characters. String: " + itemType);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ResourceEvent, EGASdkErrorAction.InvalidEventPartLength, EGASdkErrorParameter.ItemType, itemType);
            }
            if (!GAValidator2.validateEventPartCharacters(itemType)) {
              GALogger.w("Validation fail - resource event - itemType: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " + itemType);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ResourceEvent, EGASdkErrorAction.InvalidEventPartCharacters, EGASdkErrorParameter.ItemType, itemType);
            }
            if (!GAUtilities.stringArrayContainsString(availableItemTypes, itemType)) {
              GALogger.w("Validation fail - resource event - itemType: Not found in list of pre-defined available resource itemTypes. String: " + itemType);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ResourceEvent, EGASdkErrorAction.NotFoundInAvailableItemTypes, EGASdkErrorParameter.ItemType, itemType);
            }
            if (!GAValidator2.validateEventPartLength(itemId, false)) {
              GALogger.w("Validation fail - resource event - itemId: Cannot be (null), empty or above 64 characters. String: " + itemId);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ResourceEvent, EGASdkErrorAction.InvalidEventPartLength, EGASdkErrorParameter.ItemId, itemId);
            }
            if (!GAValidator2.validateEventPartCharacters(itemId)) {
              GALogger.w("Validation fail - resource event - itemId: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " + itemId);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ResourceEvent, EGASdkErrorAction.InvalidEventPartCharacters, EGASdkErrorParameter.ItemId, itemId);
            }
            return null;
          };
          GAValidator2.validateProgressionEvent = function(progressionStatus, progression01, progression02, progression03) {
            if (progressionStatus == gameanalytics2.EGAProgressionStatus.Undefined) {
              GALogger.w("Validation fail - progression event: Invalid progression status.");
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ProgressionEvent, EGASdkErrorAction.InvalidProgressionStatus, EGASdkErrorParameter.ProgressionStatus, "");
            }
            if (progression03 && !(progression02 || !progression01)) {
              GALogger.w("Validation fail - progression event: 03 found but 01+02 are invalid. Progression must be set as either 01, 01+02 or 01+02+03.");
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ProgressionEvent, EGASdkErrorAction.WrongProgressionOrder, EGASdkErrorParameter.Undefined, progression01 + ":" + progression02 + ":" + progression03);
            } else if (progression02 && !progression01) {
              GALogger.w("Validation fail - progression event: 02 found but not 01. Progression must be set as either 01, 01+02 or 01+02+03");
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ProgressionEvent, EGASdkErrorAction.WrongProgressionOrder, EGASdkErrorParameter.Undefined, progression01 + ":" + progression02 + ":" + progression03);
            } else if (!progression01) {
              GALogger.w("Validation fail - progression event: progression01 not valid. Progressions must be set as either 01, 01+02 or 01+02+03");
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ProgressionEvent, EGASdkErrorAction.WrongProgressionOrder, EGASdkErrorParameter.Undefined, (progression01 ? progression01 : "") + ":" + (progression02 ? progression02 : "") + ":" + (progression03 ? progression03 : ""));
            }
            if (!GAValidator2.validateEventPartLength(progression01, false)) {
              GALogger.w("Validation fail - progression event - progression01: Cannot be (null), empty or above 64 characters. String: " + progression01);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ProgressionEvent, EGASdkErrorAction.InvalidEventPartLength, EGASdkErrorParameter.Progression01, progression01);
            }
            if (!GAValidator2.validateEventPartCharacters(progression01)) {
              GALogger.w("Validation fail - progression event - progression01: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " + progression01);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ProgressionEvent, EGASdkErrorAction.InvalidEventPartCharacters, EGASdkErrorParameter.Progression01, progression01);
            }
            if (progression02) {
              if (!GAValidator2.validateEventPartLength(progression02, true)) {
                GALogger.w("Validation fail - progression event - progression02: Cannot be empty or above 64 characters. String: " + progression02);
                return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ProgressionEvent, EGASdkErrorAction.InvalidEventPartLength, EGASdkErrorParameter.Progression02, progression02);
              }
              if (!GAValidator2.validateEventPartCharacters(progression02)) {
                GALogger.w("Validation fail - progression event - progression02: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " + progression02);
                return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ProgressionEvent, EGASdkErrorAction.InvalidEventPartCharacters, EGASdkErrorParameter.Progression02, progression02);
              }
            }
            if (progression03) {
              if (!GAValidator2.validateEventPartLength(progression03, true)) {
                GALogger.w("Validation fail - progression event - progression03: Cannot be empty or above 64 characters. String: " + progression03);
                return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ProgressionEvent, EGASdkErrorAction.InvalidEventPartLength, EGASdkErrorParameter.Progression03, progression03);
              }
              if (!GAValidator2.validateEventPartCharacters(progression03)) {
                GALogger.w("Validation fail - progression event - progression03: Cannot contain other characters than A-z, 0-9, -_., ()!?. String: " + progression03);
                return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ProgressionEvent, EGASdkErrorAction.InvalidEventPartCharacters, EGASdkErrorParameter.Progression03, progression03);
              }
            }
            return null;
          };
          GAValidator2.validateDesignEvent = function(eventId) {
            if (!GAValidator2.validateEventIdLength(eventId)) {
              GALogger.w("Validation fail - design event - eventId: Cannot be (null) or empty. Only 5 event parts allowed seperated by :. Each part need to be 64 characters or less. String: " + eventId);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.DesignEvent, EGASdkErrorAction.InvalidEventIdLength, EGASdkErrorParameter.EventId, eventId);
            }
            if (!GAValidator2.validateEventIdCharacters(eventId)) {
              GALogger.w("Validation fail - design event - eventId: Non valid characters. Only allowed A-z, 0-9, -_., ()!?. String: " + eventId);
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.DesignEvent, EGASdkErrorAction.InvalidEventIdCharacters, EGASdkErrorParameter.EventId, eventId);
            }
            return null;
          };
          GAValidator2.validateErrorEvent = function(severity, message) {
            if (severity == gameanalytics2.EGAErrorSeverity.Undefined) {
              GALogger.w("Validation fail - error event - severity: Severity was unsupported value.");
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ErrorEvent, EGASdkErrorAction.InvalidSeverity, EGASdkErrorParameter.Severity, "");
            }
            if (!GAValidator2.validateLongString(message, true)) {
              GALogger.w("Validation fail - error event - message: Message cannot be above 8192 characters.");
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.ErrorEvent, EGASdkErrorAction.InvalidLongString, EGASdkErrorParameter.Message, message);
            }
            return null;
          };
          GAValidator2.validateAdEvent = function(adAction, adType, adSdkName, adPlacement) {
            if (adAction == gameanalytics2.EGAAdAction.Undefined) {
              GALogger.w("Validation fail - error event - severity: Severity was unsupported value.");
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.AdEvent, EGASdkErrorAction.InvalidAdAction, EGASdkErrorParameter.AdAction, "");
            }
            if (adType == gameanalytics2.EGAAdType.Undefined) {
              GALogger.w("Validation fail - ad event - adType: Ad type was unsupported value.");
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.AdEvent, EGASdkErrorAction.InvalidAdType, EGASdkErrorParameter.AdType, "");
            }
            if (!GAValidator2.validateShortString(adSdkName, false)) {
              GALogger.w("Validation fail - ad event - message: Ad SDK name cannot be above 32 characters.");
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.AdEvent, EGASdkErrorAction.InvalidShortString, EGASdkErrorParameter.AdSdkName, adSdkName);
            }
            if (!GAValidator2.validateString(adPlacement, false)) {
              GALogger.w("Validation fail - ad event - message: Ad placement cannot be above 64 characters.");
              return new ValidationResult(EGASdkErrorCategory.EventValidation, EGASdkErrorArea.AdEvent, EGASdkErrorAction.InvalidString, EGASdkErrorParameter.AdPlacement, adPlacement);
            }
            return null;
          };
          GAValidator2.validateSdkErrorEvent = function(gameKey, gameSecret, category, area, action) {
            if (!GAValidator2.validateKeys(gameKey, gameSecret)) {
              return false;
            }
            if (category === EGASdkErrorCategory.Undefined) {
              GALogger.w("Validation fail - sdk error event - type: Category was unsupported value.");
              return false;
            }
            if (area === EGASdkErrorArea.Undefined) {
              GALogger.w("Validation fail - sdk error event - type: Area was unsupported value.");
              return false;
            }
            if (action === EGASdkErrorAction.Undefined) {
              GALogger.w("Validation fail - sdk error event - type: Action was unsupported value.");
              return false;
            }
            return true;
          };
          GAValidator2.validateKeys = function(gameKey, gameSecret) {
            if (GAUtilities.stringMatch(gameKey, /^[A-z0-9]{32}$/)) {
              if (GAUtilities.stringMatch(gameSecret, /^[A-z0-9]{40}$/)) {
                return true;
              }
            }
            return false;
          };
          GAValidator2.validateCurrency = function(currency) {
            if (!currency) {
              return false;
            }
            if (!GAUtilities.stringMatch(currency, /^[A-Z]{3}$/)) {
              return false;
            }
            return true;
          };
          GAValidator2.validateEventPartLength = function(eventPart, allowNull) {
            if (allowNull && !eventPart) {
              return true;
            }
            if (!eventPart) {
              return false;
            }
            if (eventPart.length > 64) {
              return false;
            }
            return true;
          };
          GAValidator2.validateEventPartCharacters = function(eventPart) {
            if (!GAUtilities.stringMatch(eventPart, /^[A-Za-z0-9\s\-_\.\(\)\!\?]{1,64}$/)) {
              return false;
            }
            return true;
          };
          GAValidator2.validateEventIdLength = function(eventId) {
            if (!eventId) {
              return false;
            }
            if (!GAUtilities.stringMatch(eventId, /^[^:]{1,64}(?::[^:]{1,64}){0,4}$/)) {
              return false;
            }
            return true;
          };
          GAValidator2.validateEventIdCharacters = function(eventId) {
            if (!eventId) {
              return false;
            }
            if (!GAUtilities.stringMatch(eventId, /^[A-Za-z0-9\s\-_\.\(\)\!\?]{1,64}(:[A-Za-z0-9\s\-_\.\(\)\!\?]{1,64}){0,4}$/)) {
              return false;
            }
            return true;
          };
          GAValidator2.validateAndCleanInitRequestResponse = function(initResponse, configsCreated) {
            if (initResponse == null) {
              GALogger.w("validateInitRequestResponse failed - no response dictionary.");
              return null;
            }
            var validatedDict = {};
            try {
              var serverTsNumber = initResponse["server_ts"];
              if (serverTsNumber > 0) {
                validatedDict["server_ts"] = serverTsNumber;
              } else {
                GALogger.w("validateInitRequestResponse failed - invalid value in 'server_ts' field.");
                return null;
              }
            } catch (e2) {
              GALogger.w("validateInitRequestResponse failed - invalid type in 'server_ts' field. type=" + typeof initResponse["server_ts"] + ", value=" + initResponse["server_ts"] + ", " + e2);
              return null;
            }
            if (configsCreated) {
              try {
                var configurations = initResponse["configs"];
                validatedDict["configs"] = configurations;
              } catch (e2) {
                GALogger.w("validateInitRequestResponse failed - invalid type in 'configs' field. type=" + typeof initResponse["configs"] + ", value=" + initResponse["configs"] + ", " + e2);
                return null;
              }
              try {
                var configs_hash = initResponse["configs_hash"];
                validatedDict["configs_hash"] = configs_hash;
              } catch (e2) {
                GALogger.w("validateInitRequestResponse failed - invalid type in 'configs_hash' field. type=" + typeof initResponse["configs_hash"] + ", value=" + initResponse["configs_hash"] + ", " + e2);
                return null;
              }
              try {
                var ab_id = initResponse["ab_id"];
                validatedDict["ab_id"] = ab_id;
              } catch (e2) {
                GALogger.w("validateInitRequestResponse failed - invalid type in 'ab_id' field. type=" + typeof initResponse["ab_id"] + ", value=" + initResponse["ab_id"] + ", " + e2);
                return null;
              }
              try {
                var ab_variant_id = initResponse["ab_variant_id"];
                validatedDict["ab_variant_id"] = ab_variant_id;
              } catch (e2) {
                GALogger.w("validateInitRequestResponse failed - invalid type in 'ab_variant_id' field. type=" + typeof initResponse["ab_variant_id"] + ", value=" + initResponse["ab_variant_id"] + ", " + e2);
                return null;
              }
            }
            return validatedDict;
          };
          GAValidator2.validateBuild = function(build) {
            if (!GAValidator2.validateShortString(build, false)) {
              return false;
            }
            return true;
          };
          GAValidator2.validateSdkWrapperVersion = function(wrapperVersion) {
            if (!GAUtilities.stringMatch(wrapperVersion, /^(unity|unreal|gamemaker|cocos2d|construct|defold|godot|flutter) [0-9]{0,5}(\.[0-9]{0,5}){0,2}$/)) {
              return false;
            }
            return true;
          };
          GAValidator2.validateEngineVersion = function(engineVersion) {
            if (!engineVersion || !GAUtilities.stringMatch(engineVersion, /^(unity|unreal|gamemaker|cocos2d|construct|defold|godot) [0-9]{0,5}(\.[0-9]{0,5}){0,2}$/)) {
              return false;
            }
            return true;
          };
          GAValidator2.validateUserId = function(uId) {
            if (!GAValidator2.validateString(uId, false)) {
              GALogger.w("Validation fail - user id: id cannot be (null), empty or above 64 characters.");
              return false;
            }
            return true;
          };
          GAValidator2.validateShortString = function(shortString, canBeEmpty) {
            if (canBeEmpty && !shortString) {
              return true;
            }
            if (!shortString || shortString.length > 32) {
              return false;
            }
            return true;
          };
          GAValidator2.validateString = function(s2, canBeEmpty) {
            if (canBeEmpty && !s2) {
              return true;
            }
            if (!s2 || s2.length > 64) {
              return false;
            }
            return true;
          };
          GAValidator2.validateLongString = function(longString, canBeEmpty) {
            if (canBeEmpty && !longString) {
              return true;
            }
            if (!longString || longString.length > 8192) {
              return false;
            }
            return true;
          };
          GAValidator2.validateConnectionType = function(connectionType) {
            return GAUtilities.stringMatch(connectionType, /^(wwan|wifi|lan|offline)$/);
          };
          GAValidator2.validateCustomDimensions = function(customDimensions) {
            return GAValidator2.validateArrayOfStrings(20, 32, false, "custom dimensions", customDimensions);
          };
          GAValidator2.validateResourceCurrencies = function(resourceCurrencies) {
            if (!GAValidator2.validateArrayOfStrings(20, 64, false, "resource currencies", resourceCurrencies)) {
              return false;
            }
            for (var i3 = 0; i3 < resourceCurrencies.length; ++i3) {
              if (!GAUtilities.stringMatch(resourceCurrencies[i3], /^[A-Za-z]+$/)) {
                GALogger.w("resource currencies validation failed: a resource currency can only be A-Z, a-z. String was: " + resourceCurrencies[i3]);
                return false;
              }
            }
            return true;
          };
          GAValidator2.validateResourceItemTypes = function(resourceItemTypes) {
            if (!GAValidator2.validateArrayOfStrings(20, 32, false, "resource item types", resourceItemTypes)) {
              return false;
            }
            for (var i3 = 0; i3 < resourceItemTypes.length; ++i3) {
              if (!GAValidator2.validateEventPartCharacters(resourceItemTypes[i3])) {
                GALogger.w("resource item types validation failed: a resource item type cannot contain other characters than A-z, 0-9, -_., ()!?. String was: " + resourceItemTypes[i3]);
                return false;
              }
            }
            return true;
          };
          GAValidator2.validateDimension01 = function(dimension01, availableDimensions) {
            if (!dimension01) {
              return true;
            }
            if (!GAUtilities.stringArrayContainsString(availableDimensions, dimension01)) {
              return false;
            }
            return true;
          };
          GAValidator2.validateDimension02 = function(dimension02, availableDimensions) {
            if (!dimension02) {
              return true;
            }
            if (!GAUtilities.stringArrayContainsString(availableDimensions, dimension02)) {
              return false;
            }
            return true;
          };
          GAValidator2.validateDimension03 = function(dimension03, availableDimensions) {
            if (!dimension03) {
              return true;
            }
            if (!GAUtilities.stringArrayContainsString(availableDimensions, dimension03)) {
              return false;
            }
            return true;
          };
          GAValidator2.validateArrayOfStrings = function(maxCount, maxStringLength, allowNoValues, logTag, arrayOfStrings) {
            var arrayTag = logTag;
            if (!arrayTag) {
              arrayTag = "Array";
            }
            if (!arrayOfStrings) {
              GALogger.w(arrayTag + " validation failed: array cannot be null. ");
              return false;
            }
            if (allowNoValues == false && arrayOfStrings.length == 0) {
              GALogger.w(arrayTag + " validation failed: array cannot be empty. ");
              return false;
            }
            if (maxCount > 0 && arrayOfStrings.length > maxCount) {
              GALogger.w(arrayTag + " validation failed: array cannot exceed " + maxCount + " values. It has " + arrayOfStrings.length + " values.");
              return false;
            }
            for (var i3 = 0; i3 < arrayOfStrings.length; ++i3) {
              var stringLength = !arrayOfStrings[i3] ? 0 : arrayOfStrings[i3].length;
              if (stringLength === 0) {
                GALogger.w(arrayTag + " validation failed: contained an empty string. Array=" + JSON.stringify(arrayOfStrings));
                return false;
              }
              if (maxStringLength > 0 && stringLength > maxStringLength) {
                GALogger.w(arrayTag + " validation failed: a string exceeded max allowed length (which is: " + maxStringLength + "). String was: " + arrayOfStrings[i3]);
                return false;
              }
            }
            return true;
          };
          GAValidator2.validateClientTs = function(clientTs) {
            if (clientTs < 0 || clientTs > 99999999999) {
              return false;
            }
            return true;
          };
          return GAValidator2;
        }();
        validators2.GAValidator = GAValidator;
      })(validators = gameanalytics2.validators || (gameanalytics2.validators = {}));
    })(gameanalytics || (gameanalytics = {}));
    var gameanalytics;
    (function(gameanalytics2) {
      var device;
      (function(device2) {
        var NameValueVersion = /* @__PURE__ */ function() {
          function NameValueVersion2(name, value, version) {
            this.name = name;
            this.value = value;
            this.version = version;
          }
          return NameValueVersion2;
        }();
        device2.NameValueVersion = NameValueVersion;
        var NameVersion = /* @__PURE__ */ function() {
          function NameVersion2(name, version) {
            this.name = name;
            this.version = version;
          }
          return NameVersion2;
        }();
        device2.NameVersion = NameVersion;
        var GADevice = function() {
          function GADevice2() {
          }
          GADevice2.touch = function() {
          };
          GADevice2.getRelevantSdkVersion = function() {
            if (GADevice2.sdkGameEngineVersion) {
              return GADevice2.sdkGameEngineVersion;
            }
            return GADevice2.sdkWrapperVersion;
          };
          GADevice2.getConnectionType = function() {
            return GADevice2.connectionType;
          };
          GADevice2.updateConnectionType = function() {
            if (navigator.onLine) {
              if (GADevice2.buildPlatform === "ios" || GADevice2.buildPlatform === "android") {
                GADevice2.connectionType = "wwan";
              } else {
                GADevice2.connectionType = "lan";
              }
            } else {
              GADevice2.connectionType = "offline";
            }
          };
          GADevice2.getOSVersionString = function() {
            return GADevice2.buildPlatform + " " + GADevice2.osVersionPair.version;
          };
          GADevice2.runtimePlatformToString = function() {
            return GADevice2.osVersionPair.name;
          };
          GADevice2.getBrowserVersionString = function() {
            var ua = navigator.userAgent;
            var tem;
            var M2 = ua.match(/(opera|chrome|safari|firefox|ubrowser|msie|trident|fbav(?=\/))\/?\s*(\d+)/i) || [];
            if (M2.length == 0) {
              if (GADevice2.buildPlatform === "ios") {
                return "webkit_" + GADevice2.osVersion;
              }
            }
            if (/trident/i.test(M2[1])) {
              tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
              return "IE " + (tem[1] || "");
            }
            if (M2[1] === "Chrome") {
              tem = ua.match(/\b(OPR|Edge|UBrowser)\/(\d+)/);
              if (tem != null) {
                return tem.slice(1).join(" ").replace("OPR", "Opera").replace("UBrowser", "UC").toLowerCase();
              }
            }
            if (M2[1] && M2[1].toLowerCase() === "fbav") {
              M2[1] = "facebook";
              if (M2[2]) {
                return "facebook " + M2[2];
              }
            }
            var MString = M2[2] ? [M2[1], M2[2]] : [navigator.appName, navigator.appVersion, "-?"];
            if ((tem = ua.match(/version\/(\d+)/i)) != null) {
              MString.splice(1, 1, tem[1]);
            }
            return MString.join(" ").toLowerCase();
          };
          GADevice2.getDeviceModel = function() {
            var result = "unknown";
            return result;
          };
          GADevice2.getDeviceManufacturer = function() {
            var result = "unknown";
            return result;
          };
          GADevice2.matchItem = function(agent, data) {
            var result = new NameVersion("unknown", "0.0.0");
            var i3 = 0;
            var j2 = 0;
            var regex;
            var regexv;
            var match;
            var matches;
            var mathcesResult;
            var version;
            for (i3 = 0; i3 < data.length; i3 += 1) {
              regex = new RegExp(data[i3].value, "i");
              match = regex.test(agent);
              if (match) {
                regexv = new RegExp(data[i3].version + "[- /:;]([\\d._]+)", "i");
                matches = agent.match(regexv);
                version = "";
                if (matches) {
                  if (matches[1]) {
                    mathcesResult = matches[1];
                  }
                }
                if (mathcesResult) {
                  var matchesArray = mathcesResult.split(/[._]+/);
                  for (j2 = 0; j2 < Math.min(matchesArray.length, 3); j2 += 1) {
                    version += matchesArray[j2] + (j2 < Math.min(matchesArray.length, 3) - 1 ? "." : "");
                  }
                } else {
                  version = "0.0.0";
                }
                result.name = data[i3].name;
                result.version = version;
                return result;
              }
            }
            return result;
          };
          GADevice2.sdkWrapperVersion = "javascript 4.4.6";
          GADevice2.osVersionPair = GADevice2.matchItem([
            navigator.platform,
            navigator.userAgent,
            navigator.appVersion,
            navigator.vendor
          ].join(" "), [
            new NameValueVersion("windows_phone", "Windows Phone", "OS"),
            new NameValueVersion("windows", "Win", "NT"),
            new NameValueVersion("ios", "iPhone", "OS"),
            new NameValueVersion("ios", "iPad", "OS"),
            new NameValueVersion("ios", "iPod", "OS"),
            new NameValueVersion("android", "Android", "Android"),
            new NameValueVersion("blackBerry", "BlackBerry", "/"),
            new NameValueVersion("mac_osx", "Mac", "OS X"),
            new NameValueVersion("tizen", "Tizen", "Tizen"),
            new NameValueVersion("linux", "Linux", "rv"),
            new NameValueVersion("kai_os", "KAIOS", "KAIOS")
          ]);
          GADevice2.buildPlatform = GADevice2.runtimePlatformToString();
          GADevice2.deviceModel = GADevice2.getDeviceModel();
          GADevice2.deviceManufacturer = GADevice2.getDeviceManufacturer();
          GADevice2.osVersion = GADevice2.getOSVersionString();
          GADevice2.browserVersion = GADevice2.getBrowserVersionString();
          return GADevice2;
        }();
        device2.GADevice = GADevice;
      })(device = gameanalytics2.device || (gameanalytics2.device = {}));
    })(gameanalytics || (gameanalytics = {}));
    var gameanalytics;
    (function(gameanalytics2) {
      var threading;
      (function(threading2) {
        var TimedBlock = function() {
          function TimedBlock2(deadline) {
            this.deadline = deadline;
            this.ignore = false;
            this.async = false;
            this.running = false;
            this.id = ++TimedBlock2.idCounter;
          }
          TimedBlock2.idCounter = 0;
          return TimedBlock2;
        }();
        threading2.TimedBlock = TimedBlock;
      })(threading = gameanalytics2.threading || (gameanalytics2.threading = {}));
    })(gameanalytics || (gameanalytics = {}));
    var gameanalytics;
    (function(gameanalytics2) {
      var threading;
      (function(threading2) {
        var PriorityQueue = function() {
          function PriorityQueue2(priorityComparer) {
            this.comparer = priorityComparer;
            this._subQueues = {};
            this._sortedKeys = [];
          }
          PriorityQueue2.prototype.enqueue = function(priority, item) {
            if (this._sortedKeys.indexOf(priority) === -1) {
              this.addQueueOfPriority(priority);
            }
            this._subQueues[priority].push(item);
          };
          PriorityQueue2.prototype.addQueueOfPriority = function(priority) {
            var _this = this;
            this._sortedKeys.push(priority);
            this._sortedKeys.sort(function(x2, y2) {
              return _this.comparer.compare(x2, y2);
            });
            this._subQueues[priority] = [];
          };
          PriorityQueue2.prototype.peek = function() {
            if (this.hasItems()) {
              return this._subQueues[this._sortedKeys[0]][0];
            } else {
              throw new Error("The queue is empty");
            }
          };
          PriorityQueue2.prototype.hasItems = function() {
            return this._sortedKeys.length > 0;
          };
          PriorityQueue2.prototype.dequeue = function() {
            if (this.hasItems()) {
              return this.dequeueFromHighPriorityQueue();
            } else {
              throw new Error("The queue is empty");
            }
          };
          PriorityQueue2.prototype.dequeueFromHighPriorityQueue = function() {
            var firstKey = this._sortedKeys[0];
            var nextItem = this._subQueues[firstKey].shift();
            if (this._subQueues[firstKey].length === 0) {
              this._sortedKeys.shift();
              delete this._subQueues[firstKey];
            }
            return nextItem;
          };
          return PriorityQueue2;
        }();
        threading2.PriorityQueue = PriorityQueue;
      })(threading = gameanalytics2.threading || (gameanalytics2.threading = {}));
    })(gameanalytics || (gameanalytics = {}));
    var gameanalytics;
    (function(gameanalytics2) {
      var store;
      (function(store_1) {
        var GALogger = gameanalytics2.logging.GALogger;
        var EGAStoreArgsOperator;
        (function(EGAStoreArgsOperator2) {
          EGAStoreArgsOperator2[EGAStoreArgsOperator2["Equal"] = 0] = "Equal";
          EGAStoreArgsOperator2[EGAStoreArgsOperator2["LessOrEqual"] = 1] = "LessOrEqual";
          EGAStoreArgsOperator2[EGAStoreArgsOperator2["NotEqual"] = 2] = "NotEqual";
        })(EGAStoreArgsOperator = store_1.EGAStoreArgsOperator || (store_1.EGAStoreArgsOperator = {}));
        var EGAStore;
        (function(EGAStore2) {
          EGAStore2[EGAStore2["Events"] = 0] = "Events";
          EGAStore2[EGAStore2["Sessions"] = 1] = "Sessions";
          EGAStore2[EGAStore2["Progression"] = 2] = "Progression";
        })(EGAStore = store_1.EGAStore || (store_1.EGAStore = {}));
        var GAStore = function() {
          function GAStore2() {
            this.eventsStore = [];
            this.sessionsStore = [];
            this.progressionStore = [];
            this.storeItems = {};
            try {
              if (typeof localStorage === "object") {
                localStorage.setItem("testingLocalStorage", "yes");
                localStorage.removeItem("testingLocalStorage");
                GAStore2.storageAvailable = true;
              } else {
                GAStore2.storageAvailable = false;
              }
            } catch (e2) {
            }
          }
          GAStore2.isStorageAvailable = function() {
            return GAStore2.storageAvailable;
          };
          GAStore2.isStoreTooLargeForEvents = function() {
            return GAStore2.instance.eventsStore.length + GAStore2.instance.sessionsStore.length > GAStore2.MaxNumberOfEntries;
          };
          GAStore2.select = function(store2, args, sort, maxCount) {
            if (args === void 0) {
              args = [];
            }
            if (sort === void 0) {
              sort = false;
            }
            if (maxCount === void 0) {
              maxCount = 0;
            }
            var currentStore = GAStore2.getStore(store2);
            if (!currentStore) {
              return null;
            }
            var result = [];
            for (var i3 = 0; i3 < currentStore.length; ++i3) {
              var entry = currentStore[i3];
              var add = true;
              for (var j2 = 0; j2 < args.length; ++j2) {
                var argsEntry = args[j2];
                if (entry[argsEntry[0]]) {
                  switch (argsEntry[1]) {
                    case EGAStoreArgsOperator.Equal:
                      {
                        add = entry[argsEntry[0]] == argsEntry[2];
                      }
                      break;
                    case EGAStoreArgsOperator.LessOrEqual:
                      {
                        add = entry[argsEntry[0]] <= argsEntry[2];
                      }
                      break;
                    case EGAStoreArgsOperator.NotEqual:
                      {
                        add = entry[argsEntry[0]] != argsEntry[2];
                      }
                      break;
                    default:
                      {
                        add = false;
                      }
                      break;
                  }
                } else {
                  add = false;
                }
                if (!add) {
                  break;
                }
              }
              if (add) {
                result.push(entry);
              }
            }
            if (sort) {
              result.sort(function(a2, b3) {
                return a2["client_ts"] - b3["client_ts"];
              });
            }
            if (maxCount > 0 && result.length > maxCount) {
              result = result.slice(0, maxCount + 1);
            }
            return result;
          };
          GAStore2.update = function(store2, setArgs, whereArgs) {
            if (whereArgs === void 0) {
              whereArgs = [];
            }
            var currentStore = GAStore2.getStore(store2);
            if (!currentStore) {
              return false;
            }
            for (var i3 = 0; i3 < currentStore.length; ++i3) {
              var entry = currentStore[i3];
              var update = true;
              for (var j2 = 0; j2 < whereArgs.length; ++j2) {
                var argsEntry = whereArgs[j2];
                if (entry[argsEntry[0]]) {
                  switch (argsEntry[1]) {
                    case EGAStoreArgsOperator.Equal:
                      {
                        update = entry[argsEntry[0]] == argsEntry[2];
                      }
                      break;
                    case EGAStoreArgsOperator.LessOrEqual:
                      {
                        update = entry[argsEntry[0]] <= argsEntry[2];
                      }
                      break;
                    case EGAStoreArgsOperator.NotEqual:
                      {
                        update = entry[argsEntry[0]] != argsEntry[2];
                      }
                      break;
                    default:
                      {
                        update = false;
                      }
                      break;
                  }
                } else {
                  update = false;
                }
                if (!update) {
                  break;
                }
              }
              if (update) {
                for (var j2 = 0; j2 < setArgs.length; ++j2) {
                  var setArgsEntry = setArgs[j2];
                  entry[setArgsEntry[0]] = setArgsEntry[1];
                }
              }
            }
            return true;
          };
          GAStore2["delete"] = function(store2, args) {
            var currentStore = GAStore2.getStore(store2);
            if (!currentStore) {
              return;
            }
            for (var i3 = 0; i3 < currentStore.length; ++i3) {
              var entry = currentStore[i3];
              var del = true;
              for (var j2 = 0; j2 < args.length; ++j2) {
                var argsEntry = args[j2];
                if (entry[argsEntry[0]]) {
                  switch (argsEntry[1]) {
                    case EGAStoreArgsOperator.Equal:
                      {
                        del = entry[argsEntry[0]] == argsEntry[2];
                      }
                      break;
                    case EGAStoreArgsOperator.LessOrEqual:
                      {
                        del = entry[argsEntry[0]] <= argsEntry[2];
                      }
                      break;
                    case EGAStoreArgsOperator.NotEqual:
                      {
                        del = entry[argsEntry[0]] != argsEntry[2];
                      }
                      break;
                    default:
                      {
                        del = false;
                      }
                      break;
                  }
                } else {
                  del = false;
                }
                if (!del) {
                  break;
                }
              }
              if (del) {
                currentStore.splice(i3, 1);
                --i3;
              }
            }
          };
          GAStore2.insert = function(store2, newEntry, replace, replaceKey) {
            if (replace === void 0) {
              replace = false;
            }
            if (replaceKey === void 0) {
              replaceKey = null;
            }
            var currentStore = GAStore2.getStore(store2);
            if (!currentStore) {
              return;
            }
            if (replace) {
              if (!replaceKey) {
                return;
              }
              var replaced = false;
              for (var i3 = 0; i3 < currentStore.length; ++i3) {
                var entry = currentStore[i3];
                if (entry[replaceKey] == newEntry[replaceKey]) {
                  for (var s2 in newEntry) {
                    entry[s2] = newEntry[s2];
                  }
                  replaced = true;
                  break;
                }
              }
              if (!replaced) {
                currentStore.push(newEntry);
              }
            } else {
              currentStore.push(newEntry);
            }
          };
          GAStore2.save = function(gameKey) {
            if (!GAStore2.isStorageAvailable()) {
              GALogger.w("Storage is not available, cannot save.");
              return;
            }
            localStorage.setItem(GAStore2.StringFormat(GAStore2.KeyFormat, gameKey, GAStore2.EventsStoreKey), JSON.stringify(GAStore2.instance.eventsStore));
            localStorage.setItem(GAStore2.StringFormat(GAStore2.KeyFormat, gameKey, GAStore2.SessionsStoreKey), JSON.stringify(GAStore2.instance.sessionsStore));
            localStorage.setItem(GAStore2.StringFormat(GAStore2.KeyFormat, gameKey, GAStore2.ProgressionStoreKey), JSON.stringify(GAStore2.instance.progressionStore));
            localStorage.setItem(GAStore2.StringFormat(GAStore2.KeyFormat, gameKey, GAStore2.ItemsStoreKey), JSON.stringify(GAStore2.instance.storeItems));
          };
          GAStore2.load = function(gameKey) {
            if (!GAStore2.isStorageAvailable()) {
              GALogger.w("Storage is not available, cannot load.");
              return;
            }
            try {
              GAStore2.instance.eventsStore = JSON.parse(localStorage.getItem(GAStore2.StringFormat(GAStore2.KeyFormat, gameKey, GAStore2.EventsStoreKey)));
              if (!GAStore2.instance.eventsStore) {
                GAStore2.instance.eventsStore = [];
              }
            } catch (e2) {
              GALogger.w("Load failed for 'events' store. Using empty store.");
              GAStore2.instance.eventsStore = [];
            }
            try {
              GAStore2.instance.sessionsStore = JSON.parse(localStorage.getItem(GAStore2.StringFormat(GAStore2.KeyFormat, gameKey, GAStore2.SessionsStoreKey)));
              if (!GAStore2.instance.sessionsStore) {
                GAStore2.instance.sessionsStore = [];
              }
            } catch (e2) {
              GALogger.w("Load failed for 'sessions' store. Using empty store.");
              GAStore2.instance.sessionsStore = [];
            }
            try {
              GAStore2.instance.progressionStore = JSON.parse(localStorage.getItem(GAStore2.StringFormat(GAStore2.KeyFormat, gameKey, GAStore2.ProgressionStoreKey)));
              if (!GAStore2.instance.progressionStore) {
                GAStore2.instance.progressionStore = [];
              }
            } catch (e2) {
              GALogger.w("Load failed for 'progression' store. Using empty store.");
              GAStore2.instance.progressionStore = [];
            }
            try {
              GAStore2.instance.storeItems = JSON.parse(localStorage.getItem(GAStore2.StringFormat(GAStore2.KeyFormat, gameKey, GAStore2.ItemsStoreKey)));
              if (!GAStore2.instance.storeItems) {
                GAStore2.instance.storeItems = {};
              }
            } catch (e2) {
              GALogger.w("Load failed for 'items' store. Using empty store.");
              GAStore2.instance.progressionStore = [];
            }
          };
          GAStore2.setItem = function(gameKey, key, value) {
            var keyWithPrefix = GAStore2.StringFormat(GAStore2.KeyFormat, gameKey, key);
            if (!value) {
              if (keyWithPrefix in GAStore2.instance.storeItems) {
                delete GAStore2.instance.storeItems[keyWithPrefix];
              }
            } else {
              GAStore2.instance.storeItems[keyWithPrefix] = value;
            }
          };
          GAStore2.getItem = function(gameKey, key) {
            var keyWithPrefix = GAStore2.StringFormat(GAStore2.KeyFormat, gameKey, key);
            if (keyWithPrefix in GAStore2.instance.storeItems) {
              return GAStore2.instance.storeItems[keyWithPrefix];
            } else {
              return null;
            }
          };
          GAStore2.getStore = function(store2) {
            switch (store2) {
              case EGAStore.Events: {
                return GAStore2.instance.eventsStore;
              }
              case EGAStore.Sessions: {
                return GAStore2.instance.sessionsStore;
              }
              case EGAStore.Progression: {
                return GAStore2.instance.progressionStore;
              }
              default: {
                GALogger.w("GAStore.getStore(): Cannot find store: " + store2);
                return null;
              }
            }
          };
          GAStore2.instance = new GAStore2();
          GAStore2.MaxNumberOfEntries = 2e3;
          GAStore2.StringFormat = function(str) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
            }
            return str.replace(/{(\d+)}/g, function(_, index) {
              return args[index] || "";
            });
          };
          GAStore2.KeyFormat = "GA::{0}::{1}";
          GAStore2.EventsStoreKey = "ga_event";
          GAStore2.SessionsStoreKey = "ga_session";
          GAStore2.ProgressionStoreKey = "ga_progression";
          GAStore2.ItemsStoreKey = "ga_items";
          return GAStore2;
        }();
        store_1.GAStore = GAStore;
      })(store = gameanalytics2.store || (gameanalytics2.store = {}));
    })(gameanalytics || (gameanalytics = {}));
    var gameanalytics;
    (function(gameanalytics2) {
      var state;
      (function(state2) {
        var GAValidator = gameanalytics2.validators.GAValidator;
        var GAUtilities = gameanalytics2.utilities.GAUtilities;
        var GALogger = gameanalytics2.logging.GALogger;
        var GAStore = gameanalytics2.store.GAStore;
        var GADevice = gameanalytics2.device.GADevice;
        var EGAStore = gameanalytics2.store.EGAStore;
        var EGAStoreArgsOperator = gameanalytics2.store.EGAStoreArgsOperator;
        var GAState = function() {
          function GAState2() {
            this.availableCustomDimensions01 = [];
            this.availableCustomDimensions02 = [];
            this.availableCustomDimensions03 = [];
            this.currentGlobalCustomEventFields = {};
            this.availableResourceCurrencies = [];
            this.availableResourceItemTypes = [];
            this.configurations = {};
            this.remoteConfigsListeners = [];
            this.beforeUnloadListeners = [];
            this.sdkConfigDefault = {};
            this.sdkConfig = {};
            this.progressionTries = {};
            this._isEventSubmissionEnabled = true;
            this.isUnloading = false;
          }
          GAState2.setUserId = function(userId) {
            GAState2.instance.userId = userId;
            GAState2.cacheIdentifier();
          };
          GAState2.getIdentifier = function() {
            return GAState2.instance.identifier;
          };
          GAState2.isInitialized = function() {
            return GAState2.instance.initialized;
          };
          GAState2.setInitialized = function(value) {
            GAState2.instance.initialized = value;
          };
          GAState2.getSessionStart = function() {
            return GAState2.instance.sessionStart;
          };
          GAState2.getSessionNum = function() {
            return GAState2.instance.sessionNum;
          };
          GAState2.getTransactionNum = function() {
            return GAState2.instance.transactionNum;
          };
          GAState2.getSessionId = function() {
            return GAState2.instance.sessionId;
          };
          GAState2.getCurrentCustomDimension01 = function() {
            return GAState2.instance.currentCustomDimension01;
          };
          GAState2.getCurrentCustomDimension02 = function() {
            return GAState2.instance.currentCustomDimension02;
          };
          GAState2.getCurrentCustomDimension03 = function() {
            return GAState2.instance.currentCustomDimension03;
          };
          GAState2.getGameKey = function() {
            return GAState2.instance.gameKey;
          };
          GAState2.getGameSecret = function() {
            return GAState2.instance.gameSecret;
          };
          GAState2.getAvailableCustomDimensions01 = function() {
            return GAState2.instance.availableCustomDimensions01;
          };
          GAState2.setAvailableCustomDimensions01 = function(value) {
            if (!GAValidator.validateCustomDimensions(value)) {
              return;
            }
            GAState2.instance.availableCustomDimensions01 = value;
            GAState2.validateAndFixCurrentDimensions();
            GALogger.i("Set available custom01 dimension values: (" + GAUtilities.joinStringArray(value, ", ") + ")");
          };
          GAState2.getAvailableCustomDimensions02 = function() {
            return GAState2.instance.availableCustomDimensions02;
          };
          GAState2.setAvailableCustomDimensions02 = function(value) {
            if (!GAValidator.validateCustomDimensions(value)) {
              return;
            }
            GAState2.instance.availableCustomDimensions02 = value;
            GAState2.validateAndFixCurrentDimensions();
            GALogger.i("Set available custom02 dimension values: (" + GAUtilities.joinStringArray(value, ", ") + ")");
          };
          GAState2.getAvailableCustomDimensions03 = function() {
            return GAState2.instance.availableCustomDimensions03;
          };
          GAState2.setAvailableCustomDimensions03 = function(value) {
            if (!GAValidator.validateCustomDimensions(value)) {
              return;
            }
            GAState2.instance.availableCustomDimensions03 = value;
            GAState2.validateAndFixCurrentDimensions();
            GALogger.i("Set available custom03 dimension values: (" + GAUtilities.joinStringArray(value, ", ") + ")");
          };
          GAState2.getAvailableResourceCurrencies = function() {
            return GAState2.instance.availableResourceCurrencies;
          };
          GAState2.setAvailableResourceCurrencies = function(value) {
            if (!GAValidator.validateResourceCurrencies(value)) {
              return;
            }
            GAState2.instance.availableResourceCurrencies = value;
            GALogger.i("Set available resource currencies: (" + GAUtilities.joinStringArray(value, ", ") + ")");
          };
          GAState2.getAvailableResourceItemTypes = function() {
            return GAState2.instance.availableResourceItemTypes;
          };
          GAState2.setAvailableResourceItemTypes = function(value) {
            if (!GAValidator.validateResourceItemTypes(value)) {
              return;
            }
            GAState2.instance.availableResourceItemTypes = value;
            GALogger.i("Set available resource item types: (" + GAUtilities.joinStringArray(value, ", ") + ")");
          };
          GAState2.getBuild = function() {
            return GAState2.instance.build;
          };
          GAState2.setBuild = function(value) {
            GAState2.instance.build = value;
            GALogger.i("Set build version: " + value);
          };
          GAState2.getUseManualSessionHandling = function() {
            return GAState2.instance.useManualSessionHandling;
          };
          GAState2.isEventSubmissionEnabled = function() {
            return GAState2.instance._isEventSubmissionEnabled;
          };
          GAState2.getABTestingId = function() {
            return GAState2.instance.abId;
          };
          GAState2.getABTestingVariantId = function() {
            return GAState2.instance.abVariantId;
          };
          GAState2.prototype.setDefaultId = function(value) {
            this.defaultUserId = !value ? "" : value;
            GAState2.cacheIdentifier();
          };
          GAState2.getDefaultId = function() {
            return GAState2.instance.defaultUserId;
          };
          GAState2.getSdkConfig = function() {
            {
              var first;
              var count2 = 0;
              for (var json in GAState2.instance.sdkConfig) {
                if (count2 === 0) {
                  first = json;
                }
                ++count2;
              }
              if (first && count2 > 0) {
                return GAState2.instance.sdkConfig;
              }
            }
            {
              var first;
              var count2 = 0;
              for (var json in GAState2.instance.sdkConfigCached) {
                if (count2 === 0) {
                  first = json;
                }
                ++count2;
              }
              if (first && count2 > 0) {
                return GAState2.instance.sdkConfigCached;
              }
            }
            return GAState2.instance.sdkConfigDefault;
          };
          GAState2.isEnabled = function() {
            if (!GAState2.instance.initAuthorized) {
              return false;
            } else {
              return true;
            }
          };
          GAState2.setCustomDimension01 = function(dimension) {
            GAState2.instance.currentCustomDimension01 = dimension;
            GAStore.setItem(GAState2.getGameKey(), GAState2.Dimension01Key, dimension);
            GALogger.i("Set custom01 dimension value: " + dimension);
          };
          GAState2.setCustomDimension02 = function(dimension) {
            GAState2.instance.currentCustomDimension02 = dimension;
            GAStore.setItem(GAState2.getGameKey(), GAState2.Dimension02Key, dimension);
            GALogger.i("Set custom02 dimension value: " + dimension);
          };
          GAState2.setCustomDimension03 = function(dimension) {
            GAState2.instance.currentCustomDimension03 = dimension;
            GAStore.setItem(GAState2.getGameKey(), GAState2.Dimension03Key, dimension);
            GALogger.i("Set custom03 dimension value: " + dimension);
          };
          GAState2.incrementSessionNum = function() {
            var sessionNumInt = GAState2.getSessionNum() + 1;
            GAState2.instance.sessionNum = sessionNumInt;
          };
          GAState2.incrementTransactionNum = function() {
            var transactionNumInt = GAState2.getTransactionNum() + 1;
            GAState2.instance.transactionNum = transactionNumInt;
          };
          GAState2.incrementProgressionTries = function(progression) {
            var tries = GAState2.getProgressionTries(progression) + 1;
            GAState2.instance.progressionTries[progression] = tries;
            var values = {};
            values["progression"] = progression;
            values["tries"] = tries;
            GAStore.insert(EGAStore.Progression, values, true, "progression");
          };
          GAState2.getProgressionTries = function(progression) {
            if (progression in GAState2.instance.progressionTries) {
              return GAState2.instance.progressionTries[progression];
            } else {
              return 0;
            }
          };
          GAState2.clearProgressionTries = function(progression) {
            if (progression in GAState2.instance.progressionTries) {
              delete GAState2.instance.progressionTries[progression];
            }
            var parms = [];
            parms.push(["progression", EGAStoreArgsOperator.Equal, progression]);
            GAStore["delete"](EGAStore.Progression, parms);
          };
          GAState2.setKeys = function(gameKey, gameSecret) {
            GAState2.instance.gameKey = gameKey;
            GAState2.instance.gameSecret = gameSecret;
          };
          GAState2.setManualSessionHandling = function(flag) {
            GAState2.instance.useManualSessionHandling = flag;
            GALogger.i("Use manual session handling: " + flag);
          };
          GAState2.setEnabledEventSubmission = function(flag) {
            GAState2.instance._isEventSubmissionEnabled = flag;
          };
          GAState2.getEventAnnotations = function() {
            var annotations = {};
            annotations["v"] = 2;
            annotations["event_uuid"] = GAUtilities.createGuid();
            annotations["user_id"] = GAState2.instance.identifier;
            annotations["client_ts"] = GAState2.getClientTsAdjusted();
            annotations["sdk_version"] = GADevice.getRelevantSdkVersion();
            annotations["os_version"] = GADevice.osVersion;
            annotations["manufacturer"] = GADevice.deviceManufacturer;
            annotations["device"] = GADevice.deviceModel;
            annotations["browser_version"] = GADevice.browserVersion;
            annotations["platform"] = GADevice.buildPlatform;
            annotations["session_id"] = GAState2.instance.sessionId;
            annotations[GAState2.SessionNumKey] = GAState2.instance.sessionNum;
            var connection_type = GADevice.getConnectionType();
            if (GAValidator.validateConnectionType(connection_type)) {
              annotations["connection_type"] = connection_type;
            }
            if (GADevice.gameEngineVersion) {
              annotations["engine_version"] = GADevice.gameEngineVersion;
            }
            if (GAState2.instance.configurations) {
              var count2 = 0;
              for (var _ in GAState2.instance.configurations) {
                count2++;
                break;
              }
              if (count2 > 0) {
                annotations["configurations"] = GAState2.instance.configurations;
              }
            }
            if (GAState2.instance.abId) {
              annotations["ab_id"] = GAState2.instance.abId;
            }
            if (GAState2.instance.abVariantId) {
              annotations["ab_variant_id"] = GAState2.instance.abVariantId;
            }
            if (GAState2.instance.build) {
              annotations["build"] = GAState2.instance.build;
            }
            return annotations;
          };
          GAState2.getSdkErrorEventAnnotations = function() {
            var annotations = {};
            annotations["v"] = 2;
            annotations["event_uuid"] = GAUtilities.createGuid();
            annotations["category"] = GAState2.CategorySdkError;
            annotations["sdk_version"] = GADevice.getRelevantSdkVersion();
            annotations["os_version"] = GADevice.osVersion;
            annotations["manufacturer"] = GADevice.deviceManufacturer;
            annotations["device"] = GADevice.deviceModel;
            annotations["platform"] = GADevice.buildPlatform;
            var connection_type = GADevice.getConnectionType();
            if (GAValidator.validateConnectionType(connection_type)) {
              annotations["connection_type"] = connection_type;
            }
            if (GADevice.gameEngineVersion) {
              annotations["engine_version"] = GADevice.gameEngineVersion;
            }
            return annotations;
          };
          GAState2.getInitAnnotations = function() {
            var initAnnotations = {};
            if (!GAState2.getIdentifier()) {
              GAState2.cacheIdentifier();
            }
            GAStore.setItem(GAState2.getGameKey(), GAState2.LastUsedIdentifierKey, GAState2.getIdentifier());
            initAnnotations["user_id"] = GAState2.getIdentifier();
            initAnnotations["sdk_version"] = GADevice.getRelevantSdkVersion();
            initAnnotations["os_version"] = GADevice.osVersion;
            initAnnotations["platform"] = GADevice.buildPlatform;
            if (GAState2.getBuild()) {
              initAnnotations["build"] = GAState2.getBuild();
            } else {
              initAnnotations["build"] = null;
            }
            initAnnotations["session_num"] = GAState2.getSessionNum();
            initAnnotations["random_salt"] = GAState2.getSessionNum();
            return initAnnotations;
          };
          GAState2.getClientTsAdjusted = function() {
            var clientTs = GAUtilities.timeIntervalSince1970();
            var clientTsAdjustedInteger = clientTs + GAState2.instance.clientServerTimeOffset;
            if (GAValidator.validateClientTs(clientTsAdjustedInteger)) {
              return clientTsAdjustedInteger;
            } else {
              return clientTs;
            }
          };
          GAState2.sessionIsStarted = function() {
            return GAState2.instance.sessionStart != 0;
          };
          GAState2.cacheIdentifier = function() {
            if (GAState2.instance.userId) {
              GAState2.instance.identifier = GAState2.instance.userId;
            } else if (GAState2.instance.defaultUserId) {
              GAState2.instance.identifier = GAState2.instance.defaultUserId;
            }
          };
          GAState2.ensurePersistedStates = function() {
            if (GAStore.isStorageAvailable()) {
              GAStore.load(GAState2.getGameKey());
            }
            var instance = GAState2.instance;
            instance.setDefaultId(GAStore.getItem(GAState2.getGameKey(), GAState2.DefaultUserIdKey) != null ? GAStore.getItem(GAState2.getGameKey(), GAState2.DefaultUserIdKey) : GAUtilities.createGuid());
            instance.sessionNum = GAStore.getItem(GAState2.getGameKey(), GAState2.SessionNumKey) != null ? Number(GAStore.getItem(GAState2.getGameKey(), GAState2.SessionNumKey)) : 0;
            instance.transactionNum = GAStore.getItem(GAState2.getGameKey(), GAState2.TransactionNumKey) != null ? Number(GAStore.getItem(GAState2.getGameKey(), GAState2.TransactionNumKey)) : 0;
            if (instance.currentCustomDimension01) {
              GAStore.setItem(GAState2.getGameKey(), GAState2.Dimension01Key, instance.currentCustomDimension01);
            } else {
              instance.currentCustomDimension01 = GAStore.getItem(GAState2.getGameKey(), GAState2.Dimension01Key) != null ? GAStore.getItem(GAState2.getGameKey(), GAState2.Dimension01Key) : "";
              if (instance.currentCustomDimension01) {
              }
            }
            if (instance.currentCustomDimension02) {
              GAStore.setItem(GAState2.getGameKey(), GAState2.Dimension02Key, instance.currentCustomDimension02);
            } else {
              instance.currentCustomDimension02 = GAStore.getItem(GAState2.getGameKey(), GAState2.Dimension02Key) != null ? GAStore.getItem(GAState2.getGameKey(), GAState2.Dimension02Key) : "";
              if (instance.currentCustomDimension02) {
              }
            }
            if (instance.currentCustomDimension03) {
              GAStore.setItem(GAState2.getGameKey(), GAState2.Dimension03Key, instance.currentCustomDimension03);
            } else {
              instance.currentCustomDimension03 = GAStore.getItem(GAState2.getGameKey(), GAState2.Dimension03Key) != null ? GAStore.getItem(GAState2.getGameKey(), GAState2.Dimension03Key) : "";
              if (instance.currentCustomDimension03) {
              }
            }
            var sdkConfigCachedString = GAStore.getItem(GAState2.getGameKey(), GAState2.SdkConfigCachedKey) != null ? GAStore.getItem(GAState2.getGameKey(), GAState2.SdkConfigCachedKey) : "";
            if (sdkConfigCachedString) {
              var sdkConfigCached = JSON.parse(GAUtilities.decode64(sdkConfigCachedString));
              if (sdkConfigCached) {
                var lastUsedIdentifier = GAStore.getItem(GAState2.getGameKey(), GAState2.LastUsedIdentifierKey);
                if (lastUsedIdentifier != null && lastUsedIdentifier != GAState2.getIdentifier()) {
                  GALogger.w("New identifier spotted compared to last one used, clearing cached configs hash!!");
                  if (sdkConfigCached["configs_hash"]) {
                    delete sdkConfigCached["configs_hash"];
                  }
                }
                instance.sdkConfigCached = sdkConfigCached;
              }
            }
            {
              var currentSdkConfig = GAState2.getSdkConfig();
              instance.configsHash = currentSdkConfig["configs_hash"] ? currentSdkConfig["configs_hash"] : "";
              instance.abId = currentSdkConfig["ab_id"] ? currentSdkConfig["ab_id"] : "";
              instance.abVariantId = currentSdkConfig["ab_variant_id"] ? currentSdkConfig["ab_variant_id"] : "";
            }
            var results_ga_progression = GAStore.select(EGAStore.Progression);
            if (results_ga_progression) {
              for (var i3 = 0; i3 < results_ga_progression.length; ++i3) {
                var result = results_ga_progression[i3];
                if (result) {
                  instance.progressionTries[result["progression"]] = result["tries"];
                }
              }
            }
          };
          GAState2.calculateServerTimeOffset = function(serverTs) {
            var clientTs = GAUtilities.timeIntervalSince1970();
            return serverTs - clientTs;
          };
          GAState2.formatString = function(s2, args) {
            var formatted = s2;
            for (var i3 = 0; i3 < args.length; i3++) {
              var regexp = new RegExp("\\{" + i3 + "\\}", "gi");
              formatted = formatted.replace(regexp, arguments[i3]);
            }
            return formatted;
          };
          GAState2.validateAndCleanCustomFields = function(fields, errorCallback) {
            if (errorCallback === void 0) {
              errorCallback = null;
            }
            var result = {};
            if (fields) {
              var count2 = 0;
              for (var key in fields) {
                var value = fields[key];
                if (!key || !value) {
                  var baseMessage = "validateAndCleanCustomFields: entry with key={0}, value={1} has been omitted because its key or value is null";
                  var message = GAState2.formatString(baseMessage, [key, value]);
                  GALogger.w(message);
                  if (errorCallback) {
                    errorCallback(baseMessage, message);
                  }
                } else if (count2 < GAState2.MAX_CUSTOM_FIELDS_COUNT) {
                  var regex = new RegExp("^[a-zA-Z0-9_]{1," + GAState2.MAX_CUSTOM_FIELDS_KEY_LENGTH + "}$");
                  if (GAUtilities.stringMatch(key, regex)) {
                    var type = typeof value;
                    if (type === "string" || value instanceof String) {
                      var valueAsString = value;
                      if (valueAsString.length <= GAState2.MAX_CUSTOM_FIELDS_VALUE_STRING_LENGTH && valueAsString.length > 0) {
                        result[key] = valueAsString;
                        ++count2;
                      } else {
                        var baseMessage = "validateAndCleanCustomFields: entry with key={0}, value={1} has been omitted because its value is an empty string or exceeds the max number of characters (" + GAState2.MAX_CUSTOM_FIELDS_VALUE_STRING_LENGTH + ")";
                        var message = GAState2.formatString(baseMessage, [key, value]);
                        GALogger.w(message);
                        if (errorCallback) {
                          errorCallback(baseMessage, message);
                        }
                      }
                    } else if (type === "number" || value instanceof Number) {
                      var valueAsNumber = value;
                      result[key] = valueAsNumber;
                      ++count2;
                    } else {
                      var baseMessage = "validateAndCleanCustomFields: entry with key={0}, value={1} has been omitted because its value is not a string or number";
                      var message = GAState2.formatString(baseMessage, [key, value]);
                      GALogger.w(message);
                      if (errorCallback) {
                        errorCallback(baseMessage, message);
                      }
                    }
                  } else {
                    var baseMessage = "validateAndCleanCustomFields: entry with key={0}, value={1} has been omitted because its key contains illegal character, is empty or exceeds the max number of characters (" + GAState2.MAX_CUSTOM_FIELDS_KEY_LENGTH + ")";
                    var message = GAState2.formatString(baseMessage, [key, value]);
                    GALogger.w(message);
                    if (errorCallback) {
                      errorCallback(baseMessage, message);
                    }
                  }
                } else {
                  var baseMessage = "validateAndCleanCustomFields: entry with key={0}, value={1} has been omitted because it exceeds the max number of custom fields (" + GAState2.MAX_CUSTOM_FIELDS_COUNT + ")";
                  var message = GAState2.formatString(baseMessage, [key, value]);
                  GALogger.w(message);
                  if (errorCallback) {
                    errorCallback(baseMessage, message);
                  }
                }
              }
            }
            return result;
          };
          GAState2.validateAndFixCurrentDimensions = function() {
            if (!GAValidator.validateDimension01(GAState2.getCurrentCustomDimension01(), GAState2.getAvailableCustomDimensions01())) {
              GAState2.setCustomDimension01("");
            }
            if (!GAValidator.validateDimension02(GAState2.getCurrentCustomDimension02(), GAState2.getAvailableCustomDimensions02())) {
              GAState2.setCustomDimension02("");
            }
            if (!GAValidator.validateDimension03(GAState2.getCurrentCustomDimension03(), GAState2.getAvailableCustomDimensions03())) {
              GAState2.setCustomDimension03("");
            }
          };
          GAState2.getConfigurationStringValue = function(key, defaultValue2) {
            if (GAState2.instance.configurations[key]) {
              return GAState2.instance.configurations[key].toString();
            } else {
              return defaultValue2;
            }
          };
          GAState2.isRemoteConfigsReady = function() {
            return GAState2.instance.remoteConfigsIsReady;
          };
          GAState2.addRemoteConfigsListener = function(listener) {
            if (GAState2.instance.remoteConfigsListeners.indexOf(listener) < 0) {
              GAState2.instance.remoteConfigsListeners.push(listener);
            }
          };
          GAState2.removeRemoteConfigsListener = function(listener) {
            var index = GAState2.instance.remoteConfigsListeners.indexOf(listener);
            if (index > -1) {
              GAState2.instance.remoteConfigsListeners.splice(index, 1);
            }
          };
          GAState2.getRemoteConfigsContentAsString = function() {
            return JSON.stringify(GAState2.instance.configurations);
          };
          GAState2.populateConfigurations = function(sdkConfig) {
            var configurations = sdkConfig["configs"];
            if (configurations) {
              GAState2.instance.configurations = {};
              for (var i3 = 0; i3 < configurations.length; ++i3) {
                var configuration = configurations[i3];
                if (configuration) {
                  var key = configuration["key"];
                  var value = configuration["value"];
                  var start_ts = configuration["start_ts"] ? configuration["start_ts"] : Number.MIN_VALUE;
                  var end_ts = configuration["end_ts"] ? configuration["end_ts"] : Number.MAX_VALUE;
                  var client_ts_adjusted = GAState2.getClientTsAdjusted();
                  if (key && value && client_ts_adjusted > start_ts && client_ts_adjusted < end_ts) {
                    GAState2.instance.configurations[key] = value;
                  }
                }
              }
            }
            GAState2.instance.remoteConfigsIsReady = true;
            var listeners = GAState2.instance.remoteConfigsListeners;
            for (var i3 = 0; i3 < listeners.length; ++i3) {
              if (listeners[i3]) {
                listeners[i3].onRemoteConfigsUpdated();
              }
            }
          };
          GAState2.addOnBeforeUnloadListener = function(listener) {
            if (GAState2.instance.beforeUnloadListeners.indexOf(listener) < 0) {
              GAState2.instance.beforeUnloadListeners.push(listener);
            }
          };
          GAState2.removeOnBeforeUnloadListener = function(listener) {
            var index = GAState2.instance.beforeUnloadListeners.indexOf(listener);
            if (index > -1) {
              GAState2.instance.beforeUnloadListeners.splice(index, 1);
            }
          };
          GAState2.notifyBeforeUnloadListeners = function() {
            var listeners = GAState2.instance.beforeUnloadListeners;
            for (var i3 = 0; i3 < listeners.length; ++i3) {
              if (listeners[i3]) {
                listeners[i3].onBeforeUnload();
              }
            }
          };
          GAState2.CategorySdkError = "sdk_error";
          GAState2.MAX_CUSTOM_FIELDS_COUNT = 50;
          GAState2.MAX_CUSTOM_FIELDS_KEY_LENGTH = 64;
          GAState2.MAX_CUSTOM_FIELDS_VALUE_STRING_LENGTH = 256;
          GAState2.instance = new GAState2();
          GAState2.DefaultUserIdKey = "default_user_id";
          GAState2.SessionNumKey = "session_num";
          GAState2.TransactionNumKey = "transaction_num";
          GAState2.Dimension01Key = "dimension01";
          GAState2.Dimension02Key = "dimension02";
          GAState2.Dimension03Key = "dimension03";
          GAState2.SdkConfigCachedKey = "sdk_config_cached";
          GAState2.LastUsedIdentifierKey = "last_used_identifier";
          return GAState2;
        }();
        state2.GAState = GAState;
      })(state = gameanalytics2.state || (gameanalytics2.state = {}));
    })(gameanalytics || (gameanalytics = {}));
    var gameanalytics;
    (function(gameanalytics2) {
      var tasks;
      (function(tasks2) {
        var GAUtilities = gameanalytics2.utilities.GAUtilities;
        var GALogger = gameanalytics2.logging.GALogger;
        var SdkErrorTask = function() {
          function SdkErrorTask2() {
          }
          SdkErrorTask2.execute = function(url, type, payloadData, secretKey) {
            var now = /* @__PURE__ */ new Date();
            if (!SdkErrorTask2.timestampMap[type]) {
              SdkErrorTask2.timestampMap[type] = now;
            }
            if (!SdkErrorTask2.countMap[type]) {
              SdkErrorTask2.countMap[type] = 0;
            }
            var diff = now.getTime() - SdkErrorTask2.timestampMap[type].getTime();
            var diffSeconds = diff / 1e3;
            if (diffSeconds >= 3600) {
              SdkErrorTask2.timestampMap[type] = now;
              SdkErrorTask2.countMap[type] = 0;
            }
            if (SdkErrorTask2.countMap[type] >= SdkErrorTask2.MaxCount) {
              return;
            }
            var hashHmac = GAUtilities.getHmac(secretKey, payloadData);
            var request = new XMLHttpRequest();
            request.onreadystatechange = function() {
              if (request.readyState === 4) {
                if (!request.responseText) {
                  return;
                }
                if (request.status != 200) {
                  GALogger.w("sdk error failed. response code not 200. status code: " + request.status + ", description: " + request.statusText + ", body: " + request.responseText);
                  return;
                } else {
                  SdkErrorTask2.countMap[type] = SdkErrorTask2.countMap[type] + 1;
                }
              }
            };
            request.open("POST", url, true);
            request.setRequestHeader("Content-Type", "application/json");
            request.setRequestHeader("Authorization", hashHmac);
            try {
              request.send(payloadData);
            } catch (e2) {
              console.error(e2);
            }
          };
          SdkErrorTask2.MaxCount = 10;
          SdkErrorTask2.countMap = {};
          SdkErrorTask2.timestampMap = {};
          return SdkErrorTask2;
        }();
        tasks2.SdkErrorTask = SdkErrorTask;
      })(tasks = gameanalytics2.tasks || (gameanalytics2.tasks = {}));
    })(gameanalytics || (gameanalytics = {}));
    var gameanalytics;
    (function(gameanalytics2) {
      var http;
      (function(http2) {
        var GAState = gameanalytics2.state.GAState;
        var GALogger = gameanalytics2.logging.GALogger;
        var GAUtilities = gameanalytics2.utilities.GAUtilities;
        var GAValidator = gameanalytics2.validators.GAValidator;
        var SdkErrorTask = gameanalytics2.tasks.SdkErrorTask;
        var EGASdkErrorCategory = gameanalytics2.events.EGASdkErrorCategory;
        var EGASdkErrorArea = gameanalytics2.events.EGASdkErrorArea;
        var EGASdkErrorAction = gameanalytics2.events.EGASdkErrorAction;
        var EGASdkErrorParameter = gameanalytics2.events.EGASdkErrorParameter;
        var GAHTTPApi = function() {
          function GAHTTPApi2() {
            this.protocol = "https";
            this.hostName = "api.gameanalytics.com";
            this.version = "v2";
            this.remoteConfigsVersion = "v1";
            this.baseUrl = this.protocol + "://" + this.hostName + "/" + this.version;
            this.remoteConfigsBaseUrl = this.protocol + "://" + this.hostName + "/remote_configs/" + this.remoteConfigsVersion;
            this.initializeUrlPath = "init";
            this.eventsUrlPath = "events";
            this.useGzip = false;
          }
          GAHTTPApi2.prototype.requestInit = function(configsHash, callback) {
            var gameKey = GAState.getGameKey();
            var url = this.remoteConfigsBaseUrl + "/" + this.initializeUrlPath + "?game_key=" + gameKey + "&interval_seconds=0&configs_hash=" + configsHash;
            var initAnnotations = GAState.getInitAnnotations();
            var JSONstring = JSON.stringify(initAnnotations);
            if (!JSONstring) {
              callback(http2.EGAHTTPApiResponse.JsonEncodeFailed, null);
              return;
            }
            var payloadData = this.createPayloadData(JSONstring, this.useGzip);
            var extraArgs = [];
            extraArgs.push(JSONstring);
            GAHTTPApi2.sendRequest(url, payloadData, extraArgs, this.useGzip, GAHTTPApi2.initRequestCallback, callback);
          };
          GAHTTPApi2.prototype.sendEventsInArray = function(eventArray, requestId, callback) {
            if (eventArray.length == 0) {
              return;
            }
            var gameKey = GAState.getGameKey();
            var url = this.baseUrl + "/" + gameKey + "/" + this.eventsUrlPath;
            var JSONstring = JSON.stringify(eventArray);
            if (!JSONstring) {
              callback(http2.EGAHTTPApiResponse.JsonEncodeFailed, null, requestId, eventArray.length);
              return;
            }
            var payloadData = this.createPayloadData(JSONstring, this.useGzip);
            var extraArgs = [];
            extraArgs.push(JSONstring);
            extraArgs.push(requestId);
            extraArgs.push(eventArray.length.toString());
            GAHTTPApi2.sendRequest(url, payloadData, extraArgs, this.useGzip, GAHTTPApi2.sendEventInArrayRequestCallback, callback);
          };
          GAHTTPApi2.prototype.sendSdkErrorEvent = function(category, area, action, parameter, reason, gameKey, secretKey) {
            if (!GAState.isEventSubmissionEnabled()) {
              return;
            }
            if (!GAValidator.validateSdkErrorEvent(gameKey, secretKey, category, area, action)) {
              return;
            }
            var url = this.baseUrl + "/" + gameKey + "/" + this.eventsUrlPath;
            var payloadJSONString = "";
            var errorType = "";
            var json = GAState.getSdkErrorEventAnnotations();
            var categoryString = GAHTTPApi2.sdkErrorCategoryString(category);
            json["error_category"] = categoryString;
            errorType += categoryString;
            var areaString = GAHTTPApi2.sdkErrorAreaString(area);
            json["error_area"] = areaString;
            errorType += ":" + areaString;
            var actionString = GAHTTPApi2.sdkErrorActionString(action);
            json["error_action"] = actionString;
            var parameterString = GAHTTPApi2.sdkErrorParameterString(parameter);
            if (parameterString.length > 0) {
              json["error_parameter"] = parameterString;
            }
            if (reason.length > 0) {
              var reasonTrimmed = reason;
              if (reason.length > GAHTTPApi2.MAX_ERROR_MESSAGE_LENGTH) {
                var reasonTrimmed = reason.substring(0, GAHTTPApi2.MAX_ERROR_MESSAGE_LENGTH);
              }
              json["reason"] = reasonTrimmed;
            }
            var eventArray = [];
            eventArray.push(json);
            payloadJSONString = JSON.stringify(eventArray);
            if (!payloadJSONString) {
              GALogger.w("sendSdkErrorEvent: JSON encoding failed.");
              return;
            }
            SdkErrorTask.execute(url, errorType, payloadJSONString, secretKey);
          };
          GAHTTPApi2.sendEventInArrayRequestCallback = function(request, url, callback, extra) {
            if (extra === void 0) {
              extra = null;
            }
            var authorization = extra[0];
            var JSONstring = extra[1];
            var requestId = extra[2];
            var eventCount = parseInt(extra[3]);
            var body = "";
            var responseCode = 0;
            body = request.responseText;
            responseCode = request.status;
            var requestResponseEnum = GAHTTPApi2.instance.processRequestResponse(responseCode, request.statusText, body, "Events");
            if (requestResponseEnum != http2.EGAHTTPApiResponse.Ok && requestResponseEnum != http2.EGAHTTPApiResponse.Created && requestResponseEnum != http2.EGAHTTPApiResponse.BadRequest) {
              callback(requestResponseEnum, null, requestId, eventCount);
              return;
            }
            var requestJsonDict = body ? JSON.parse(body) : {};
            if (requestJsonDict == null) {
              callback(http2.EGAHTTPApiResponse.JsonDecodeFailed, null, requestId, eventCount);
              GAHTTPApi2.instance.sendSdkErrorEvent(EGASdkErrorCategory.Http, EGASdkErrorArea.EventsHttp, EGASdkErrorAction.FailHttpJsonDecode, EGASdkErrorParameter.Undefined, body, GAState.getGameKey(), GAState.getGameSecret());
              return;
            }
            if (requestResponseEnum == http2.EGAHTTPApiResponse.BadRequest) {
            }
            callback(requestResponseEnum, requestJsonDict, requestId, eventCount);
          };
          GAHTTPApi2.sendRequest = function(url, payloadData, extraArgs, gzip, callback, callback2) {
            var request = new XMLHttpRequest();
            var key = GAState.getGameSecret();
            var authorization = GAUtilities.getHmac(key, payloadData);
            var args = [];
            args.push(authorization);
            for (var s2 in extraArgs) {
              args.push(extraArgs[s2]);
            }
            request.onreadystatechange = function() {
              if (request.readyState === 4) {
                callback(request, url, callback2, args);
              }
            };
            request.open("POST", url, true);
            request.setRequestHeader("Content-Type", "application/json");
            request.setRequestHeader("Authorization", authorization);
            if (gzip) {
              throw new Error("gzip not supported");
            }
            try {
              request.send(payloadData);
            } catch (e2) {
              console.error(e2.stack);
            }
          };
          GAHTTPApi2.initRequestCallback = function(request, url, callback, extra) {
            if (extra === void 0) {
              extra = null;
            }
            var authorization = extra[0];
            var JSONstring = extra[1];
            var body = "";
            var responseCode = 0;
            body = request.responseText;
            responseCode = request.status;
            var requestJsonDict = body ? JSON.parse(body) : {};
            var requestResponseEnum = GAHTTPApi2.instance.processRequestResponse(responseCode, request.statusText, body, "Init");
            if (requestResponseEnum != http2.EGAHTTPApiResponse.Ok && requestResponseEnum != http2.EGAHTTPApiResponse.Created && requestResponseEnum != http2.EGAHTTPApiResponse.BadRequest) {
              callback(requestResponseEnum, null, "", 0);
              return;
            }
            if (requestJsonDict == null) {
              callback(http2.EGAHTTPApiResponse.JsonDecodeFailed, null, "", 0);
              GAHTTPApi2.instance.sendSdkErrorEvent(EGASdkErrorCategory.Http, EGASdkErrorArea.InitHttp, EGASdkErrorAction.FailHttpJsonDecode, EGASdkErrorParameter.Undefined, body, GAState.getGameKey(), GAState.getGameSecret());
              return;
            }
            if (requestResponseEnum === http2.EGAHTTPApiResponse.BadRequest) {
              callback(requestResponseEnum, null, "", 0);
              return;
            }
            var validatedInitValues = GAValidator.validateAndCleanInitRequestResponse(requestJsonDict, requestResponseEnum === http2.EGAHTTPApiResponse.Created);
            if (!validatedInitValues) {
              callback(http2.EGAHTTPApiResponse.BadResponse, null, "", 0);
              return;
            }
            callback(requestResponseEnum, validatedInitValues, "", 0);
          };
          GAHTTPApi2.prototype.createPayloadData = function(payload, gzip) {
            var payloadData;
            if (gzip) {
              throw new Error("gzip not supported");
            } else {
              payloadData = payload;
            }
            return payloadData;
          };
          GAHTTPApi2.prototype.processRequestResponse = function(responseCode, responseMessage, body, requestId) {
            if (!body) {
              return http2.EGAHTTPApiResponse.NoResponse;
            }
            if (responseCode === 200) {
              return http2.EGAHTTPApiResponse.Ok;
            }
            if (responseCode === 201) {
              return http2.EGAHTTPApiResponse.Created;
            }
            if (responseCode === 0 || responseCode === 401) {
              return http2.EGAHTTPApiResponse.Unauthorized;
            }
            if (responseCode === 400) {
              return http2.EGAHTTPApiResponse.BadRequest;
            }
            if (responseCode === 500) {
              return http2.EGAHTTPApiResponse.InternalServerError;
            }
            return http2.EGAHTTPApiResponse.UnknownResponseCode;
          };
          GAHTTPApi2.sdkErrorCategoryString = function(value) {
            switch (value) {
              case EGASdkErrorCategory.EventValidation:
                return "event_validation";
              case EGASdkErrorCategory.Database:
                return "db";
              case EGASdkErrorCategory.Init:
                return "init";
              case EGASdkErrorCategory.Http:
                return "http";
              case EGASdkErrorCategory.Json:
                return "json";
              default:
                break;
            }
            return "";
          };
          GAHTTPApi2.sdkErrorAreaString = function(value) {
            switch (value) {
              case EGASdkErrorArea.BusinessEvent:
                return "business";
              case EGASdkErrorArea.ResourceEvent:
                return "resource";
              case EGASdkErrorArea.ProgressionEvent:
                return "progression";
              case EGASdkErrorArea.DesignEvent:
                return "design";
              case EGASdkErrorArea.ErrorEvent:
                return "error";
              case EGASdkErrorArea.InitHttp:
                return "init_http";
              case EGASdkErrorArea.EventsHttp:
                return "events_http";
              case EGASdkErrorArea.ProcessEvents:
                return "process_events";
              case EGASdkErrorArea.AddEventsToStore:
                return "add_events_to_store";
              default:
                break;
            }
            return "";
          };
          GAHTTPApi2.sdkErrorActionString = function(value) {
            switch (value) {
              case EGASdkErrorAction.InvalidCurrency:
                return "invalid_currency";
              case EGASdkErrorAction.InvalidShortString:
                return "invalid_short_string";
              case EGASdkErrorAction.InvalidEventPartLength:
                return "invalid_event_part_length";
              case EGASdkErrorAction.InvalidEventPartCharacters:
                return "invalid_event_part_characters";
              case EGASdkErrorAction.InvalidStore:
                return "invalid_store";
              case EGASdkErrorAction.InvalidFlowType:
                return "invalid_flow_type";
              case EGASdkErrorAction.StringEmptyOrNull:
                return "string_empty_or_null";
              case EGASdkErrorAction.NotFoundInAvailableCurrencies:
                return "not_found_in_available_currencies";
              case EGASdkErrorAction.InvalidAmount:
                return "invalid_amount";
              case EGASdkErrorAction.NotFoundInAvailableItemTypes:
                return "not_found_in_available_item_types";
              case EGASdkErrorAction.WrongProgressionOrder:
                return "wrong_progression_order";
              case EGASdkErrorAction.InvalidEventIdLength:
                return "invalid_event_id_length";
              case EGASdkErrorAction.InvalidEventIdCharacters:
                return "invalid_event_id_characters";
              case EGASdkErrorAction.InvalidProgressionStatus:
                return "invalid_progression_status";
              case EGASdkErrorAction.InvalidSeverity:
                return "invalid_severity";
              case EGASdkErrorAction.InvalidLongString:
                return "invalid_long_string";
              case EGASdkErrorAction.DatabaseTooLarge:
                return "db_too_large";
              case EGASdkErrorAction.DatabaseOpenOrCreate:
                return "db_open_or_create";
              case EGASdkErrorAction.JsonError:
                return "json_error";
              case EGASdkErrorAction.FailHttpJsonDecode:
                return "fail_http_json_decode";
              case EGASdkErrorAction.FailHttpJsonEncode:
                return "fail_http_json_encode";
              default:
                break;
            }
            return "";
          };
          GAHTTPApi2.sdkErrorParameterString = function(value) {
            switch (value) {
              case EGASdkErrorParameter.Currency:
                return "currency";
              case EGASdkErrorParameter.CartType:
                return "cart_type";
              case EGASdkErrorParameter.ItemType:
                return "item_type";
              case EGASdkErrorParameter.ItemId:
                return "item_id";
              case EGASdkErrorParameter.Store:
                return "store";
              case EGASdkErrorParameter.FlowType:
                return "flow_type";
              case EGASdkErrorParameter.Amount:
                return "amount";
              case EGASdkErrorParameter.Progression01:
                return "progression01";
              case EGASdkErrorParameter.Progression02:
                return "progression02";
              case EGASdkErrorParameter.Progression03:
                return "progression03";
              case EGASdkErrorParameter.EventId:
                return "event_id";
              case EGASdkErrorParameter.ProgressionStatus:
                return "progression_status";
              case EGASdkErrorParameter.Severity:
                return "severity";
              case EGASdkErrorParameter.Message:
                return "message";
              default:
                break;
            }
            return "";
          };
          GAHTTPApi2.instance = new GAHTTPApi2();
          GAHTTPApi2.MAX_ERROR_MESSAGE_LENGTH = 256;
          return GAHTTPApi2;
        }();
        http2.GAHTTPApi = GAHTTPApi;
      })(http = gameanalytics2.http || (gameanalytics2.http = {}));
    })(gameanalytics || (gameanalytics = {}));
    var gameanalytics;
    (function(gameanalytics2) {
      var events;
      (function(events_1) {
        var GAStore = gameanalytics2.store.GAStore;
        var EGAStore = gameanalytics2.store.EGAStore;
        var EGAStoreArgsOperator = gameanalytics2.store.EGAStoreArgsOperator;
        var GAState = gameanalytics2.state.GAState;
        var GALogger = gameanalytics2.logging.GALogger;
        var GAUtilities = gameanalytics2.utilities.GAUtilities;
        var EGAHTTPApiResponse = gameanalytics2.http.EGAHTTPApiResponse;
        var GAHTTPApi = gameanalytics2.http.GAHTTPApi;
        var GAValidator = gameanalytics2.validators.GAValidator;
        var GAEvents = function() {
          function GAEvents2() {
          }
          GAEvents2.customEventFieldsErrorCallback = function(baseMessage, message) {
            if (!GAState.isEventSubmissionEnabled()) {
              return;
            }
            var now = /* @__PURE__ */ new Date();
            if (!GAEvents2.timestampMap[baseMessage]) {
              GAEvents2.timestampMap[baseMessage] = now;
            }
            if (!GAEvents2.countMap[baseMessage]) {
              GAEvents2.countMap[baseMessage] = 0;
            }
            var diff = now.getTime() - GAEvents2.timestampMap[baseMessage].getTime();
            var diffSeconds = diff / 1e3;
            if (diffSeconds >= 3600) {
              GAEvents2.timestampMap[baseMessage] = now;
              GAEvents2.countMap[baseMessage] = 0;
            }
            if (GAEvents2.countMap[baseMessage] >= GAEvents2.MAX_ERROR_COUNT) {
              return;
            }
            gameanalytics2.threading.GAThreading.performTaskOnGAThread(function() {
              GAEvents2.addErrorEvent(gameanalytics2.EGAErrorSeverity.Warning, message, null, true);
              GAEvents2.countMap[baseMessage] = GAEvents2.countMap[baseMessage] + 1;
            });
          };
          GAEvents2.addSessionStartEvent = function() {
            if (!GAState.isEventSubmissionEnabled()) {
              return;
            }
            var eventDict = {};
            eventDict["category"] = GAEvents2.CategorySessionStart;
            GAState.incrementSessionNum();
            GAStore.setItem(GAState.getGameKey(), GAState.SessionNumKey, GAState.getSessionNum().toString());
            GAEvents2.addDimensionsToEvent(eventDict);
            var fieldsToUse = GAState.instance.currentGlobalCustomEventFields;
            GAEvents2.addCustomFieldsToEvent(eventDict, GAState.validateAndCleanCustomFields(fieldsToUse, GAEvents2.customEventFieldsErrorCallback));
            GAEvents2.addEventToStore(eventDict);
            GALogger.i("Add SESSION START event");
            GAEvents2.processEvents(GAEvents2.CategorySessionStart, false);
          };
          GAEvents2.addSessionEndEvent = function() {
            if (!GAState.isEventSubmissionEnabled()) {
              return;
            }
            var session_start_ts = GAState.getSessionStart();
            var client_ts_adjusted = GAState.getClientTsAdjusted();
            var sessionLength = client_ts_adjusted - session_start_ts;
            if (sessionLength < 0) {
              GALogger.w("Session length was calculated to be less then 0. Should not be possible. Resetting to 0.");
              sessionLength = 0;
            }
            var eventDict = {};
            eventDict["category"] = GAEvents2.CategorySessionEnd;
            eventDict["length"] = sessionLength;
            GAEvents2.addDimensionsToEvent(eventDict);
            var fieldsToUse = GAState.instance.currentGlobalCustomEventFields;
            GAEvents2.addCustomFieldsToEvent(eventDict, GAState.validateAndCleanCustomFields(fieldsToUse, GAEvents2.customEventFieldsErrorCallback));
            GAEvents2.addEventToStore(eventDict);
            GALogger.i("Add SESSION END event.");
            GAEvents2.processEvents("", false);
          };
          GAEvents2.addBusinessEvent = function(currency, amount, itemType, itemId, cartType, fields, mergeFields) {
            if (cartType === void 0) {
              cartType = null;
            }
            if (!GAState.isEventSubmissionEnabled()) {
              return;
            }
            var validationResult = GAValidator.validateBusinessEvent(currency, amount, cartType, itemType, itemId);
            if (validationResult != null) {
              GAHTTPApi.instance.sendSdkErrorEvent(validationResult.category, validationResult.area, validationResult.action, validationResult.parameter, validationResult.reason, GAState.getGameKey(), GAState.getGameSecret());
              return;
            }
            var eventDict = {};
            GAState.incrementTransactionNum();
            GAStore.setItem(GAState.getGameKey(), GAState.TransactionNumKey, GAState.getTransactionNum().toString());
            eventDict["event_id"] = itemType + ":" + itemId;
            eventDict["category"] = GAEvents2.CategoryBusiness;
            eventDict["currency"] = currency;
            eventDict["amount"] = amount;
            eventDict[GAState.TransactionNumKey] = GAState.getTransactionNum();
            if (cartType) {
              eventDict["cart_type"] = cartType;
            }
            GAEvents2.addDimensionsToEvent(eventDict);
            var fieldsToUse = {};
            if (fields && Object.keys(fields).length > 0) {
              for (var key in fields) {
                fieldsToUse[key] = fields[key];
              }
            } else {
              for (var key in GAState.instance.currentGlobalCustomEventFields) {
                fieldsToUse[key] = GAState.instance.currentGlobalCustomEventFields[key];
              }
            }
            if (mergeFields && fields && Object.keys(fields).length > 0) {
              for (var key in GAState.instance.currentGlobalCustomEventFields) {
                if (!fieldsToUse[key]) {
                  fieldsToUse[key] = GAState.instance.currentGlobalCustomEventFields[key];
                }
              }
            }
            GAEvents2.addCustomFieldsToEvent(eventDict, GAState.validateAndCleanCustomFields(fieldsToUse, GAEvents2.customEventFieldsErrorCallback));
            GALogger.i("Add BUSINESS event: {currency:" + currency + ", amount:" + amount + ", itemType:" + itemType + ", itemId:" + itemId + ", cartType:" + cartType + "}");
            GAEvents2.addEventToStore(eventDict);
          };
          GAEvents2.addResourceEvent = function(flowType, currency, amount, itemType, itemId, fields, mergeFields) {
            if (!GAState.isEventSubmissionEnabled()) {
              return;
            }
            var validationResult = GAValidator.validateResourceEvent(flowType, currency, amount, itemType, itemId, GAState.getAvailableResourceCurrencies(), GAState.getAvailableResourceItemTypes());
            if (validationResult != null) {
              GAHTTPApi.instance.sendSdkErrorEvent(validationResult.category, validationResult.area, validationResult.action, validationResult.parameter, validationResult.reason, GAState.getGameKey(), GAState.getGameSecret());
              return;
            }
            if (flowType === gameanalytics2.EGAResourceFlowType.Sink) {
              amount *= -1;
            }
            var eventDict = {};
            var flowTypeString = GAEvents2.resourceFlowTypeToString(flowType);
            eventDict["event_id"] = flowTypeString + ":" + currency + ":" + itemType + ":" + itemId;
            eventDict["category"] = GAEvents2.CategoryResource;
            eventDict["amount"] = amount;
            GAEvents2.addDimensionsToEvent(eventDict);
            var fieldsToUse = {};
            if (fields && Object.keys(fields).length > 0) {
              for (var key in fields) {
                fieldsToUse[key] = fields[key];
              }
            } else {
              for (var key in GAState.instance.currentGlobalCustomEventFields) {
                fieldsToUse[key] = GAState.instance.currentGlobalCustomEventFields[key];
              }
            }
            if (mergeFields && fields && Object.keys(fields).length > 0) {
              for (var key in GAState.instance.currentGlobalCustomEventFields) {
                if (!fieldsToUse[key]) {
                  fieldsToUse[key] = GAState.instance.currentGlobalCustomEventFields[key];
                }
              }
            }
            GAEvents2.addCustomFieldsToEvent(eventDict, GAState.validateAndCleanCustomFields(fieldsToUse, GAEvents2.customEventFieldsErrorCallback));
            GALogger.i("Add RESOURCE event: {currency:" + currency + ", amount:" + amount + ", itemType:" + itemType + ", itemId:" + itemId + "}");
            GAEvents2.addEventToStore(eventDict);
          };
          GAEvents2.addProgressionEvent = function(progressionStatus, progression01, progression02, progression03, score, sendScore, fields, mergeFields) {
            if (!GAState.isEventSubmissionEnabled()) {
              return;
            }
            var progressionStatusString = GAEvents2.progressionStatusToString(progressionStatus);
            var validationResult = GAValidator.validateProgressionEvent(progressionStatus, progression01, progression02, progression03);
            if (validationResult != null) {
              GAHTTPApi.instance.sendSdkErrorEvent(validationResult.category, validationResult.area, validationResult.action, validationResult.parameter, validationResult.reason, GAState.getGameKey(), GAState.getGameSecret());
              return;
            }
            var eventDict = {};
            var progressionIdentifier;
            if (!progression02) {
              progressionIdentifier = progression01;
            } else if (!progression03) {
              progressionIdentifier = progression01 + ":" + progression02;
            } else {
              progressionIdentifier = progression01 + ":" + progression02 + ":" + progression03;
            }
            eventDict["category"] = GAEvents2.CategoryProgression;
            eventDict["event_id"] = progressionStatusString + ":" + progressionIdentifier;
            var attempt_num = 0;
            if (sendScore && progressionStatus != gameanalytics2.EGAProgressionStatus.Start) {
              eventDict["score"] = Math.round(score);
            }
            if (progressionStatus === gameanalytics2.EGAProgressionStatus.Fail) {
              GAState.incrementProgressionTries(progressionIdentifier);
            }
            if (progressionStatus === gameanalytics2.EGAProgressionStatus.Complete) {
              GAState.incrementProgressionTries(progressionIdentifier);
              attempt_num = GAState.getProgressionTries(progressionIdentifier);
              eventDict["attempt_num"] = attempt_num;
              GAState.clearProgressionTries(progressionIdentifier);
            }
            GAEvents2.addDimensionsToEvent(eventDict);
            var fieldsToUse = {};
            if (fields && Object.keys(fields).length > 0) {
              for (var key in fields) {
                fieldsToUse[key] = fields[key];
              }
            } else {
              for (var key in GAState.instance.currentGlobalCustomEventFields) {
                fieldsToUse[key] = GAState.instance.currentGlobalCustomEventFields[key];
              }
            }
            if (mergeFields && fields && Object.keys(fields).length > 0) {
              for (var key in GAState.instance.currentGlobalCustomEventFields) {
                if (!fieldsToUse[key]) {
                  fieldsToUse[key] = GAState.instance.currentGlobalCustomEventFields[key];
                }
              }
            }
            GAEvents2.addCustomFieldsToEvent(eventDict, GAState.validateAndCleanCustomFields(fieldsToUse, GAEvents2.customEventFieldsErrorCallback));
            GALogger.i("Add PROGRESSION event: {status:" + progressionStatusString + ", progression01:" + progression01 + ", progression02:" + progression02 + ", progression03:" + progression03 + ", score:" + score + ", attempt:" + attempt_num + "}");
            GAEvents2.addEventToStore(eventDict);
          };
          GAEvents2.addDesignEvent = function(eventId, value, sendValue, fields, mergeFields) {
            if (!GAState.isEventSubmissionEnabled()) {
              return;
            }
            var validationResult = GAValidator.validateDesignEvent(eventId);
            if (validationResult != null) {
              GAHTTPApi.instance.sendSdkErrorEvent(validationResult.category, validationResult.area, validationResult.action, validationResult.parameter, validationResult.reason, GAState.getGameKey(), GAState.getGameSecret());
              return;
            }
            var eventData = {};
            eventData["category"] = GAEvents2.CategoryDesign;
            eventData["event_id"] = eventId;
            if (sendValue) {
              eventData["value"] = value;
            }
            GAEvents2.addDimensionsToEvent(eventData);
            var fieldsToUse = {};
            if (fields && Object.keys(fields).length > 0) {
              for (var key in fields) {
                fieldsToUse[key] = fields[key];
              }
            } else {
              for (var key in GAState.instance.currentGlobalCustomEventFields) {
                fieldsToUse[key] = GAState.instance.currentGlobalCustomEventFields[key];
              }
            }
            if (mergeFields && fields && Object.keys(fields).length > 0) {
              for (var key in GAState.instance.currentGlobalCustomEventFields) {
                if (!fieldsToUse[key]) {
                  fieldsToUse[key] = GAState.instance.currentGlobalCustomEventFields[key];
                }
              }
            }
            GAEvents2.addCustomFieldsToEvent(eventData, GAState.validateAndCleanCustomFields(fieldsToUse, GAEvents2.customEventFieldsErrorCallback));
            GALogger.i("Add DESIGN event: {eventId:" + eventId + ", value:" + value + "}");
            GAEvents2.addEventToStore(eventData);
          };
          GAEvents2.addErrorEvent = function(severity, message, fields, mergeFields, skipAddingFields) {
            if (skipAddingFields === void 0) {
              skipAddingFields = false;
            }
            if (!GAState.isEventSubmissionEnabled()) {
              return;
            }
            var severityString = GAEvents2.errorSeverityToString(severity);
            var validationResult = GAValidator.validateErrorEvent(severity, message);
            if (validationResult != null) {
              GAHTTPApi.instance.sendSdkErrorEvent(validationResult.category, validationResult.area, validationResult.action, validationResult.parameter, validationResult.reason, GAState.getGameKey(), GAState.getGameSecret());
              return;
            }
            var eventData = {};
            eventData["category"] = GAEvents2.CategoryError;
            eventData["severity"] = severityString;
            eventData["message"] = message;
            GAEvents2.addDimensionsToEvent(eventData);
            if (!skipAddingFields) {
              var fieldsToUse = {};
              if (fields && Object.keys(fields).length > 0) {
                for (var key in fields) {
                  fieldsToUse[key] = fields[key];
                }
              } else {
                for (var key in GAState.instance.currentGlobalCustomEventFields) {
                  fieldsToUse[key] = GAState.instance.currentGlobalCustomEventFields[key];
                }
              }
              if (mergeFields && fields && Object.keys(fields).length > 0) {
                for (var key in GAState.instance.currentGlobalCustomEventFields) {
                  if (!fieldsToUse[key]) {
                    fieldsToUse[key] = GAState.instance.currentGlobalCustomEventFields[key];
                  }
                }
              }
              GAEvents2.addCustomFieldsToEvent(eventData, GAState.validateAndCleanCustomFields(fieldsToUse, GAEvents2.customEventFieldsErrorCallback));
            }
            GALogger.i("Add ERROR event: {severity:" + severityString + ", message:" + message + "}");
            GAEvents2.addEventToStore(eventData);
          };
          GAEvents2.addAdEvent = function(adAction, adType, adSdkName, adPlacement, noAdReason, duration, sendDuration, fields, mergeFields) {
            if (!GAState.isEventSubmissionEnabled()) {
              return;
            }
            var adActionString = GAEvents2.adActionToString(adAction);
            var adTypeString = GAEvents2.adTypeToString(adType);
            var noAdReasonString = GAEvents2.adErrorToString(noAdReason);
            var validationResult = GAValidator.validateAdEvent(adAction, adType, adSdkName, adPlacement);
            if (validationResult != null) {
              GAHTTPApi.instance.sendSdkErrorEvent(validationResult.category, validationResult.area, validationResult.action, validationResult.parameter, validationResult.reason, GAState.getGameKey(), GAState.getGameSecret());
              return;
            }
            var eventData = {};
            eventData["category"] = GAEvents2.CategoryAds;
            eventData["ad_sdk_name"] = adSdkName;
            eventData["ad_placement"] = adPlacement;
            eventData["ad_type"] = adTypeString;
            eventData["ad_action"] = adActionString;
            if (adAction == gameanalytics2.EGAAdAction.FailedShow && noAdReasonString.length > 0) {
              eventData["ad_fail_show_reason"] = noAdReasonString;
            }
            if (sendDuration && (adType == gameanalytics2.EGAAdType.RewardedVideo || adType == gameanalytics2.EGAAdType.Video)) {
              eventData["ad_duration"] = duration;
            }
            GAEvents2.addDimensionsToEvent(eventData);
            var fieldsToUse = {};
            if (fields && Object.keys(fields).length > 0) {
              for (var key in fields) {
                fieldsToUse[key] = fields[key];
              }
            } else {
              for (var key in GAState.instance.currentGlobalCustomEventFields) {
                fieldsToUse[key] = GAState.instance.currentGlobalCustomEventFields[key];
              }
            }
            if (mergeFields && fields && Object.keys(fields).length > 0) {
              for (var key in GAState.instance.currentGlobalCustomEventFields) {
                if (!fieldsToUse[key]) {
                  fieldsToUse[key] = GAState.instance.currentGlobalCustomEventFields[key];
                }
              }
            }
            GAEvents2.addCustomFieldsToEvent(eventData, GAState.validateAndCleanCustomFields(fieldsToUse, GAEvents2.customEventFieldsErrorCallback));
            GALogger.i("Add AD event: {ad_sdk_name:" + adSdkName + ", ad_placement:" + adPlacement + ", ad_type:" + adTypeString + ", ad_action:" + adActionString + (adAction == gameanalytics2.EGAAdAction.FailedShow && noAdReasonString.length > 0 ? ", ad_fail_show_reason:" + noAdReasonString : "") + (sendDuration && (adType == gameanalytics2.EGAAdType.RewardedVideo || adType == gameanalytics2.EGAAdType.Video) ? ", ad_duration:" + duration : "") + "}");
            GAEvents2.addEventToStore(eventData);
          };
          GAEvents2.processEvents = function(category, performCleanUp) {
            if (!GAState.isEventSubmissionEnabled()) {
              return;
            }
            try {
              var requestIdentifier = GAUtilities.createGuid();
              if (performCleanUp) {
                GAEvents2.cleanupEvents();
                GAEvents2.fixMissingSessionEndEvents();
              }
              var selectArgs = [];
              selectArgs.push(["status", EGAStoreArgsOperator.Equal, "new"]);
              var updateWhereArgs = [];
              updateWhereArgs.push(["status", EGAStoreArgsOperator.Equal, "new"]);
              if (category) {
                selectArgs.push(["category", EGAStoreArgsOperator.Equal, category]);
                updateWhereArgs.push(["category", EGAStoreArgsOperator.Equal, category]);
              }
              var updateSetArgs = [];
              updateSetArgs.push(["status", requestIdentifier]);
              var events2 = GAStore.select(EGAStore.Events, selectArgs);
              if (!events2 || events2.length == 0) {
                GALogger.i("Event queue: No events to send");
                GAEvents2.updateSessionStore();
                return;
              }
              if (events2.length > GAEvents2.MaxEventCount) {
                events2 = GAStore.select(EGAStore.Events, selectArgs, true, GAEvents2.MaxEventCount);
                if (!events2) {
                  return;
                }
                var lastItem = events2[events2.length - 1];
                var lastTimestamp = lastItem["client_ts"];
                selectArgs.push(["client_ts", EGAStoreArgsOperator.LessOrEqual, lastTimestamp]);
                events2 = GAStore.select(EGAStore.Events, selectArgs);
                if (!events2) {
                  return;
                }
                updateWhereArgs.push(["client_ts", EGAStoreArgsOperator.LessOrEqual, lastTimestamp]);
              }
              GALogger.i("Event queue: Sending " + events2.length + " events.");
              if (!GAStore.update(EGAStore.Events, updateSetArgs, updateWhereArgs)) {
                return;
              }
              var payloadArray = [];
              for (var i3 = 0; i3 < events2.length; ++i3) {
                var ev = events2[i3];
                var eventDict = JSON.parse(GAUtilities.decode64(ev["event"]));
                if (eventDict.length != 0) {
                  var clientTs = eventDict["client_ts"];
                  if (clientTs && !GAValidator.validateClientTs(clientTs)) {
                    delete eventDict["client_ts"];
                  }
                  payloadArray.push(eventDict);
                }
              }
              GAHTTPApi.instance.sendEventsInArray(payloadArray, requestIdentifier, GAEvents2.processEventsCallback);
            } catch (e2) {
              GALogger.e("Error during ProcessEvents(): " + e2.stack);
              GAHTTPApi.instance.sendSdkErrorEvent(events_1.EGASdkErrorCategory.Json, events_1.EGASdkErrorArea.ProcessEvents, events_1.EGASdkErrorAction.JsonError, events_1.EGASdkErrorParameter.Undefined, e2.stack, GAState.getGameKey(), GAState.getGameSecret());
            }
          };
          GAEvents2.processEventsCallback = function(responseEnum, dataDict, requestId, eventCount) {
            var requestIdWhereArgs = [];
            requestIdWhereArgs.push(["status", EGAStoreArgsOperator.Equal, requestId]);
            if (responseEnum === EGAHTTPApiResponse.Ok) {
              GAStore["delete"](EGAStore.Events, requestIdWhereArgs);
              GALogger.i("Event queue: " + eventCount + " events sent.");
            } else {
              if (responseEnum === EGAHTTPApiResponse.NoResponse) {
                var setArgs = [];
                setArgs.push(["status", "new"]);
                GALogger.w("Event queue: Failed to send events to collector - Retrying next time");
                GAStore.update(EGAStore.Events, setArgs, requestIdWhereArgs);
              } else {
                if (dataDict) {
                  var json;
                  var count2 = 0;
                  for (var j2 in dataDict) {
                    if (count2 == 0) {
                      json = dataDict[j2];
                    }
                    ++count2;
                  }
                  if (responseEnum === EGAHTTPApiResponse.BadRequest && json.constructor === Array) {
                    GALogger.w("Event queue: " + eventCount + " events sent. " + count2 + " events failed GA server validation.");
                  } else {
                    GALogger.w("Event queue: Failed to send events.");
                  }
                } else {
                  GALogger.w("Event queue: Failed to send events.");
                }
                GAStore["delete"](EGAStore.Events, requestIdWhereArgs);
              }
            }
          };
          GAEvents2.cleanupEvents = function() {
            GAStore.update(EGAStore.Events, [["status", "new"]]);
          };
          GAEvents2.fixMissingSessionEndEvents = function() {
            if (!GAState.isEventSubmissionEnabled()) {
              return;
            }
            var args = [];
            args.push(["session_id", EGAStoreArgsOperator.NotEqual, GAState.getSessionId()]);
            var sessions = GAStore.select(EGAStore.Sessions, args);
            if (!sessions || sessions.length == 0) {
              return;
            }
            GALogger.i(sessions.length + " session(s) located with missing session_end event.");
            for (var i3 = 0; i3 < sessions.length; ++i3) {
              var sessionEndEvent = JSON.parse(GAUtilities.decode64(sessions[i3]["event"]));
              var event_ts = sessionEndEvent["client_ts"];
              var start_ts = sessions[i3]["timestamp"];
              var length = event_ts - start_ts;
              length = Math.max(0, length);
              sessionEndEvent["category"] = GAEvents2.CategorySessionEnd;
              sessionEndEvent["length"] = length;
              GAEvents2.addEventToStore(sessionEndEvent);
            }
          };
          GAEvents2.addEventToStore = function(eventData) {
            if (!GAState.isEventSubmissionEnabled()) {
              return;
            }
            if (!GAState.isInitialized()) {
              GALogger.w("Could not add event: SDK is not initialized");
              return;
            }
            try {
              if (GAStore.isStoreTooLargeForEvents() && !GAUtilities.stringMatch(eventData["category"], /^(user|session_end|business)$/)) {
                GALogger.w("Database too large. Event has been blocked.");
                GAHTTPApi.instance.sendSdkErrorEvent(events_1.EGASdkErrorCategory.Database, events_1.EGASdkErrorArea.AddEventsToStore, events_1.EGASdkErrorAction.DatabaseTooLarge, events_1.EGASdkErrorParameter.Undefined, "", GAState.getGameKey(), GAState.getGameSecret());
                return;
              }
              var ev = GAState.getEventAnnotations();
              for (var e2 in eventData) {
                ev[e2] = eventData[e2];
              }
              var json = JSON.stringify(ev);
              GALogger.ii("Event added to queue: " + json);
              var values = {};
              values["status"] = "new";
              values["category"] = ev["category"];
              values["session_id"] = ev["session_id"];
              values["client_ts"] = ev["client_ts"];
              values["event"] = GAUtilities.encode64(JSON.stringify(ev));
              GAStore.insert(EGAStore.Events, values);
              if (eventData["category"] == GAEvents2.CategorySessionEnd) {
                GAStore["delete"](EGAStore.Sessions, [["session_id", EGAStoreArgsOperator.Equal, ev["session_id"]]]);
              } else {
                GAEvents2.updateSessionStore();
              }
              if (GAStore.isStorageAvailable()) {
                GAStore.save(GAState.getGameKey());
              }
            } catch (e3) {
              GALogger.e("addEventToStore: error");
              GALogger.e(e3.stack);
              GAHTTPApi.instance.sendSdkErrorEvent(events_1.EGASdkErrorCategory.Database, events_1.EGASdkErrorArea.AddEventsToStore, events_1.EGASdkErrorAction.DatabaseTooLarge, events_1.EGASdkErrorParameter.Undefined, e3.stack, GAState.getGameKey(), GAState.getGameSecret());
            }
          };
          GAEvents2.updateSessionStore = function() {
            if (GAState.sessionIsStarted()) {
              var values = {};
              values["session_id"] = GAState.instance.sessionId;
              values["timestamp"] = GAState.getSessionStart();
              var ev = GAState.getEventAnnotations();
              GAEvents2.addDimensionsToEvent(ev);
              var fieldsToUse = GAState.instance.currentGlobalCustomEventFields;
              GAEvents2.addCustomFieldsToEvent(ev, GAState.validateAndCleanCustomFields(fieldsToUse, GAEvents2.customEventFieldsErrorCallback));
              values["event"] = GAUtilities.encode64(JSON.stringify(ev));
              GAStore.insert(EGAStore.Sessions, values, true, "session_id");
              if (GAStore.isStorageAvailable()) {
                GAStore.save(GAState.getGameKey());
              }
            }
          };
          GAEvents2.addDimensionsToEvent = function(eventData) {
            if (!eventData) {
              return;
            }
            if (GAState.getCurrentCustomDimension01()) {
              eventData["custom_01"] = GAState.getCurrentCustomDimension01();
            }
            if (GAState.getCurrentCustomDimension02()) {
              eventData["custom_02"] = GAState.getCurrentCustomDimension02();
            }
            if (GAState.getCurrentCustomDimension03()) {
              eventData["custom_03"] = GAState.getCurrentCustomDimension03();
            }
          };
          GAEvents2.addCustomFieldsToEvent = function(eventData, fields) {
            if (!eventData) {
              return;
            }
            if (fields && Object.keys(fields).length > 0) {
              eventData["custom_fields"] = fields;
            }
          };
          GAEvents2.resourceFlowTypeToString = function(value) {
            if (value == gameanalytics2.EGAResourceFlowType.Source || value == gameanalytics2.EGAResourceFlowType[gameanalytics2.EGAResourceFlowType.Source]) {
              return "Source";
            } else if (value == gameanalytics2.EGAResourceFlowType.Sink || value == gameanalytics2.EGAResourceFlowType[gameanalytics2.EGAResourceFlowType.Sink]) {
              return "Sink";
            } else {
              return "";
            }
          };
          GAEvents2.progressionStatusToString = function(value) {
            if (value == gameanalytics2.EGAProgressionStatus.Start || value == gameanalytics2.EGAProgressionStatus[gameanalytics2.EGAProgressionStatus.Start]) {
              return "Start";
            } else if (value == gameanalytics2.EGAProgressionStatus.Complete || value == gameanalytics2.EGAProgressionStatus[gameanalytics2.EGAProgressionStatus.Complete]) {
              return "Complete";
            } else if (value == gameanalytics2.EGAProgressionStatus.Fail || value == gameanalytics2.EGAProgressionStatus[gameanalytics2.EGAProgressionStatus.Fail]) {
              return "Fail";
            } else {
              return "";
            }
          };
          GAEvents2.errorSeverityToString = function(value) {
            if (value == gameanalytics2.EGAErrorSeverity.Debug || value == gameanalytics2.EGAErrorSeverity[gameanalytics2.EGAErrorSeverity.Debug]) {
              return "debug";
            } else if (value == gameanalytics2.EGAErrorSeverity.Info || value == gameanalytics2.EGAErrorSeverity[gameanalytics2.EGAErrorSeverity.Info]) {
              return "info";
            } else if (value == gameanalytics2.EGAErrorSeverity.Warning || value == gameanalytics2.EGAErrorSeverity[gameanalytics2.EGAErrorSeverity.Warning]) {
              return "warning";
            } else if (value == gameanalytics2.EGAErrorSeverity.Error || value == gameanalytics2.EGAErrorSeverity[gameanalytics2.EGAErrorSeverity.Error]) {
              return "error";
            } else if (value == gameanalytics2.EGAErrorSeverity.Critical || value == gameanalytics2.EGAErrorSeverity[gameanalytics2.EGAErrorSeverity.Critical]) {
              return "critical";
            } else {
              return "";
            }
          };
          GAEvents2.adActionToString = function(value) {
            if (value == gameanalytics2.EGAAdAction.Clicked || value == gameanalytics2.EGAAdAction[gameanalytics2.EGAAdAction.Clicked]) {
              return "clicked";
            } else if (value == gameanalytics2.EGAAdAction.Show || value == gameanalytics2.EGAAdAction[gameanalytics2.EGAAdAction.Show]) {
              return "show";
            } else if (value == gameanalytics2.EGAAdAction.FailedShow || value == gameanalytics2.EGAAdAction[gameanalytics2.EGAAdAction.FailedShow]) {
              return "failed_show";
            } else if (value == gameanalytics2.EGAAdAction.RewardReceived || value == gameanalytics2.EGAAdAction[gameanalytics2.EGAAdAction.RewardReceived]) {
              return "reward_received";
            } else {
              return "";
            }
          };
          GAEvents2.adErrorToString = function(value) {
            if (value == gameanalytics2.EGAAdError.Unknown || value == gameanalytics2.EGAAdError[gameanalytics2.EGAAdError.Unknown]) {
              return "unknown";
            } else if (value == gameanalytics2.EGAAdError.Offline || value == gameanalytics2.EGAAdError[gameanalytics2.EGAAdError.Offline]) {
              return "offline";
            } else if (value == gameanalytics2.EGAAdError.NoFill || value == gameanalytics2.EGAAdError[gameanalytics2.EGAAdError.NoFill]) {
              return "no_fill";
            } else if (value == gameanalytics2.EGAAdError.InternalError || value == gameanalytics2.EGAAdError[gameanalytics2.EGAAdError.InternalError]) {
              return "internal_error";
            } else if (value == gameanalytics2.EGAAdError.InvalidRequest || value == gameanalytics2.EGAAdError[gameanalytics2.EGAAdError.InvalidRequest]) {
              return "invalid_request";
            } else if (value == gameanalytics2.EGAAdError.UnableToPrecache || value == gameanalytics2.EGAAdError[gameanalytics2.EGAAdError.UnableToPrecache]) {
              return "unable_to_precache";
            } else {
              return "";
            }
          };
          GAEvents2.adTypeToString = function(value) {
            if (value == gameanalytics2.EGAAdType.Video || value == gameanalytics2.EGAAdType[gameanalytics2.EGAAdType.Video]) {
              return "video";
            } else if (value == gameanalytics2.EGAAdType.RewardedVideo || value == gameanalytics2.EGAAdError[gameanalytics2.EGAAdType.RewardedVideo]) {
              return "rewarded_video";
            } else if (value == gameanalytics2.EGAAdType.Playable || value == gameanalytics2.EGAAdError[gameanalytics2.EGAAdType.Playable]) {
              return "playable";
            } else if (value == gameanalytics2.EGAAdType.Interstitial || value == gameanalytics2.EGAAdError[gameanalytics2.EGAAdType.Interstitial]) {
              return "interstitial";
            } else if (value == gameanalytics2.EGAAdType.OfferWall || value == gameanalytics2.EGAAdError[gameanalytics2.EGAAdType.OfferWall]) {
              return "offer_wall";
            } else if (value == gameanalytics2.EGAAdType.Banner || value == gameanalytics2.EGAAdError[gameanalytics2.EGAAdType.Banner]) {
              return "banner";
            } else {
              return "";
            }
          };
          GAEvents2.CategorySessionStart = "user";
          GAEvents2.CategorySessionEnd = "session_end";
          GAEvents2.CategoryDesign = "design";
          GAEvents2.CategoryBusiness = "business";
          GAEvents2.CategoryProgression = "progression";
          GAEvents2.CategoryResource = "resource";
          GAEvents2.CategoryError = "error";
          GAEvents2.CategoryAds = "ads";
          GAEvents2.MaxEventCount = 500;
          GAEvents2.MAX_ERROR_COUNT = 10;
          GAEvents2.countMap = {};
          GAEvents2.timestampMap = {};
          return GAEvents2;
        }();
        events_1.GAEvents = GAEvents;
      })(events = gameanalytics2.events || (gameanalytics2.events = {}));
    })(gameanalytics || (gameanalytics = {}));
    var gameanalytics;
    (function(gameanalytics2) {
      var threading;
      (function(threading2) {
        var GALogger = gameanalytics2.logging.GALogger;
        var GAState = gameanalytics2.state.GAState;
        var GAEvents = gameanalytics2.events.GAEvents;
        var GAThreading = function() {
          function GAThreading2() {
            this.blocks = new threading2.PriorityQueue({
              compare: function(x2, y2) {
                return x2 - y2;
              }
            });
            this.id2TimedBlockMap = {};
            GAThreading2.startThread();
          }
          GAThreading2.createTimedBlock = function(delayInSeconds) {
            if (delayInSeconds === void 0) {
              delayInSeconds = 0;
            }
            var time = /* @__PURE__ */ new Date();
            time.setUTCSeconds(time.getUTCSeconds() + delayInSeconds);
            var timedBlock = new threading2.TimedBlock(time);
            return timedBlock;
          };
          GAThreading2.performTaskOnGAThread = function(taskBlock, delayInSeconds) {
            if (delayInSeconds === void 0) {
              delayInSeconds = 0;
            }
            var time = /* @__PURE__ */ new Date();
            time.setUTCSeconds(time.getUTCSeconds() + delayInSeconds);
            var timedBlock = new threading2.TimedBlock(time);
            timedBlock.block = taskBlock;
            GAThreading2.instance.id2TimedBlockMap[timedBlock.id] = timedBlock;
            GAThreading2.instance.addTimedBlock(timedBlock);
          };
          GAThreading2.performTimedBlockOnGAThread = function(timedBlock) {
            GAThreading2.instance.id2TimedBlockMap[timedBlock.id] = timedBlock;
            GAThreading2.instance.addTimedBlock(timedBlock);
          };
          GAThreading2.scheduleTimer = function(interval, callback) {
            var time = /* @__PURE__ */ new Date();
            time.setUTCSeconds(time.getUTCSeconds() + interval);
            var timedBlock = new threading2.TimedBlock(time);
            timedBlock.block = callback;
            GAThreading2.instance.id2TimedBlockMap[timedBlock.id] = timedBlock;
            GAThreading2.instance.addTimedBlock(timedBlock);
            return timedBlock.id;
          };
          GAThreading2.getTimedBlockById = function(blockIdentifier) {
            if (blockIdentifier in GAThreading2.instance.id2TimedBlockMap) {
              return GAThreading2.instance.id2TimedBlockMap[blockIdentifier];
            } else {
              return null;
            }
          };
          GAThreading2.ensureEventQueueIsRunning = function() {
            GAThreading2.instance.keepRunning = true;
            if (!GAThreading2.instance.isRunning) {
              GAThreading2.instance.isRunning = true;
              GAThreading2.scheduleTimer(GAThreading2.ProcessEventsIntervalInSeconds, GAThreading2.processEventQueue);
            }
          };
          GAThreading2.endSessionAndStopQueue = function() {
            if (GAState.isInitialized()) {
              GALogger.i("Ending session.");
              GAThreading2.stopEventQueue();
              if (GAState.isEnabled() && GAState.sessionIsStarted()) {
                GAEvents.addSessionEndEvent();
                GAState.instance.sessionStart = 0;
              }
            }
          };
          GAThreading2.stopEventQueue = function() {
            GAThreading2.instance.keepRunning = false;
          };
          GAThreading2.ignoreTimer = function(blockIdentifier) {
            if (blockIdentifier in GAThreading2.instance.id2TimedBlockMap) {
              GAThreading2.instance.id2TimedBlockMap[blockIdentifier].ignore = true;
            }
          };
          GAThreading2.setEventProcessInterval = function(interval) {
            if (interval > 0) {
              GAThreading2.ProcessEventsIntervalInSeconds = interval;
            }
          };
          GAThreading2.prototype.addTimedBlock = function(timedBlock) {
            this.blocks.enqueue(timedBlock.deadline.getTime(), timedBlock);
          };
          GAThreading2.run = function() {
            clearTimeout(GAThreading2.runTimeoutId);
            try {
              var timedBlock;
              while (timedBlock = GAThreading2.getNextBlock()) {
                if (!timedBlock.ignore) {
                  if (timedBlock.async) {
                    if (!timedBlock.running) {
                      timedBlock.running = true;
                      timedBlock.block();
                      break;
                    }
                  } else {
                    timedBlock.block();
                  }
                }
              }
              GAThreading2.runTimeoutId = setTimeout(GAThreading2.run, GAThreading2.ThreadWaitTimeInMs);
              return;
            } catch (e2) {
              GALogger.e("Error on GA thread");
              GALogger.e(e2.stack);
            }
          };
          GAThreading2.startThread = function() {
            GAThreading2.runTimeoutId = setTimeout(GAThreading2.run, 0);
          };
          GAThreading2.getNextBlock = function() {
            var now = /* @__PURE__ */ new Date();
            if (GAThreading2.instance.blocks.hasItems() && GAThreading2.instance.blocks.peek().deadline.getTime() <= now.getTime()) {
              if (GAThreading2.instance.blocks.peek().async) {
                if (GAThreading2.instance.blocks.peek().running) {
                  return GAThreading2.instance.blocks.peek();
                } else {
                  return GAThreading2.instance.blocks.dequeue();
                }
              } else {
                return GAThreading2.instance.blocks.dequeue();
              }
            }
            return null;
          };
          GAThreading2.processEventQueue = function() {
            GAEvents.processEvents("", true);
            if (GAThreading2.instance.keepRunning) {
              GAThreading2.scheduleTimer(GAThreading2.ProcessEventsIntervalInSeconds, GAThreading2.processEventQueue);
            } else {
              GAThreading2.instance.isRunning = false;
            }
          };
          GAThreading2.instance = new GAThreading2();
          GAThreading2.ThreadWaitTimeInMs = 1e3;
          GAThreading2.ProcessEventsIntervalInSeconds = 8;
          return GAThreading2;
        }();
        threading2.GAThreading = GAThreading;
      })(threading = gameanalytics2.threading || (gameanalytics2.threading = {}));
    })(gameanalytics || (gameanalytics = {}));
    var gameanalytics;
    (function(gameanalytics2) {
      var GAThreading = gameanalytics2.threading.GAThreading;
      var GALogger = gameanalytics2.logging.GALogger;
      var GAStore = gameanalytics2.store.GAStore;
      var GAState = gameanalytics2.state.GAState;
      var GAHTTPApi = gameanalytics2.http.GAHTTPApi;
      var GADevice = gameanalytics2.device.GADevice;
      var GAValidator = gameanalytics2.validators.GAValidator;
      var EGAHTTPApiResponse = gameanalytics2.http.EGAHTTPApiResponse;
      var GAUtilities = gameanalytics2.utilities.GAUtilities;
      var GAEvents = gameanalytics2.events.GAEvents;
      var GameAnalytics2 = function() {
        function GameAnalytics3() {
        }
        GameAnalytics3.getGlobalObject = function() {
          if (typeof globalThis !== "undefined") {
            return globalThis;
          }
          if (typeof self !== "undefined") {
            return self;
          }
          if (typeof window !== "undefined") {
            return window;
          }
          if (typeof global !== "undefined") {
            return global;
          }
          return void 0;
        };
        GameAnalytics3.init = function() {
          GADevice.touch();
          GameAnalytics3.methodMap["configureAvailableCustomDimensions01"] = GameAnalytics3.configureAvailableCustomDimensions01;
          GameAnalytics3.methodMap["configureAvailableCustomDimensions02"] = GameAnalytics3.configureAvailableCustomDimensions02;
          GameAnalytics3.methodMap["configureAvailableCustomDimensions03"] = GameAnalytics3.configureAvailableCustomDimensions03;
          GameAnalytics3.methodMap["configureAvailableResourceCurrencies"] = GameAnalytics3.configureAvailableResourceCurrencies;
          GameAnalytics3.methodMap["configureAvailableResourceItemTypes"] = GameAnalytics3.configureAvailableResourceItemTypes;
          GameAnalytics3.methodMap["configureBuild"] = GameAnalytics3.configureBuild;
          GameAnalytics3.methodMap["configureSdkGameEngineVersion"] = GameAnalytics3.configureSdkGameEngineVersion;
          GameAnalytics3.methodMap["configureGameEngineVersion"] = GameAnalytics3.configureGameEngineVersion;
          GameAnalytics3.methodMap["configureUserId"] = GameAnalytics3.configureUserId;
          GameAnalytics3.methodMap["initialize"] = GameAnalytics3.initialize;
          GameAnalytics3.methodMap["addBusinessEvent"] = GameAnalytics3.addBusinessEvent;
          GameAnalytics3.methodMap["addResourceEvent"] = GameAnalytics3.addResourceEvent;
          GameAnalytics3.methodMap["addProgressionEvent"] = GameAnalytics3.addProgressionEvent;
          GameAnalytics3.methodMap["addDesignEvent"] = GameAnalytics3.addDesignEvent;
          GameAnalytics3.methodMap["addErrorEvent"] = GameAnalytics3.addErrorEvent;
          GameAnalytics3.methodMap["addAdEvent"] = GameAnalytics3.addAdEvent;
          GameAnalytics3.methodMap["setEnabledInfoLog"] = GameAnalytics3.setEnabledInfoLog;
          GameAnalytics3.methodMap["setEnabledVerboseLog"] = GameAnalytics3.setEnabledVerboseLog;
          GameAnalytics3.methodMap["setEnabledManualSessionHandling"] = GameAnalytics3.setEnabledManualSessionHandling;
          GameAnalytics3.methodMap["setEnabledEventSubmission"] = GameAnalytics3.setEnabledEventSubmission;
          GameAnalytics3.methodMap["setCustomDimension01"] = GameAnalytics3.setCustomDimension01;
          GameAnalytics3.methodMap["setCustomDimension02"] = GameAnalytics3.setCustomDimension02;
          GameAnalytics3.methodMap["setCustomDimension03"] = GameAnalytics3.setCustomDimension03;
          GameAnalytics3.methodMap["setGlobalCustomEventFields"] = GameAnalytics3.setGlobalCustomEventFields;
          GameAnalytics3.methodMap["setEventProcessInterval"] = GameAnalytics3.setEventProcessInterval;
          GameAnalytics3.methodMap["startSession"] = GameAnalytics3.startSession;
          GameAnalytics3.methodMap["endSession"] = GameAnalytics3.endSession;
          GameAnalytics3.methodMap["onStop"] = GameAnalytics3.onStop;
          GameAnalytics3.methodMap["onResume"] = GameAnalytics3.onResume;
          GameAnalytics3.methodMap["addRemoteConfigsListener"] = GameAnalytics3.addRemoteConfigsListener;
          GameAnalytics3.methodMap["removeRemoteConfigsListener"] = GameAnalytics3.removeRemoteConfigsListener;
          GameAnalytics3.methodMap["getRemoteConfigsValueAsString"] = GameAnalytics3.getRemoteConfigsValueAsString;
          GameAnalytics3.methodMap["isRemoteConfigsReady"] = GameAnalytics3.isRemoteConfigsReady;
          GameAnalytics3.methodMap["getRemoteConfigsContentAsString"] = GameAnalytics3.getRemoteConfigsContentAsString;
          GameAnalytics3.methodMap["addOnBeforeUnloadListener"] = GameAnalytics3.addOnBeforeUnloadListener;
          GameAnalytics3.methodMap["removeOnBeforeUnloadListener"] = GameAnalytics3.removeOnBeforeUnloadListener;
          if (typeof GameAnalytics3.getGlobalObject() !== "undefined" && typeof GameAnalytics3.getGlobalObject()["GameAnalytics"] !== "undefined" && typeof GameAnalytics3.getGlobalObject()["GameAnalytics"]["q"] !== "undefined") {
            var q = GameAnalytics3.getGlobalObject()["GameAnalytics"]["q"];
            for (var i3 in q) {
              GameAnalytics3.gaCommand.apply(null, q[i3]);
            }
          }
          window.addEventListener("beforeunload", function(e2) {
            console.log("addEventListener unload");
            GAState.instance.isUnloading = true;
            GAState.notifyBeforeUnloadListeners();
            GAThreading.endSessionAndStopQueue();
            GAState.instance.isUnloading = false;
          });
        };
        GameAnalytics3.gaCommand = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (args.length > 0) {
            if (args[0] in gameanalytics2.GameAnalytics.methodMap) {
              if (args.length > 1) {
                gameanalytics2.GameAnalytics.methodMap[args[0]].apply(null, Array.prototype.slice.call(args, 1));
              } else {
                gameanalytics2.GameAnalytics.methodMap[args[0]]();
              }
            }
          }
        };
        GameAnalytics3.configureAvailableCustomDimensions01 = function(customDimensions) {
          if (customDimensions === void 0) {
            customDimensions = [];
          }
          GAThreading.performTaskOnGAThread(function() {
            if (GameAnalytics3.isSdkReady(true, false)) {
              GALogger.w("Available custom dimensions must be set before SDK is initialized");
              return;
            }
            GAState.setAvailableCustomDimensions01(customDimensions);
          });
        };
        GameAnalytics3.configureAvailableCustomDimensions02 = function(customDimensions) {
          if (customDimensions === void 0) {
            customDimensions = [];
          }
          GAThreading.performTaskOnGAThread(function() {
            if (GameAnalytics3.isSdkReady(true, false)) {
              GALogger.w("Available custom dimensions must be set before SDK is initialized");
              return;
            }
            GAState.setAvailableCustomDimensions02(customDimensions);
          });
        };
        GameAnalytics3.configureAvailableCustomDimensions03 = function(customDimensions) {
          if (customDimensions === void 0) {
            customDimensions = [];
          }
          GAThreading.performTaskOnGAThread(function() {
            if (GameAnalytics3.isSdkReady(true, false)) {
              GALogger.w("Available custom dimensions must be set before SDK is initialized");
              return;
            }
            GAState.setAvailableCustomDimensions03(customDimensions);
          });
        };
        GameAnalytics3.configureAvailableResourceCurrencies = function(resourceCurrencies) {
          if (resourceCurrencies === void 0) {
            resourceCurrencies = [];
          }
          GAThreading.performTaskOnGAThread(function() {
            if (GameAnalytics3.isSdkReady(true, false)) {
              GALogger.w("Available resource currencies must be set before SDK is initialized");
              return;
            }
            GAState.setAvailableResourceCurrencies(resourceCurrencies);
          });
        };
        GameAnalytics3.configureAvailableResourceItemTypes = function(resourceItemTypes) {
          if (resourceItemTypes === void 0) {
            resourceItemTypes = [];
          }
          GAThreading.performTaskOnGAThread(function() {
            if (GameAnalytics3.isSdkReady(true, false)) {
              GALogger.w("Available resource item types must be set before SDK is initialized");
              return;
            }
            GAState.setAvailableResourceItemTypes(resourceItemTypes);
          });
        };
        GameAnalytics3.configureBuild = function(build) {
          if (build === void 0) {
            build = "";
          }
          GAThreading.performTaskOnGAThread(function() {
            if (GameAnalytics3.isSdkReady(true, false)) {
              GALogger.w("Build version must be set before SDK is initialized.");
              return;
            }
            if (!GAValidator.validateBuild(build)) {
              GALogger.i("Validation fail - configure build: Cannot be null, empty or above 32 length. String: " + build);
              return;
            }
            GAState.setBuild(build);
          });
        };
        GameAnalytics3.configureSdkGameEngineVersion = function(sdkGameEngineVersion) {
          if (sdkGameEngineVersion === void 0) {
            sdkGameEngineVersion = "";
          }
          GAThreading.performTaskOnGAThread(function() {
            if (GameAnalytics3.isSdkReady(true, false)) {
              return;
            }
            if (!GAValidator.validateSdkWrapperVersion(sdkGameEngineVersion)) {
              GALogger.i("Validation fail - configure sdk version: Sdk version not supported. String: " + sdkGameEngineVersion);
              return;
            }
            GADevice.sdkGameEngineVersion = sdkGameEngineVersion;
          });
        };
        GameAnalytics3.configureGameEngineVersion = function(gameEngineVersion) {
          if (gameEngineVersion === void 0) {
            gameEngineVersion = "";
          }
          GAThreading.performTaskOnGAThread(function() {
            if (GameAnalytics3.isSdkReady(true, false)) {
              return;
            }
            if (!GAValidator.validateEngineVersion(gameEngineVersion)) {
              GALogger.i("Validation fail - configure game engine version: Game engine version not supported. String: " + gameEngineVersion);
              return;
            }
            GADevice.gameEngineVersion = gameEngineVersion;
          });
        };
        GameAnalytics3.configureUserId = function(uId) {
          if (uId === void 0) {
            uId = "";
          }
          GAThreading.performTaskOnGAThread(function() {
            if (GameAnalytics3.isSdkReady(true, false)) {
              GALogger.w("A custom user id must be set before SDK is initialized.");
              return;
            }
            if (!GAValidator.validateUserId(uId)) {
              GALogger.i("Validation fail - configure user_id: Cannot be null, empty or above 64 length. Will use default user_id method. Used string: " + uId);
              return;
            }
            GAState.setUserId(uId);
          });
        };
        GameAnalytics3.initialize = function(gameKey, gameSecret) {
          if (gameKey === void 0) {
            gameKey = "";
          }
          if (gameSecret === void 0) {
            gameSecret = "";
          }
          GADevice.updateConnectionType();
          var timedBlock = GAThreading.createTimedBlock();
          timedBlock.async = true;
          GameAnalytics3.initTimedBlockId = timedBlock.id;
          timedBlock.block = function() {
            if (GameAnalytics3.isSdkReady(true, false)) {
              GALogger.w("SDK already initialized. Can only be called once.");
              return;
            }
            if (!GAValidator.validateKeys(gameKey, gameSecret)) {
              GALogger.w("SDK failed initialize. Game key or secret key is invalid. Can only contain characters A-z 0-9, gameKey is 32 length, gameSecret is 40 length. Failed keys - gameKey: " + gameKey + ", secretKey: " + gameSecret);
              return;
            }
            GAState.setKeys(gameKey, gameSecret);
            GameAnalytics3.internalInitialize();
          };
          GAThreading.performTimedBlockOnGAThread(timedBlock);
        };
        GameAnalytics3.addBusinessEvent = function(currency, amount, itemType, itemId, cartType, customFields, mergeFields) {
          if (currency === void 0) {
            currency = "";
          }
          if (amount === void 0) {
            amount = 0;
          }
          if (itemType === void 0) {
            itemType = "";
          }
          if (itemId === void 0) {
            itemId = "";
          }
          if (cartType === void 0) {
            cartType = "";
          }
          if (customFields === void 0) {
            customFields = {};
          }
          if (mergeFields === void 0) {
            mergeFields = false;
          }
          GADevice.updateConnectionType();
          if (!GAState.instance.isUnloading) {
            GAThreading.performTaskOnGAThread(function() {
              if (!GameAnalytics3.isSdkReady(true, true, "Could not add business event")) {
                return;
              }
              GAEvents.addBusinessEvent(currency, amount, itemType, itemId, cartType, customFields, mergeFields);
            });
          } else {
            if (!GameAnalytics3.isSdkReady(true, true, "Could not add business event")) {
              return;
            }
            GAEvents.addBusinessEvent(currency, amount, itemType, itemId, cartType, customFields, mergeFields);
          }
        };
        GameAnalytics3.addResourceEvent = function(flowType, currency, amount, itemType, itemId, customFields, mergeFields) {
          if (flowType === void 0) {
            flowType = gameanalytics2.EGAResourceFlowType.Undefined;
          }
          if (currency === void 0) {
            currency = "";
          }
          if (amount === void 0) {
            amount = 0;
          }
          if (itemType === void 0) {
            itemType = "";
          }
          if (itemId === void 0) {
            itemId = "";
          }
          if (customFields === void 0) {
            customFields = {};
          }
          if (mergeFields === void 0) {
            mergeFields = false;
          }
          GADevice.updateConnectionType();
          if (!GAState.instance.isUnloading) {
            GAThreading.performTaskOnGAThread(function() {
              if (!GameAnalytics3.isSdkReady(true, true, "Could not add resource event")) {
                return;
              }
              GAEvents.addResourceEvent(flowType, currency, amount, itemType, itemId, customFields, mergeFields);
            });
          } else {
            if (!GameAnalytics3.isSdkReady(true, true, "Could not add resource event")) {
              return;
            }
            GAEvents.addResourceEvent(flowType, currency, amount, itemType, itemId, customFields, mergeFields);
          }
        };
        GameAnalytics3.addProgressionEvent = function(progressionStatus, progression01, progression02, progression03, score, customFields, mergeFields) {
          if (progressionStatus === void 0) {
            progressionStatus = gameanalytics2.EGAProgressionStatus.Undefined;
          }
          if (progression01 === void 0) {
            progression01 = "";
          }
          if (progression02 === void 0) {
            progression02 = "";
          }
          if (progression03 === void 0) {
            progression03 = "";
          }
          if (customFields === void 0) {
            customFields = {};
          }
          if (mergeFields === void 0) {
            mergeFields = false;
          }
          GADevice.updateConnectionType();
          if (!GAState.instance.isUnloading) {
            GAThreading.performTaskOnGAThread(function() {
              if (!GameAnalytics3.isSdkReady(true, true, "Could not add progression event")) {
                return;
              }
              var sendScore2 = typeof score === "number";
              GAEvents.addProgressionEvent(progressionStatus, progression01, progression02, progression03, sendScore2 ? score : 0, sendScore2, customFields, mergeFields);
            });
          } else {
            if (!GameAnalytics3.isSdkReady(true, true, "Could not add progression event")) {
              return;
            }
            var sendScore = typeof score === "number";
            GAEvents.addProgressionEvent(progressionStatus, progression01, progression02, progression03, sendScore ? score : 0, sendScore, customFields, mergeFields);
          }
        };
        GameAnalytics3.addDesignEvent = function(eventId, value, customFields, mergeFields) {
          if (customFields === void 0) {
            customFields = {};
          }
          if (mergeFields === void 0) {
            mergeFields = false;
          }
          GADevice.updateConnectionType();
          if (!GAState.instance.isUnloading) {
            GAThreading.performTaskOnGAThread(function() {
              if (!GameAnalytics3.isSdkReady(true, true, "Could not add design event")) {
                return;
              }
              var sendValue2 = typeof value === "number";
              GAEvents.addDesignEvent(eventId, sendValue2 ? value : 0, sendValue2, customFields, mergeFields);
            });
          } else {
            if (!GameAnalytics3.isSdkReady(true, true, "Could not add design event")) {
              return;
            }
            var sendValue = typeof value === "number";
            GAEvents.addDesignEvent(eventId, sendValue ? value : 0, sendValue, customFields, mergeFields);
          }
        };
        GameAnalytics3.addErrorEvent = function(severity, message, customFields, mergeFields) {
          if (severity === void 0) {
            severity = gameanalytics2.EGAErrorSeverity.Undefined;
          }
          if (message === void 0) {
            message = "";
          }
          if (customFields === void 0) {
            customFields = {};
          }
          if (mergeFields === void 0) {
            mergeFields = false;
          }
          GADevice.updateConnectionType();
          if (!GAState.instance.isUnloading) {
            GAThreading.performTaskOnGAThread(function() {
              if (!GameAnalytics3.isSdkReady(true, true, "Could not add error event")) {
                return;
              }
              GAEvents.addErrorEvent(severity, message, customFields, mergeFields);
            });
          } else {
            if (!GameAnalytics3.isSdkReady(true, true, "Could not add error event")) {
              return;
            }
            GAEvents.addErrorEvent(severity, message, customFields, mergeFields);
          }
        };
        GameAnalytics3.addAdEventWithNoAdReason = function(adAction, adType, adSdkName, adPlacement, noAdReason, customFields, mergeFields) {
          if (adAction === void 0) {
            adAction = gameanalytics2.EGAAdAction.Undefined;
          }
          if (adType === void 0) {
            adType = gameanalytics2.EGAAdType.Undefined;
          }
          if (adSdkName === void 0) {
            adSdkName = "";
          }
          if (adPlacement === void 0) {
            adPlacement = "";
          }
          if (noAdReason === void 0) {
            noAdReason = gameanalytics2.EGAAdError.Undefined;
          }
          if (customFields === void 0) {
            customFields = {};
          }
          if (mergeFields === void 0) {
            mergeFields = false;
          }
          GADevice.updateConnectionType();
          if (!GAState.instance.isUnloading) {
            GAThreading.performTaskOnGAThread(function() {
              if (!GameAnalytics3.isSdkReady(true, true, "Could not add ad event")) {
                return;
              }
              GAEvents.addAdEvent(adAction, adType, adSdkName, adPlacement, noAdReason, 0, false, customFields, mergeFields);
            });
          } else {
            if (!GameAnalytics3.isSdkReady(true, true, "Could not add ad event")) {
              return;
            }
            GAEvents.addAdEvent(adAction, adType, adSdkName, adPlacement, noAdReason, 0, false, customFields, mergeFields);
          }
        };
        GameAnalytics3.addAdEventWithDuration = function(adAction, adType, adSdkName, adPlacement, duration, customFields, mergeFields) {
          if (adAction === void 0) {
            adAction = gameanalytics2.EGAAdAction.Undefined;
          }
          if (adType === void 0) {
            adType = gameanalytics2.EGAAdType.Undefined;
          }
          if (adSdkName === void 0) {
            adSdkName = "";
          }
          if (adPlacement === void 0) {
            adPlacement = "";
          }
          if (duration === void 0) {
            duration = 0;
          }
          if (customFields === void 0) {
            customFields = {};
          }
          if (mergeFields === void 0) {
            mergeFields = false;
          }
          GADevice.updateConnectionType();
          if (!GAState.instance.isUnloading) {
            GAThreading.performTaskOnGAThread(function() {
              if (!GameAnalytics3.isSdkReady(true, true, "Could not add ad event")) {
                return;
              }
              GAEvents.addAdEvent(adAction, adType, adSdkName, adPlacement, gameanalytics2.EGAAdError.Undefined, duration, true, customFields, mergeFields);
            });
          } else {
            if (!GameAnalytics3.isSdkReady(true, true, "Could not add ad event")) {
              return;
            }
            GAEvents.addAdEvent(adAction, adType, adSdkName, adPlacement, gameanalytics2.EGAAdError.Undefined, duration, true, customFields, mergeFields);
          }
        };
        GameAnalytics3.addAdEvent = function(adAction, adType, adSdkName, adPlacement, customFields, mergeFields) {
          if (adAction === void 0) {
            adAction = gameanalytics2.EGAAdAction.Undefined;
          }
          if (adType === void 0) {
            adType = gameanalytics2.EGAAdType.Undefined;
          }
          if (adSdkName === void 0) {
            adSdkName = "";
          }
          if (adPlacement === void 0) {
            adPlacement = "";
          }
          if (customFields === void 0) {
            customFields = {};
          }
          if (mergeFields === void 0) {
            mergeFields = false;
          }
          GADevice.updateConnectionType();
          if (!GAState.instance.isUnloading) {
            GAThreading.performTaskOnGAThread(function() {
              if (!GameAnalytics3.isSdkReady(true, true, "Could not add ad event")) {
                return;
              }
              GAEvents.addAdEvent(adAction, adType, adSdkName, adPlacement, gameanalytics2.EGAAdError.Undefined, 0, false, customFields, mergeFields);
            });
          } else {
            if (!GameAnalytics3.isSdkReady(true, true, "Could not add ad event")) {
              return;
            }
            GAEvents.addAdEvent(adAction, adType, adSdkName, adPlacement, gameanalytics2.EGAAdError.Undefined, 0, false, customFields, mergeFields);
          }
        };
        GameAnalytics3.setEnabledInfoLog = function(flag) {
          if (flag === void 0) {
            flag = false;
          }
          GAThreading.performTaskOnGAThread(function() {
            if (flag) {
              GALogger.setInfoLog(flag);
              GALogger.i("Info logging enabled");
            } else {
              GALogger.i("Info logging disabled");
              GALogger.setInfoLog(flag);
            }
          });
        };
        GameAnalytics3.setEnabledVerboseLog = function(flag) {
          if (flag === void 0) {
            flag = false;
          }
          GAThreading.performTaskOnGAThread(function() {
            if (flag) {
              GALogger.setVerboseLog(flag);
              GALogger.i("Verbose logging enabled");
            } else {
              GALogger.i("Verbose logging disabled");
              GALogger.setVerboseLog(flag);
            }
          });
        };
        GameAnalytics3.setEnabledManualSessionHandling = function(flag) {
          if (flag === void 0) {
            flag = false;
          }
          GAThreading.performTaskOnGAThread(function() {
            GAState.setManualSessionHandling(flag);
          });
        };
        GameAnalytics3.setEnabledEventSubmission = function(flag) {
          if (flag === void 0) {
            flag = false;
          }
          GAThreading.performTaskOnGAThread(function() {
            if (flag) {
              GAState.setEnabledEventSubmission(flag);
              GALogger.i("Event submission enabled");
            } else {
              GALogger.i("Event submission disabled");
              GAState.setEnabledEventSubmission(flag);
            }
          });
        };
        GameAnalytics3.setCustomDimension01 = function(dimension) {
          if (dimension === void 0) {
            dimension = "";
          }
          GAThreading.performTaskOnGAThread(function() {
            if (!GAValidator.validateDimension01(dimension, GAState.getAvailableCustomDimensions01())) {
              GALogger.w("Could not set custom01 dimension value to '" + dimension + "'. Value not found in available custom01 dimension values");
              return;
            }
            GAState.setCustomDimension01(dimension);
          });
        };
        GameAnalytics3.setCustomDimension02 = function(dimension) {
          if (dimension === void 0) {
            dimension = "";
          }
          GAThreading.performTaskOnGAThread(function() {
            if (!GAValidator.validateDimension02(dimension, GAState.getAvailableCustomDimensions02())) {
              GALogger.w("Could not set custom02 dimension value to '" + dimension + "'. Value not found in available custom02 dimension values");
              return;
            }
            GAState.setCustomDimension02(dimension);
          });
        };
        GameAnalytics3.setCustomDimension03 = function(dimension) {
          if (dimension === void 0) {
            dimension = "";
          }
          GAThreading.performTaskOnGAThread(function() {
            if (!GAValidator.validateDimension03(dimension, GAState.getAvailableCustomDimensions03())) {
              GALogger.w("Could not set custom03 dimension value to '" + dimension + "'. Value not found in available custom03 dimension values");
              return;
            }
            GAState.setCustomDimension03(dimension);
          });
        };
        GameAnalytics3.setGlobalCustomEventFields = function(customFields) {
          if (customFields === void 0) {
            customFields = {};
          }
          GAThreading.performTaskOnGAThread(function() {
            GALogger.i("Set global custom event fields: " + JSON.stringify(customFields));
            GAState.instance.currentGlobalCustomEventFields = customFields;
          });
        };
        GameAnalytics3.setEventProcessInterval = function(intervalInSeconds) {
          GAThreading.performTaskOnGAThread(function() {
            GAThreading.setEventProcessInterval(intervalInSeconds);
          });
        };
        GameAnalytics3.startSession = function() {
          {
            if (!GAState.isInitialized()) {
              return;
            }
            var timedBlock = GAThreading.createTimedBlock();
            timedBlock.async = true;
            GameAnalytics3.initTimedBlockId = timedBlock.id;
            timedBlock.block = function() {
              if (GAState.isEnabled() && GAState.sessionIsStarted()) {
                GAThreading.endSessionAndStopQueue();
              }
              GameAnalytics3.resumeSessionAndStartQueue();
            };
            GAThreading.performTimedBlockOnGAThread(timedBlock);
          }
        };
        GameAnalytics3.endSession = function() {
          {
            GameAnalytics3.onStop();
          }
        };
        GameAnalytics3.onStop = function() {
          GAThreading.performTaskOnGAThread(function() {
            try {
              GAThreading.endSessionAndStopQueue();
            } catch (Exception) {
            }
          });
        };
        GameAnalytics3.onResume = function() {
          var timedBlock = GAThreading.createTimedBlock();
          timedBlock.async = true;
          GameAnalytics3.initTimedBlockId = timedBlock.id;
          timedBlock.block = function() {
            GameAnalytics3.resumeSessionAndStartQueue();
          };
          GAThreading.performTimedBlockOnGAThread(timedBlock);
        };
        GameAnalytics3.getRemoteConfigsValueAsString = function(key, defaultValue2) {
          if (defaultValue2 === void 0) {
            defaultValue2 = null;
          }
          return GAState.getConfigurationStringValue(key, defaultValue2);
        };
        GameAnalytics3.isRemoteConfigsReady = function() {
          return GAState.isRemoteConfigsReady();
        };
        GameAnalytics3.addRemoteConfigsListener = function(listener) {
          GAState.addRemoteConfigsListener(listener);
        };
        GameAnalytics3.removeRemoteConfigsListener = function(listener) {
          GAState.removeRemoteConfigsListener(listener);
        };
        GameAnalytics3.getRemoteConfigsContentAsString = function() {
          return GAState.getRemoteConfigsContentAsString();
        };
        GameAnalytics3.getABTestingId = function() {
          return GAState.getABTestingId();
        };
        GameAnalytics3.getABTestingVariantId = function() {
          return GAState.getABTestingVariantId();
        };
        GameAnalytics3.addOnBeforeUnloadListener = function(listener) {
          GAState.addOnBeforeUnloadListener(listener);
        };
        GameAnalytics3.removeOnBeforeUnloadListener = function(listener) {
          GAState.removeOnBeforeUnloadListener(listener);
        };
        GameAnalytics3.internalInitialize = function() {
          GAState.ensurePersistedStates();
          GAStore.setItem(GAState.getGameKey(), GAState.DefaultUserIdKey, GAState.getDefaultId());
          GAState.setInitialized(true);
          GameAnalytics3.newSession();
          if (GAState.isEnabled()) {
            GAThreading.ensureEventQueueIsRunning();
          }
        };
        GameAnalytics3.newSession = function() {
          GALogger.i("Starting a new session.");
          GAState.validateAndFixCurrentDimensions();
          GAHTTPApi.instance.requestInit(GAState.instance.configsHash, GameAnalytics3.startNewSessionCallback);
        };
        GameAnalytics3.startNewSessionCallback = function(initResponse, initResponseDict) {
          if ((initResponse === EGAHTTPApiResponse.Ok || initResponse === EGAHTTPApiResponse.Created) && initResponseDict) {
            var timeOffsetSeconds = 0;
            if (initResponseDict["server_ts"]) {
              var serverTs = initResponseDict["server_ts"];
              timeOffsetSeconds = GAState.calculateServerTimeOffset(serverTs);
            }
            initResponseDict["time_offset"] = timeOffsetSeconds;
            if (initResponse != EGAHTTPApiResponse.Created) {
              var currentSdkConfig = GAState.getSdkConfig();
              if (currentSdkConfig["configs"]) {
                initResponseDict["configs"] = currentSdkConfig["configs"];
              }
              if (currentSdkConfig["configs_hash"]) {
                initResponseDict["configs_hash"] = currentSdkConfig["configs_hash"];
              }
              if (currentSdkConfig["ab_id"]) {
                initResponseDict["ab_id"] = currentSdkConfig["ab_id"];
              }
              if (currentSdkConfig["ab_variant_id"]) {
                initResponseDict["ab_variant_id"] = currentSdkConfig["ab_variant_id"];
              }
            }
            GAState.instance.configsHash = initResponseDict["configs_hash"] ? initResponseDict["configs_hash"] : "";
            GAState.instance.abId = initResponseDict["ab_id"] ? initResponseDict["ab_id"] : "";
            GAState.instance.abVariantId = initResponseDict["ab_variant_id"] ? initResponseDict["ab_variant_id"] : "";
            GAStore.setItem(GAState.getGameKey(), GAState.SdkConfigCachedKey, GAUtilities.encode64(JSON.stringify(initResponseDict)));
            GAState.instance.sdkConfigCached = initResponseDict;
            GAState.instance.sdkConfig = initResponseDict;
            GAState.instance.initAuthorized = true;
          } else if (initResponse == EGAHTTPApiResponse.Unauthorized) {
            GALogger.w("Initialize SDK failed - Unauthorized");
            GAState.instance.initAuthorized = false;
          } else {
            if (initResponse === EGAHTTPApiResponse.NoResponse || initResponse === EGAHTTPApiResponse.RequestTimeout) {
              GALogger.i("Init call (session start) failed - no response. Could be offline or timeout.");
            } else if (initResponse === EGAHTTPApiResponse.BadResponse || initResponse === EGAHTTPApiResponse.JsonEncodeFailed || initResponse === EGAHTTPApiResponse.JsonDecodeFailed) {
              GALogger.i("Init call (session start) failed - bad response. Could be bad response from proxy or GA servers.");
            } else if (initResponse === EGAHTTPApiResponse.BadRequest || initResponse === EGAHTTPApiResponse.UnknownResponseCode) {
              GALogger.i("Init call (session start) failed - bad request or unknown response.");
            }
            if (GAState.instance.sdkConfig == null) {
              if (GAState.instance.sdkConfigCached != null) {
                GALogger.i("Init call (session start) failed - using cached init values.");
                GAState.instance.sdkConfig = GAState.instance.sdkConfigCached;
              } else {
                GALogger.i("Init call (session start) failed - using default init values.");
                GAState.instance.sdkConfig = GAState.instance.sdkConfigDefault;
              }
            } else {
              GALogger.i("Init call (session start) failed - using cached init values.");
            }
            GAState.instance.initAuthorized = true;
          }
          GAState.instance.clientServerTimeOffset = GAState.getSdkConfig()["time_offset"] ? GAState.getSdkConfig()["time_offset"] : 0;
          GAState.populateConfigurations(GAState.getSdkConfig());
          if (!GAState.isEnabled()) {
            GALogger.w("Could not start session: SDK is disabled.");
            GAThreading.stopEventQueue();
            return;
          } else {
            GAThreading.ensureEventQueueIsRunning();
          }
          var newSessionId = GAUtilities.createGuid();
          GAState.instance.sessionId = newSessionId;
          GAState.instance.sessionStart = GAState.getClientTsAdjusted();
          GAEvents.addSessionStartEvent();
          var timedBlock = GAThreading.getTimedBlockById(GameAnalytics3.initTimedBlockId);
          if (timedBlock != null) {
            timedBlock.running = false;
          }
          GameAnalytics3.initTimedBlockId = -1;
        };
        GameAnalytics3.resumeSessionAndStartQueue = function() {
          if (!GAState.isInitialized()) {
            return;
          }
          GALogger.i("Resuming session.");
          if (!GAState.sessionIsStarted()) {
            GameAnalytics3.newSession();
          }
        };
        GameAnalytics3.isSdkReady = function(needsInitialized, warn2, message) {
          if (warn2 === void 0) {
            warn2 = true;
          }
          if (message === void 0) {
            message = "";
          }
          if (message) {
            message = message + ": ";
          }
          if (needsInitialized && !GAState.isInitialized()) {
            if (warn2) {
              GALogger.w(message + "SDK is not initialized");
            }
            return false;
          }
          if (needsInitialized && !GAState.isEnabled()) {
            if (warn2) {
              GALogger.w(message + "SDK is disabled");
            }
            return false;
          }
          if (needsInitialized && !GAState.sessionIsStarted()) {
            if (warn2) {
              GALogger.w(message + "Session has not started yet");
            }
            return false;
          }
          return true;
        };
        GameAnalytics3.initTimedBlockId = -1;
        GameAnalytics3.methodMap = {};
        return GameAnalytics3;
      }();
      gameanalytics2.GameAnalytics = GameAnalytics2;
    })(gameanalytics || (gameanalytics = {}));
    gameanalytics.GameAnalytics.init();
    var GameAnalytics = gameanalytics.GameAnalytics.gaCommand;
    module.exports = gameanalytics;
  }
});

// node_modules/@vkontakte/vk-bridge/dist/index.umd.js
var require_index_umd = __commonJS({
  "node_modules/@vkontakte/vk-bridge/dist/index.umd.js"(exports, module) {
    init_define_AnParams();
    !function(e2, n2) {
      "object" == typeof exports && "undefined" != typeof module ? n2(exports) : "function" == typeof define && define.amd ? define(["exports"], n2) : n2((e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).vkBridge = {});
    }(exports, function(e2) {
      "use strict";
      var n2 = function() {
        return n2 = Object.assign || function(e3) {
          for (var n3, t3 = 1, r3 = arguments.length; t3 < r3; t3++) for (var o3 in n3 = arguments[t3]) Object.prototype.hasOwnProperty.call(n3, o3) && (e3[o3] = n3[o3]);
          return e3;
        }, n2.apply(this, arguments);
      };
      function t2(e3, n3, t3, r3) {
        return new (t3 || (t3 = Promise))(function(o3, a3) {
          function i4(e4) {
            try {
              s3(r3.next(e4));
            } catch (e5) {
              a3(e5);
            }
          }
          function p3(e4) {
            try {
              s3(r3.throw(e4));
            } catch (e5) {
              a3(e5);
            }
          }
          function s3(e4) {
            var n4;
            e4.done ? o3(e4.value) : (n4 = e4.value, n4 instanceof t3 ? n4 : new t3(function(e5) {
              e5(n4);
            })).then(i4, p3);
          }
          s3((r3 = r3.apply(e3, n3 || [])).next());
        });
      }
      function r2(e3, n3) {
        var t3, r3, o3, a3, i4 = { label: 0, sent: function() {
          if (1 & o3[0]) throw o3[1];
          return o3[1];
        }, trys: [], ops: [] };
        return a3 = { next: p3(0), throw: p3(1), return: p3(2) }, "function" == typeof Symbol && (a3[Symbol.iterator] = function() {
          return this;
        }), a3;
        function p3(p4) {
          return function(s3) {
            return function(p5) {
              if (t3) throw new TypeError("Generator is already executing.");
              for (; a3 && (a3 = 0, p5[0] && (i4 = 0)), i4; ) try {
                if (t3 = 1, r3 && (o3 = 2 & p5[0] ? r3.return : p5[0] ? r3.throw || ((o3 = r3.return) && o3.call(r3), 0) : r3.next) && !(o3 = o3.call(r3, p5[1])).done) return o3;
                switch (r3 = 0, o3 && (p5 = [2 & p5[0], o3.value]), p5[0]) {
                  case 0:
                  case 1:
                    o3 = p5;
                    break;
                  case 4:
                    return i4.label++, { value: p5[1], done: false };
                  case 5:
                    i4.label++, r3 = p5[1], p5 = [0];
                    continue;
                  case 7:
                    p5 = i4.ops.pop(), i4.trys.pop();
                    continue;
                  default:
                    if (!(o3 = i4.trys, (o3 = o3.length > 0 && o3[o3.length - 1]) || 6 !== p5[0] && 2 !== p5[0])) {
                      i4 = 0;
                      continue;
                    }
                    if (3 === p5[0] && (!o3 || p5[1] > o3[0] && p5[1] < o3[3])) {
                      i4.label = p5[1];
                      break;
                    }
                    if (6 === p5[0] && i4.label < o3[1]) {
                      i4.label = o3[1], o3 = p5;
                      break;
                    }
                    if (o3 && i4.label < o3[2]) {
                      i4.label = o3[2], i4.ops.push(p5);
                      break;
                    }
                    o3[2] && i4.ops.pop(), i4.trys.pop();
                    continue;
                }
                p5 = n3.call(e3, i4);
              } catch (e4) {
                p5 = [6, e4], r3 = 0;
              } finally {
                t3 = o3 = 0;
              }
              if (5 & p5[0]) throw p5[1];
              return { value: p5[0] ? p5[1] : void 0, done: true };
            }([p4, s3]);
          };
        }
      }
      function o2(e3, n3, t3) {
        if (t3 || 2 === arguments.length) for (var r3, o3 = 0, a3 = n3.length; o3 < a3; o3++) !r3 && o3 in n3 || (r3 || (r3 = Array.prototype.slice.call(n3, 0, o3)), r3[o3] = n3[o3]);
        return e3.concat(r3 || Array.prototype.slice.call(n3));
      }
      function a2(e3, t3, r3) {
        var o3 = /* @__PURE__ */ function(e4) {
          var n3 = { current: 0, next: function() {
            return ++this.current;
          } }, t4 = {};
          return { add: function(r4, o4) {
            var a3 = null != o4 ? o4 : "".concat(n3.next(), "_").concat(e4);
            return t4[a3] = r4, a3;
          }, resolve: function(e5, n4, r4) {
            var o4 = t4[e5];
            o4 && (r4(n4) ? o4.resolve(n4) : o4.reject(n4), t4[e5] = null);
          } };
        }(r3);
        return t3(function(e4) {
          if (e4.detail && e4.detail.data && "object" == typeof e4.detail.data && "request_id" in e4.detail.data) {
            var n3 = e4.detail.data, t4 = n3.request_id, r4 = function(e5, n4) {
              var t5 = {};
              for (var r5 in e5) Object.prototype.hasOwnProperty.call(e5, r5) && n4.indexOf(r5) < 0 && (t5[r5] = e5[r5]);
              if (null != e5 && "function" == typeof Object.getOwnPropertySymbols) {
                var o4 = 0;
                for (r5 = Object.getOwnPropertySymbols(e5); o4 < r5.length; o4++) n4.indexOf(r5[o4]) < 0 && Object.prototype.propertyIsEnumerable.call(e5, r5[o4]) && (t5[r5[o4]] = e5[r5[o4]]);
              }
              return t5;
            }(n3, ["request_id"]);
            t4 && o3.resolve(t4, r4, function(e5) {
              return !("error_type" in e5);
            });
          }
        }), function(t4, r4) {
          return void 0 === r4 && (r4 = {}), new Promise(function(a3, i4) {
            var p3 = o3.add({ resolve: a3, reject: i4 }, r4.request_id);
            e3(t4, n2(n2({}, r4), { request_id: p3 }));
          });
        };
      }
      var i3, p2 = "undefined" != typeof window, s2 = Boolean(p2 && window.AndroidBridge), u2 = Boolean(p2 && window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.VKWebAppClose), c2 = Boolean(p2 && window.ReactNativeWebView && "function" == typeof window.ReactNativeWebView.postMessage), d2 = p2 && !s2 && !u2, l2 = d2 && /(^\?|&)vk_platform=mobile_web(&|$)/.test(location.search), f2 = d2 ? "message" : "VKWebAppEvent", b3 = o2(["VKWebAppInit", "VKWebAppGetCommunityAuthToken", "VKWebAppAddToCommunity", "VKWebAppAddToHomeScreenInfo", "VKWebAppClose", "VKWebAppCopyText", "VKWebAppCreateHash", "VKWebAppGetUserInfo", "VKWebAppSetLocation", "VKWebAppSendToClient", "VKWebAppGetClientVersion", "VKWebAppGetPhoneNumber", "VKWebAppGetEmail", "VKWebAppGetGroupInfo", "VKWebAppGetGeodata", "VKWebAppGetCommunityToken", "VKWebAppGetConfig", "VKWebAppGetLaunchParams", "VKWebAppSetTitle", "VKWebAppGetAuthToken", "VKWebAppCallAPIMethod", "VKWebAppJoinGroup", "VKWebAppLeaveGroup", "VKWebAppAllowMessagesFromGroup", "VKWebAppDenyNotifications", "VKWebAppAllowNotifications", "VKWebAppOpenPayForm", "VKWebAppOpenApp", "VKWebAppShare", "VKWebAppShowWallPostBox", "VKWebAppScroll", "VKWebAppShowOrderBox", "VKWebAppShowLeaderBoardBox", "VKWebAppShowInviteBox", "VKWebAppShowRequestBox", "VKWebAppAddToFavorites", "VKWebAppShowStoryBox", "VKWebAppStorageGet", "VKWebAppStorageGetKeys", "VKWebAppStorageSet", "VKWebAppFlashGetInfo", "VKWebAppSubscribeStoryApp", "VKWebAppOpenWallPost", "VKWebAppCheckAllowedScopes", "VKWebAppCheckBannerAd", "VKWebAppHideBannerAd", "VKWebAppShowBannerAd", "VKWebAppCheckNativeAds", "VKWebAppShowNativeAds", "VKWebAppRetargetingPixel", "VKWebAppConversionHit", "VKWebAppShowSubscriptionBox", "VKWebAppCheckSurvey", "VKWebAppShowSurvey", "VKWebAppScrollTop", "VKWebAppScrollTopStart", "VKWebAppScrollTopStop", "VKWebAppShowSlidesSheet", "VKWebAppTranslate", "VKWebAppRecommend", "VKWebAppAddToProfile", "VKWebAppGetFriends"], d2 && !l2 ? ["VKWebAppResizeWindow", "VKWebAppAddToMenu", "VKWebAppShowInstallPushBox", "VKWebAppShowCommunityWidgetPreviewBox", "VKWebAppCallStart", "VKWebAppCallJoin", "VKWebAppCallGetStatus"] : ["VKWebAppShowImages"], true), A = p2 ? window.AndroidBridge : void 0, v2 = u2 ? window.webkit.messageHandlers : void 0, h2 = d2 ? parent : void 0;
      var m2, w2, W, y2, V, K, _, g2, S2, E;
      e2.EAdsFormats = void 0, (m2 = e2.EAdsFormats || (e2.EAdsFormats = {})).REWARD = "reward", m2.INTERSTITIAL = "interstitial", e2.BannerAdLayoutType = void 0, (w2 = e2.BannerAdLayoutType || (e2.BannerAdLayoutType = {})).RESIZE = "resize", w2.OVERLAY = "overlay", e2.BannerAdLocation = void 0, (W = e2.BannerAdLocation || (e2.BannerAdLocation = {})).TOP = "top", W.BOTTOM = "bottom", e2.BannerAdAlign = void 0, (y2 = e2.BannerAdAlign || (e2.BannerAdAlign = {})).LEFT = "left", y2.RIGHT = "right", y2.CENTER = "center", e2.BannerAdHeightType = void 0, (V = e2.BannerAdHeightType || (e2.BannerAdHeightType = {})).COMPACT = "compact", V.REGULAR = "regular", e2.BannerAdOrientation = void 0, (K = e2.BannerAdOrientation || (e2.BannerAdOrientation = {})).HORIZONTAL = "horizontal", K.VERTICAL = "vertical", e2.EGrantedPermission = void 0, (_ = e2.EGrantedPermission || (e2.EGrantedPermission = {})).CAMERA = "camera", _.LOCATION = "location", _.PHOTO = "photo", e2.EGetLaunchParamsResponseLanguages = void 0, (g2 = e2.EGetLaunchParamsResponseLanguages || (e2.EGetLaunchParamsResponseLanguages = {})).RU = "ru", g2.UK = "uk", g2.UA = "ua", g2.EN = "en", g2.BE = "be", g2.KZ = "kz", g2.PT = "pt", g2.ES = "es", e2.EGetLaunchParamsResponseGroupRole = void 0, (S2 = e2.EGetLaunchParamsResponseGroupRole || (e2.EGetLaunchParamsResponseGroupRole = {})).ADMIN = "admin", S2.EDITOR = "editor", S2.MEMBER = "member", S2.MODER = "moder", S2.NONE = "none", e2.EGetLaunchParamsResponsePlatforms = void 0, (E = e2.EGetLaunchParamsResponsePlatforms || (e2.EGetLaunchParamsResponsePlatforms = {})).DESKTOP_WEB = "desktop_web", E.DESKTOP_WEB_MESSENGER = "desktop_web_messenger", E.DESKTOP_APP_MESSENGER = "desktop_app_messenger", E.MOBILE_WEB = "mobile_web", E.MOBILE_ANDROID = "mobile_android", E.MOBILE_ANDROID_MESSENGER = "mobile_android_messenger", E.MOBILE_IPHONE = "mobile_iphone", E.MOBILE_IPHONE_MESSENGER = "mobile_iphone_messenger", E.MOBILE_IPAD = "mobile_ipad";
      var O = function(e3) {
        var n3 = void 0, p3 = [], l3 = Math.random().toString(36).substring(2, 5);
        function m3(e4) {
          p3.push(e4);
        }
        function w3(e4) {
          return s2 ? !(!A || "function" != typeof A[e4]) : u2 ? !(!v2 || !v2[e4] || "function" != typeof v2[e4].postMessage) : !!d2 && b3.includes(e4);
        }
        function W2() {
          return u2 || s2;
        }
        function y3() {
          return d2 && window.parent !== window;
        }
        function V2() {
          return W2() || y3();
        }
        function K2(e4) {
          if (u2 || s2) return o2([], p3, true).map(function(n4) {
            return n4.call(null, e4);
          });
          var t3 = null == e4 ? void 0 : e4.data;
          if (d2 && t3) {
            if (c2 && "string" == typeof t3) try {
              t3 = JSON.parse(t3);
            } catch (e5) {
            }
            var r3 = t3.type, a3 = t3.data, i4 = t3.frameId;
            r3 && ("VKWebAppSettings" !== r3 ? o2([], p3, true).map(function(e5) {
              return e5({ detail: { type: r3, data: a3 } });
            }) : n3 = i4);
          }
        }
        c2 && /(android)/i.test(navigator.userAgent) ? document.addEventListener(f2, K2) : "undefined" != typeof window && "addEventListener" in window && window.addEventListener(f2, K2);
        var _2 = a2(function(t3, r3) {
          A && A[t3] ? A[t3](JSON.stringify(r3)) : v2 && v2[t3] && "function" == typeof v2[t3].postMessage ? v2[t3].postMessage(r3) : c2 ? window.ReactNativeWebView.postMessage(JSON.stringify({ handler: t3, params: r3 })) : h2 && "function" == typeof h2.postMessage && h2.postMessage({ handler: t3, params: r3, type: "vk-connect", webFrameId: n3, connectVersion: e3 }, "*");
        }, m3, l3);
        return m3(function(e4) {
          if (e4.detail && "SetSupportedHandlers" === e4.detail.type) i3 = new Set(e4.detail.data.supportedHandlers);
        }), { send: _2, sendPromise: _2, subscribe: m3, unsubscribe: function(e4) {
          var n4 = p3.indexOf(e4);
          n4 > -1 && p3.splice(n4, 1);
        }, supports: function(e4) {
          return console.warn("bridge.supports method is deprecated. Use bridge.supportsAsync instead."), w3(e4);
        }, supportsAsync: function(e4) {
          return t2(this, void 0, void 0, function() {
            var n4;
            return r2(this, function(t3) {
              switch (t3.label) {
                case 0:
                  if (s2 || u2) return [2, w3(e4)];
                  if (i3) return [2, i3.has(e4)];
                  t3.label = 1;
                case 1:
                  return t3.trys.push([1, 3, , 4]), [4, _2("SetSupportedHandlers")];
                case 2:
                  return n4 = t3.sent(), i3 = new Set(n4.supportedHandlers), [3, 4];
                case 3:
                  return t3.sent(), i3 = /* @__PURE__ */ new Set(["VKWebAppInit"]), [3, 4];
                case 4:
                  return [2, i3.has(e4)];
              }
            });
          });
        }, isWebView: W2, isIframe: y3, isEmbedded: V2, isStandalone: function() {
          return !V2();
        } };
      }("2.15.11");
      e2.applyMiddleware = function e3() {
        for (var t3 = [], r3 = 0; r3 < arguments.length; r3++) t3[r3] = arguments[r3];
        return t3.includes(void 0) || t3.includes(null) ? e3.apply(void 0, t3.filter(function(e4) {
          return "function" == typeof e4;
        })) : function(e4) {
          if (0 === t3.length) return e4;
          var r4, o3 = { subscribe: e4.subscribe, send: function() {
            for (var n3 = [], t4 = 0; t4 < arguments.length; t4++) n3[t4] = arguments[t4];
            return e4.send.apply(e4, n3);
          } }, a3 = t3.filter(function(e5) {
            return "function" == typeof e5;
          }).map(function(e5) {
            return e5(o3);
          }).reduce(function(e5, n3) {
            return function(t4) {
              return e5(n3(t4));
            };
          });
          return r4 = a3(e4.send), n2(n2({}, e4), { send: r4 });
        };
      }, e2.default = O, e2.parseURLSearchParamsForGetLaunchParams = function(n3) {
        var t3 = {};
        try {
          var r3 = new URLSearchParams(n3);
          r3.forEach(function(n4, r4) {
            switch (r4) {
              case "vk_ts":
              case "vk_is_recommended":
              case "vk_profile_id":
              case "vk_has_profile_button":
              case "vk_testing_group_id":
              case "vk_user_id":
              case "vk_app_id":
              case "vk_group_id":
                t3[r4] = Number(n4);
                break;
              case "sign":
              case "vk_chat_id":
              case "vk_ref":
              case "vk_access_token_settings":
                t3[r4] = n4;
                break;
              case "odr_enabled":
                t3.odr_enabled = "1" === n4 ? 1 : void 0;
                break;
              case "vk_is_app_user":
              case "vk_are_notifications_enabled":
              case "vk_is_favorite":
                t3[r4] = function(e3) {
                  switch (e3) {
                    case "0":
                      return 0;
                    case "1":
                      return 1;
                    default:
                      return;
                  }
                }(n4);
                break;
              case "vk_language":
                t3.vk_language = function(n5) {
                  return Object.values(e2.EGetLaunchParamsResponseLanguages).some(function(e3) {
                    return e3 === n5;
                  });
                }(n4) ? n4 : void 0;
                break;
              case "vk_viewer_group_role":
                t3.vk_viewer_group_role = function(n5) {
                  return Object.values(e2.EGetLaunchParamsResponseGroupRole).some(function(e3) {
                    return e3 === n5;
                  });
                }(n4) ? n4 : void 0;
                break;
              case "vk_platform":
                t3.vk_platform = function(n5) {
                  return Object.values(e2.EGetLaunchParamsResponsePlatforms).some(function(e3) {
                    return e3 === n5;
                  });
                }(n4) ? n4 : void 0;
            }
          });
        } catch (e3) {
          console.warn(e3);
        }
        return t3;
      }, Object.defineProperty(e2, "__esModule", { value: true });
    });
  }
});

// games/packer/src/main.ts
init_define_AnParams();

// games/packer/src/GameApp.ts
init_define_AnParams();

// angine/src/app/AnApp.ts
init_define_AnParams();

// angine/src/core/AnCore.ts
init_define_AnParams();

// angine/src/3D/AnRender3D.ts
init_define_AnParams();

// angine/src/singleton.ts
init_define_AnParams();
init_lib();

// node_modules/pixi.js/lib/math-extras/init.mjs
init_define_AnParams();
init_ObservablePoint();
init_Point();
init_Rectangle();

// node_modules/pixi.js/lib/math-extras/pointExtras.mjs
init_define_AnParams();
init_Point();
var pointExtraMixins = {
  /**
   * Adds `other` to `this` point and outputs into `outPoint` or a new Point.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method add
   * @memberof maths.Point#
   * @param {maths.PointData} other - The point to add to `this`.
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The `outPoint` reference or a new Point, with the result of the addition.
   */
  /**
   * Adds `other` to `this` point and outputs into `outPoint` or a new Point.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method add
   * @memberof maths.ObservablePoint#
   * @param {maths.PointData} other - The point to add to `this`.
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The `outPoint` reference or a new Point, with the result of the addition.
   */
  add(other, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    outPoint.x = this.x + other.x;
    outPoint.y = this.y + other.y;
    return outPoint;
  },
  /**
   * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method subtract
   * @memberof maths.Point#
   * @param {maths.PointData} other - The point to subtract to `this`.
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The `outPoint` reference or a new Point, with the result of the subtraction.
   */
  /**
   * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method subtract
   * @memberof maths.ObservablePoint#
   * @param {maths.PointData} other - The point to subtract to `this`.
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The `outPoint` reference or a new Point, with the result of the subtraction.
   */
  subtract(other, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    outPoint.x = this.x - other.x;
    outPoint.y = this.y - other.y;
    return outPoint;
  },
  /**
   * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method multiply
   * @memberof maths.Point#
   * @param {maths.PointData} other - The point to multiply with `this`.
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The `outPoint` reference or a new Point, with the component-wise multiplication.
   */
  /**
   * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method multiply
   * @memberof maths.ObservablePoint#
   * @param {maths.PointData} other - The point to multiply with `this`.
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The `outPoint` reference or a new Point, with the component-wise multiplication.
   */
  multiply(other, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    outPoint.x = this.x * other.x;
    outPoint.y = this.y * other.y;
    return outPoint;
  },
  /**
   * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method multiplyScalar
   * @memberof maths.Point#
   * @param {number} scalar - The number to multiply both components of `this`.
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The `outPoint` reference or a new Point, with the multiplication.
   */
  /**
   * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method multiplyScalar
   * @memberof maths.ObservablePoint#
   * @param {number} scalar - The number to multiply both components of `this`.
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The `outPoint` reference or a new Point, with the multiplication.
   */
  multiplyScalar(scalar, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    outPoint.x = this.x * scalar;
    outPoint.y = this.y * scalar;
    return outPoint;
  },
  /**
   * Computes the dot product of `other` with `this` point.
   * The dot product is the sum of the products of the corresponding components of two vectors.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method dot
   * @memberof maths.Point#
   * @param {maths.PointData} other - The other point to calculate the dot product with `this`.
   * @returns {number} The result of the dot product. This is an scalar value.
   */
  /**
   * Computes the dot product of `other` with `this` point.
   * The dot product is the sum of the products of the corresponding components of two vectors.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method dot
   * @memberof maths.ObservablePoint#
   * @param {maths.PointData} other - The other point to calculate the dot product with `this`.
   * @returns {number} The result of the dot product. This is an scalar value.
   */
  dot(other) {
    return this.x * other.x + this.y * other.y;
  },
  /**
   * Computes the cross product of `other` with `this` point.
   * Given two linearly independent R3 vectors a and b, the cross product, a  b (read "a cross b"),
   * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.
   * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and
   * the result becomes a vector that will only have magnitude on the z axis.
   *
   * This function returns the z component of the cross product of the two points.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method cross
   * @memberof maths.Point#
   * @param {maths.PointData} other - The other point to calculate the cross product with `this`.
   * @returns {number} The z component of the result of the cross product.
   */
  /**
   * Computes the cross product of `other` with `this` point.
   * Given two linearly independent R3 vectors a and b, the cross product, a  b (read "a cross b"),
   * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.
   * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and
   * the result becomes a vector that will only have magnitude on the z axis.
   *
   * This function returns the z component of the cross product of the two points.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method cross
   * @memberof maths.ObservablePoint#
   * @param {maths.PointData} other - The other point to calculate the cross product with `this`.
   * @returns {number} The z component of the result of the cross product.
   */
  cross(other) {
    return this.x * other.y - this.y * other.x;
  },
  /**
   * Computes a normalized version of `this` point.
   *
   * A normalized vector is a vector of magnitude (length) 1
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method normalize
   * @memberof maths.Point#
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The normalized point.
   */
  /**
   * Computes a normalized version of `this` point.
   *
   * A normalized vector is a vector of magnitude (length) 1
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method normalize
   * @memberof maths.ObservablePoint#
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The normalized point.
   */
  normalize(outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    const magnitude = Math.sqrt(this.x * this.x + this.y * this.y);
    outPoint.x = this.x / magnitude;
    outPoint.y = this.y / magnitude;
    return outPoint;
  },
  /**
   * Computes the magnitude of this point (Euclidean distance from 0, 0).
   *
   * Defined as the square root of the sum of the squares of each component.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method magnitude
   * @memberof maths.Point#
   * @returns {number} The magnitude (length) of the vector.
   */
  /**
   * Computes the magnitude of this point (Euclidean distance from 0, 0).
   *
   * Defined as the square root of the sum of the squares of each component.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method magnitude
   * @memberof maths.ObservablePoint#
   * @returns {number} The magnitude (length) of the vector.
   */
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  /**
   * Computes the square magnitude of this point.
   * If you are comparing the lengths of vectors, you should compare the length squared instead
   * as it is slightly more efficient to calculate.
   *
   * Defined as the sum of the squares of each component.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method magnitudeSquared
   * @memberof maths.Point#
   * @returns {number} The magnitude squared (length squared) of the vector.
   */
  /**
   * Computes the square magnitude of this point.
   * If you are comparing the lengths of vectors, you should compare the length squared instead
   * as it is slightly more efficient to calculate.
   *
   * Defined as the sum of the squares of each component.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method magnitudeSquared
   * @memberof maths.ObservablePoint#
   * @returns {number} The magnitude squared (length squared) of the vector.
   */
  magnitudeSquared() {
    return this.x * this.x + this.y * this.y;
  },
  /**
   * Computes vector projection of `this` on `onto`.
   *
   * Imagine a light source, parallel to `onto`, above `this`.
   * The light would cast rays perpendicular to `onto`.
   * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method project
   * @memberof maths.Point#
   * @param {maths.PointData} onto - A non zero vector describing a line on which to project `this`.
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The `this` on `onto` projection.
   */
  /**
   * Computes vector projection of `this` on `onto`.
   *
   * Imagine a light source, parallel to `onto`, above `this`.
   * The light would cast rays perpendicular to `onto`.
   * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method project
   * @memberof maths.ObservablePoint#
   * @param {maths.PointData} onto - A non zero vector describing a line on which to project `this`.
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The `this` on `onto` projection.
   */
  project(onto, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    const normalizedScalarProjection = (this.x * onto.x + this.y * onto.y) / (onto.x * onto.x + onto.y * onto.y);
    outPoint.x = onto.x * normalizedScalarProjection;
    outPoint.y = onto.y * normalizedScalarProjection;
    return outPoint;
  },
  /**
   * Reflects `this` vector off of a plane orthogonal to `normal`.
   * `normal` is not normalized during this process. Consider normalizing your `normal` before use.
   *
   * Imagine a light source bouncing onto a mirror.
   * `this` vector is the light and `normal` is a vector perpendicular to the mirror.
   * `this.reflect(normal)` is the reflection of `this` on that mirror.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method reflect
   * @memberof maths.Point#
   * @param {maths.PointData} normal - The normal vector of your reflecting plane.
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The reflection of `this` on your reflecting plane.
   */
  /**
   * Reflects `this` vector off of a plane orthogonal to `normal`.
   * `normal` is not normalized during this process. Consider normalizing your `normal` before use.
   *
   * Imagine a light source bouncing onto a mirror.
   * `this` vector is the light and `normal` is a vector perpendicular to the mirror.
   * `this.reflect(normal)` is the reflection of `this` on that mirror.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method reflect
   * @memberof maths.ObservablePoint#
   * @param {maths.PointData} normal - The normal vector of your reflecting plane.
   * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,
   * optional (otherwise will create a new Point).
   * @returns {PointData} The reflection of `this` on your reflecting plane.
   */
  reflect(normal, outPoint) {
    if (!outPoint) {
      outPoint = new Point();
    }
    const dotProduct = this.x * normal.x + this.y * normal.y;
    outPoint.x = this.x - 2 * dotProduct * normal.x;
    outPoint.y = this.y - 2 * dotProduct * normal.y;
    return outPoint;
  }
};

// node_modules/pixi.js/lib/math-extras/rectangleExtras.mjs
init_define_AnParams();
init_Rectangle();
var rectangleExtraMixins = {
  /**
   * Determines whether the `other` Rectangle is contained within `this` Rectangle object.
   * Rectangles that occupy the same space are considered to be containing each other.
   * Rectangles without area (width or height equal to zero) can't contain anything,
   * not even other arealess rectangles.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method containsRect
   * @memberof maths.Rectangle#
   * @param {Rectangle} other - The Rectangle to fit inside `this`.
   * @returns {boolean} A value of `true` if `this` Rectangle contains `other`; otherwise `false`.
   */
  containsRect(other) {
    if (other.width <= 0 || other.height <= 0) {
      return other.x > this.x && other.y > this.y && other.right < this.right && other.bottom < this.bottom;
    }
    return other.x >= this.x && other.y >= this.y && other.right <= this.right && other.bottom <= this.bottom;
  },
  /**
   * Accepts `other` Rectangle and returns true if the given Rectangle is equal to `this` Rectangle.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method equals
   * @memberof maths.Rectangle#
   * @param {Rectangle} other - The Rectangle to compare with `this`
   * @returns {boolean} Returns true if all `x`, `y`, `width`, and `height` are equal.
   */
  equals(other) {
    if (other === this) {
      return true;
    }
    return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
  },
  /**
   * If the area of the intersection between the Rectangles `other` and `this` is not zero,
   * returns the area of intersection as a Rectangle object. Otherwise, return an empty Rectangle
   * with its properties set to zero.
   * Rectangles without area (width or height equal to zero) can't intersect or be intersected
   * and will always return an empty rectangle with its properties set to zero.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method intersection
   * @memberof maths.Rectangle#
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,
   * optional (otherwise will create a new Rectangle).
   * @returns {Rectangle} The intersection of `this` and `other`.
   */
  intersection(other, outRect) {
    if (!outRect) {
      outRect = new Rectangle();
    }
    const x0 = this.x < other.x ? other.x : this.x;
    const x1 = this.right > other.right ? other.right : this.right;
    if (x1 <= x0) {
      outRect.x = outRect.y = outRect.width = outRect.height = 0;
      return outRect;
    }
    const y0 = this.y < other.y ? other.y : this.y;
    const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;
    if (y1 <= y0) {
      outRect.x = outRect.y = outRect.width = outRect.height = 0;
      return outRect;
    }
    outRect.x = x0;
    outRect.y = y0;
    outRect.width = x1 - x0;
    outRect.height = y1 - y0;
    return outRect;
  },
  /**
   * Adds `this` and `other` Rectangles together to create a new Rectangle object filling
   * the horizontal and vertical space between the two rectangles.
   *
   * _Note: Only available with **pixi.js/math-extras**._
   * @method union
   * @memberof maths.Rectangle#
   * @param {Rectangle} other - The Rectangle to unite with `this`.
   * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,
   * optional (otherwise will create a new Rectangle).
   * @returns {Rectangle} The union of `this` and `other`.
   */
  union(other, outRect) {
    if (!outRect) {
      outRect = new Rectangle();
    }
    const x1 = Math.min(this.x, other.x);
    const x2 = Math.max(this.x + this.width, other.x + other.width);
    const y1 = Math.min(this.y, other.y);
    const y2 = Math.max(this.y + this.height, other.y + other.height);
    outRect.x = x1;
    outRect.y = y1;
    outRect.width = x2 - x1;
    outRect.height = y2 - y1;
    return outRect;
  }
};

// node_modules/pixi.js/lib/math-extras/init.mjs
Object.assign(Point.prototype, pointExtraMixins);
Object.assign(ObservablePoint.prototype, pointExtraMixins);
Object.assign(Rectangle.prototype, rectangleExtraMixins);

// angine/src/singleton.ts
init_init15();

// virtual-three:three-stub
var three_stub_exports = {};
__export(three_stub_exports, {
  BoxGeometry: () => BoxGeometry,
  Color: () => Color2,
  Mesh: () => Mesh2,
  MeshBasicMaterial: () => MeshBasicMaterial,
  PerspectiveCamera: () => PerspectiveCamera,
  Scene: () => Scene,
  Texture: () => Texture2,
  TextureLoader: () => TextureLoader,
  WebGLRenderer: () => WebGLRenderer2,
  default: () => three_stub_default
});
init_define_AnParams();
var BoxGeometry = class {
};
var Color2 = class {
};
var Mesh2 = class {
};
var MeshBasicMaterial = class {
};
var PerspectiveCamera = class {
};
var Scene = class {
};
var Texture2 = class {
};
var TextureLoader = class {
};
var WebGLRenderer2 = class {
};
var three_stub_default = {};

// angine/src/singleton.ts
var import_howler = __toESM(require_howler());

// node_modules/fflate/esm/browser.js
init_define_AnParams();
var ch2 = {};
var wk = function(c2, id, msg, transfer, cb) {
  var w2 = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
    c2 + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
  ], { type: "text/javascript" }))));
  w2.onmessage = function(e2) {
    var d2 = e2.data, ed = d2.$e$;
    if (ed) {
      var err2 = new Error(ed[0]);
      err2["code"] = ed[1];
      err2.stack = ed[2];
      cb(err2, null);
    } else
      cb(null, d2);
  };
  w2.postMessage(msg, transfer);
  return w2;
};
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b3 = new u16(31);
  for (var i3 = 0; i3 < 31; ++i3) {
    b3[i3] = start += 1 << eb[i3 - 1];
  }
  var r2 = new i32(b3[30]);
  for (var i3 = 1; i3 < 30; ++i3) {
    for (var j2 = b3[i3]; j2 < b3[i3 + 1]; ++j2) {
      r2[j2] = j2 - b3[i3] << 5 | i3;
    }
  }
  return { b: b3, r: r2 };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i3 = 0; i3 < 32768; ++i3) {
  x2 = (i3 & 43690) >> 1 | (i3 & 21845) << 1;
  x2 = (x2 & 52428) >> 2 | (x2 & 13107) << 2;
  x2 = (x2 & 61680) >> 4 | (x2 & 3855) << 4;
  rev[i3] = ((x2 & 65280) >> 8 | (x2 & 255) << 8) >> 1;
}
var x2;
var i3;
var hMap = function(cd, mb, r2) {
  var s2 = cd.length;
  var i3 = 0;
  var l2 = new u16(mb);
  for (; i3 < s2; ++i3) {
    if (cd[i3])
      ++l2[cd[i3] - 1];
  }
  var le = new u16(mb);
  for (i3 = 1; i3 < mb; ++i3) {
    le[i3] = le[i3 - 1] + l2[i3 - 1] << 1;
  }
  var co;
  if (r2) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i3 = 0; i3 < s2; ++i3) {
      if (cd[i3]) {
        var sv = i3 << 4 | cd[i3];
        var r_1 = mb - cd[i3];
        var v2 = le[cd[i3] - 1]++ << r_1;
        for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
          co[rev[v2] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i3 = 0; i3 < s2; ++i3) {
      if (cd[i3]) {
        co[i3] = rev[le[cd[i3] - 1]++] >> 15 - cd[i3];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i3 = 0; i3 < 144; ++i3)
  flt[i3] = 8;
var i3;
for (i3 = 144; i3 < 256; ++i3)
  flt[i3] = 9;
var i3;
for (i3 = 256; i3 < 280; ++i3)
  flt[i3] = 7;
var i3;
for (i3 = 280; i3 < 288; ++i3)
  flt[i3] = 8;
var i3;
var fdt = new u8(32);
for (i3 = 0; i3 < 32; ++i3)
  fdt[i3] = 5;
var i3;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function(a2) {
  var m2 = a2[0];
  for (var i3 = 1; i3 < a2.length; ++i3) {
    if (a2[i3] > m2)
      m2 = a2[i3];
  }
  return m2;
};
var bits = function(d2, p2, m2) {
  var o2 = p2 / 8 | 0;
  return (d2[o2] | d2[o2 + 1] << 8) >> (p2 & 7) & m2;
};
var bits16 = function(d2, p2) {
  var o2 = p2 / 8 | 0;
  return (d2[o2] | d2[o2 + 1] << 8 | d2[o2 + 2] << 16) >> (p2 & 7);
};
var shft = function(p2) {
  return (p2 + 7) / 8 | 0;
};
var slc = function(v2, s2, e2) {
  if (s2 == null || s2 < 0)
    s2 = 0;
  if (e2 == null || e2 > v2.length)
    e2 = v2.length;
  return new u8(v2.subarray(s2, e2));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e2 = new Error(msg || ec[ind]);
  e2.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e2, err);
  if (!nt)
    throw e2;
  return e2;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l3) {
    var bl = buf.length;
    if (l3 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l3));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s2 = shft(pos) + 4, l2 = dat[s2 - 4] | dat[s2 - 3] << 8, t2 = s2 + l2;
        if (t2 > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l2);
        buf.set(dat.subarray(s2, t2), bt);
        st.b = bt += l2, st.p = pos = t2 * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i3 = 0; i3 < hcLen; ++i3) {
          clt[clim[i3]] = bits(dat, pos + i3 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i3 = 0; i3 < tl; ) {
          var r2 = clm[bits(dat, pos, clbmsk)];
          pos += r2 & 15;
          var s2 = r2 >> 4;
          if (s2 < 16) {
            ldt[i3++] = s2;
          } else {
            var c2 = 0, n2 = 0;
            if (s2 == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c2 = ldt[i3 - 1];
            else if (s2 == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s2 == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i3++] = c2;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c2 = lm[bits16(dat, pos) & lms], sym = c2 >> 4;
      pos += c2 & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c2)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i3 = sym - 257, b3 = fleb[i3];
          add = bits(dat, pos, (1 << b3) - 1) + fl[i3];
          pos += b3;
        }
        var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >> 4;
        if (!d2)
          err(3);
        pos += d2 & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b3 = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b3) - 1, pos += b3;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var et = /* @__PURE__ */ new u8(0);
var mrg = function(a2, b3) {
  var o2 = {};
  for (var k2 in a2)
    o2[k2] = a2[k2];
  for (var k2 in b3)
    o2[k2] = b3[k2];
  return o2;
};
var wcln = function(fn, fnStr, td2) {
  var dt = fn();
  var st = fn.toString();
  var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
  for (var i3 = 0; i3 < dt.length; ++i3) {
    var v2 = dt[i3], k2 = ks[i3];
    if (typeof v2 == "function") {
      fnStr += ";" + k2 + "=";
      var st_1 = v2.toString();
      if (v2.prototype) {
        if (st_1.indexOf("[native code]") != -1) {
          var spInd = st_1.indexOf(" ", 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
        } else {
          fnStr += st_1;
          for (var t2 in v2.prototype)
            fnStr += ";" + k2 + ".prototype." + t2 + "=" + v2.prototype[t2].toString();
        }
      } else
        fnStr += st_1;
    } else
      td2[k2] = v2;
  }
  return fnStr;
};
var ch = [];
var cbfs = function(v2) {
  var tl = [];
  for (var k2 in v2) {
    if (v2[k2].buffer) {
      tl.push((v2[k2] = new v2[k2].constructor(v2[k2])).buffer);
    }
  }
  return tl;
};
var wrkr = function(fns, init2, id, cb) {
  if (!ch[id]) {
    var fnStr = "", td_1 = {}, m2 = fns.length - 1;
    for (var i3 = 0; i3 < m2; ++i3)
      fnStr = wcln(fns[i3], fnStr, td_1);
    ch[id] = { c: wcln(fns[m2], fnStr, td_1), e: td_1 };
  }
  var td2 = mrg({}, ch[id].e);
  return wk(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init2.toString() + "}", id, td2, cbfs(td2), cb);
};
var bInflt = function() {
  return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];
};
var pbf = function(msg) {
  return postMessage(msg, [msg.buffer]);
};
var gopt = function(o2) {
  return o2 && {
    out: o2.size && new u8(o2.size),
    dictionary: o2.dictionary
  };
};
var cbify = function(dat, opts, fns, init2, id, cb) {
  var w2 = wrkr(fns, init2, id, function(err2, dat2) {
    w2.terminate();
    cb(err2, dat2);
  });
  w2.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
  return function() {
    w2.terminate();
  };
};
var b2 = function(d2, b3) {
  return d2[b3] | d2[b3 + 1] << 8;
};
var b4 = function(d2, b3) {
  return (d2[b3] | d2[b3 + 1] << 8 | d2[b3 + 2] << 16 | d2[b3 + 3] << 24) >>> 0;
};
var b8 = function(d2, b3) {
  return b4(d2, b3) + b4(d2, b3 + 4) * 4294967296;
};
function inflate(data, opts, cb) {
  if (!cb)
    cb = opts, opts = {};
  if (typeof cb != "function")
    err(7);
  return cbify(data, opts, [
    bInflt
  ], function(ev) {
    return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));
  }, 1, cb);
}
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e2) {
}
var dutf8 = function(d2) {
  for (var r2 = "", i3 = 0; ; ) {
    var c2 = d2[i3++];
    var eb = (c2 > 127) + (c2 > 223) + (c2 > 239);
    if (i3 + eb > d2.length)
      return { s: r2, r: slc(d2, i3 - 1) };
    if (!eb)
      r2 += String.fromCharCode(c2);
    else if (eb == 3) {
      c2 = ((c2 & 15) << 18 | (d2[i3++] & 63) << 12 | (d2[i3++] & 63) << 6 | d2[i3++] & 63) - 65536, r2 += String.fromCharCode(55296 | c2 >> 10, 56320 | c2 & 1023);
    } else if (eb & 1)
      r2 += String.fromCharCode((c2 & 31) << 6 | d2[i3++] & 63);
    else
      r2 += String.fromCharCode((c2 & 15) << 12 | (d2[i3++] & 63) << 6 | d2[i3++] & 63);
  }
};
function strFromU8(dat, latin1) {
  if (latin1) {
    var r2 = "";
    for (var i3 = 0; i3 < dat.length; i3 += 16384)
      r2 += String.fromCharCode.apply(null, dat.subarray(i3, i3 + 16384));
    return r2;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a2 = dutf8(dat), s2 = _a2.s, r2 = _a2.r;
    if (r2.length)
      err(8);
    return s2;
  }
}
var slzh = function(d2, b3) {
  return b3 + 30 + b2(d2, b3 + 26) + b2(d2, b3 + 28);
};
var zh = function(d2, b3, z) {
  var fnl = b2(d2, b3 + 28), fn = strFromU8(d2.subarray(b3 + 46, b3 + 46 + fnl), !(b2(d2, b3 + 8) & 2048)), es = b3 + 46 + fnl, bs = b4(d2, b3 + 20);
  var _a2 = z && bs == 4294967295 ? z64e(d2, es) : [bs, b4(d2, b3 + 24), b4(d2, b3 + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];
  return [b2(d2, b3 + 10), sc, su, fn, es + b2(d2, b3 + 30) + b2(d2, b3 + 32), off];
};
var z64e = function(d2, b3) {
  for (; b2(d2, b3) != 1; b3 += 4 + b2(d2, b3 + 2))
    ;
  return [b8(d2, b3 + 12), b8(d2, b3 + 4), b8(d2, b3 + 20)];
};
var mt = typeof queueMicrotask == "function" ? queueMicrotask : typeof setTimeout == "function" ? setTimeout : function(fn) {
  fn();
};
function unzip(data, opts, cb) {
  if (!cb)
    cb = opts, opts = {};
  if (typeof cb != "function")
    err(7);
  var term = [];
  var tAll = function() {
    for (var i4 = 0; i4 < term.length; ++i4)
      term[i4]();
  };
  var files = {};
  var cbd = function(a2, b3) {
    mt(function() {
      cb(a2, b3);
    });
  };
  mt(function() {
    cbd = cb;
  });
  var e2 = data.length - 22;
  for (; b4(data, e2) != 101010256; --e2) {
    if (!e2 || data.length - e2 > 65558) {
      cbd(err(13, 0, 1), null);
      return tAll;
    }
  }
  ;
  var lft = b2(data, e2 + 8);
  if (lft) {
    var c2 = lft;
    var o2 = b4(data, e2 + 16);
    var z = o2 == 4294967295 || c2 == 65535;
    if (z) {
      var ze = b4(data, e2 - 12);
      z = b4(data, ze) == 101075792;
      if (z) {
        c2 = lft = b4(data, ze + 32);
        o2 = b4(data, ze + 48);
      }
    }
    var fltr = opts && opts.filter;
    var _loop_3 = function(i4) {
      var _a2 = zh(data, o2, z), c_1 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b3 = slzh(data, off);
      o2 = no;
      var cbl = function(e3, d2) {
        if (e3) {
          tAll();
          cbd(e3, null);
        } else {
          if (d2)
            files[fn] = d2;
          if (!--lft)
            cbd(null, files);
        }
      };
      if (!fltr || fltr({
        name: fn,
        size: sc,
        originalSize: su,
        compression: c_1
      })) {
        if (!c_1)
          cbl(null, slc(data, b3, b3 + sc));
        else if (c_1 == 8) {
          var infl = data.subarray(b3, b3 + sc);
          if (su < 524288 || sc > 0.8 * su) {
            try {
              cbl(null, inflateSync(infl, { out: new u8(su) }));
            } catch (e3) {
              cbl(e3, null);
            }
          } else
            term.push(inflate(infl, { size: su }, cbl));
        } else
          cbl(err(14, "unknown compression type " + c_1, 1), null);
      } else
        cbl(null, null);
    };
    for (var i3 = 0; i3 < c2; ++i3) {
      _loop_3(i3);
    }
  } else
    cbd(null, {});
  return tAll;
}

// angine/src/singleton.ts
var Default = "default";

// angine/src/core/AnViewport.ts
init_define_AnParams();

// angine/src/utils/AnEvents.ts
init_define_AnParams();
var _AnEvents = class _AnEvents {
  //   ..  
  constructor() {
  }
  /**
   *   
   * @param event -   ( event:item)
   * @param callback - -
   * @returns id    
   */
  static on(event, callback) {
    if (!_AnEvents.listeners.has(event))
      _AnEvents.listeners.set(event, /* @__PURE__ */ new Map());
    const id = Symbol("AnEvents");
    _AnEvents.listeners.get(event).set(id, callback);
    return { unsub: () => _AnEvents.off(event, id), id };
  }
  /**
   *   
   * @param event -  
   * @param id - ID  ()
   */
  static off(event, id) {
    _AnEvents.listeners.get(event)?.delete(id);
  }
  /**
   *  
   * @param event -  
   * @param callback - -
   */
  static once(event, callback) {
    const { unsub } = _AnEvents.on(event, (event2) => {
      callback(event2);
      unsub();
    });
  }
  /**
   *  
   * @param event -   ( event:item)
   * @param data -   
   */
  static emit(event, data) {
    _AnEvents.listeners.get(event)?.forEach((callback) => callback({ event, data }));
  }
  /**
   *   
   * @param event - :   
   */
  static clear(event) {
    if (event)
      _AnEvents.listeners.delete(event);
    else
      _AnEvents.listeners.clear();
  }
};
_AnEvents.listeners = /* @__PURE__ */ new Map();
var AnEvents = _AnEvents;

// angine/src/utils/AnLog.ts
init_define_AnParams();
var AnLogLevel = /* @__PURE__ */ ((AnLogLevel2) => {
  AnLogLevel2[AnLogLevel2["DEBUG"] = 0] = "DEBUG";
  AnLogLevel2[AnLogLevel2["INFO"] = 1] = "INFO";
  AnLogLevel2[AnLogLevel2["WARN"] = 2] = "WARN";
  AnLogLevel2[AnLogLevel2["ERROR"] = 3] = "ERROR";
  AnLogLevel2[AnLogLevel2["SILENT"] = 4] = "SILENT";
  return AnLogLevel2;
})(AnLogLevel || {});
var badgesStyle = {
  [4 /* SILENT */]: "",
  [0 /* DEBUG */]: "color: #666; background: #e0e0e0; padding: 2px 4px; border-radius: 10px; font-weight: bold;",
  [1 /* INFO */]: "color: #fff; background: #2196F3; padding: 2px 4px; border-radius: 10px; font-weight: bold;",
  [2 /* WARN */]: "color: #000; background: #FFC107; padding: 2px 4px; border-radius: 10px; font-weight: bold;",
  [3 /* ERROR */]: "color: #fff; background: #F44336; padding: 2px 4px; border-radius: 10px; font-weight: bold;"
};
var badgesEmoji = {
  [4 /* SILENT */]: "",
  [0 /* DEBUG */]: "\u{1F41B}",
  [1 /* INFO */]: "\u2139\uFE0F",
  [2 /* WARN */]: "\u26A0\uFE0F",
  [3 /* ERROR */]: "\u{1F525}"
};
var timestampStyle = "color: #888; font-style: italic;";
var AnLog = class {
  //   ..  
  constructor() {
  }
  /**
   *  
   */
  static init(options) {
    if (options.level !== void 0) this.level = options.level;
    if (options.maxHistory !== void 0) this.maxHistory = options.maxHistory;
    if (options.enableHistory !== void 0) this.enableHistory = options.enableHistory;
    if (options.enableEvents !== void 0) this.enableEvents = options.enableEvents;
  }
  /**
   *    .  :
   * -    
   * -   
   * -   
   *  production  .
   * : "Render loop started (frameId: 42)"
   */
  static debug(message, data) {
    if (true) {
      this.log(0 /* DEBUG */, message, data);
    }
  }
  /**
   *     .  :
   * - / 
   * - ,    
   * -   
   * : "Game scene loaded in 1.25s"
   */
  static info(message, data) {
    this.log(1 /* INFO */, message, data);
  }
  /**
   *   .  :
   * - ,   
   * -  API (deprecation warnings)
   * -  
   * : "Texture 'grass.png' has unusual size 513x513"
   */
  static warn(message, data) {
    this.log(2 /* WARN */, message, data);
  }
  /**
   *  .  :
   * -  
   * -   (,  )
   * -  
   * : "Failed to load asset: 404 Not Found"
   */
  static error(message, data) {
    this.log(3 /* ERROR */, message, data);
  }
  /**
   *  ""     :
   * -  
   * - ::
   */
  static ping(extra) {
    if (false) return;
    if (this.level > 0 /* DEBUG */) return;
    const stack = new Error().stack;
    if (!stack) return;
    const lines = stack.split("\n");
    let callerLine = null;
    for (let i3 = 2; i3 < lines.length; i3++) {
      const line = lines[i3].trim();
      if (!line.includes("AnLog.ping") && !line.includes("at Object.")) {
        callerLine = line;
        break;
      }
    }
    if (!callerLine) return;
    this.log(0 /* DEBUG */, extra ? `\u{1F4CD} PING[${extra}] ${callerLine}` : `\u{1F4CD} PING ${callerLine}`);
  }
  /**
   *   
   */
  static getHistory(filter) {
    return filter !== void 0 ? this.history.filter((entry) => entry.level >= filter) : [...this.history];
  }
  /**
   *     
   */
  static log(level, message, data) {
    if (level < this.level) return;
    const timestamp = /* @__PURE__ */ new Date();
    if (this.enableHistory || this.enableEvents) {
      const logEntry = {
        level,
        message,
        data,
        timestamp
      };
      if (this.enableHistory) {
        this.history.push(logEntry);
        if (this.history.length > this.maxHistory) {
          this.history.shift();
        }
      }
      if (this.enableEvents) {
        AnEvents.emit("log-message", logEntry);
      }
    }
    const badge = `${badgesEmoji[level]} ${AnLogLevel[level]}`;
    const timestampText = `${timestamp.toLocaleTimeString()}`;
    const messageWithData = data !== void 0 ? `${message} %o` : message;
    const formatLogString = `%c${badge}%c ${timestampText}%c ${messageWithData}`;
    const styleArgs = [
      badgesStyle[level],
      //   badge
      timestampStyle,
      //   timestamp
      ""
      //    message
    ];
    const consoleArgs = [formatLogString, ...styleArgs];
    if (data !== void 0) consoleArgs.push(data);
    switch (level) {
      case 0 /* DEBUG */:
        console.debug(...consoleArgs);
        break;
      case 1 /* INFO */:
        console.info(...consoleArgs);
        break;
      case 2 /* WARN */:
        console.warn(...consoleArgs);
        break;
      case 3 /* ERROR */:
        console.error(...consoleArgs);
        break;
    }
  }
};
AnLog.level = 0 /* DEBUG */;
AnLog.history = [];
AnLog.maxHistory = define_AnParams_default.maxLogHistory;
AnLog.enableHistory = false;
AnLog.enableEvents = false;

// angine/src/core/AnViewport.ts
var scaled = (value) => value * AnViewport.scale;
var _AnViewport = class _AnViewport {
  constructor() {
  }
  static async init() {
    _AnViewport.createCanvas();
    await _AnViewport.initGLContext();
    document.body.appendChild(_AnViewport._canvas);
    _AnViewport.resize(window.innerWidth, window.innerHeight);
  }
  // ---   ---
  /** Canvas  */
  static get canvas() {
    return _AnViewport._canvas;
  }
  /** WebGL2  */
  static get glContext() {
    return _AnViewport._glContext;
  }
  /**  viewport    (  devicePixelRatio) */
  static get physWidth() {
    return _AnViewport._physWidth;
  }
  /**  viewport    (  devicePixelRatio) */
  static get physHeight() {
    return _AnViewport._physHeight;
  }
  /**   viewport */
  static get halfWidth() {
    return _AnViewport._width * 0.5;
  }
  /**   viewport */
  static get halfHeight() {
    return _AnViewport._height * 0.5;
  }
  /**       (    ultra-wide) */
  static get maxWidth() {
    return _AnViewport._maxWidth;
  }
  /**    */
  static get aspectRatio() {
    return _AnViewport._physWidth / _AnViewport._physHeight;
  }
  /**    */
  static get portraitMode() {
    return _AnViewport.width < _AnViewport.height;
  }
  /**    */
  static get landscapeMode() {
    return _AnViewport.width >= _AnViewport.height;
  }
  /**  viewport   (CSS)  */
  static get width() {
    return _AnViewport._width;
  }
  /**  viewport   (CSS)  */
  static get height() {
    return _AnViewport._height;
  }
  /**   */
  static get scale() {
    return _AnViewport._scale;
  }
  /**   () */
  static get baseWidth() {
    return _AnViewport._baseWidth;
  }
  /**   () */
  static get baseHeight() {
    return _AnViewport._baseHeight;
  }
  // ---   ---
  /**
   *     
   * @param width -   
   * @param height -   
   */
  static setBaseSize(width, height) {
    _AnViewport._baseWidth = width;
    _AnViewport._baseHeight = height;
    _AnViewport.updateScaleFactor();
  }
  /**
   *   viewport
   * @param newLogicalWidth -     
   * @param newLogicalHeight -     
   */
  static resize(newLogicalWidth, newLogicalHeight) {
    _AnViewport._width = newLogicalWidth;
    _AnViewport._height = newLogicalHeight;
    _AnViewport._maxWidth = Math.min(_AnViewport._width, _AnViewport._height);
    _AnViewport._physWidth = Math.floor(newLogicalWidth * devicePixelRatio);
    _AnViewport._physHeight = Math.floor(newLogicalHeight * devicePixelRatio);
    _AnViewport.updateScaleFactor();
    _AnViewport.invalidate();
    AnLog.info(`\u0420\u0430\u0437\u043C\u0435\u0440\u044B \u0432\u044C\u044E\u043F\u043E\u0440\u0442\u0430: ${_AnViewport._physWidth}x${_AnViewport._physHeight} \u043C\u0430\u0441\u0448\u0442\u0430\u0431: ${_AnViewport._scale.toFixed(3)}`);
  }
  //        
  static invalidate() {
    AnEvents.emit("viewport:resize", { width: _AnViewport._width, height: _AnViewport._height });
  }
  // ---   ---
  /**  canvas  */
  static createCanvas() {
    _AnViewport._canvas = document.createElement("canvas");
  }
  /**  WebGL2  */
  static async initGLContext() {
    if ("gpu" in navigator) {
      try {
        const adapter = await navigator.gpu.requestAdapter({
          //powerPreference: 'high-performance'
        });
        if (adapter) {
          const device = await adapter.requestDevice();
          const gpuContext = _AnViewport._canvas.getContext("webgpu");
          if (gpuContext) {
            const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
            gpuContext.configure({
              device,
              format: presentationFormat,
              alphaMode: "premultiplied"
              //  alpha: true
              // antialias   multisample  render pipeline
              // preserveDrawingBuffer    
              // stencil   depthStencilFormat
            });
            _AnViewport._glContext = gpuContext;
            AnLog.info("\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0441\u044F \u0440\u0435\u043D\u0434\u0435\u0440 \u0447\u0435\u0440\u0435\u0437 WebGPU");
            return;
          }
        }
      } catch (e2) {
        AnLog.warn("WebGPU \u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D, \u043D\u043E \u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F \u043D\u0435 \u0443\u0434\u0430\u043B\u0430\u0441\u044C: ", e2);
      }
    }
    const glConfing = {
      alpha: true,
      antialias: true,
      powerPreference: "high-performance",
      preserveDrawingBuffer: true,
      stencil: true
    };
    const webGL2Context = _AnViewport._canvas.getContext("webgl2", glConfing);
    if (webGL2Context) {
      _AnViewport._glContext = webGL2Context;
      AnLog.info("\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0441\u044F \u0440\u0435\u043D\u0434\u0435\u0440 \u0447\u0435\u0440\u0435\u0437 WebGL2");
      return;
    }
    const webGL1Context = _AnViewport._canvas.getContext("webgl", glConfing);
    if (webGL1Context) {
      _AnViewport._glContext = webGL1Context;
      AnLog.info("\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442\u0441\u044F \u0440\u0435\u043D\u0434\u0435\u0440 \u0447\u0435\u0440\u0435\u0437 WebGL1");
      return;
    }
    throw new Error("\u0410\u043F\u043F\u0430\u0440\u0430\u0442\u043D\u043E\u0435 \u0443\u0441\u043A\u043E\u0440\u0435\u043D\u0438\u0435 (WebGPU/WebGL2/WebGL) \u043D\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F, \u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0435\u043D\u0438\u0435 \u043D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E :(");
  }
  /**    */
  static updateScaleFactor() {
    _AnViewport._scaleWidth = _AnViewport._width / _AnViewport._baseWidth;
    _AnViewport._scaleHeight = _AnViewport._height / _AnViewport._baseHeight;
    _AnViewport._scale = (_AnViewport._scaleWidth + _AnViewport._scaleHeight) * 0.5;
  }
};
//    
_AnViewport._baseWidth = define_AnParams_default.baseWidth;
_AnViewport._baseHeight = define_AnParams_default.baseHeight;
// 
_AnViewport._scale = 1;
_AnViewport._scaleWidth = 1;
_AnViewport._scaleHeight = 1;
// 
_AnViewport._physWidth = 0;
_AnViewport._physHeight = 0;
_AnViewport._width = 0;
_AnViewport._height = 0;
_AnViewport._maxWidth = 0;
var AnViewport = _AnViewport;

// angine/src/2D/AnRender2D.ts
init_define_AnParams();

// node_modules/@pixi/devtools/dist/index.js
init_define_AnParams();
async function i2(p2) {
  var a2;
  const e2 = {
    importPixi: false,
    ...p2
  };
  e2.app && (e2.renderer = e2.app.renderer, e2.stage = e2.app.stage), e2.importPixi && !e2.pixi && (e2.pixi = await Promise.resolve().then(() => (init_lib(), lib_exports))), window.__PIXI_DEVTOOLS__ = {
    ...window.__PIXI_DEVTOOLS__ || {},
    app: e2.app,
    stage: e2.stage,
    renderer: e2.renderer,
    extensions: [...((a2 = window.__PIXI_DEVTOOLS__) == null ? void 0 : a2.extensions) || [], ...e2.extensions || []],
    plugins: {}
  };
}

// angine/src/ui/AnUI.ts
init_define_AnParams();
var defaultColorSheme = {
  foreground: 16777215,
  background: 3355443,
  shadow: 1118481
};
var defaultStyleParams = {
  shadowOffset: 3,
  roundCorners: 10
};
var _AnUI = class _AnUI {
  constructor() {
  }
  static get colorSheme() {
    return _AnUI.currentColorSheme;
  }
  static set colorSheme(colorSheme) {
    _AnUI.currentColorSheme = colorSheme;
  }
  static get styleParams() {
    return _AnUI.currentStyleParams;
  }
  static set styleParams(styleParams) {
    _AnUI.currentStyleParams = styleParams;
  }
};
_AnUI.currentColorSheme = defaultColorSheme;
_AnUI.currentStyleParams = defaultStyleParams;
var AnUI = _AnUI;

// angine/src/2D/AnRender2D.ts
var AnRender2D = class _AnRender2D {
  constructor() {
  }
  static async init() {
    this.pixiRender = AnViewport.glContext instanceof GPUCanvasContext ? new lib_exports.WebGPURenderer() : new lib_exports.WebGLRenderer();
    await this.pixiRender.init({
      // @ts-ignore     ,  !
      context: AnViewport.glContext,
      canvas: AnViewport.canvas,
      width: AnViewport.physWidth,
      height: AnViewport.physHeight,
      //resolution: window.devicePixelRatio || 1,
      resolution: 1,
      // :  -DPR!
      autoDensity: false,
      //   
      antialias: true,
      // 
      //useBackBuffer: true,
      backgroundColor: new lib_exports.Color(AnUI.colorSheme.shadow),
      clearBeforeRender: true
      //   ,   Three.js.
    });
    this._stage = new lib_exports.Container();
    if (true) {
      AnLog.warn("PIXI DevTools \u0432\u043A\u043B\u044E\u0447\u0435\u043D!");
      i2({ stage: this._stage, renderer: this.pixiRender });
    }
  }
  static get stage() {
    return this._stage;
  }
  static addToFront(child) {
    return _AnRender2D.stage.addChild(child);
  }
  static addToBack(child) {
    return _AnRender2D.stage.addChildAt(child, 0);
  }
  static terminate() {
    this.pixiRender.destroy();
  }
  static resize(width, height) {
    this.pixiRender.resize(width, height);
  }
  static render() {
    this.pixiRender.resetState();
    this.pixiRender.render(this._stage);
  }
};

// angine/src/core/AnMainLoop.ts
init_define_AnParams();
var _AnMainLoop = class _AnMainLoop {
  static init(_onUpdate, _onRender) {
    AnLog.info(`\u041B\u0438\u043C\u0438\u0442 FPS: [${_AnMainLoop._minFPS}..${_AnMainLoop._maxFPS}] \u0431\u0430\u0437\u043E\u0432\u044B\u0439 FPS: ${_AnMainLoop._baseFPS}`);
    _AnMainLoop._onUpdate = _onUpdate;
    _AnMainLoop._onRender = _onRender;
  }
  // ---   ---
  /**
   *   .
   *    ,    .
   *       .
   */
  static start() {
    if (_AnMainLoop._isRunning) return;
    _AnMainLoop._isRunning = true;
    _AnMainLoop._lastTime = performance.now();
    _AnMainLoop._frameCount = 0;
    _AnMainLoop._run();
  }
  /**
   *   .
   *     ,    .
   *      cancelAnimationFrame.
   */
  static stop() {
    if (!_AnMainLoop._isRunning) return;
    _AnMainLoop._isRunning = false;
    if (_AnMainLoop._requestId) cancelAnimationFrame(_AnMainLoop._requestId);
  }
  /**   FPS (, min: 30, max: 60) */
  static setFPSLimits(min, max2) {
    _AnMainLoop._minFPS = min;
    _AnMainLoop._maxFPS = max2;
  }
  // ---  ---
  /**     (, 0.016  60 FPS) */
  static get dt() {
    return _AnMainLoop._dt;
  }
  /**  FPS (    ) */
  static get FPS() {
    return _AnMainLoop._FPS;
  }
  /**   (1.0 = 60 FPS, 2.0 = 120 FPS) */
  static get performanceFactor() {
    return _AnMainLoop._FPS / _AnMainLoop._baseFPS;
  }
  /**     FPS*/
  static get baseFPS() {
    return _AnMainLoop._baseFPS;
  }
  // ---   ---
  /**
   *      .
   *    requestAnimationFrame.
   *  dt,  FPS,     .
   */
  static _run() {
    if (!_AnMainLoop._isRunning) return;
    const now = performance.now();
    const delta = now - _AnMainLoop._lastTime;
    const minFrameTime = 1e3 / _AnMainLoop._maxFPS;
    const maxFrameTime = 1e3 / _AnMainLoop._minFPS;
    if (delta >= minFrameTime) {
      _AnMainLoop._dt = Math.min(delta, maxFrameTime) / 1e3;
      _AnMainLoop._lastTime = now - delta % minFrameTime;
      _AnMainLoop._frameCount++;
      if (now >= _AnMainLoop._lastTime + 1e3) {
        _AnMainLoop._FPS = _AnMainLoop._frameCount;
        _AnMainLoop._frameCount = 0;
      }
      _AnMainLoop._onUpdate(_AnMainLoop._dt);
      _AnMainLoop._onRender();
    }
    _AnMainLoop._requestId = requestAnimationFrame(() => _AnMainLoop._run());
  }
};
// , ,       
_AnMainLoop._isRunning = false;
// ID     (requestAnimationFrame)
//      cancelAnimationFrame
// null -    
_AnMainLoop._requestId = null;
//   ( )  
//    dt  
//      performance.now()
_AnMainLoop._lastTime = 0;
// ,       ( )
//   (  - _lastTime) / 1000
//       FPS
_AnMainLoop._dt = 0;
//      (FPS)
//      _frameCount
_AnMainLoop._FPS = 0;
//  ,    FPS
//   ,   
_AnMainLoop._frameCount = 0;
//   FPS (  )
//      :
// - dt   (maxFrameTime)
// -       FPS
//    : 25-30 FPS
_AnMainLoop._minFPS = define_AnParams_default.minFPS;
//   FPS (  )
//   :
// -       
// -   /GPU
//       (60, 120, 144  ..)
_AnMainLoop._maxFPS = define_AnParams_default.maxFPS;
//  FPS   (  60)
_AnMainLoop._baseFPS = define_AnParams_default.baseFPS;
var AnMainLoop = _AnMainLoop;

// angine/src/utils/AnUpdater.ts
init_define_AnParams();

// angine/src/utils/AnHelpers.ts
init_define_AnParams();

// angine/src/anim/AnTween.ts
init_define_AnParams();

// angine/src/anim/AnEase.ts
init_define_AnParams();
var AnEase = class _AnEase {
  /**
   *    
   * @param t   (0-1)
   */
  static linear(t2) {
    return t2;
  }
  /**
   *    
   * @param t   (0-1)
   */
  static easeIn(t2) {
    return t2 * t2;
  }
  /**
   *    
   * @param t   (0-1)
   */
  static easeOut(t2) {
    return t2 * (2 - t2);
  }
  /**
   *       
   * @param t   (0-1)
   */
  static easeInOut(t2) {
    return t2 < 0.5 ? 2 * t2 * t2 : -1 + (4 - 2 * t2) * t2;
  }
  /**
   *       
   * @param t   (0-1)
   */
  static easeOutIn(t2) {
    return t2 < 0.5 ? 0.5 * (1 - _AnEase.easeOut(1 - 2 * t2)) : 0.5 * _AnEase.easeIn(2 * t2 - 1) + 0.5;
  }
  /**
   *  ""   
   * @param t   (0-1)
   * @param s   (  1.70158)
   */
  static easeInBack(t2, s2 = 1.70158) {
    return t2 * t2 * ((s2 + 1) * t2 - s2);
  }
  /**
   *  ""   
   * @param t   (0-1)
   * @param s   (  1.70158)
   */
  static easeOutBack(t2, s2 = 1.70158) {
    return 1 + --t2 * t2 * ((s2 + 1) * t2 + s2);
  }
  /**
   *  ""     
   * @param t   (0-1)
   * @param s   (  1.70158)
   */
  static easeInOutBack(t2, s2 = 1.70158) {
    return (t2 *= 2) < 1 ? 0.5 * (t2 * t2 * (((s2 *= 1.525) + 1) * t2 - s2)) : 0.5 * ((t2 -= 2) * t2 * (((s2 *= 1.525) + 1) * t2 + s2) + 2);
  }
  /**
   *  ""     
   * @param t   (0-1)
   */
  static easeOutInBack(t2) {
    return t2 < 0.5 ? _AnEase.easeOutBack(t2 * 2) / 2 : _AnEase.easeInBack(2 * t2 - 1) / 2 + 0.5;
  }
  /**
   *  ""   
   * @param t   (0-1)
   */
  static easeInElastic(t2) {
    if (t2 === 0 || t2 === 1) return t2;
    return -Math.pow(2, 10 * (t2 - 1)) * Math.sin((t2 - 1.075) * (2 * Math.PI) / 0.3);
  }
  /**
   *  ""   
   * @param t   (0-1)
   */
  static easeOutElastic(t2) {
    if (t2 === 0 || t2 === 1) return t2;
    return Math.pow(2, -10 * t2) * Math.sin((t2 - 0.075) * (2 * Math.PI) / 0.3) + 1;
  }
  /**
   *  ""     
   * @param t   (0-1)
   */
  static easeInOutElastic(t2) {
    return t2 < 0.5 ? 0.5 * _AnEase.easeInElastic(2 * t2) : 0.5 * _AnEase.easeOutElastic(2 * t2 - 1) + 0.5;
  }
  /**
   *  ""     
   * @param t   (0-1)
   */
  static easeOutInElastic(t2) {
    return t2 < 0.5 ? _AnEase.easeOutElastic(2 * t2) / 2 : _AnEase.easeInElastic(2 * t2 - 1) / 2 + 0.5;
  }
  /**
   *  ""   
   * @param t   (0-1)
   */
  static easeInBounce(t2) {
    return 1 - _AnEase.easeOutBounce(1 - t2);
  }
  /**
   *  ""   
   * @param t   (0-1)
   */
  static easeOutBounce(t2) {
    if (t2 < 1 / 2.75) return 7.5625 * t2 * t2;
    if (t2 < 2 / 2.75) return 7.5625 * (t2 -= 1.5 / 2.75) * t2 + 0.75;
    if (t2 < 2.5 / 2.75) return 7.5625 * (t2 -= 2.25 / 2.75) * t2 + 0.9375;
    return 7.5625 * (t2 -= 2.625 / 2.75) * t2 + 0.984375;
  }
  /**
   *  ""     
   * @param t   (0-1)
   */
  static easeInOutBounce(t2) {
    return t2 < 0.5 ? _AnEase.easeInBounce(2 * t2) / 2 : _AnEase.easeOutBounce(2 * t2 - 1) / 2 + 0.5;
  }
  /**
   *  ""     
   * @param t   (0-1)
   */
  static easeOutInBounce(t2) {
    return t2 < 0.5 ? _AnEase.easeOutBounce(2 * t2) / 2 : _AnEase.easeInBounce(2 * t2 - 1) / 2 + 0.5;
  }
};

// angine/src/mixins/AnUpdatableMixin.ts
init_define_AnParams();
function isAnUpdatable(object) {
  return object && object["AnUpdatableMixin"] === "AnUpdatableMixin";
}
function AnUpdatableMixin(Base) {
  return class AnUpdatable extends Base {
    constructor() {
      super(...arguments);
      /**    */
      this.AnUpdatableMixin = "AnUpdatableMixin";
      /**    AnUpdater */
      this.updater = null;
    }
    /**
     *     
     * @param updater -  AnUpdater
     */
    bind(updater) {
      if (this.updater !== null) {
        this.removeFromUpdater();
      }
      updater.add(this);
      this.updater = updater;
    }
    /**
     *     AnUpdater
     */
    getUpdater() {
      return this.updater;
    }
    /**
     *     
     *   
     */
    addToUpdater(updater) {
      this.bind(updater);
      return () => this.removeFromUpdater();
    }
    /**
     *      
     */
    removeFromUpdater() {
      this.updater?.remove(this);
      this.updater = null;
    }
    /**
     *    ( )
     * @param dt -    
     */
    update(dt) {
    }
  };
}

// angine/src/mixins/AnTaggableMixin.ts
init_define_AnParams();
function AnTaggableMixin(Base) {
  return class AnTaggable extends Base {
    constructor() {
      super(...arguments);
      this._tags = /* @__PURE__ */ new Set();
    }
    /**
     *    
     * @param tag -  
     * @returns     
     */
    addTag(tag) {
      this._tags.add(tag.toLowerCase());
      return this;
    }
    /**
     *    
     * @param tag -  
     * @returns     
     */
    removeTag(tag) {
      this._tags.delete(tag.toLowerCase());
      return this;
    }
    /**
     *     
     * @param tag -  
     * @returns true   
     */
    hasTag(tag) {
      return this._tags.has(tag.toLowerCase());
    }
    /**
     *     
     * @returns    
     */
    getTags() {
      return Array.from(this._tags);
    }
    /**
     *    
     * @returns     
     */
    clearTags() {
      this._tags.clear();
      return this;
    }
  };
}

// angine/src/utils/AnMath.ts
init_define_AnParams();
var _AnMath = class _AnMath {
  /**
   *  
   */
  static isEven(val) {
    return val % 2 === 0;
  }
  /**
   *  
   */
  static isOdd(val) {
    return val % 2 !== 0;
  }
  /**
   *   val   A..B   C..D
   */
  static remap(val, A, B, C, D) {
    return C + (D - C) * (val - A) / (B - A);
  }
  /**
   *   val   A..B   C..D c    
   */
  static remapClamp(val, A, B, C, D) {
    return _AnMath.remap(_AnMath.clamp(val, A, B), A, B, C, D);
  }
  static distance(point1, point2) {
    const dx = point2.x - point1.x;
    const dy = point2.y - point1.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  /**
   *         .
   * @param a  .
   * @param b  .
   * @param eps  (  1e-9).
   * @returns `true`,      ,  `false`.
   */
  static floatEqual(a2, b3, eps = 1e-9) {
    return Math.abs(a2 - b3) < eps;
  }
  /**
   *     .
   * @param start  .
   * @param end  .
   * @param t   ( 0  1).
   * @returns  .
   */
  static lerp(start, end, t2) {
    return start * (1 - t2) + end * t2;
  }
  static lerpColor(start, end, progress) {
    const startR = start >> 16 & 255;
    const startG = start >> 8 & 255;
    const startB = start & 255;
    const endR = end >> 16 & 255;
    const endG = end >> 8 & 255;
    const endB = end & 255;
    const r2 = _AnMath.clamp(Math.round(startR + (endR - startR) * progress), 0, 255);
    const g2 = _AnMath.clamp(Math.round(startG + (endG - startG) * progress), 0, 255);
    const b3 = _AnMath.clamp(Math.round(startB + (endB - startB) * progress), 0, 255);
    return r2 << 16 | g2 << 8 | b3;
  }
  /**
   *     from..to
   */
  static clamp(val, from, to) {
    return val < from ? from : val > to ? to : val;
  }
  /**
   *       lRange  uRange
   */
  static inRange(Num, lRange, uRange) {
    return Num >= lRange && Num <= uRange;
  }
  /**
   *     arg  Val1  Val2
   */
  static closest(arg, Val1, Val2) {
    return Math.abs(arg - Val1) < Math.abs(arg - Val2) ? Val1 : Val2;
  }
  static rotate90(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    const result = [];
    for (let j2 = 0; j2 < cols; j2++) {
      const newRow = [];
      for (let i3 = rows - 1; i3 >= 0; i3--) {
        newRow.push(matrix[i3][j2]);
      }
      result.push(newRow);
    }
    return result;
  }
  static rotate180(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    const result = [];
    for (let i3 = rows - 1; i3 >= 0; i3--) {
      const newRow = [];
      for (let j2 = cols - 1; j2 >= 0; j2--) {
        newRow.push(matrix[i3][j2]);
      }
      result.push(newRow);
    }
    return result;
  }
  static rotate270(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    const result = [];
    for (let j2 = cols - 1; j2 >= 0; j2--) {
      const newRow = [];
      for (let i3 = 0; i3 < rows; i3++) {
        newRow.push(matrix[i3][j2]);
      }
      result.push(newRow);
    }
    return result;
  }
  //     
  static fitRectangleToRectangle(width, height, width2, height2) {
    const widthRatio = width / width2;
    const heightByWidth = height2 * widthRatio;
    const heightRatio = height / height2;
    const widthByHeight = width2 * heightRatio;
    if (heightByWidth <= height) {
      return { width, height: heightByWidth };
    } else {
      return { width: widthByHeight, height };
    }
  }
  /**
   *       
   * @param value -  
   * @param multiple -  (  10)
   * @returns  
   */
  static floorToMultiple(value, multiple = 10) {
    return Math.floor(value / multiple) * multiple;
  }
  /**
   *       
   * @param value -  
   * @param multiple -  (  10)
   * @returns  
   */
  static ceilToMultiple(value, multiple = 10) {
    return Math.ceil(value / multiple) * multiple;
  }
  /**
   *      
   * @param value -    
   * @param multiple -  (  10)
   * @returns  
   */
  static roundToMultiple(value, multiple = 10) {
    return Math.round(value / multiple) * multiple;
  }
};
_AnMath.toDeg = 57.29577951308232;
_AnMath.toRad = 0.017453292519943295;
var AnMath = _AnMath;

// angine/src/anim/AnTween.ts
var AnTween = class extends enhance(Object).with(AnUpdatableMixin, AnTaggableMixin) {
  //private nextTween: AnTween | null = null;
  /**
   *    -
   * @param config  
   */
  constructor(config2) {
    super();
    this.startValues = {};
    this.elapsedTime = 0;
    this.delayCounter = 0;
    this.repeatCount = 0;
    this.tolerance = 0;
    this.isReversing = false;
    this._paused = false;
    this._running = false;
    this.target = config2.target;
    this.to = config2.to ?? { alpha: 1 };
    this.tolerance = config2.tolerance ?? 0;
    this.duration = config2.duration ?? 1;
    this.delay = config2.delay ?? 0;
    this.round = config2.round ?? false;
    this.repeat = config2.repeat ?? 0;
    this.reverse = config2.reverse ?? false;
    this.autoRemove = config2.autoRemove ?? true;
    this.easing = config2.easing ?? AnEase.linear;
    this._callbacks = config2.callbacks ?? {};
    let autoStart = config2.autoStart ?? true;
    let applyFromOnCreate = config2.applyFromOnCreate ?? true;
    if (config2.tags) {
      config2.tags.forEach((tag) => this.addTag(tag));
    }
    if (config2.updater) this.addToUpdater(config2.updater);
    for (const key in this.to) {
      if (!this.isValidProperty(key)) continue;
      const startVal = config2.from && key in config2.from ? config2.from[key] : this.target[key];
      this.startValues[key] = typeof startVal === "object" ? dataClone(startVal) : startVal;
    }
    if (config2.from && applyFromOnCreate)
      this.applyFromValues();
    if (autoStart) this.start();
  }
  /** ,        */
  isValidProperty(key) {
    if (this.target[key] === void 0) {
      AnLog.warn(`\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u043E "${key}" \u043D\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0432 \u0446\u0435\u043B\u0435\u0432\u043E\u043C \u043E\u0431\u044A\u0435\u043A\u0442\u0435 \u0438 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0430\u043D\u0438\u043C\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u043E`);
      return false;
    }
    if (Array.isArray(this.target[key])) {
      AnLog.warn(`\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u043E "${key}" \u044F\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u043C \u0438 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0430\u043D\u0438\u043C\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u043E`);
      return false;
    }
    return true;
  }
  /**
   *    
   */
  get callbacks() {
    return this._callbacks;
  }
  /**
   *     `from`   .
   *        .
   */
  applyFromValues() {
    for (const key in this.startValues) {
      const startVal = this.startValues[key];
      this.target[key] = typeof startVal === "object" ? dataClone(startVal) : startVal;
    }
    return this;
  }
  /**
   *    
   * @returns    (  )
   */
  start() {
    if (this._running || !this.getUpdater()) return this;
    this._running = true;
    this.elapsedTime = 0;
    this.delayCounter = 0;
    this.repeatCount = 0;
    this.isReversing = false;
    if (this.delay === 0)
      this._callbacks.onStart?.(this);
    return this;
  }
  /**
   *    
   * @returns    (  )
   */
  pause() {
    if (!this._running || this._paused || !this.getUpdater()) return this;
    this._paused = true;
    this._callbacks.onPause?.(this);
    return this;
  }
  /**
   *    
   * @returns    (  )
   */
  resume() {
    if (!this._running || !this._paused || !this.getUpdater()) return this;
    this._paused = false;
    this._callbacks.onResume?.(this);
    return this;
  }
  /**
   *  
   * @returns    (  )
   */
  stop() {
    if (!this._running) return this;
    this._running = false;
    if (this.autoRemove)
      this.removeFromUpdater();
    return this;
  }
  /**
   *   ,   
   * @returns    (  )
   */
  finish() {
    if (!this._running) return this;
    this.elapsedTime = this.duration;
    this.delayCounter = this.delay;
    this.calcPropertyChanges(1);
    this._callbacks.onComplete?.(this);
    this.stop();
    return this;
  }
  // /**
  //  *     ,     
  //  * @param nextTween    
  //  * @returns    (  )
  //  */
  // public chain(nextTween: AnTween): this
  // {
  // 	this.nextTween = nextTween;
  // 	return this;
  // }
  /**
   *   ,   AnUpdater
   * @param dt ,     ( )
   */
  update(dt) {
    super.update(dt);
    if (!this._running || this._paused) return;
    if (this.target.destroyed) {
      AnLog.error(`AnTween: target[label:${this.target?.label} className:${className(this.target)}] \u0443\u043D\u0438\u0447\u0442\u043E\u0436\u0435\u043D, \u043D\u043E \u0442\u0432\u0438\u043D \u043D\u0435 \u043E\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D!`);
      this.terminate();
      return;
    }
    if (this.delayCounter < this.delay) {
      this.delayCounter += dt;
      if (this.delayCounter >= this.delay)
        this.callbacks.onStart?.(this);
      return;
    }
    this.elapsedTime += dt;
    const rawProgress = Math.min(this.elapsedTime / this.duration, 1);
    const easedProgress = this.easing(this.isReversing ? 1 - rawProgress : rawProgress);
    this.calcPropertyChanges(easedProgress);
    this._callbacks.onUpdate?.(this, easedProgress);
    if (rawProgress + this.tolerance >= 1) {
      if (!this.reverse)
        this.calcPropertyChanges(1);
      this.handleCompletion();
    }
  }
  /**       */
  applyValues(progress, target, key, start, end) {
    let value;
    if (typeof start === "number" && typeof end === "number") {
      if (key === "tint") {
        value = AnMath.lerpColor(start, end, progress);
      } else {
        value = start + (end - start) * progress;
        if (this.round) value = Math.round(value);
      }
    } else {
      value = progress >= 1 ? end : start;
    }
    target[key] = value;
  }
  /**     */
  calcPropertyChanges(progress) {
    for (const [key, end] of Object.entries(this.to)) {
      const start = this.startValues[key];
      if (typeof start === "object" && typeof end === "object") {
        for (const innerKey in end)
          if (innerKey in start)
            this.applyValues(progress, this.target[key], innerKey, start[innerKey], end[innerKey]);
        continue;
      }
      this.applyValues(progress, this.target, key, start, end);
    }
  }
  /**      */
  handleCompletion() {
    this._callbacks.onComplete?.(this);
    if (this.shouldRepeat()) {
      this.repeatCount++;
      this.elapsedTime = 0;
      this.isReversing = this.reverse ? !this.isReversing : false;
      this._callbacks.onRepeat?.(this, this.repeatCount);
    } else {
      this.stop();
    }
  }
  /** ,     */
  shouldRepeat() {
    return this.repeatCount < this.repeat || this.repeat === Infinity;
  }
  //    
  /**  true,    (     ) */
  get playing() {
    return !this._paused && this.progress < 1;
  }
  /**     (0-1) */
  get progress() {
    return Math.min(this.elapsedTime / this.duration, 1);
  }
  /**    */
  get running() {
    return this._running;
  }
  /**  true,      */
  get paused() {
    return this._paused;
  }
  /**     (0   ) */
  get currentRepeat() {
    return this.repeatCount;
  }
  /**       */
  terminate() {
    this.stop();
    if (!this.autoRemove)
      this.removeFromUpdater();
  }
};

// angine/src/menu/AnMenu.ts
init_define_AnParams();

// angine/src/ui/AnUIGroupElement.ts
init_define_AnParams();

// angine/src/ui/AnUIElement.ts
init_define_AnParams();

// angine/src/mixins/AnDestructibleMixin.ts
init_define_AnParams();
function AnDestructibleMixin(Base) {
  return class AnDestructible extends Base {
    constructor(...args) {
      super(...args);
      //    
      this.cleanupFuncs = null;
      //     
      this._destroyed = false;
    }
    /**
     * ,    
     */
    get isDestroyed() {
      return this._destroyed;
    }
    /**
     *    
     *      
     */
    terminate() {
      if (this._destroyed) {
        AnLog.warn(`\u041E\u0431\u044A\u0435\u043A\u0442 ${className(this)} \u0443\u0436\u0435 \u0431\u044B\u043B \u0443\u0434\u0430\u043B\u0435\u043D!`);
        return;
      }
      this._destroyed = true;
      if (this.cleanupFuncs !== null) {
        this.cleanupFuncs.forEach((func) => func());
        this.cleanupFuncs.length = 0;
      }
    }
    /**
     *     
     * @param cleanupFunc  
     */
    addToCleanup(cleanupFunc) {
      if (this.cleanupFuncs === null)
        this.cleanupFuncs = [];
      addUniqueValue(this.cleanupFuncs, cleanupFunc);
    }
    // /**
    //  *     
    //  * @param id ID 
    //  */
    // public removeFromCleanup(id: symbol): void
    // {
    // 	//    ,    
    // 	//         
    // }
  };
}

// angine/src/ui/AnAnchor.ts
init_define_AnParams();
var AnAnchor = {
  // 
  TopLeft: new lib_exports.Point(0, 0),
  TopRight: new lib_exports.Point(1, 0),
  BottomLeft: new lib_exports.Point(0, 1),
  BottomRight: new lib_exports.Point(1, 1),
  // 
  Center: new lib_exports.Point(0.5, 0.5),
  TopCenter: new lib_exports.Point(0.5, 0),
  BottomCenter: new lib_exports.Point(0.5, 1),
  LeftCenter: new lib_exports.Point(0, 0.5),
  RightCenter: new lib_exports.Point(1, 0.5),
  //   
  MiddleTop: new lib_exports.Point(0.5, 0),
  //   TopCenter
  MiddleBottom: new lib_exports.Point(0.5, 1),
  //   BottomCenter
  MiddleLeft: new lib_exports.Point(0, 0.5),
  //   LeftCenter
  MiddleRight: new lib_exports.Point(1, 0.5)
  //   RightCenter
};

// angine/src/ui/AnUIElement.ts
var AnUIElement = class extends enhance(lib_exports.Container).with(AnDestructibleMixin) {
  constructor(config2) {
    super();
    this._scaledWidth = null;
    this._scaledHeight = null;
    this._realWidth = null;
    this._realHeight = null;
    //    anchor,    
    this._anchor = AnAnchor.TopLeft;
    //        
    this.controlsRouter = "";
    this.resizeStrategy = null;
    this.defaultResizeStrategy = null;
    if (config2) {
      if (config2.anchor !== void 0) this._anchor = config2.anchor;
      if (config2.controlsRouter !== void 0) this.controlsRouter = config2.controlsRouter;
    }
    super.addChild(this.anchorContainer = new lib_exports.Container());
    this.alignGraphicsToAnchor();
  }
  addGraphics(graphics, at) {
    if (at !== void 0) {
      this.anchorContainer.addChildAt(graphics, at);
    } else
      this.anchorContainer.addChild(graphics);
    this.alignGraphicsToAnchor();
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    this._anchor = value;
    this.alignGraphicsToAnchor();
  }
  alignGraphicsToAnchor() {
    if (this._scaledWidth !== null && this._scaledHeight !== null) {
      this.anchorContainer.position.set(
        -1 * this.scaledWidth * this.anchor.x,
        -1 * this.scaledHeight * this.anchor.y
      );
    } else {
      this.anchorContainer.position.set(
        -1 * this.width * this.anchor.x,
        -1 * this.height * this.anchor.y
      );
    }
  }
  //      
  configResizeStrategy(resizeStrategy) {
    this.assignResizeStrategy(resizeStrategy === void 0 || resizeStrategy === null ? null : resizeStrategy === Default ? this.defaultResizeStrategy : resizeStrategy);
  }
  assignResizeStrategy(resizeStrategy) {
    this.resizeStrategy = resizeStrategy;
  }
  clearResizeStrategy() {
    this.assignResizeStrategy(null);
  }
  setScaledSize(scaledWidth, scaledHeight) {
    this.scaledWidth = scaledWidth;
    this.scaledHeight = scaledHeight;
  }
  get scaledWidth() {
    return this._scaledWidth ?? this.anchorContainer.width;
  }
  get scaledHeight() {
    return this._scaledHeight ?? this.anchorContainer.height;
  }
  set scaledWidth(width) {
    this._scaledWidth = width;
  }
  set scaledHeight(height) {
    this._scaledHeight = height;
  }
  get realHeight() {
    return this._realHeight ?? this.anchorContainer.height;
  }
  get realWidth() {
    return this._realWidth ?? this.anchorContainer.width;
  }
  get realSizeRatio() {
    return this.realWidth / this.realHeight;
  }
  set realHeight(height) {
    this._realHeight = height;
  }
  set realWidth(width) {
    this._realWidth = width;
  }
  /**
   *      anchor
   * @example (0.5, 0.5)  left = x - width/2
   */
  get left() {
    return this.x - this._anchor.x * this.scaledWidth;
  }
  /**
   *      anchor
   * @example (0.5, 0.5)  right = x + width/2
   */
  get right() {
    return this.x + (1 - this._anchor.x) * this.scaledWidth;
  }
  /**
   *      anchor
   * @example (0.5, 0.5)  top = y - height/2
   */
  get top() {
    return this.y - this._anchor.y * this.scaledHeight;
  }
  /**
   *      anchor
   * @example (0.5, 0.5)  bottom = y + height/2
   */
  get bottom() {
    return this.y + (1 - this._anchor.y) * this.scaledHeight;
  }
  /**
   *     
   */
  get bounds() {
    return {
      left: this.left,
      right: this.right,
      top: this.top,
      bottom: this.bottom
    };
  }
  /**
   * ,    (x, y)    
   * @param x -  X  (  )
   * @param y -  Y  (  )
   * @returns true,    
   */
  isPointInside(point) {
    const localPoint = this.parent.toLocal(point);
    return localPoint.x >= this.left && localPoint.x <= this.right && localPoint.y >= this.top && localPoint.y <= this.bottom;
  }
  applyResizeStrategy() {
    if (this.resizeStrategy) {
      this.resizeStrategy();
      this.alignGraphicsToAnchor();
    }
  }
  applyDefaultResizeStrategy() {
    if (this.defaultResizeStrategy) {
      this.defaultResizeStrategy();
      this.alignGraphicsToAnchor();
    }
  }
  terminate() {
    super.terminate();
    safeDestroy(this);
  }
};

// angine/src/ui/AnUIGroupElement.ts
var AnUIGroupElement = class extends AnUIElement {
  //TODO: aligment options?
  constructor(config2) {
    super(config2);
    this.elements = {};
    this.elementsOrder = [];
  }
  //     
  addUIElement(arg1, arg2) {
    let name;
    let element;
    if (typeof arg1 === "string") {
      name = arg1;
      element = arg2;
    } else {
      element = arg1;
    }
    if (name) {
      this.elements[name] = element;
      if (true) element.label = name;
    } else {
      if (true) element.label = "unnamed ui element";
    }
    this.elementsOrder.push(element);
    this.addGraphics(element);
    return element;
  }
  /**
   *    removeUIElement
   */
  removeUIElement(arg) {
    let element;
    if (typeof arg === "string") {
      const name = arg;
      const elem = this.elements[name];
      if (!elem) {
        AnLog.warn(`\u041F\u043E\u043F\u044B\u0442\u043A\u0430 \u0443\u0434\u0430\u043B\u0438\u0442\u044C \u043D\u0435\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0439 \u044D\u043B\u0435\u043C\u0435\u043D\u0442: ${name}`);
        return null;
      }
      element = elem;
      delete this.elements[name];
    } else
      element = arg;
    removeByValue(this.elementsOrder, element);
    this.removeChild(element);
    return element;
  }
  /**
   *    terminateUIElement
   */
  terminateUIElement(arg) {
    const element = typeof arg === "string" ? this.removeUIElement(arg) : this.removeUIElement(arg);
    element?.terminate();
  }
  /**
   *    
   */
  cleanUIGroup() {
    this.elements = {};
    this.elementsOrder.length = 0;
  }
  /**
   *   
   */
  terminate() {
    for (const element of this.elementsOrder)
      element.terminate();
    this.cleanUIGroup();
    super.terminate();
  }
  /**
   *  applyResizeStrategy,     
   */
  applyResizeStrategy() {
    super.applyResizeStrategy();
    for (const element of this.elementsOrder)
      element.applyResizeStrategy();
  }
};

// angine/src/menu/AnMenu.ts
var AnMenu = class extends enhance(AnUIGroupElement).with(AnUpdatableMixin) {
  //        
  constructor(config2) {
    super(config2);
    this.localUpdater = new AnUpdater();
    this.controlsRouter = className(this) + ":";
  }
  addUIElement(arg1, arg2) {
    let name;
    let element;
    if (typeof arg1 === "string") {
      name = arg1;
      element = arg2;
      super.addUIElement(name, element);
    } else {
      element = arg1;
      super.addUIElement(element);
    }
    if (isAnUpdatable(element)) {
      const updatable = element;
      updatable.addToUpdater(this.localUpdater);
    }
    return element;
  }
  removeUIElement(arg) {
    const element = typeof arg === "string" ? super.removeUIElement(arg) : super.removeUIElement(arg);
    if (element) {
      if (isAnUpdatable(element)) {
        const updatable = element;
        updatable.removeFromUpdater();
      }
      removeAllTweensByTarget(this.localUpdater, element);
    }
    return element;
  }
  // public override terminateUIElement(name: string): void;
  // public override terminateUIElement<T extends AnUIElement>(element: T): void;
  // public override terminateUIElement<T extends AnUIElement>(arg: string | T): void
  // {
  // 	let element: T;
  // 	if (typeof arg === "string")
  // 	{
  // 		const name = arg;
  // 		const elem = this.elements[name];
  // 		if (!elem)
  // 		{
  // 			AnLog.warn(`   : ${name}`);
  // 			return;
  // 		}
  // 		element = elem as T;
  // 	}
  // 	else
  // 		element = arg;
  // 	removeAllTweensByTarget(this.localUpdater, element);
  // 	super.terminateUIElement(element);
  // }
  /**      */
  createUI() {
  }
  //    
  createEntranceTweens() {
    const tweens = [];
    return tweens;
  }
  //     
  createExitTweens() {
    const tweens = [];
    return tweens;
  }
  /**     ,   
   *      */
  resizeUI() {
    finishAllTweensByTag(this.localUpdater, "transition");
    super.applyResizeStrategy();
  }
  /**     ,    */
  show() {
    AnApp.self.registerMenu(this);
    this.addToCleanup(this.addToUpdater(AnCore.updater));
    this.addToCleanup(AnEvents.on("viewport:resize", () => this.resizeUI()).unsub);
    this.createEntranceTweens().forEach(
      (tween) => {
        tween.addTag("transition");
        tween.addToUpdater(this.localUpdater);
        tween.start();
      }
    );
    AnRender2D.addToFront(this);
  }
  /**   ,    */
  hide(terminateCallback) {
    AnApp.self.unregisterMenu(this);
    if (terminateCallback)
      this.addToCleanup(terminateCallback);
    finishAllTweensByTag(this.localUpdater, "transition");
    const exitTweens = this.createExitTweens();
    if (exitTweens.length === 0) {
      this.terminate();
      return;
    }
    exitTweens.forEach((tween) => {
      tween.addTag("transition");
      if (tween.hasTag("terminate"))
        tween.callbacks.onComplete = () => this.terminate();
      tween.addToUpdater(this.localUpdater);
      tween.start();
    });
  }
  terminate() {
    super.terminate();
    safeDestroy(this);
  }
  update(dt) {
    super.update(dt);
    this.localUpdater.update(dt);
  }
};

// angine/src/utils/AnHelpers.ts
function enhance(baseClass) {
  return {
    /**
     *     
     */
    with: (...mixins) => {
      let currentClass = baseClass;
      for (const mixin of mixins) {
        currentClass = mixin(currentClass);
      }
      return currentClass;
    }
  };
}
function className(object) {
  return object.constructor.name;
}
function capitalize(str) {
  if (!str) return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function struct(object) {
  return JSON.stringify(object, void 0, 3);
}
function addUniqueValue(array, item) {
  if (!array.includes(item))
    array.push(item);
  else
    AnLog.error(`\u041E\u0431\u044A\u0435\u043A\u0442 ${className(item)} \u0443\u0436\u0435 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D \u0432 \u043C\u0430\u0441\u0441\u0438\u0432 ${array}`);
}
function removeByValue(array, value) {
  const index = array.indexOf(value);
  if (index !== -1)
    array.splice(index, 1);
  return array;
}
function shuffle(array, rnd) {
  for (let i3 = array.length - 1; i3 > 0; i3--) {
    const j2 = Math.floor((rnd ? rnd.seed_float(0, 1) : Math.random()) * (i3 + 1));
    [array[i3], array[j2]] = [array[j2], array[i3]];
  }
  return array;
}
function getNextElement(array, currentElement) {
  const currentIndex = array.indexOf(currentElement);
  if (currentIndex === -1) {
    throw new Error("\u042D\u043B\u0435\u043C\u0435\u043D\u0442 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D \u0432 \u043C\u0430\u0441\u0441\u0438\u0432\u0435");
  }
  const nextIndex = (currentIndex + 1) % array.length;
  return array[nextIndex];
}
function openURL(url, newTab = true) {
  window.open(url, newTab ? "_blank" : "_self");
}
function getCurrentOSLanguage() {
  const browserLanguage = navigator.language || navigator.userLanguage;
  return browserLanguage.split("-")[0].toLowerCase();
}
function dataClone(source9) {
  const target = {};
  const propertyNames = [...Object.getOwnPropertyNames(Object.getPrototypeOf(source9)), ...Object.getOwnPropertyNames(source9)];
  for (const i3 in propertyNames) {
    const key = propertyNames[i3];
    if (typeof source9[key] !== "function" && typeof source9[key] !== "object") {
      target[key] = source9[key];
    }
  }
  return target;
}
function uptime() {
  return performance.now() / 1e3;
}
function runAfter(delay2, callback) {
  return setTimeout(callback, delay2 * 1e3);
}
function runAfterSafe(delay2, destructible, callback) {
  return setTimeout(() => {
    if (!destructible.isDestroyed) callback();
  }, delay2 * 1e3);
}
function notImplemented(info) {
  const message = info ?? "\u0424\u0443\u043D\u043A\u0446\u0438\u044F \u043D\u0435 \u0440\u0435\u0430\u043B\u0438\u0437\u043E\u0432\u0430\u043D\u0430";
  if (true) {
    const stack = new Error().stack;
    const callerLine = stack?.split("\n")[2]?.trim() || "<\u043D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u044B\u0439 \u0432\u044B\u0437\u043E\u0432>";
    throw new Error(`NotImplementedError: ${message} (${callerLine})`);
  } else
    AnLog.error(message);
}
function removeAllTweensByTarget(updater, target) {
  updater.forEach(
    (tween) => {
      if (tween instanceof AnTween && tween.target === target)
        tween.terminate();
    }
  );
}
function finishAllTweensByTag(updater, tag, andRemove = true) {
  updater.forEach(
    (tween) => {
      if (tween instanceof AnTween && tween.hasTag(tag)) {
        tween.finish();
        if (!tween.autoRemove && andRemove)
          tween.removeFromUpdater();
      }
    }
  );
}
function calculateDialogDisplayTime(text, wordsPerMinute = 200, baseTime = 2, complexity = 1) {
  const words = text.trim().split(/\s+/).length;
  const readingTime = words / wordsPerMinute * 60;
  const adjustedTime = readingTime * complexity;
  return Math.max(baseTime, adjustedTime);
}
function getSplitComplementaryColors(color) {
  const r2 = color >> 16 & 255;
  const g2 = color >> 8 & 255;
  const b3 = color & 255;
  const hsl2 = rgbToHsl(r2, g2, b3);
  const h2 = hsl2.h;
  const s2 = hsl2.s;
  const l2 = hsl2.l;
  const hue1 = (h2 + 150) % 360;
  const hue2 = (h2 - 150 + 360) % 360;
  const rgb1 = hslToRgb(hue1, s2, l2);
  const rgb2 = hslToRgb(hue2, s2, l2);
  const complementaryColor1 = rgb1.r << 16 | rgb1.g << 8 | rgb1.b;
  const complementaryColor2 = rgb2.r << 16 | rgb2.g << 8 | rgb2.b;
  return { color1: complementaryColor1, color2: complementaryColor2 };
}
function rgbToHsl(r2, g2, b3) {
  r2 /= 255;
  g2 /= 255;
  b3 /= 255;
  const max2 = Math.max(r2, g2, b3);
  const min = Math.min(r2, g2, b3);
  let h2 = 0, s2, l2 = (max2 + min) / 2;
  if (max2 === min) {
    h2 = s2 = 0;
  } else {
    const d2 = max2 - min;
    s2 = l2 > 0.5 ? d2 / (2 - max2 - min) : d2 / (max2 + min);
    switch (max2) {
      case r2:
        h2 = (g2 - b3) / d2 + (g2 < b3 ? 6 : 0);
        break;
      case g2:
        h2 = (b3 - r2) / d2 + 2;
        break;
      case b3:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 *= 60;
  }
  return { h: h2, s: s2, l: l2 };
}
function hslToRgb(h2, s2, l2) {
  let r2, g2, b3;
  if (s2 === 0) {
    r2 = g2 = b3 = l2;
  } else {
    const hue2rgb = (p3, q2, t2) => {
      if (t2 < 0) t2 += 1;
      if (t2 > 1) t2 -= 1;
      if (t2 < 1 / 6) return p3 + (q2 - p3) * 6 * t2;
      if (t2 < 1 / 2) return q2;
      if (t2 < 2 / 3) return p3 + (q2 - p3) * (2 / 3 - t2) * 6;
      return p3;
    };
    const q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    const p2 = 2 * l2 - q;
    r2 = hue2rgb(p2, q, h2 / 360 + 1 / 3);
    g2 = hue2rgb(p2, q, h2 / 360);
    b3 = hue2rgb(p2, q, h2 / 360 - 1 / 3);
  }
  return {
    r: Math.round(r2 * 255),
    g: Math.round(g2 * 255),
    b: Math.round(b3 * 255)
  };
}
function safeDestroyFunc4(child) {
  return safeDestroy.bind(null, child);
}
function safeDestroy(object) {
  object.removeFromParent?.();
  object.removeFromUpdater?.();
  object.destroy?.();
}
function getSpriteXCentralDistribution(i3, spriteWidth, baseWidth, count2, spacing = 0) {
  if (spacing < 0) {
    const effectiveSpacing = (baseWidth - spriteWidth * count2) / (count2 - 1);
    return i3 * (spriteWidth + effectiveSpacing) + spriteWidth * 0.5;
  }
  const centerX = baseWidth * 0.5;
  const totalWidth = count2 * spriteWidth + (count2 - 1) * spacing;
  const offset = centerX - totalWidth * 0.5;
  return offset + (i3 + 0.5) * spriteWidth + i3 * spacing;
}

// angine/src/utils/AnUpdater.ts
var AnUpdater = class {
  constructor() {
    this.updatables = [];
  }
  /**
   *  ()   
   * @param items - (),   AnUpdatableInterface
   */
  add(items) {
    if (Array.isArray(items))
      items.forEach((updatable) => addUniqueValue(this.updatables, updatable));
    else
      addUniqueValue(this.updatables, items);
  }
  /**
   *  ()   
   * @param items - ()  
   */
  remove(items) {
    if (Array.isArray(items)) {
      items.reduceRight((_, updatable) => {
        removeByValue(this.updatables, updatable);
        return _;
      }, null);
    } else
      removeByValue(this.updatables, items);
  }
  /**
   *   
   * @param dt -    
   */
  update(dt) {
    for (let i3 = 0; i3 < this.updatables.length; ++i3)
      this.updatables[i3].update(dt);
  }
  /**
   *        
   * (         !)
   */
  forEach(callback) {
    for (let i3 = this.updatables.length - 1; i3 >= 0; i3--)
      callback(this.updatables[i3]);
  }
  /**
   *    
   */
  get count() {
    return this.updatables.length;
  }
  /**
   *    
   */
  clear() {
    this.updatables = [];
  }
};

// angine/src/core/AnCore.ts
var AnCore = class _AnCore {
  constructor() {
  }
  static get fullGameVersion() {
    return `${"1.0.0"} [${"playdeck"}]`;
  }
  static async init() {
    AnLog.info(`--- \u0421\u0442\u0430\u0440\u0442 AnGINE \u0432\u0435\u0440\u0441\u0438\u044F ${"0.1.0"} ${false ? "prod" : "dev"}  ---`);
    await AnViewport.init();
    _AnCore.updater = new AnUpdater();
    AnLog.info(`\u0412\u0435\u0440\u0441\u0438\u044F \u0438\u0433\u0440\u044B: ${this.fullGameVersion}`);
    AnMainLoop.init(
      (dt) => _AnCore.update(dt),
      // 
      () => _AnCore.render()
      // 
    );
    if (false) {
      AnRender3D.init();
    }
    await AnRender2D.init();
    _AnCore.setupEventHandlers();
    AnMainLoop.start();
  }
  static terminate() {
    AnMainLoop.stop();
    if (false) {
      AnRender3D.terminate();
    }
    AnRender2D.terminate();
    AnLog.info(`--- AnGINE \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D  ---`);
  }
  static setupEventHandlers() {
    const resize = (width, height) => {
      AnViewport.resize(width, height);
      if (false) {
        AnRender3D.resize(width, height);
      }
      AnRender2D.resize(width, height);
    };
    resize(window.innerWidth, window.innerHeight);
    window.addEventListener("resize", () => {
      resize(window.innerWidth, window.innerHeight);
    });
  }
  static update(dt) {
    _AnCore.updater.update(dt);
  }
  static render() {
    if (false) {
      AnRender3D.render();
    }
    AnRender2D.render();
  }
};

// angine/src/input/AnControls.ts
init_define_AnParams();

// angine/src/input/AnControlsEnums.ts
init_define_AnParams();

// angine/src/input/AnControls.ts
var _AnControls = class _AnControls {
  constructor() {
  }
  static init() {
    window.addEventListener("keydown", (e2) => {
      if (["ArrowUp", "ArrowDown", " "].includes(e2.key))
        e2.preventDefault();
      _AnControls.handleKeyboardEvent("controls:keydown" /* KeyboardDown */, e2);
    }, { passive: false });
    window.addEventListener("keyup", (e2) => _AnControls.handleKeyboardEvent("controls:keyup" /* KeyboardUp */, e2));
    window.addEventListener("pointerdown", (e2) => _AnControls.handlePointerEvent("controls:pointerdown" /* PointerDown */, e2));
    window.addEventListener("pointerup", (e2) => _AnControls.handlePointerEvent("controls:pointerup" /* PointerUp */, e2));
    window.addEventListener("pointermove", (e2) => _AnControls.handlePointerEvent("controls:pointermove" /* PointerMove */, e2));
    window.addEventListener("pointercancel", (e2) => _AnControls.handlePointerEvent("controls:pointercancel" /* PointerCancel */, e2));
    window.addEventListener("wheel", (e2) => {
      e2.preventDefault();
      _AnControls.handleMouseEvent("controls:mouse:wheel" /* MouseWheel */, e2);
    }, { passive: false });
    window.addEventListener("gamepadconnected", (e2) => _AnControls.handleGamepadEvent("controls:gamepadconnected" /* GamepadConnected */, e2));
    window.addEventListener("gamepaddisconnected", (e2) => _AnControls.handleGamepadEvent("controls:gamepaddisconnected" /* GamepadDisconnected */, e2));
    window.addEventListener("contextmenu", (e2) => e2.preventDefault(), { passive: false });
  }
  static handleKeyboardEvent(type, event) {
    switch (type) {
      case "controls:keydown" /* KeyboardDown */:
        this._key.add(event.code);
        this._keyNew.add(event.code);
        break;
      case "controls:keyup" /* KeyboardUp */:
        this._key.delete(event.code);
        break;
    }
    AnEvents.emit(type, event);
  }
  static handlePointerEvent(type, event) {
    switch (type) {
      case "controls:pointermove" /* PointerMove */:
        this._pointerPos.x = event.x;
        this._pointerPos.y = event.y;
        break;
      case "controls:pointerdown" /* PointerDown */:
        this._pointerClick = true;
        break;
      case "controls:pointerup" /* PointerUp */:
        this._pointerClick = false;
        break;
      case "controls:pointercancel" /* PointerCancel */:
        break;
    }
    AnEvents.emit(type, event);
  }
  static handleMouseEvent(type, event) {
    switch (type) {
      // case AnControlsEvent.MouseMove:
      // 	this._mousePos.x = event.x;
      // 	this._mousePos.y = event.y;
      // 	break;
      // case AnControlsEvent.MouseDown:
      // 	this._mouseButtons.add(event.button); //  - 0  - 2  - 1
      // 	break;
      // case AnControlsEvent.MouseUp:
      // 	this._mouseButtons.delete(event.button); //  - 0  - 2  - 1
      // 	break;
      case "controls:mouse:wheel" /* MouseWheel */:
        this._mouseWheel = event.deltaY;
        break;
    }
    AnEvents.emit(type, event);
  }
  // private static handleTouchEvent(type: AnControlsEvent, event: TouchEvent)
  // {
  // }
  static handleGamepadEvent(type, event) {
  }
  static vibrate(pattern = 20) {
    navigator.vibrate?.(pattern);
  }
  //    
  static get isTouchEnabled() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0;
  }
  static get pointerX() {
    return this._pointerPos.x;
  }
  static get pointerY() {
    return this._pointerPos.y;
  }
  static update() {
    this._keyNew.clear();
  }
};
_AnControls._pointerPos = { x: 0, y: 0 };
//private static _mouseButtons = new Set<AnMouseButton>();
_AnControls._mouseWheel = 0;
_AnControls._key = /* @__PURE__ */ new Set();
_AnControls._keyNew = /* @__PURE__ */ new Set();
var AnControls = _AnControls;

// angine/src/app/AnPreloader.ts
init_define_AnParams();

// angine/src/assets/AnAssets.ts
init_define_AnParams();

// angine/src/utils/AnLang.ts
init_define_AnParams();
var AnLang = class {
  //    
  constructor() {
  }
  static async loadLanguages(xmlLangsData) {
    try {
      await Promise.all(
        xmlLangsData.map((xml) => this.parseLanguage(xml))
      );
    } catch (error) {
      console.error("Failed to load languages:", error);
      throw new Error("Language loading failed");
    }
    if (!this.eventSubscribed) {
      this.eventSubscribed = true;
      AnEvents.on("storage:language:update", (e2) => {
        this.currentLanguage = e2.data.value;
      });
    }
  }
  /**
   *  XML     .
   * 
   * @param xml - XML-  
   * @throws Error :
   *   - XML 
   *   -    (name/code)
   *   -     
   */
  static async parseLanguage(xml) {
    try {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xml, "text/xml");
      if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
        throw new Error("Invalid XML format");
      }
      const langData = xmlDoc.documentElement;
      const code = langData.getAttribute("code");
      const name = langData.getAttribute("name");
      if (!code || !name) {
        throw new Error("Missing required attributes (code/name) in langData");
      }
      let strings = {};
      let inited = false;
      const textNodes = langData.getElementsByTagName("text");
      for (let i3 = 0; i3 < textNodes.length; i3++) {
        const node = textNodes[i3];
        const id = node.getAttribute("id");
        const text = node.textContent;
        if (id && text) {
          strings[id] = text;
          inited = true;
        }
      }
      if (!inited) {
        throw new Error("No localized strings found");
      }
      this._loadedLanguages[code] = {
        strings,
        name,
        code
      };
    } catch (error) {
      console.error("Failed to parse language XML:", error);
      throw error;
    }
  }
  /**
   *     .
   * 
   * @param id -   ( 'GameTitle')
   * @returns     :
   *   - [LANG_NOT_LOADED:...]    
   *   - [MISSING:...]    
   * 
   * @example
   * AnLang.getString('GameTitle'); // "SUPER UTILIZER"
   */
  static get(id) {
    const lang = this._loadedLanguages[this._currentLanguage];
    if (!lang) {
      console.warn(`Language '${this._currentLanguage}' not loaded`);
      return `[LANG_NOT_LOADED:${id}]`;
    }
    return (lang.strings[id] ?? `[MISSING:${id}]`).replace(
      /[]/g,
      (match) => {
        switch (match) {
          case "\u0451":
            return "\u0435";
          default:
            return match;
        }
      }
    ).replace(/\\n/g, "\n") ?? `[MISSING:${id}]`;
  }
  /**
   * /   .
   *   ,    .
   * 
   * @throws Error     
   */
  static get currentLanguage() {
    return this._currentLanguage;
  }
  static set currentLanguage(lang) {
    if (this._loadedLanguages[lang] === void 0) {
      AnLog.error(`\u042F\u0437\u044B\u043A '${lang}' \u043D\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D. \u0421\u043D\u0430\u0447\u0430\u043B\u0430 \u0432\u044B\u0437\u043E\u0432\u0438\u0442\u0435 loadLanguages()`);
      return;
    }
    if (true)
      AnLog.debug(`\u041C\u0435\u043D\u044F\u0435\u043C \u044F\u0437\u044B\u043A \u043D\u0430 ${lang}`);
    this._currentLanguage = lang;
    AnEvents.emit("settings:changed:lang", lang);
    AnViewport.invalidate();
  }
  /**
   *    (  ).
   * 
   * @param code -   ( 'en')
   * @returns   name  code  undefined    
   * 
   * @example
   * const meta = AnLang.getLanguageMeta('en');
   * console.log(meta?.name); // "English"
   */
  static getLanguageMeta(code) {
    const lang = this._loadedLanguages[code];
    return lang ? {
      name: lang.name,
      code: lang.code
    } : void 0;
  }
  /**
   *     .
   * 
   * @returns   ( ['en', 'ru'])
   */
  static get loadedLanguages() {
    return Object.keys(this._loadedLanguages);
  }
  /**
   * ,    .
   * 
   * @param code -    
   * @returns true   
   */
  static hasLanguage(code) {
    return this._loadedLanguages[code] !== void 0;
  }
};
/**
 *   .
 *  -   ( 'en', 'ru')
 *  -  :
 *   - strings: Map   
 *   - name:   ( "English")
 *   - code:   (  )
 */
AnLang._loadedLanguages = {};
/**
 *    (   ).
 *   'en' - .
 */
AnLang._currentLanguage = "en";
/**
 *    .
 *   XML-   .
 * 
 * @param xmlLangsData -  XML-  :
 *   `<langData name="..." code="..."><text id="...">...</text>...</langData>`
 * @throws Error      XML
 * 
 * @example
 * await AnLang.loadLanguages([enXml, ruXml]);
 */
AnLang.eventSubscribed = false;

// angine/src/assets/AnAssets.ts
var _AnAssets = class _AnAssets {
  /**
   *        
   * @param bundle -   
   * @param include -    ('all'   )
   * @param exclude -   
   * @param callbacks -      
   */
  // TODO:     
  static async load(bundle, include = "all", exclude = [], callbacks) {
    AnLog.info(`\u041D\u0430\u0447\u0430\u043B\u043E \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0430\u0441\u0441\u0435\u0442\u043E\u0432 \u0438\u0437 \u0431\u0430\u043D\u0434\u043B\u0430: ${bundle.metadata.name}`);
    try {
      const files = bundle.listFiles().filter(
        (path2) => (include === "all" || include.includes(path2)) && !exclude.includes(path2)
      );
      callbacks?.onStart?.(files.length);
      let successCount = 0;
      let errorCount = 0;
      for (const path2 of files) {
        try {
          AnLog.info(`\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u043C: ${path2}`);
          const { type, engine, ext } = this.parseAssetType(path2);
          const metadata = {
            path: path2,
            type,
            engine,
            ext,
            data: null
          };
          const blob = bundle.getFile(path2);
          if (!blob) throw new Error("\u0424\u0430\u0439\u043B \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D \u0432 \u0431\u0430\u043D\u0434\u043B\u0435");
          metadata.data = await this.loadAsset(blob, type, engine, ext);
          this.assets[path2] = metadata;
          successCount++;
          callbacks?.onAssetLoaded?.(path2, metadata);
        } catch (error) {
          errorCount++;
          const err2 = error;
          AnLog.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 ${path2}: ${err2.message}`);
          callbacks?.onAssetError?.(path2, err2);
        }
      }
      await _AnAssets.installLangs();
      await _AnAssets.installFonts();
      await _AnAssets.makeAtlases();
      AnLog.info(`\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u0430\u0441\u0441\u0435\u0442\u043E\u0432 \u0438\u0437 \u0431\u0430\u043D\u0434\u043B\u0430 ${bundle.metadata.name} \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u0430. \u0423\u0441\u043F\u0435\u0448\u043D\u043E: ${successCount}, \u041E\u0448\u0438\u0431\u043E\u043A: ${errorCount}`);
      callbacks?.onComplete?.(successCount, errorCount);
    } catch (error) {
      const err2 = error;
      AnLog.error(`\u041A\u0440\u0438\u0442\u0438\u0447\u0435\u0441\u043A\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438: ${err2.message}`);
    }
  }
  /**
   *   
   */
  static async installLangs() {
    for (const path2 in this.assets) {
      const asset = this.assets[path2];
      if (asset && asset.type === "lang" && asset.engine === "common") {
        try {
          if (asset.ext === "xml") {
            const xmlText = asset.data;
            AnLang.loadLanguages([xmlText]);
            AnLog.info(`\u042F\u0437\u044B\u043A \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D: ${path2}`);
          } else {
            throw "\u0434\u0430\u043D\u043D\u044B\u0439 \u0442\u0438\u043F \u044F\u0437\u044B\u043A\u043E\u0432 \u043D\u0430 \u0434\u0430\u043D\u043D\u044B\u0439 \u043C\u043E\u043C\u0435\u043D\u0442 \u043D\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0438\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F";
          }
        } catch (error) {
          const err2 = error;
          AnLog.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043A\u0438 \u044F\u0437\u044B\u043A\u0430 ${path2}: ${err2.message}`);
        }
      }
    }
  }
  /**
   *    ,    
   *   
   */
  static async installFonts() {
    for (const path2 in this.assets) {
      const asset = this.assets[path2];
      if (asset && asset.type === "font" && asset.engine === "pixi") {
        let getFaceNameAndTexturePathFromXML2 = function(fntText) {
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(fntText, "text/xml");
          return [xmlDoc.querySelector("info")?.getAttribute("face") || null, xmlDoc.querySelector("page")?.getAttribute("file") || null];
        };
        var getFaceNameAndTexturePathFromXML = getFaceNameAndTexturePathFromXML2;
        try {
          if (asset.ext === "xml") {
            const fontXMLText = await asset.data.text();
            const fontData = lib_exports.bitmapFontXMLStringParser.parse(fontXMLText);
            const [faceName, texturePath] = getFaceNameAndTexturePathFromXML2(fontXMLText);
            const key = faceName + "-bitmap";
            if (lib_exports.Cache.has(key))
              continue;
            if (!texturePath) {
              AnLog.error(`\u041D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D \u043F\u0443\u0442\u044C \u043A \u0442\u0435\u043A\u0441\u0442\u0443\u0440\u0435 \u0432 .fnt \u0444\u0430\u0439\u043B\u0435: ${path2}`);
              continue;
            }
            const texture = this.get(texturePath);
            texture.source.scaleMode = "linear";
            texture.source.lodMaxClamp = 1.6;
            texture.source.antialias = true;
            texture.source.autoGenerateMipmaps = true;
            if (!texture) {
              AnLog.error(`\u0422\u0435\u043A\u0441\u0442\u0443\u0440\u0430 \u0434\u043B\u044F \u0448\u0440\u0438\u0444\u0442\u0430 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u0430: ${texturePath}`);
              continue;
            }
            const font = new lib_exports.BitmapFont({ data: fontData, textures: [texture] });
            lib_exports.Cache.set(key, font);
            AnLog.info(`\u0428\u0440\u0438\u0444\u0442 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D: ${path2}`);
          } else {
            throw "\u0434\u0430\u043D\u043D\u044B\u0439 \u0442\u0438\u043F \u0448\u0440\u0438\u0444\u0442\u043E\u0432 \u043D\u0430 \u0434\u0430\u043D\u043D\u044B\u0439 \u043C\u043E\u043C\u0435\u043D\u0442 \u043D\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0438\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F";
          }
        } catch (error) {
          const err2 = error;
          AnLog.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043A\u0438 \u0448\u0440\u0438\u0444\u0442\u0430 ${path2}: ${err2.message}`);
        }
      }
    }
  }
  /**
   *    
   */
  static async makeAtlases() {
    for (const path2 in this.assets) {
      const asset = this.assets[path2];
      if (asset.type !== "ss") continue;
      try {
        switch (asset.engine) {
          case "pixi":
            if (asset.ext === "json") {
              const jsonBlob = asset.data;
              const jsonText = await jsonBlob.text();
              const json = JSON.parse(jsonText);
              const texturePath = json.meta.image;
              const textureAsset = this.assets[texturePath];
              if (!textureAsset || textureAsset.type !== "tex" || textureAsset.engine !== "pixi") {
                throw new Error(`\u0422\u0435\u043A\u0441\u0442\u0443\u0440\u0430 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u0430: ${texturePath}`);
              }
              const texture = textureAsset.data;
              const spritesheet = new lib_exports.Spritesheet(texture, json);
              await spritesheet.parse();
              const atlasPath = path2.replace(".pixi.json", ".pixi.atlas");
              const metadata = {
                path: atlasPath,
                type: asset.type,
                engine: asset.engine,
                ext: "atlas",
                data: spritesheet
              };
              this.assets[atlasPath] = metadata;
              AnLog.info(`\u0410\u0442\u043B\u0430\u0441 \u0441\u043E\u0437\u0434\u0430\u043D: ${atlasPath}`);
            }
            break;
          //       
          default:
            AnLog.error(`\u0414\u0432\u0438\u0436\u043E\u043A ${asset.engine} \u0434\u043B\u044F \u0430\u0442\u043B\u0430\u0441\u0430 \u043D\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F`);
        }
      } catch (error) {
        const err2 = error;
        AnLog.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u044F \u0430\u0442\u043B\u0430\u0441\u0430 ${path2}: ${err2.message}`);
      }
    }
  }
  /**
   *     
   */
  static get(path2) {
    const asset = this.assets[path2];
    if (!asset) AnLog.warn(`\u0410\u0441\u0441\u0435\u0442 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D: ${path2}`);
    return asset?.data;
  }
  /**
   *    
   */
  static getFont(font) {
    const cachedFont = lib_exports.Cache.get(font + "-bitmap");
    if (cachedFont)
      return cachedFont;
    AnLog.warn(`\u0428\u0440\u0438\u0444\u0442 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D \u0432 \u043A\u044D\u0448\u0435: ${font}`);
    return null;
  }
  /**
   *    
   */
  // public static getByType(type: AnAssetType): AnAssetMetadata[]
  // {
  // 	return Array.from(this.metadata.values())
  // 		.filter(meta => meta.type === type);
  // }
  /**
   *       
   * : resourcename.engine.type.ext
   */
  static parseAssetType(path2) {
    const parts = path2.split(".").slice(1);
    const ext = parts.pop() ?? "none";
    const engine = parts.length > 1 ? parts.pop() : "common";
    const type = parts.pop() ?? "none";
    return { type, engine, ext };
  }
  /**
   *        
   */
  static async loadAsset(blob, type, engine, ext) {
    try {
      switch (`${type}.${engine}`) {
        case "tex.three":
          return await this.loadThreeTexture(blob);
        case "tex.pixi":
          return await this.loadPixiTexture(blob);
        case "mus.common":
        case "voc.common":
        case "snd.common":
          return await this.loadHowlSound(blob, ext);
        case "lang.common":
          return await blob.text();
        default:
          return blob;
      }
    } catch (error) {
      const err2 = error;
      throw new Error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0438: ${err2.message}`);
    }
  }
  /**
   *    
   */
  static loadHowlSound(blob, ext) {
    const url = URL.createObjectURL(blob);
    return new Promise((resolve, reject) => {
      const sound = new import_howler.default.Howl({
        src: [url],
        format: ext,
        //html5: type === 'music' || type === 'voice', //       
        onload: () => {
          URL.revokeObjectURL(url);
          resolve(sound);
        },
        onloaderror: (_, err2) => {
          URL.revokeObjectURL(url);
          reject(new Error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0437\u0432\u0443\u043A\u043E\u0432\u043E\u0433\u043E \u0444\u0430\u0439\u043B\u0430: ${err2}`));
        }
      });
    });
  }
  /**
   *     Three.js
   */
  static async loadThreeTexture(blob) {
    if (true) {
      throw new Error("3D \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445 \u0441\u0431\u043E\u0440\u043A\u0438!");
    }
    const url = URL.createObjectURL(blob);
    try {
      return await new three_stub_exports.TextureLoader().loadAsync(url);
    } finally {
      URL.revokeObjectURL(url);
    }
  }
  /**
   *     Pixi.js
   */
  static async loadPixiTexture(blob) {
    const texture = lib_exports.Texture.from(await this.createImageFromBlob(blob), true);
    return texture;
  }
  /**
   *  ImageBitmap  HTMLImageElement  Blob
   * @param blob - Blob   (PNG, JPEG  ..)
   * @returns Promise  ImageBitmap  HTMLImageElement
   */
  static async createImageFromBlob(blob) {
    if (typeof createImageBitmap === "function") {
      try {
        return await createImageBitmap(blob);
      } catch (error) {
        AnLog.warn("createImageBitmap \u043E\u0442\u0441\u0443\u0442\u0441\u0432\u0443\u0435\u0442, \u043E\u0442\u043A\u0430\u0442 \u043D\u0430 HTMLImage:", error);
      }
    }
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.onload = () => {
        URL.revokeObjectURL(url);
        resolve(img);
      };
      img.onerror = (error) => {
        URL.revokeObjectURL(url);
        reject(new Error(`\u041D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044C image \u0438\u0437 Blob: ${error}`));
      };
      img.src = url;
    });
  }
};
_AnAssets.assets = {};
var AnAssets = _AnAssets;

// angine/src/loader/AnLoader.ts
init_define_AnParams();

// angine/src/loader/AnBundle.ts
init_define_AnParams();
var AnBundle = class {
  constructor(metadata, files) {
    /**
     *    : 
     *  -     ,
     *  -   
     */
    this.files = {};
    this.metadata = metadata;
    files.forEach((file) => {
      if (file.data && file.path) {
        this.files[file.path] = file.data;
      }
    });
  }
  /**
   *       
   * @param path -      (, 'textures/main.png')
   * @returns Uint8Array     null    
   */
  getFile(path2) {
    if (path2.includes("\\")) {
      AnLog.warn(`(\u0438\u0441\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E) \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 \u0441\u043B\u0435\u0448 /, \u0430 \u043D\u0435 \u043E\u0431\u0440\u0430\u0442\u043D\u044B\u0439 \u0441\u043B\u0435\u0448 \\ \u0432 \u043F\u0443\u0442\u044F\u0445: ${path2}`);
      path2 = path2.replace(/\\/g, "/");
    }
    let file = this.files[path2] ?? null;
    if (!file) AnLog.error(`\u0412 \u0431\u0430\u043D\u0434\u043B\u0435 ${this.metadata.name} \u041D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D \u0437\u0430\u043F\u0440\u043E\u0448\u0435\u043D\u043D\u044B\u0439 \u0444\u0430\u0439\u043B: ${path2}`);
    return file;
  }
  /**
   *     
   * @param path -     
   * @returns Promise   
   */
  async getTextFile(path2) {
    const blob = this.getFile(path2);
    if (!blob) return null;
    return blob.text();
  }
  /**
   *    JSON
   * @param path -   JSON-  
   * @returns Promise   JSON
   */
  async getJsonFile(path2) {
    const text = await this.getTextFile(path2);
    if (text) {
      try {
        return JSON.parse(text);
      } catch (error) {
        const err2 = error;
        AnLog.error(`\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 JSON \u0432 \u0444\u0430\u0439\u043B\u0435 ${path2}: ${err2.message}`);
      }
    }
    return null;
  }
  /**
   *      
   * @returns     
   */
  listFiles() {
    return Object.keys(this.files);
  }
  /**
   *     
   * @param path -   
   * @returns true   
   */
  hasFile(path2) {
    return this.files[path2] !== void 0;
  }
};

// angine/src/loader/AnLoader.ts
var BUNDLE_EXTENSION = "zip";
var MULTIPART_REGEX = new RegExp(`\\.${BUNDLE_EXTENSION}\\.\\d{3}$`);
var AnLoader = class {
  /**
   *     
   * @param bundles -   
   * @param callbacks -    
   * @returns Promise     
   * 
   * @example
   * await AnLoader.loadBundles(
   *   [{ urls: ['data.bundle'] }],
   *   {
   *     onProgress: (loaded, total) => console.log(`${loaded}/${total}`)
   *   }
   * );
   */
  static async loadBundles(bundles, callbacks) {
    const results = [];
    callbacks?.onStart?.(bundles.length);
    for (const [index, bundle] of bundles.entries()) {
      try {
        const result = await this.processBundle(bundle, index, callbacks);
        results.push(result);
        callbacks?.onBundleComplete?.(result.metadata, index);
        AnLog.info(`[\u0411\u0430\u043D\u0434\u043B ${index + 1}] ${bundle.urls[0]} \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D!`);
      } catch (error) {
        this.handleError(error, bundle.urls, index, callbacks);
      }
    }
    callbacks?.onAllComplete?.(results);
    return results;
  }
  /**
   *   :     
   * @private
   */
  static async processBundle(bundle, index, callbacks) {
    this.validateBundle(bundle.urls);
    callbacks?.onBundleStart?.(bundle.urls, index);
    AnLog.info(`[\u0411\u0430\u043D\u0434\u043B ${index + 1}] \u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u043C ${bundle.urls[0]}...`);
    const parts = await this.loadParts(
      bundle.urls,
      index,
      callbacks?.onProgress
    );
    if (parts.some((part) => part.length === 0)) {
      throw new Error(this.ERROR_MESSAGES.CORRUPTED_DATA(bundle.urls));
    }
    return this.createBundle(parts, bundle);
  }
  /**
   *     
   * @throws Error   
   * @private
   */
  static validateBundle(urls) {
    if (urls.length === 1 && !urls[0].endsWith(`.${BUNDLE_EXTENSION}`)) {
      throw new Error(`\u041E\u0436\u0438\u0434\u0430\u0435\u0442\u0441\u044F \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u0435 .${BUNDLE_EXTENSION}`);
    }
    if (urls.length > 1) {
      const [valid, invalid] = this.partitionUrls(urls);
      if (invalid.length > 0) {
        throw new Error(`\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0435 \u0438\u043C\u0435\u043D\u0430 \u0444\u0430\u0439\u043B\u043E\u0432: ${invalid.join(", ")}`);
      }
      if (!this.isValidSequence(urls)) {
        throw new Error(this.ERROR_MESSAGES.INVALID_SEQUENCE(
          this.getExpectedSequence(urls.length),
          this.getActualSequence(urls)
        ));
      }
    }
  }
  /**
   *      
   * @private
   */
  static async loadParts(urls, index, progress) {
    const [sizes, totalSize] = await this.getSizes(urls);
    const parts = [];
    let loadedSize = 0;
    await Promise.all(urls.map(async (url, i3) => {
      const part = await this.loadPart(url, sizes[i3], (loaded) => {
        loadedSize += loaded;
        progress?.(loadedSize, totalSize, index);
      });
      parts[i3] = part;
    }));
    return parts;
  }
  /**
   *   AnBundle   
   * @private
   */
  static async createBundle(parts, descriptor) {
    const merged = this.mergeParts(parts);
    const zipContent = await this.unzip(merged);
    return new AnBundle({
      name: this.getBaseName(descriptor.urls[0]),
      version: "1.0",
      //zipContent.metadata?.version || '1.0',
      compression: "DEFLATE",
      parts: parts.length,
      created: /* @__PURE__ */ new Date()
    }, await this.extractFiles(zipContent));
  }
  // -----------------------------------------------------------
  //  
  // -----------------------------------------------------------
  /**
   *       
   * @example
   * 'assets.bundle.001'  'assets'
   * 'ui.bundle'  'ui'
   * @private
   */
  static getBaseName(filename) {
    return filename.split(`.${BUNDLE_EXTENSION}`)[0];
  }
  /**
   *      Uint8Array
   * @private
   */
  static mergeParts(parts) {
    const totalSize = parts.reduce((sum, part) => sum + part.length, 0);
    const merged = new Uint8Array(totalSize);
    let offset = 0;
    parts.forEach((part) => {
      merged.set(part, offset);
      offset += part.length;
    });
    return merged;
  }
  // /**
  //  *     JSZip
  //  * @throws Error   
  //  * @private
  //  */
  // private static async unzip(data: Uint8Array): Promise<JSZip>
  // {
  // 	try
  // 	{
  // 		return await new JSZip().loadAsync(data, {
  // 			createFolders: false,
  // 			optimizedBinaryString: true,
  // 			decodeFileName: bytes => new TextDecoder().decode(bytes)
  // 		});
  // 	} catch (error)
  // 	{
  // 		throw new Error(this.ERROR_MESSAGES.INVALID_ARCHIVE(String(error)));
  // 	}
  // }
  /**
   *     fflate   
   * @param data -   ZIP-
   * @returns Promise      Record<string, Uint8Array>
   * @throws Error   
   * @private
   */
  static async unzip(data) {
    return new Promise((resolve, reject) => {
      unzip(
        new Uint8Array(data),
        {},
        (err2, unzipped) => {
          if (err2) {
            reject(new Error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0440\u0430\u0441\u043F\u0430\u043A\u043E\u0432\u043A\u0438 \u0430\u0440\u0445\u0438\u0432\u0430: ${err2.message}`));
          } else {
            resolve(unzipped);
          }
        }
      );
    });
  }
  // /**
  //  *     
  //  * @private
  //  */
  // private static async extractFiles(zip: JSZip): Promise<Array<{ path: string; data: Blob }>>
  // {
  // 	return Promise.all(
  // 		Object.keys(zip.files)
  // 			.filter(path => !zip.files[path].dir)
  // 			.map(async path => ({
  // 				path,
  // 				data: new Blob(
  // 					[await zip.file(path)!.async('arraybuffer')],
  // 					{ type: this.getMimeType(path) }
  // 				)
  // 			}))
  // 	);
  // }
  /**
   *     
   * @param unzipped -     Record<string, Uint8Array>
   * @returns Promise    { path: string; data: Blob }
   * @private
   */
  static extractFiles(unzipped) {
    return Object.entries(unzipped).filter(([path2]) => !path2.endsWith("/")).map(([path2, content]) => {
      const buffer = content.buffer instanceof ArrayBuffer ? content.buffer : new ArrayBuffer(content.length);
      const uint8Content = new Uint8Array(buffer, content.byteOffset, content.byteLength);
      return {
        path: path2,
        data: new Blob(
          [uint8Content],
          { type: this.getMimeType(path2) }
        )
      };
    });
  }
  /**
   *  MIME-     .
   * @param filename -  ,     MIME-.
   * @returns ,  MIME- .
   */
  static getMimeType(filename) {
    const extension = filename.split(".").pop()?.toLowerCase();
    switch (extension) {
      case "png":
        return "image/png";
      case "jpg":
      case "jpeg":
        return "image/jpeg";
      case "json":
        return "application/json";
      case "txt":
        return "text/plain";
      default:
        return "application/octet-stream";
    }
  }
  /**
   *  URL    
   * @private
   */
  static partitionUrls(urls) {
    const valid = [];
    const invalid = [];
    urls.forEach((url) => {
      MULTIPART_REGEX.test(url) ? valid.push(url) : invalid.push(url);
    });
    return [valid, invalid];
  }
  /**
   *    
   * @private
   */
  static isValidSequence(urls) {
    return this.getActualSequence(urls) === this.getExpectedSequence(urls.length);
  }
  /**
   *    
   * @example  3 : ['001', '002', '003']
   * @private
   */
  static getExpectedSequence(length) {
    return Array.from({ length }, (_, i3) => {
      const num = i3 + 1;
      if (num < 10) return `00${num}`;
      if (num < 100) return `0${num}`;
      return `${num}`;
    }).join(",");
  }
  /**
   *     URL
   * @example ['file.bundle.001', 'file.bundle.002']  '001,002'
   * @private
   */
  static getActualSequence(urls) {
    return urls.map((url) => url.split(".").pop()).join(",");
  }
  /**
   *     HEAD-
   * @private
   */
  static async getSizes(urls) {
    try {
      const sizes = await Promise.all(urls.map(async (url) => {
        const response = await fetch(url, { method: "HEAD" });
        return parseInt(response.headers.get("Content-Length") || "0");
      }));
      return [sizes, sizes.reduce((sum, size) => sum + size, 0)];
    } catch (error) {
      throw new Error("\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0440\u0430\u0437\u043C\u0435\u0440\u044B \u0444\u0430\u0439\u043B\u043E\u0432");
    }
  }
  /**
   *       
   * @private
   */
  static async loadPart(url, expectedSize, onProgress) {
    const response = await fetch(url).catch((error) => null);
    if (!response?.ok) throw new Error(this.ERROR_MESSAGES.FILE_NOT_FOUND(url));
    const reader = response.body?.getReader();
    if (!reader) throw new Error("\u041E\u0448\u0438\u0431\u043A\u0430 \u0447\u0442\u0435\u043D\u0438\u044F \u043F\u043E\u0442\u043E\u043A\u0430");
    const chunks = [];
    let received = 0;
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
      received += value.length;
      onProgress(value.length);
    }
    const buffer = new Uint8Array(received);
    chunks.reduce((offset, chunk) => {
      buffer.set(chunk, offset);
      return offset + chunk.length;
    }, 0);
    if (buffer.length !== expectedSize) {
      AnLog.warn("AnLoader.loadPart: \u041D\u0435\u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0435 \u0440\u0430\u0437\u043C\u0435\u0440\u0430 \u0444\u0430\u0439\u043B\u0430!");
    }
    return buffer;
  }
  /**
   *   
   * @private
   */
  static handleError(error, urls, index, callbacks) {
    const message = error instanceof Error ? error.message : "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430";
    AnLog.error(`\u274C \u0411\u0430\u043D\u0434\u043B ${index + 1} \u043D\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D: ${message}`, { urls, error });
    callbacks?.onError?.(new Error(message), urls, index);
  }
};
/**
 *     
 * @private
 */
AnLoader.ERROR_MESSAGES = {
  FILE_NOT_FOUND: (url) => `\u0424\u0430\u0439\u043B \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D: ${url}`,
  INVALID_ARCHIVE: (url) => `\u0424\u0430\u0439\u043B \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D \u0438\u043B\u0438 \u043D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 \u0430\u0440\u0445\u0438\u0432\u0430: ${url}`,
  CORRUPTED_DATA: (urls) => `\u041F\u043E\u043B\u0443\u0447\u0435\u043D\u044B \u043F\u0443\u0441\u0442\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435 \u0438\u0437 ${urls.join(", ")}`,
  INVALID_SEQUENCE: (expected, actual) => `\u041D\u0430\u0440\u0443\u0448\u0435\u043D\u0430 \u043F\u043E\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0442\u043E\u043C\u043E\u0432. \u041E\u0436\u0438\u0434\u0430\u0435\u0442\u0441\u044F: ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E: ${actual}`
};

// angine/src/ui/AnProgressBar.ts
init_define_AnParams();

// angine/src/anim/AnInterpolator.ts
init_define_AnParams();

// angine/src/anim/AnInterpolation.ts
init_define_AnParams();
var AnInterpolation = class {
  /**
   *     a  b.
   * @param t ,   0  1.
   * @param a  .
   * @param b  .
   * @returns  .
   */
  static linear(t2, a2, b3) {
    return a2 + (b3 - a2) * t2;
  }
  /**
   *     a  b.
   * @param t ,   0  1.
   * @param a  .
   * @param b  .
   * @returns  .
   */
  static exponential(t2, a2, b3) {
    return a2 * Math.pow(b3 / a2, t2);
  }
  /**
   *     a  b.
   * @param t ,   0  1.
   * @param a  .
   * @param b  .
   * @returns  .
   */
  static sinusoidal(t2, a2, b3) {
    return a2 + (b3 - a2) * Math.sin(Math.PI / 2 * t2);
  }
};

// angine/src/anim/AnInterpolator.ts
var AnInterpolator = class extends enhance(Object).with(AnUpdatableMixin) {
  constructor(config2) {
    super();
    this._isActive = false;
    this._currentValue = config2.initialValue ?? 0;
    this._targetValue = typeof this._currentValue === "object" ? dataClone(this._currentValue) : this._currentValue;
    this._speed = config2.speed ?? 1;
    this.eps = config2.eps ?? 1e-4;
    this._interpolation = config2.interpolation ?? AnInterpolation.linear;
    this._callbacks = config2.callbacks ?? {};
    if (config2.updater) this.addToUpdater(config2.updater);
    if (config2.autoStart !== false) this.start();
  }
  start() {
    this._isActive = true;
  }
  stop() {
    this._isActive = false;
  }
  update(dt) {
    super.update(dt);
    if (!this._isActive || this.isTargetReached()) return;
    const t2 = Math.min(this._speed * dt, 1);
    if (typeof this._currentValue === "number" && typeof this._targetValue === "number") {
      this._currentValue = this._interpolation(t2, this._currentValue, this._targetValue);
    } else if (this.isObject(this._currentValue) && this.isObject(this._targetValue)) {
      for (const key in this._currentValue) {
        if (this._targetValue.hasOwnProperty(key)) {
          this._currentValue[key] = this._interpolation(
            t2,
            this._currentValue[key],
            this._targetValue[key]
          );
        }
      }
    }
    this._callbacks.onUpdate?.(this._currentValue, this._targetValue);
    if (this.isTargetReached()) {
      this.finish();
    }
  }
  isTargetReached() {
    if (typeof this._currentValue === "number" && typeof this._targetValue === "number") {
      return Math.abs(this._targetValue - this._currentValue) < this.eps;
    } else if (this.isObject(this._currentValue) && this.isObject(this._targetValue)) {
      for (const key in this._currentValue) {
        if (this._targetValue.hasOwnProperty(key)) {
          if (Math.abs(this._targetValue[key] - this._currentValue[key]) >= this.eps) {
            return false;
          }
        }
      }
      return true;
    }
    return true;
  }
  isObject(value) {
    return typeof value === "object" && value !== null && !Array.isArray(value);
  }
  get currentValue() {
    return this._currentValue;
  }
  get targetValue() {
    return this._targetValue;
  }
  set targetValue(value) {
    if (typeof this._currentValue !== typeof value) {
      throw new Error("Target value must be of the same type as current value");
    }
    this._targetValue = value;
  }
  setSpeed(speed) {
    this._speed = speed;
  }
  setInterpolation(fn) {
    this._interpolation = fn;
  }
  finish() {
    if (typeof this._currentValue === "number") {
      this._currentValue = this._targetValue;
    } else if (this.isObject(this._currentValue) && this.isObject(this._targetValue)) {
      for (const key in this._currentValue) {
        if (this._targetValue.hasOwnProperty(key)) {
          this._currentValue[key] = this._targetValue[key];
        }
      }
    }
    this._callbacks.onUpdate?.(this._currentValue, this._targetValue);
    this._callbacks.onComplete?.();
  }
};

// angine/src/ui/AnImage.ts
init_define_AnParams();
var AnImage = class _AnImage extends AnUIElement {
  constructor(config2) {
    super(config2);
    this.sprite = null;
    this.graphics = null;
    //    slice9
    this._useSlice9 = false;
    this.scale9Adopt = 1;
    this._useSlice9 = config2.slice9 !== void 0;
    this.type = config2.sprite ? config2.atlas ? "atlasSprite" /* AtlasSprite */ : "sprite" /* Sprite */ : "solid" /* Solid */;
    if (this.type == "solid" /* Solid */) {
      this.graphics = new lib_exports.Graphics();
      this.addToCleanup(safeDestroyFunc4(this.graphics));
      this.graphics.rect(0, 0, 256, 256);
      this.graphics.fill(config2.tint ?? AnUI.colorSheme.shadow);
      this.graphics.alpha = config2.alpha ?? 1;
      this.addGraphics(this.graphics);
      if (true) this.graphics.label = "solid color";
    } else {
      const texture = _AnImage.loadTexture(config2.sprite, config2.atlas);
      this.realWidth = texture.width;
      this.realHeight = texture.height;
      if (this._useSlice9) {
        this.sprite = new lib_exports.NineSliceSprite({
          texture,
          leftWidth: config2.slice9?.left,
          topHeight: config2.slice9?.top,
          rightWidth: config2.slice9?.right,
          bottomHeight: config2.slice9?.bottom
          // width: 200,
          // height: 80,
        });
      } else
        this.sprite = new lib_exports.Sprite(texture);
      this.sprite.anchor = AnAnchor.TopLeft;
      this.sprite.alpha = config2.alpha ?? 1;
      this.addToCleanup(safeDestroyFunc4(this.sprite));
      this.sprite.tint = config2.tint ?? 16777215;
      this.addGraphics(this.sprite);
      if (true) this.sprite.label = "sprite";
    }
    this.defaultResizeStrategy = this.simpleGraphics ? () => {
      this.graphics.width = this._scaledWidth;
      this.graphics.height = this._scaledHeight;
    } : () => {
      if (this.scaledWidth && this.scaledHeight) {
        if (this._useSlice9) {
          this.sprite.scale.set(this.scale9Adopt);
          this.sprite.setSize(this.scaledWidth / this.scale9Adopt, this.scaledHeight / this.scale9Adopt);
        } else {
          this.sprite.setSize(this.scaledWidth, this.scaledHeight);
        }
      } else
        this.sprite.scale.set(AnViewport.scale);
    };
    this.configResizeStrategy(config2.resizeStrategy);
  }
  /**      PIXI.Graphics */
  get simpleGraphics() {
    return this.type === "solid" /* Solid */;
  }
  /**  Slice9  */
  get useSlice9() {
    return this._useSlice9;
  }
  /**    */
  set clippingWidth(factor) {
    if (this.sprite && !this.useSlice9) {
      this.sprite.texture.frame.width = this.sprite.texture.orig.width * factor;
      this.sprite.texture.updateUvs();
    }
  }
  /**    */
  set clippingHeight(factor) {
    notImplemented();
  }
  /**
   *        
   * @param sprite  
   * @param atlas    
   * @public
   */
  static loadTexture(sprite, atlas) {
    let texture;
    if (atlas) {
      const atlasData = AnAssets.get(atlas);
      if (!atlasData) {
        throw new Error(`\u0410\u0442\u043B\u0430\u0441 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D: ${atlas}`);
      }
      texture = atlasData.textures[sprite];
      if (!texture) {
        throw new Error(`\u0421\u043F\u0440\u0430\u0439\u0442 "${sprite}" \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D \u0432 \u0430\u0442\u043B\u0430\u0441\u0435 "${atlas}"`);
      }
    } else {
      texture = AnAssets.get(sprite);
      if (!texture) {
        throw new Error(`\u0422\u0435\u043A\u0441\u0442\u0443\u0440\u0430 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u0430: ${sprite}`);
      }
    }
    return texture;
  }
  /**
   *     
   * @param sprite        
   * @param atlas ,   ,  
   */
  changeTexture(sprite, atlas) {
    if (!this.sprite) {
      AnLog.warn("\u041D\u0435 \u043C\u043E\u0433\u0443 \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u0442\u0435\u043A\u0441\u0442\u0443\u0440\u0443: \u0441\u043F\u0440\u0430\u0439\u0442 \u043D\u0435 \u0441\u043E\u0437\u0434\u0430\u043D");
      return;
    }
    try {
      const newTexture = _AnImage.loadTexture(sprite, atlas);
      this.sprite.texture = newTexture;
      this.realWidth = newTexture.width;
      this.realHeight = newTexture.height;
    } catch (error) {
      AnLog.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u043C\u0435\u043D\u0435 \u0442\u0435\u043A\u0441\u0442\u0443\u0440\u044B: ${error}`);
    }
  }
};

// angine/src/ui/AnProgressBar.ts
var AnProgressBar = class extends enhance(AnUIElement).with(AnUpdatableMixin) {
  constructor(config2) {
    super(config2);
    this.simpleForeground = null;
    this.simpleBackground = null;
    this.simpleBackgroundShadow = null;
    this.foregroundSprite = null;
    this.backgroundSprite = null;
    this.foregroundSprite = config2.foreground ? new AnImage({ anchor: AnAnchor.TopLeft, ...config2.foreground }) : null;
    this.backgroundSprite = config2.background ? new AnImage({ anchor: AnAnchor.TopLeft, ...config2.background }) : null;
    this._value = new AnInterpolator(
      {
        initialValue: config2.value ?? 0,
        speed: config2.speedAnim ?? 1,
        autoStart: true,
        interpolation: AnInterpolation.sinusoidal,
        callbacks: {
          onUpdate: () => this.syncWithValue()
        }
      }
    );
    this.scaledWidth = 100;
    this.scaledHeight = 5;
    if (this.simpleGraphics) {
      this.createSimpleGraphics();
    } else {
      this.createSpriteGraphics();
    }
    this.defaultResizeStrategy = this.simpleGraphics ? () => {
      this.syncWithValue();
      this.simpleBackground.width = this._scaledWidth;
      this.simpleBackgroundShadow.width = this._scaledWidth;
      this.simpleForeground.height = this._scaledHeight;
      this.simpleBackground.height = this._scaledHeight;
      this.simpleBackgroundShadow.height = this._scaledHeight;
      this.simpleBackgroundShadow.x = this.simpleBackground.x + AnUI.styleParams.shadowOffset * AnViewport.scale;
      this.simpleBackgroundShadow.y = this.simpleBackground.y + AnUI.styleParams.shadowOffset * AnViewport.scale;
      this.simpleForeground.x = this.simpleBackground.x;
      this.simpleForeground.y = this.simpleBackground.y;
    } : () => {
      this.syncWithValue();
      this.backgroundSprite.scaledWidth = this.scaledWidth;
      this.backgroundSprite.scaledHeight = this.scaledHeight;
      this.foregroundSprite.scaledHeight = this.scaledHeight;
      this.backgroundSprite.scale9Adopt = AnViewport.scale;
      this.foregroundSprite.scale9Adopt = AnViewport.scale;
      this.backgroundSprite.applyDefaultResizeStrategy();
      this.foregroundSprite.applyDefaultResizeStrategy();
    };
    this.configResizeStrategy(config2.resizeStrategy);
  }
  syncWithValue() {
    if (this.simpleGraphics)
      this.simpleForeground.width = this._scaledWidth * this._value.currentValue;
    else {
      const value = this._value.currentValue === 0 ? 1e-4 : this._value.currentValue;
      if (this.useClipping) {
        this.foregroundSprite.clippingWidth = value;
        this.foregroundSprite.scaledWidth = this.scaledWidth * value;
        this.foregroundSprite.applyDefaultResizeStrategy();
      } else {
        this.foregroundSprite.scale9Adopt = AnViewport.scale;
        this.foregroundSprite.scaledWidth = this.scaledWidth * value;
        this.foregroundSprite.scaledHeight = this.scaledHeight;
        this.foregroundSprite.applyDefaultResizeStrategy();
      }
    }
  }
  /**      PIXI.Graphics */
  get simpleGraphics() {
    return this.foregroundSprite === null && this.backgroundSprite === null;
  }
  /**       */
  get useClipping() {
    return this.foregroundSprite && !this.foregroundSprite.useSlice9;
  }
  createSpriteGraphics() {
    if (!this.foregroundSprite || !this.backgroundSprite) return;
    this.addToCleanup(safeDestroyFunc4(this.foregroundSprite));
    this.addToCleanup(safeDestroyFunc4(this.backgroundSprite));
    this.addGraphics(this.backgroundSprite);
    this.addGraphics(this.foregroundSprite);
    if (true) {
      this.backgroundSprite.label = "sprite foreground";
      this.foregroundSprite.label = "sprite background";
    }
  }
  createSimpleGraphics() {
    this.simpleForeground = new lib_exports.Graphics();
    this.simpleBackground = new lib_exports.Graphics();
    this.simpleBackgroundShadow = new lib_exports.Graphics();
    this.addToCleanup(safeDestroyFunc4(this.simpleForeground));
    this.addToCleanup(safeDestroyFunc4(this.simpleBackground));
    this.addToCleanup(safeDestroyFunc4(this.simpleBackgroundShadow));
    this.simpleBackgroundShadow.rect(0, 0, this._scaledWidth, this._scaledHeight);
    this.simpleBackgroundShadow.fill(AnUI.colorSheme.shadow);
    this.simpleBackground.rect(0, 0, this._scaledWidth, this._scaledHeight);
    this.simpleBackground.fill(AnUI.colorSheme.background);
    this.simpleForeground.rect(0, 0, this._scaledWidth, this._scaledHeight);
    this.simpleForeground.fill(AnUI.colorSheme.foreground);
    this.addGraphics(this.simpleBackgroundShadow);
    this.addGraphics(this.simpleBackground);
    this.addGraphics(this.simpleForeground);
    if (true) {
      this.simpleForeground.label = "solid foreground";
      this.simpleBackground.label = "solid background";
      this.simpleBackgroundShadow.label = "solid shadow";
    }
  }
  get value() {
    return this._value.targetValue;
  }
  set value(value) {
    this._value.targetValue = AnMath.clamp(value, 0, 1);
  }
  update(dt) {
    super.update(dt);
    this._value.update(dt);
  }
};

// angine/src/ui/AnLabel.ts
init_define_AnParams();

// angine/src/2D/AnText.ts
init_define_AnParams();
var AnText = class _AnText extends lib_exports.BitmapText {
  // text: string ->  ID  AnLang
  constructor(config2) {
    const fontName = config2.fontName ?? "sysFont";
    const font = AnAssets.getFont(fontName);
    const textColor = config2.color ?? 16777215;
    const wordWrap = config2.wordWarp !== void 0;
    if (font === null) {
      AnLog.error(`\u0428\u0440\u0438\u0444\u0442 \u043D\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D: ${fontName}`);
      throw `\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u0435 \u0448\u0440\u0438\u0444\u0442 ${fontName}`;
    }
    super(
      {
        text: "text",
        anchor: config2.anchor ?? AnAnchor.TopLeft,
        style: {
          wordWrap,
          //wordWrapWidth: 100,
          // maxWidth: config.maxWidthForWordWarp,
          fontFamily: fontName,
          fontSize: config2.fontSize ?? font.baseMeasurementFontSize,
          align: config2.textAlign ?? "left" /* Left */,
          fill: textColor
        }
      }
    );
    this.wordWarp = wordWrap;
    this._textColor = textColor;
    this.font = font;
    this._fontSize = config2.fontSize ?? font.baseMeasurementFontSize;
    this._textSource = config2.textSource;
    this._autoUpdateLang = config2.autoUpdateLang ?? true;
    this.setupEventHandlers();
    this.updateText();
  }
  get textColor() {
    return this._textColor;
  }
  set textColor(color) {
    this._textColor = color;
    this.style.fill = color;
  }
  static textSourceResolver(textSource, autoUpdateLang = false) {
    return typeof textSource === "function" ? textSource() : autoUpdateLang ? AnLang.get(textSource) : textSource;
  }
  resolveTextSource() {
    return _AnText.textSourceResolver(this._textSource, this._autoUpdateLang);
  }
  updateText() {
    this.text = this.resolveTextSource();
  }
  setupEventHandlers() {
    if (this._autoUpdateLang) {
      const { unsub } = AnEvents.on("settings:changed:lang", () => this.updateText());
      this.on("destroyed", () => unsub());
    }
  }
  get autoUpdateLang() {
    return this._autoUpdateLang;
  }
  set textSource(value) {
    this._textSource = value;
    this.updateText();
  }
  calcOffsetY() {
    return this.fontSize * this.baseLineOffset / this.assetFontSize;
  }
  get scaledFontSize() {
    return this.style.fontSize;
  }
  // public set scaledFontSize(size: number)
  // {
  //     this.style.fontSize = size;
  // }
  get fontSize() {
    return this._fontSize;
  }
  get assetFontSize() {
    return this.font.baseMeasurementFontSize;
  }
  get baseLineOffset() {
    return this.font.baseLineOffset;
  }
  applyResize(scaleFactor) {
    this.scale.set(scaleFactor);
  }
  applyFontResize() {
    this.style.lineHeight = scaled(this.fontSize);
    this.style.fontSize = scaled(this.fontSize);
  }
};

// angine/src/ui/AnLabel.ts
var AnLabel = class extends AnUIElement {
  constructor(config2) {
    super(config2);
    this.shadowTextObj = null;
    //    
    // private baseFontSize: number;
    // private baseLine: number;
    this.background = null;
    this.textObj = new AnText({ ...config2.text });
    this.backgroundColor = config2.backgroundColor ?? 0;
    this.backgroundAlpha = config2.backgroundAlpha ?? 1;
    this.backgroundPadding = config2.backgroundPadding ?? 1;
    this.labelAlign = config2.labelAlign ?? "left" /* Left */;
    if (config2.backgroundColor !== void 0)
      this.createBackground();
    if (config2.text.shadowOffsetX !== void 0 || config2.text.shadowOffsetY !== void 0 || config2.text.shadowColor !== void 0 || config2.text.shadowAlpha !== void 0) {
      this.shadowOffsetX = config2.text.shadowOffsetX ?? 2;
      this.shadowOffsetY = config2.text.shadowOffsetY ?? 2;
      this.shadowColor = config2.text.shadowColor ?? 0;
      this.shadowAlpha = config2.text.shadowAlpha ?? 1;
      this.shadowTextObj = new AnText({
        ...config2.text
      });
      this.shadowTextObj.tint = this.shadowColor;
      this.shadowTextObj.alpha = this.shadowAlpha;
      this.addGraphics(this.shadowTextObj);
      this.addToCleanup(safeDestroyFunc4(this.shadowTextObj));
      if (true) this.shadowTextObj.label = "shadow text";
    }
    this.addGraphics(this.textObj);
    this.addToCleanup(safeDestroyFunc4(this.textObj));
    if (true) this.textObj.label = "bitmap text";
    this.defaultResizeStrategy = () => {
      this.textObj.applyFontResize();
      const textBounds = this.textObj.getLocalBounds();
      const offsetY = scaled(this.textObj.calcOffsetY());
      if (this._scaledWidth !== null && this._scaledHeight !== null) {
        const finalScale = Math.min(1, this.scaledWidth / textBounds.width, this.scaledHeight / textBounds.height);
        this.textObj.applyResize(finalScale);
        switch (this.labelAlign) {
          case "left" /* Left */:
            this.textObj.x = 0;
            break;
          case "right" /* Right */:
            this.textObj.x = this.scaledWidth - this.textObj.width;
            break;
          case "center" /* Center */:
            this.textObj.x = (this.scaledWidth - this.textObj.width) * 0.5;
            break;
        }
        this.textObj.y = this.scaledHeight * 0.5 - this.textObj.height * 0.5 - offsetY * finalScale;
      } else {
        this.textObj.x = 0;
        this.textObj.y = -offsetY;
        if (this.textObj.style.wordWrap && this.scaledWidth !== null) {
          this.textObj.style.wordWrapWidth = this.scaledWidth;
        }
      }
      if (this.shadowTextObj) {
        this.shadowTextObj.applyFontResize();
        this.shadowTextObj.applyResize(this.textObj.scale.x);
        this.shadowTextObj.position.set(this.textObj.x + this.shadowOffsetX * AnViewport.scale, this.textObj.y + this.shadowOffsetY * AnViewport.scale);
        if (this.shadowTextObj.style.wordWrap && this.scaledWidth !== null) {
          this.shadowTextObj.style.wordWrapWidth = this.scaledWidth;
        }
      }
      if (this.background) {
        const scaledPadding = scaled(this.backgroundPadding);
        this.background.x = this.background.y = -scaledPadding;
        if (this._scaledWidth !== null && this._scaledHeight !== null) {
          this.background.width = this._scaledWidth;
          this.background.height = this._scaledHeight;
        } else {
          this.background.width = this.textObj.width;
          this.background.height = this.textObj.height;
        }
        this.background.width += scaledPadding * 2;
        this.background.height += scaledPadding * 2;
      }
    };
    this.configResizeStrategy(config2.resizeStrategy);
  }
  updateShadowRealPixels() {
    this.shadowTextObj?.position.set(this.textObj.x + this.shadowOffsetX, this.textObj.y + this.shadowOffsetY);
  }
  get textOffsetY() {
    return this.textObj.calcOffsetY();
  }
  get textColor() {
    return this.textObj.textColor;
  }
  set textColor(color) {
    this.textObj.textColor = color;
  }
  getText() {
    return this.textObj.resolveTextSource();
  }
  getTextWidth() {
    return this.textObj.getLocalBounds().width;
  }
  getTextHeight() {
    return this.textObj.getLocalBounds().height;
  }
  setText(text) {
    this.textObj.textSource = text;
    if (this.shadowTextObj) this.shadowTextObj.textSource = text;
    this.updateText();
  }
  updateText() {
    this.textObj.updateText();
    this.shadowTextObj?.updateText();
    this.applyDefaultResizeStrategy();
  }
  createBackground() {
    this.background = new lib_exports.Graphics();
    this.addToCleanup(safeDestroyFunc4(this.background));
    this.background.rect(0, 0, 100, 100);
    this.background.fill({ color: this.backgroundColor, alpha: this.backgroundAlpha });
    this.addGraphics(this.background);
    if (true) this.background.label = "background";
  }
};

// angine/src/ui/AnFader.ts
init_define_AnParams();
var AnFader = class extends AnImage {
  constructor(config2) {
    super({
      anchor: AnAnchor.TopLeft,
      resizeStrategy: () => {
        this.width = AnViewport.width;
        this.height = AnViewport.height;
      },
      ...config2
    });
    this.faderType = config2.type;
    this.delay = config2.delay ?? 0;
    this.duration = config2.duration ?? 2;
    this.autoTerminate = config2.autoTerminate ?? true;
    this.callbacks = config2.callbacks;
    this.createTween();
    this.addToCleanup(AnEvents.on("viewport:resize", () => this.resizeUI()).unsub);
    this.resizeUI();
  }
  createTween() {
    const tween = new AnTween(
      {
        target: this,
        from: { alpha: this.faderType == "in" ? 0 : 1 },
        to: { alpha: this.faderType == "in" ? 1 : 0 },
        duration: this.duration,
        delay: this.delay,
        easing: this.faderType === "in" ? AnEase.easeOut : AnEase.easeIn,
        updater: AnCore.updater,
        //FIXME:         
        callbacks: {
          onComplete: () => {
            this.callbacks?.onComplete?.();
            if (this.autoTerminate)
              this.terminate();
          }
        }
      }
    );
    this.addToCleanup(() => tween.terminate());
  }
  resizeUI() {
    this.applyResizeStrategy();
  }
};

// angine/src/app/AnPreloader.ts
var AnPreloader = class extends AnMenu {
  constructor(config2, callbacks) {
    super();
    this.config = config2;
    this.callbacks = callbacks;
    this.preloaderBundle = config2.preloaderBundle ?? "preloader.zip";
    this.assetsBundle = config2.assetsBundle ?? "assets.zip";
    this.skipExitAnimations = config2.skipExitAnimations ?? false;
  }
  async start() {
    const preloaderBundle = (await AnLoader.loadBundles([{ urls: [this.preloaderBundle] }]))[0];
    await AnAssets.load(preloaderBundle);
    this.createUI();
    this.resizeUI();
    this.show();
    this.callbacks?.onStart?.();
    this.callbacks?.onProgress?.(0);
    const assetsBundle = (await AnLoader.loadBundles(
      [{ urls: this.assetsBundle.split(",") }],
      {
        onProgress: (loaded, total, index) => {
          this.elements["progressBar"].value = loaded / total;
          this.elements["textPercent"].updateText();
          const percent = Math.trunc(loaded / total * 100);
          this.callbacks?.onProgress?.(AnMath.clamp(percent, 0, 100));
        }
      }
    ))[0];
    await AnAssets.load(
      assetsBundle,
      "all",
      [],
      {
        /**       */
        onStart: (total) => {
        },
        /**       */
        onAssetLoaded: (path2, metadata) => {
        },
        /**      */
        onComplete: (successCount, errorCount) => {
        }
      }
    );
    this.callbacks?.onComplete?.();
    this.callbacks?.onProgress?.(100);
  }
  createUI() {
    const background = this.addUIElement(
      "background",
      new AnImage(
        {
          sprite: "preloader/preloaderBG.tex.pixi.jpg",
          tint: 16724553,
          anchor: AnAnchor.TopLeft,
          resizeStrategy: () => {
            background.position.set(0, 0);
            background.setSize(AnViewport.width, AnViewport.height);
          }
        }
      )
    );
    const logo = this.addUIElement(
      "logo",
      new AnImage({
        sprite: "preloader/anegLogo.tex.pixi.png",
        anchor: AnAnchor.Center,
        resizeStrategy: () => {
          logo.applyDefaultResizeStrategy();
          logo.position.set(AnViewport.width * 0.5, AnViewport.height * 0.5);
        }
      })
    );
    const progressBar = this.addUIElement(
      "progressBar",
      new AnProgressBar(
        {
          value: 0,
          anchor: AnAnchor.Center,
          resizeStrategy: () => {
            progressBar.scaledWidth = logo.width * 1.2;
            progressBar.scaledHeight = 15 * AnViewport.scale;
            progressBar.applyDefaultResizeStrategy();
            progressBar.position.set(AnViewport.width * 0.5, logo.bottom + 50 * AnViewport.scale);
          }
        }
      )
    );
    const textPercent = this.addUIElement(
      "textPercent",
      new AnLabel(
        {
          text: {
            textSource: () => (progressBar.value * 100).toFixed(0) + "%",
            fontName: "sysFont",
            fontSize: 40,
            autoUpdateLang: false
          },
          anchor: AnAnchor.Center,
          resizeStrategy: () => {
            textPercent.applyDefaultResizeStrategy();
            textPercent.position.set(AnViewport.width * 0.5, progressBar.bottom + 50 * AnViewport.scale);
          }
        }
      )
    );
  }
  //    
  createEntranceTweens() {
    const tweens = [];
    tweens.push(new AnTween({
      target: this.elements["logo"],
      from: { alpha: 0, scale: { x: 0.1, y: 0.1 }, rotation: 10 * AnMath.toRad },
      to: { alpha: 1, scale: { x: 1, y: 1 }, rotation: 0 },
      delay: 1,
      duration: 5,
      easing: AnEase.easeOutElastic
    }));
    tweens.push(new AnTween({
      target: this.elements["progressBar"],
      from: { alpha: 0, scale: { x: 0.1, y: 1 } },
      to: { alpha: 1, scale: { x: 1, y: 1 } },
      delay: 1,
      duration: 2,
      easing: AnEase.easeOutBack
    }));
    tweens.push(new AnTween({
      target: this.elements["textPercent"],
      from: { alpha: 0 },
      to: { alpha: 1 },
      delay: 3,
      duration: 4,
      easing: AnEase.easeOut
    }));
    AnRender2D.addToFront(new AnFader({ type: "out" }));
    return tweens;
  }
  //     
  createExitTweens() {
    const tweens = [];
    if (this.skipExitAnimations) return [];
    tweens.push(new AnTween({
      target: this.elements["logo"],
      to: { alpha: 0, scale: { x: 0.1, y: 0.1 } },
      from: { alpha: 1, scale: { x: 1, y: 1 } },
      delay: 0,
      duration: 4,
      tags: ["terminate"],
      easing: AnEase.easeInElastic
    }));
    tweens.push(new AnTween({
      target: this.elements["progressBar"],
      to: { alpha: 0, scale: { x: 0.1, y: 1 } },
      from: { alpha: 1, scale: { x: 1, y: 1 } },
      delay: 0,
      duration: 2,
      easing: AnEase.easeInBack
    }));
    tweens.push(new AnTween({
      target: this.elements["textPercent"],
      to: { alpha: 0, scale: { x: 0.5, y: 0.5 }, y: this.elements["textPercent"].y + 50 * AnViewport.scale },
      from: { alpha: 1, scale: { x: 1, y: 1 }, y: this.elements["textPercent"].y },
      delay: 1,
      duration: 3,
      easing: AnEase.easeOut
    }));
    AnRender2D.addToFront(new AnFader({ type: "in", delay: 2 }));
    return tweens;
  }
};

// angine/src/app/AnApp.ts
var AnApp = class _AnApp {
  constructor(config2) {
    this.menus = [];
    this.isStarted = false;
    this.preloaderSkipExitAnimations = false;
    //    
    this._paused = false;
    if (_AnApp.instance)
      return _AnApp.instance;
    this.preloaderSkipExitAnimations = config2.preloaderSkipExitAnimations ?? false;
    _AnApp.instance = this;
  }
  static get self() {
    if (!_AnApp.instance)
      throw new Error("AnApp \u0435\u0449\u0451 \u043D\u0435 \u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D");
    return _AnApp.instance;
  }
  /**
   *  
   */
  async start() {
    if (this.isStarted) return;
    await AnCore.init();
    AnControls.init();
    this.setupInputRouting();
    await this.startPreloader();
    this.isStarted = true;
  }
  /**
   *      
   */
  setupInputRouting() {
    AnEvents.on("controls:pointerdown" /* PointerDown */, this.forwardEvents.bind(this));
    AnEvents.on("controls:pointermove" /* PointerMove */, this.forwardEvents.bind(this));
    AnEvents.on("controls:pointerup" /* PointerUp */, this.forwardEvents.bind(this));
    AnEvents.on("controls:pointercancel" /* PointerCancel */, this.forwardEvents.bind(this));
    AnEvents.on("controls:mouse:wheel" /* MouseWheel */, this.forwardEvents.bind(this));
    window.addEventListener("blur", () => {
      if (true) AnLog.debug("\u041F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u043F\u043E\u0442\u0435\u0440\u044F\u043B\u043E \u0444\u043E\u043A\u0443\u0441");
      this.paused = true;
      AnEvents.emit("app:lostFocus");
    });
    window.addEventListener("focus", () => {
      if (true) AnLog.debug("\u041F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u043F\u043E\u043B\u0443\u0447\u0438\u043B\u043E \u0444\u043E\u043A\u0443\u0441");
      this.paused = false;
      AnEvents.emit("app:getFocus");
    });
  }
  forwardEvents(e2) {
    const activeMenu = this.getActiveMenu();
    if (activeMenu) AnEvents.emit(`${className(activeMenu)}:${e2.event}`, e2.data);
  }
  /**
   *  
   */
  async startPreloader() {
    const preloader = new AnPreloader({
      skipExitAnimations: this.preloaderSkipExitAnimations
    }, {
      onStart: () => this.onPreloaderStart(),
      onProgress: (percent) => this.onPreloaderProgress(percent),
      onComplete: () => {
        preloader.hide(() => {
          runAfter(0.1, () => this.onPreloaderComplete());
        });
      }
    });
    await preloader.start();
  }
  /**
   *      , sdk,  ..
   */
  onPreloaderStart() {
  }
  /**
   *     
   */
  onPreloaderProgress(percent) {
  }
  /**
   *   
   */
  onPreloaderComplete() {
  }
  /**
   *   
   */
  registerMenu(menu) {
    this.menus.push(menu);
  }
  /**
   *    
   */
  unregisterMenu(menu) {
    removeByValue(this.menus, menu);
  }
  /**
   *   
   */
  getActiveMenu() {
    return this.menus.length > 0 ? this.menus[this.menus.length - 1] : null;
  }
  get paused() {
    return this._paused;
  }
  set paused(paused) {
    if (this._paused === paused) return;
    this._paused = paused;
    if (paused) {
      AnMainLoop.stop();
      Howler.mute(true);
    } else {
      AnMainLoop.start();
      Howler.mute(false);
    }
  }
};

// games/packer/src/game/Game.ts
init_define_AnParams();

// angine/src/ui/AnButton.ts
init_define_AnParams();

// angine/src/audio/AnSounds.ts
init_define_AnParams();
var AnSounds = class {
  /**
   *   
   */
  static init(config2) {
    this._soundVolume = config2?.soundVolume ?? 100;
    this._enabled = config2?.enabled ?? true;
    this._maxInstances = config2?.maxInstances ?? 5;
    AnEvents.on("storage:soundVolume:update", (e2) => this.volume = e2.data.value);
  }
  /**
   *   
   * @param name -    AnAssets
   * @param volumeMultipler -   (0-1)
   * @param panning -  (-1 , 1 )
   */
  static play(name, volumeMultipler = 1, panning, rate) {
    if (!this._enabled) return;
    const count2 = this._instanceCounter.get(name) || 0;
    if (count2 >= this._maxInstances) {
      return;
    }
    const sound = AnAssets.get(name);
    if (sound) {
      this._instanceCounter.set(name, count2 + 1);
      sound.volume(this._soundVolume / 100 * volumeMultipler);
      if (panning !== void 0) sound.stereo(panning);
      if (rate !== void 0) sound.rate(rate);
      sound.play();
      sound.once("end", () => {
        let count3 = this._instanceCounter.get(name) ?? 0;
        if (count3 <= 1)
          this._instanceCounter.delete(name);
        else
          this._instanceCounter.set(name, count3 - 1);
      });
    }
  }
  static set volume(value) {
    this._soundVolume = Math.min(100, Math.max(0, value));
  }
  static get volume() {
    return this._soundVolume;
  }
  static set enabled(value) {
    this._enabled = value;
  }
  static get enabled() {
    return this._enabled;
  }
};
AnSounds._instanceCounter = /* @__PURE__ */ new Map();

// angine/src/ui/AnButton.ts
var AnButton = class extends enhance(AnUIGroupElement).with(AnUpdatableMixin) {
  constructor(config2) {
    super(config2);
    this._state = "normal" /* Normal */;
    this.hoverSprite = null;
    this.icon = null;
    this.hoverIcon = null;
    this.labelText = null;
    this.labelTextColor = null;
    this.labelTextHoverColor = null;
    this.stateTween = null;
    // private posTween: AnTween | null = null;
    this._enabled = true;
    this.callbacks = config2.callbacks ?? {};
    this.padding = config2.padding ?? 0;
    this.spriteAdoptSlice9Factor = config2.spriteAdoptSlice9Factor ?? 1;
    this.sprite = this.addUIElement("sprite", new AnImage(config2.sprite));
    if (config2.hoverSprite) {
      this.hoverSprite = this.addUIElement("hoverSprite", new AnImage(config2.hoverSprite));
      this.hoverSprite.visible = false;
    }
    if (config2.labelText) {
      this.labelText = this.addUIElement(
        "labelText",
        new AnLabel(
          {
            ...config2.labelText,
            anchor: AnAnchor.Center
          }
        )
      );
      if (config2.labelTextColorHover) {
        this.labelTextColor = this.labelText.textColor;
        this.labelTextHoverColor = config2.labelTextColorHover;
      }
    }
    if (config2.icon) {
      this.icon = this.addUIElement(
        "icon",
        new AnImage({
          ...config2.icon,
          anchor: AnAnchor.Center
        })
      );
    }
    this.iconAlign = config2.iconAlign ?? "center" /* Center */;
    this.defaultResizeStrategy = () => {
      const padding = scaled(this.padding);
      this.sprite.scale9Adopt = AnViewport.scale * this.spriteAdoptSlice9Factor;
      if (this.hoverSprite) this.hoverSprite.scale9Adopt = AnViewport.scale * this.spriteAdoptSlice9Factor;
      this.sprite.setScaledSize(this.scaledWidth, this.scaledHeight);
      this.hoverSprite?.setScaledSize(this.scaledWidth, this.scaledHeight);
      this.sprite.applyDefaultResizeStrategy();
      this.hoverSprite?.applyDefaultResizeStrategy();
      const buttonCenterX = this.scaledWidth * 0.5;
      const buttonCenterY = this.scaledHeight * 0.5;
      const labelOffsetX = scaled(config2.labelTextOffset?.x ?? 0);
      const labelOffsetY = scaled(config2.labelTextOffset?.y ?? 0);
      if (this.icon) {
        const iconHeight = this.scaledHeight - padding * 2;
        const iconWidth = iconHeight * this.icon.realSizeRatio;
        const iconScaleX = config2.iconScale?.x ?? 1;
        const iconScaleY = config2.iconScale?.y ?? 1;
        this.icon.setScaledSize(iconWidth * iconScaleX, iconHeight * iconScaleY);
        this.icon.applyDefaultResizeStrategy();
      }
      if (this.labelText) {
        let textWidth = this.scaledWidth - padding * 2;
        if (this.icon && this.iconAlign !== "center" /* Center */) {
          textWidth -= this.icon?.scaledWidth + padding * 2;
        }
        this.labelText.setScaledSize(textWidth, this.scaledHeight - padding * 2);
        this.labelText.applyDefaultResizeStrategy();
      }
      if (this.icon && this.labelText) {
        switch (this.iconAlign) {
          case "left" /* Left */:
            this.icon.position.set(this.icon.scaledWidth / 2 + padding * 2, buttonCenterY);
            this.labelText.position.set(this.scaledWidth + labelOffsetX - this.labelText.scaledWidth / 2 - padding, buttonCenterY + labelOffsetY);
            break;
          case "right" /* Right */:
            this.icon.position.set(this.scaledWidth - this.icon.scaledWidth / 2 - padding * 2, buttonCenterY);
            this.labelText.position.set(labelOffsetX + this.labelText.scaledWidth / 2 + padding, buttonCenterY + labelOffsetY);
            break;
          case "center" /* Center */:
          default:
            this.icon.position.set(buttonCenterX, buttonCenterY);
            this.labelText.position.set(buttonCenterX + labelOffsetX, buttonCenterY + labelOffsetY);
            break;
        }
      } else if (this.icon) {
        this.icon.position.set(buttonCenterX, buttonCenterY);
      } else if (this.labelText) {
        this.labelText.position.set(buttonCenterX + labelOffsetX, buttonCenterY + labelOffsetY);
      }
    };
    this.configResizeStrategy(config2.resizeStrategy);
    this.setupEventHandlers();
    this.disabledStyle = config2.disabledStyle ?? "darken" /* Darken */;
    this.setEnabled(this._enabled);
    this.addToCleanup(() => this.stateTween?.terminate());
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.setEnabled(value);
  }
  /**
   *    
   * @param enabled true  , false  
   */
  setEnabled(enabled) {
    if (this._enabled === enabled) return;
    this._enabled = enabled;
    if (enabled) {
      switch (this.disabledStyle) {
        case "opacity" /* Opacity */:
          this.sprite.alpha = 1;
          if (this.hoverSprite) this.hoverSprite.alpha = 1;
          if (this.labelText) this.labelText.alpha = 1;
          if (this.icon) this.icon.alpha = 1;
          break;
        case "darken" /* Darken */:
          this.sprite.tint = 16777215;
          if (this.hoverSprite) this.hoverSprite.tint = 16777215;
          break;
      }
    } else {
      switch (this.disabledStyle) {
        case "opacity" /* Opacity */:
          this.sprite.alpha = 0.5;
          if (this.hoverSprite) this.hoverSprite.alpha = 0.5;
          if (this.labelText) this.labelText.alpha = 0.5;
          if (this.icon) this.icon.alpha = 0.5;
          break;
        case "darken" /* Darken */:
          this.sprite.tint = 5592405;
          if (this.hoverSprite) this.hoverSprite.tint = 5592405;
          break;
      }
      if (this._state !== "normal" /* Normal */) {
        this.state = "normal" /* Normal */;
      }
    }
  }
  setIcon(icon, atlas) {
    if (!this.icon) return;
    this.icon.changeTexture(icon, atlas);
  }
  setupEventHandlers() {
    if (!AnControls.isTouchEnabled)
      this.addToCleanup(AnEvents.on(this.controlsRouter + "controls:pointermove" /* PointerMove */, this.onMove.bind(this)).unsub);
    this.addToCleanup(AnEvents.on(this.controlsRouter + "controls:pointerdown" /* PointerDown */, this.onDown.bind(this)).unsub);
    this.addToCleanup(AnEvents.on(this.controlsRouter + "controls:pointerup" /* PointerUp */, this.onUp.bind(this)).unsub);
  }
  onMove(e2) {
    if (!this._enabled || !this.visible) return;
    const pixelPos = new lib_exports.Point(e2.data.x, e2.data.y);
    const isPointInside = this.isPointInside(pixelPos);
    if (this._state === "pressed" /* Pressed */) {
      if (!isPointInside) this.state = "normal" /* Normal */;
      return;
    }
    this.state = isPointInside ? "hover" /* Hover */ : "normal" /* Normal */;
  }
  onDown(e2) {
    if (!this._enabled || !this.visible) return;
    if (this._state === "pressed" /* Pressed */) return;
    const pixelPos = new lib_exports.Point(e2.data.x, e2.data.y);
    this.state = this.isPointInside(pixelPos) ? "pressed" /* Pressed */ : "normal" /* Normal */;
  }
  onUp(e2) {
    if (!this._enabled || !this.visible) return;
    if (this._state !== "pressed" /* Pressed */) return;
    const pixelPos = new lib_exports.Point(e2.data.x, e2.data.y);
    this.state = this.isPointInside(pixelPos) && !AnControls.isTouchEnabled ? "hover" /* Hover */ : "normal" /* Normal */;
    //!     
    AnSounds.play(
      `sounds/click.snd.mp3`,
      0.6
    );
    AnControls.vibrate(50);
    this.callbacks.onClick?.();
  }
  setText(text) {
    this.labelText?.setText(text);
  }
  get state() {
    return this._state;
  }
  set state(value) {
    if (!this._enabled)
      value = "normal" /* Normal */;
    if (this._state === value) return;
    this._state = value;
    if (this.stateTween) {
      this.stateTween.terminate();
      this.stateTween = null;
    }
    switch (this.state) {
      case "normal" /* Normal */:
        if (this.hoverSprite) {
          this.sprite.visible = true;
          this.hoverSprite.visible = false;
        }
        if (this.labelText && this.labelTextColor)
          this.labelText.textColor = this.labelTextColor;
        this.stateTween = new AnTween({
          target: this,
          to: { scale: { x: 1, y: 1 } },
          duration: 0.6,
          easing: AnEase.easeOutBack,
          updater: this.getUpdater(),
          autoRemove: true,
          callbacks: {
            onComplete: () => this.stateTween = null
          }
        });
        break;
      case "hover" /* Hover */:
        if (this.hoverSprite) {
          this.sprite.visible = false;
          this.hoverSprite.visible = true;
        }
        if (this.labelText && this.labelTextHoverColor)
          this.labelText.textColor = this.labelTextHoverColor;
        this.stateTween = new AnTween({
          target: this,
          to: { scale: { x: 1.1, y: 1.1 } },
          duration: 0.6,
          easing: AnEase.easeOutBack,
          updater: this.getUpdater(),
          autoRemove: true,
          callbacks: {
            onComplete: () => this.stateTween = null
          }
        });
        break;
      case "pressed" /* Pressed */:
        if (this.hoverSprite) {
          this.sprite.visible = false;
          this.hoverSprite.visible = true;
        }
        if (this.labelText && this.labelTextHoverColor)
          this.labelText.textColor = this.labelTextHoverColor;
        this.stateTween = new AnTween({
          target: this,
          to: { scale: { x: 0.95, y: 0.95 } },
          duration: 0.6,
          easing: AnEase.easeOutBack,
          updater: this.getUpdater(),
          autoRemove: true,
          callbacks: {
            onComplete: () => this.stateTween = null
          }
        });
        break;
    }
  }
};

// games/packer/src/game/Field.ts
init_define_AnParams();

// games/packer/src/game/Block.ts
init_define_AnParams();

// angine/src/utils/AnRnd.ts
init_define_AnParams();
var import_seedrandom = __toESM(require_seedrandom2());
var AnRnd = class _AnRnd {
  /**
   *     
   * @param seed   .   ,   .
   */
  constructor(seed = "") {
    if (seed === "") {
      seed = _AnRnd.string(20);
    }
    this.rng = (0, import_seedrandom.default)(seed);
    this._seed = seed;
  }
  /**     */
  get seed() {
    return this._seed;
  }
  /**     */
  set seed(seed) {
    this._seed = seed;
    this.rng = (0, import_seedrandom.default)(seed);
  }
  // ===========   ( ) ===========
  /**    (-1  1) */
  seed_sgn() {
    return this.rng() > 0.5 ? -1 : 1;
  }
  /** 
   *    
   * @param chanceToTrue  true (0.8 = 80% chance)
   */
  seed_bool(chanceToTrue = 0.5) {
    return this.rng() < chanceToTrue;
  }
  /** 
   *        
   * @param clow   
   * @param chigh   
   */
  seed_float(clow = 0, chigh = 1) {
    return this.rng() * (chigh - clow) + clow;
  }
  /** 
   *      
   * @param clow   
   * @param chigh   
   */
  seed_int(clow, chigh) {
    return Math.floor(this.rng() * (chigh - clow + 1)) + clow;
  }
  /** 
   *     
   * @param length  
   * @param charactersToUse     (  a-zA-Z0-9)
   */
  seed_string(length, charactersToUse = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") {
    let str = "";
    for (let i3 = 0; i3 < length; i3++) {
      str += charactersToUse.charAt(this.seed_int(0, charactersToUse.length - 1));
    }
    return str;
  }
  // ===========   ( ) ===========
  /**    (-1  1) */
  static sgn() {
    return Math.random() > 0.5 ? -1 : 1;
  }
  /** 
   *    
   * @param chanceToTrue  true (0.8 = 80% chance)
   */
  static bool(chanceToTrue = 0.5) {
    return Math.random() < chanceToTrue;
  }
  /** 
   *        
   * @param clow   
   * @param chigh   
   */
  static float(clow = 0, chigh = 1) {
    return Math.random() * (chigh - clow) + clow;
  }
  /** 
   *      
   * @param clow   
   * @param chigh   
   */
  static int(clow, chigh) {
    return Math.floor(Math.random() * (chigh - clow + 1)) + clow;
  }
  /** 
   *     
   * @param length  
   * @param charactersToUse     (  a-zA-Z0-9)
   */
  static string(length, charactersToUse = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") {
    let str = "";
    for (let i3 = 0; i3 < length; i3++) {
      str += charactersToUse.charAt(_AnRnd.int(0, charactersToUse.length - 1));
    }
    return str;
  }
  //     (  )
  static executeByChance(events, rnd) {
    const totalProbability = events.reduce((sum, event) => sum + event.chance, 0);
    if (totalProbability <= 0) {
      return;
    }
    const randomValue = (rnd ? rnd.seed_float() : _AnRnd.float()) * totalProbability;
    let cumulativeProbability = 0;
    for (const event of events) {
      cumulativeProbability += event.chance;
      if (randomValue <= cumulativeProbability) {
        event.action();
        return;
      }
    }
    return;
  }
};

// angine/src/utils/AnTask.ts
init_define_AnParams();
var AnTask = class _AnTask extends AnUpdatableMixin(Object) {
  constructor(config2) {
    super();
    this._active = false;
    this._handler = config2.handler;
    let autoStart = config2.autoStart ?? true;
    this._context = config2.context;
    this._runOnce = config2.runOnce ?? false;
    if (config2.updater) this.addToUpdater(config2.updater);
    if (autoStart) this.start();
  }
  /**
   *   
   */
  start() {
    if (this._active || !this.getUpdater()) return this;
    this._active = true;
    return this;
  }
  /**
   *   
   */
  stop() {
    if (!this._active) return this;
    this._active = false;
    return this;
  }
  /**
   *   
   * @param dt    
   */
  update(dt) {
    if (!this._active) return;
    this._handler.call(this._context, dt);
    if (this._runOnce) {
      this.stop();
      this.removeFromUpdater();
    }
  }
  /**
   *   
   */
  set context(_context) {
    this._context = _context;
  }
  /**
   *   
   */
  get context() {
    return this._context;
  }
  /**
   *   
   */
  get active() {
    return this._active;
  }
  // --------------------------------------------------------
  //   :    
  // --------------------------------------------------------
  /**
   *           .
   *
   * @param handler ,      update
   * @param updater  AnUpdater,    
   * @param context  (this)   
   */
  static runNextUpdate(handler, context2) {
    const task = new _AnTask({
      handler,
      updater: AnCore.updater,
      runOnce: true,
      //    
      autoStart: true,
      //  
      context: context2
    });
    return task;
  }
};

// games/packer/src/game/G.ts
init_define_AnParams();
var _G = class _G {
  static disableDevFeatures() {
    for (const key in this) {
      if (key.startsWith("dev_") && this.hasOwnProperty(key) && typeof this[key] === "boolean") {
        this[key] = false;
      }
    }
  }
  ////////////////////////////////////////////////////////////////
  //    
  ////////////////////////////////////////////////////////////////
  //  
  static calculateTotalMoves(perfectMoves) {
    if (_G.dev_totalMovesInfinity) return 999;
    return perfectMoves * _G.totalMovesMultipler + _G.totalMovesAddMore;
  }
  //   
  static calculatePerfectMoves(totalMoves) {
    if (_G.dev_totalMovesInfinity) {
      return 999;
    }
    const adjustedTotalMoves = totalMoves - _G.totalMovesAddMore;
    const multiplier = _G.totalMovesMultipler;
    return Math.trunc(adjustedTotalMoves / multiplier);
  }
  //  
  static calculateStars(usedMoves, totalMoves) {
    if (_G.zeroStarsForComplete && usedMoves === totalMoves) return 0;
    if (usedMoves <= totalMoves * _G.threeStarsPerc) return 3;
    if (usedMoves <= totalMoves * _G.twoStarsPerc) return 2;
    return 1;
  }
  //    (     )
  static calculateStarsProgressbar(usedMoves, totalMoves) {
    if (_G.zeroStarsForComplete && usedMoves === totalMoves) return 0;
    const threeStarsThreshold = totalMoves * _G.threeStarsPerc;
    const twoStarsThreshold = totalMoves * _G.twoStarsPerc;
    if (usedMoves <= threeStarsThreshold) {
      const segmentProgress = (threeStarsThreshold - usedMoves) / threeStarsThreshold;
      return 0.66 + segmentProgress * 0.34;
    }
    if (usedMoves <= twoStarsThreshold) {
      const segmentSize = twoStarsThreshold - threeStarsThreshold;
      const segmentProgress = 1 - (usedMoves - threeStarsThreshold) / segmentSize;
      return 0.33 + segmentProgress * 0.33;
    }
    if (usedMoves < totalMoves) {
      const segmentSize = totalMoves - twoStarsThreshold;
      const segmentProgress = 1 - (usedMoves - twoStarsThreshold) / segmentSize;
      return segmentProgress * 0.33;
    }
    return 0;
  }
  //    
  static calculateLevelMultiplier(levelNumber) {
    const saturation = 1 - Math.exp(-levelNumber / 30);
    return 1 + saturation * 2;
  }
  //    
  static calculateCoinReward(levelNum, stars) {
    const baseReward = _G.coinRewardForStars[stars];
    const multiplier = _G.calculateLevelMultiplier(levelNum);
    return AnMath.floorToMultiple(baseReward * multiplier, 5);
  }
  //     levels 
  static calculateForLevels(levels, stars) {
    let total = 0;
    for (let i3 = 1; i3 <= levels; i3++) {
      total += _G.calculateCoinReward(i3, stars);
    }
    return total;
  }
  //         
  static evalTotalRewardForLevels(levels = 100) {
    return {
      min: _G.calculateForLevels(levels, 1),
      avg: _G.calculateForLevels(levels, 2),
      max: _G.calculateForLevels(levels, 3)
    };
  }
  //     
  static calcColorCostByID(id) {
    if (id > 0)
      return AnMath.ceilToMultiple(AnMath.remap(id, 1, gameColorsArray.length - 1, 20, 500), 5);
    return 0;
  }
  //     
  static calcThemeCostByID(id) {
    if (id > 0)
      return AnMath.ceilToMultiple(AnMath.remap(id, 1, gameThemesArray.length - 1, 150, 1500), 5);
    return 0;
  }
};
// +++ DEV MODE +++
//     
_G.dev_preloaderSkipExitAnimations = true;
//         
_G.dev_startWithFullReset = false;
//       
_G.dev_disableMenuInfo = true;
//   
_G.dev_forceFirstRun = false;
//    
_G.dev_forceNoMusic = true;
//     
_G.dev_totalMovesInfinity = false;
//      
_G.dev_showAllPossibleChains = false;
// +++     +++
//      
_G.adsCooldownMin = 5;
//      (game monetize )
_G.adsShowAfterLoading = false;
//     
_G.musicStreaming = false;
//!   ,  
//    " ",   -   
_G.moreGamesURL = "";
//"https://olegantipov.com/";
//    
_G.btnDoubleReward = false;
//    
_G.btnMoreMoves = false;
//   
_G.forceLowQulity = false;
// +++ +++ +++ +++
//      
_G.storageName = "ChainAndGainData";
//     
_G.predefinedLevels = 16;
//  -   
_G.cellsTotalCount = 72;
//  -   
_G.UIBackgroundTransparent = 0.5;
//       ( , ..   )
_G.specialsSpreyPaint = false;
//     
_G.applySpecialsByDiagonals = false;
//     
_G.applyCellModifiersByDiagonals = false;
//     ( ),       
_G.stonesCrushBellowBlock = true;
//   ,    
_G.specialBlockDropChance = 0.1;
// 10%
//     (  .  -  )
_G.propBlockDropChance = 0.8;
// 80%
//       ,   
_G.removeLastLineAfterMove = false;
//   ,     
_G.continueMoreMoves = 5;
//     >=  
_G.specialBlockForLongChain = 7;
//    X 
_G.chestDropEachMoves = 5;
//         
_G.totalMovesMultipler = 2;
//        
// perfectMoves * totalMovesMultipler + totalMovesAddMoves
_G.totalMovesAddMore = 5;
//        3 
_G.threeStarsPerc = 0.5;
//        2 
_G.twoStarsPerc = 0.75;
//      0   1 
_G.zeroStarsForComplete = false;
//     
_G.coinRewardForStars = [0, 10, 25, 50];
//public static readonly coinRewardForStars: number[] = [20, 100, 250, 500];
//  ,      
_G.useCancelSelectionByTop = false;
//    
_G.chestBonusMovesCount = 3;
//    
_G.chestBonusCoinsCount = 10;
//    
_G.chestBonusPropsCount = 5;
//        
_G.maxChanceDropPropTypeCount = 5;
//      
_G.maxChanceDropPropType = 2;
//       ,   
_G.shopShowForwardColorItems = 4;
//       ,   
_G.shopShowForwardThemeItems = 4;
var G = _G;

// games/packer/src/game/Block.ts
var BonusSpecBlockTypeArray = [
  "spec_bomb",
  "spec_dice",
  "spec_rainbow",
  "spec_mirror",
  "spec_chest",
  "spec_rocket_horizontal",
  "spec_rocket_vertical",
  "spec_rocket_diagonal1",
  "spec_rocket_diagonal2"
];
var SpecBlockTypeArray = [...BonusSpecBlockTypeArray, "spec_heart", "spec_stone"];
var PropBlockTypeArray = [
  "prop_0",
  "prop_1",
  "prop_2",
  "prop_3",
  "prop_4",
  "prop_5",
  "prop_6"
];
var Block = class extends enhance(AnUIGroupElement).with(AnUpdatableMixin) {
  constructor(config2) {
    config2.anchor = config2.anchor ?? AnAnchor.Center;
    super(config2);
    this.selectorSpecial = null;
    this._gridPos = new GridPos(0, 0);
    this._targetPos = new GridPos(0, 0);
    this.tweenPic = null;
    this.tweenPicTypeChange = null;
    this.tweenSelector1 = null;
    this.tweenSelector2 = null;
    this.tweenSelectorSpecial = null;
    this.tweenPos = null;
    this.selector1_update = null;
    this.selector2_update = null;
    this._canMove = false;
    this._highlighted = false;
    this._selected = false;
    //    -     
    this.activatedType = null;
    //    -    
    this.activatedBlocks = null;
    //     
    this.activatedAndPainted = false;
    //    ,      
    this._removed = false;
    if (config2.updater) this.addToUpdater(config2.updater);
    this.theme = config2.theme ?? null;
    this.scaledWidth = CellSize;
    this.scaledHeight = CellSize;
    this._type = config2.type;
    this._gridPos.set(config2.pos);
    this._targetPos.set(config2.pos);
    const { x: x2, y: y2 } = config2.pos.toPixelPos();
    this.position.set(x2, y2);
    this.selector1 = new AnImage(
      {
        atlas: "atlases/game.ss.pixi.atlas",
        sprite: "./selector",
        anchor: AnAnchor.Center
        //   ,    
      }
    );
    this.selector1.position.set(CellHalfSize, CellHalfSize);
    this.addUIElement("selector1", this.selector1);
    this.selector2 = new AnImage(
      {
        atlas: "atlases/game.ss.pixi.atlas",
        sprite: "./selector",
        anchor: AnAnchor.Center
        //   ,    
      }
    );
    this.selector2.position.set(CellHalfSize, CellHalfSize);
    this.addUIElement("selector2", this.selector2);
    this.selector1.visible = this.selector2.visible = false;
    this.selector1.blendMode = G.forceLowQulity ? "normal" : "add";
    this.selector2.blendMode = G.forceLowQulity ? "normal" : "add";
    if (config2.selectionLayer) {
      config2.selectionLayer.attach(this.selector1);
      config2.selectionLayer.attach(this.selector2);
    }
    this.addToCleanup(() => {
      if (this.selector1_update) {
        this.selector1_update.removeFromUpdater();
        this.selector1_update = null;
      }
      if (this.selector2_update) {
        this.selector2_update.removeFromUpdater();
        this.selector2_update = null;
      }
    });
    this.pic = new AnImage(
      {
        atlas: "atlases/game.ss.pixi.atlas",
        sprite: `./${this._type}` + (this.theme ? `_${this.theme}` : ""),
        anchor: AnAnchor.Center
        //   ,    
      }
    );
    this.pic.position.set(CellHalfSize, CellHalfSize);
    this.addUIElement("pic", this.pic);
    if (config2.blockLayer)
      config2.blockLayer.attach(this.pic);
    if (this.special) {
      const durationAnim = 3;
      let addSpecialTweenAnim = true;
      if (this.specialStone) {
        addSpecialTweenAnim = false;
      }
      if (addSpecialTweenAnim) {
        this.tweenPic = new AnTween({
          target: this.pic,
          from: { scale: { x: 1, y: 1 } },
          to: { scale: { x: 1.15, y: 1.15 } },
          duration: durationAnim,
          easing: AnEase.easeInOut,
          repeat: Infinity,
          reverse: true,
          updater: this.getUpdater()
        });
      }
      this.selectorSpecial = new AnImage(
        {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./selectorSpecial",
          anchor: AnAnchor.Center
          //   ,    
        }
      );
      if (addSpecialTweenAnim) {
        this.tweenSelectorSpecial = new AnTween({
          target: this.selectorSpecial,
          from: { alpha: 0.6, scale: { x: 3.5, y: 3.5 } },
          to: { alpha: 0.7, scale: { x: 4.5, y: 4.5 } },
          duration: durationAnim,
          easing: AnEase.easeInOutBack,
          repeat: Infinity,
          reverse: true,
          updater: this.getUpdater()
        });
      }
      this.addUIElement("selectorSpecial", this.selectorSpecial);
      this.selectorSpecial.blendMode = G.forceLowQulity ? "normal" : "add";
      if (config2.selectionLayer)
        config2.selectionLayer.attach(this.selectorSpecial);
      this.selectorSpecial.position.set(this.pic.x, this.pic.y);
    }
    if (!config2.skipCreatingAnim) {
      const makeMarkableAnim = this.specialStone || this.specialHeart || (config2.makeMarkableAnim ?? false);
      let sndBlockPlayed = false;
      const snd_name = this.specialStone ? `stone` : this.specialHeart ? `heart` : ``;
      new AnTween({
        target: this,
        from: { alpha: 0, scale: makeMarkableAnim ? { x: 2, y: 2 } : { x: 0.4, y: 0.4 }, position: { x: this.x, y: this.y - 80 } },
        //to: { alpha: 1, scale: { x: 0.9, y: 0.9 } },
        to: { alpha: 1, scale: { x: 1, y: 1 }, position: { x: this.x, y: this.y } },
        tolerance: makeMarkableAnim ? 0.1 : 0.3,
        duration: makeMarkableAnim ? 1.5 : 0.4,
        delay: config2.delayCreatingAnim ?? 0,
        easing: makeMarkableAnim ? AnEase.easeOutBounce : AnEase.easeOutBack,
        updater: this.getUpdater(),
        callbacks: {
          onUpdate: (tween, progress) => {
            if (snd_name.length && progress > 0.5 && !sndBlockPlayed) {
              sndBlockPlayed = true;
              AnSounds.play(
                `sounds/${snd_name}.snd.mp3`,
                AnRnd.float(0.4, 0.6),
                AnMath.remapClamp(this._gridPos.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
                AnRnd.float(0.9, 1.1)
              );
            }
          },
          onComplete: () => this._canMove = true
        }
      });
    } else
      this._canMove = true;
    this.addToCleanup(() => {
      this.tweenPic?.terminate();
      this.tweenPicTypeChange?.terminate();
      this.tweenPos?.terminate();
      this.tweenSelector1?.terminate();
      this.tweenSelector2?.terminate();
      this.tweenSelectorSpecial?.terminate();
    });
    this.addToCleanup(AnEvents.on(
      "storage:theme:update",
      (e2) => this.onSettingsThemeUpdate(e2.data.value)
    ).unsub);
  }
  onSettingsThemeUpdate(theme) {
    if (this.prop && this.type != "prop_heart") {
      this.theme = theme;
      this.updatePic();
    }
  }
  prepareToApply() {
    this.highlighted = false;
    if (!this.selector1.destroyed) {
      this.selector1.visible = false;
      this.selector1.parentRenderLayer.detach(this.selector1);
    }
    if (!this.selector2.destroyed) {
      this.selector2.visible = false;
      this.selector2.parentRenderLayer.detach(this.selector2);
    }
    if (this.selectorSpecial && !this.selectorSpecial.destroyed) {
      this.selectorSpecial.visible = false;
      this.selectorSpecial.parentRenderLayer.detach(this.selectorSpecial);
    }
    if (!this.pic.destroyed) {
      this.pic.parentRenderLayer.detach(this.pic);
    }
    this.tweenPos?.stop();
  }
  //    ,        
  markAsRemoved() {
    this._removed = true;
  }
  get removed() {
    return this._removed;
  }
  get moving() {
    return this.tweenPos?.running ?? false;
  }
  get type() {
    return this._type;
  }
  showSelectors() {
    this.selector1.renderable = true;
    this.selector2.renderable = true;
  }
  hideSelectors() {
    this.selector1.renderable = false;
    this.selector2.renderable = false;
  }
  setTypeNoAnim(type) {
    if (this._type === type) return;
    this._type = type;
    this.updatePic();
  }
  updatePic() {
    this.pic.changeTexture("./" + this._type + (this.prop ? `_${this.theme}` : ""), "atlases/game.ss.pixi.atlas");
  }
  set type(type) {
    if (this._type === type) return;
    this._type = type;
    if (this.tweenPicTypeChange) {
      this.tweenPicTypeChange.finish();
      this.tweenPicTypeChange.terminate();
      this.tweenPicTypeChange = null;
    }
    this.tweenPicTypeChange = new AnTween({
      target: this.pic,
      from: { alpha: 1, rotation: 0 },
      to: { alpha: 0, rotation: Math.PI },
      duration: 1,
      easing: AnEase.easeInElastic,
      updater: this.getUpdater(),
      callbacks: {
        onComplete: () => {
          if (this.tweenPicTypeChange) {
            this.tweenPicTypeChange.terminate();
            this.tweenPicTypeChange = null;
          }
          this.pic.changeTexture("./" + this._type + (this.prop ? `_${this.theme}` : ""), "atlases/game.ss.pixi.atlas");
          this.tweenPicTypeChange = new AnTween({
            target: this.pic,
            from: { alpha: 0, rotation: Math.PI },
            to: { alpha: 1, rotation: 0 },
            duration: 0.5,
            easing: AnEase.easeOutBack,
            updater: this.getUpdater()
          });
        }
      }
    });
  }
  get canMoveNotHighlighted() {
    return this._canMove && !this.highlighted;
  }
  get canMove() {
    return this._canMove;
  }
  get selected() {
    return this._selected;
  }
  set selected(value) {
    this._selected = value;
  }
  get highlighted() {
    return this._highlighted;
  }
  set highlighted(value) {
    if (this._highlighted === value) return;
    this._highlighted = value;
    if (this.tweenPic) {
      this.tweenPic.finish();
      this.tweenPic.terminate();
      this.tweenPic = null;
    }
    if (this.tweenSelector1) {
      this.tweenSelector1.finish();
      this.tweenSelector1.terminate();
      this.tweenSelector1 = null;
    }
    if (this.tweenSelectorSpecial) {
      this.tweenSelectorSpecial.finish();
      this.tweenSelectorSpecial.terminate();
      this.tweenSelectorSpecial = null;
    }
    if (this.tweenSelector2) {
      this.tweenSelector2.finish();
      this.tweenSelector2.terminate();
      this.tweenSelector2 = null;
    }
    const selectorScale = 1.45;
    const selectorAlpha = 0.4;
    const selectorRotationSpeed1 = 0.15;
    const selectorRotationSpeed2 = 0.15;
    if (this._highlighted) {
      this.tweenPic = new AnTween({
        target: this.pic,
        from: { scale: { x: 1, y: 1 } },
        to: { scale: { x: 1.25, y: 1.25 } },
        duration: 1,
        easing: AnEase.easeOutElastic,
        updater: this.getUpdater()
      });
      this.selector1.visible = true;
      this.tweenSelector1 = new AnTween({
        target: this.selector1,
        from: { alpha: 0, scale: { x: 0.2, y: 0.2 } },
        to: { alpha: selectorAlpha, scale: { x: selectorScale, y: selectorScale } },
        duration: 1,
        easing: AnEase.easeOutBack,
        updater: this.getUpdater()
      });
      this.selector1_update = new AnTask({
        handler: (dt) => this.selector1.rotation += selectorRotationSpeed1 * dt,
        updater: this.getUpdater()
      });
      this.selector2.visible = true;
      this.tweenSelector2 = new AnTween({
        target: this.selector2,
        from: { alpha: 0, scale: { x: 0.2, y: 0.2 } },
        to: { alpha: selectorAlpha, scale: { x: selectorScale, y: selectorScale } },
        duration: 1,
        easing: AnEase.easeOutBack,
        updater: this.getUpdater()
      });
      this.selector2_update = new AnTask({
        handler: (dt) => this.selector2.rotation -= selectorRotationSpeed2 * dt,
        updater: this.getUpdater()
      });
    } else {
      this.tweenPic = new AnTween({
        target: this.pic,
        to: { scale: { x: 1, y: 1 } },
        from: { scale: { x: 1.25, y: 1.25 } },
        duration: 1,
        easing: AnEase.easeOut,
        updater: this.getUpdater()
      });
      this.tweenSelector1 = new AnTween({
        target: this.selector1,
        to: { alpha: 0, scale: { x: 0.2, y: 0.2 } },
        from: { alpha: selectorAlpha, scale: { x: selectorScale, y: selectorScale } },
        duration: 1,
        easing: AnEase.easeOut,
        updater: this.getUpdater(),
        callbacks: {
          onComplete: () => this.selector1.visible = false
        }
      });
      if (this.selector1_update) {
        this.selector1_update.removeFromUpdater();
        this.selector1_update = null;
      }
      this.tweenSelector2 = new AnTween({
        target: this.selector2,
        to: { alpha: 0, scale: { x: 0.2, y: 0.2 } },
        from: { alpha: selectorAlpha, scale: { x: selectorScale, y: selectorScale } },
        duration: 1,
        easing: AnEase.easeOut,
        updater: this.getUpdater(),
        callbacks: {
          onComplete: () => this.selector2.visible = false
        }
      });
      if (this.selector2_update) {
        this.selector2_update.removeFromUpdater();
        this.selector2_update = null;
      }
    }
  }
  updateGridPos(row, col) {
    this._gridPos.row = row;
    this._gridPos.col = col;
  }
  calcGridPos() {
    return new GridPos(
      Math.floor(this.position.y / CellSize),
      // - CellHalfSize),
      Math.floor(this.position.x / CellSize)
      // - CellHalfSize),
    );
  }
  syncGridPosWithPixelPos() {
    const pos = this.calcGridPos();
    this._gridPos.set(pos);
    this._targetPos.set(pos);
  }
  //   
  get special() {
    return this._type.startsWith("spec_");
  }
  get specialStone() {
    return this._type.startsWith("spec_stone");
  }
  get specialHeart() {
    return this._type.startsWith("spec_heart");
  }
  get specialRocket() {
    return this._type.startsWith("spec_rocket");
  }
  get specialBomb() {
    return this._type.startsWith("spec_bomb");
  }
  get specialRainbow() {
    return this._type.startsWith("spec_rainbow");
  }
  get specialDice() {
    return this._type.startsWith("spec_dice");
  }
  get specialMirror() {
    return this._type.startsWith("spec_mirror");
  }
  get specialChest() {
    return this._type.startsWith("spec_chest");
  }
  //   
  get prop() {
    return this._type.startsWith("prop_");
  }
  get gridPos() {
    return this._gridPos;
  }
  get targetPos() {
    return this._targetPos;
  }
  moveTo(pos, dropAnims = false) {
    const oldPos = this._gridPos;
    const newPos = pos;
    this._targetPos.set(pos);
    if (this.tweenPos)
      this.tweenPos.terminate();
    const duration = (newPos.row - oldPos.row) * (dropAnims ? 0.35 : 0.3);
    let sndBlockPlayed = false;
    this.tweenPos = new AnTween({
      target: this,
      from: { position: oldPos.toPixelPos() },
      to: { position: newPos.toPixelPos() },
      duration,
      delay: dropAnims ? AnRnd.float(0, 0.2) : 0,
      //easing: duration >= 1.5 ? AnEase.easeOutBounce : (duration <= 0.5 ? AnEase.easeOut : AnEase.easeOutBack),
      easing: dropAnims ? AnEase.easeOutBounce : AnEase.easeOutBack,
      updater: this.getUpdater(),
      callbacks: {
        onUpdate: (tween, progress) => {
          const pos2 = this.calcGridPos();
          this._gridPos.set(pos2);
          if (progress > 0.5 && !sndBlockPlayed) {
            sndBlockPlayed = true;
            AnSounds.play(
              `sounds/block0${AnRnd.int(1, 5)}.snd.mp3`,
              AnRnd.float(0.4, 0.6) * 0.5,
              AnMath.remapClamp(pos2.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
              AnRnd.float(0.9, 1.1)
            );
          }
        },
        onComplete: () => {
          this._gridPos.set(newPos);
        }
      }
    });
  }
};

// angine/src/utils/AnTimer.ts
init_define_AnParams();
var AnTimer = class extends enhance(Object).with(AnUpdatableMixin) {
  //  
  /**
   *  
   * @param config -  
   */
  constructor(config2) {
    super();
    //     
    this._elapsed = 0;
    //     
    this._running = false;
    //   
    this._paused = false;
    this._duration = config2.duration;
    this._loopCount = config2.loopCount ?? 0;
    this._initialLoopCount = this._loopCount;
    this._autoRemove = config2.autoRemove ?? true;
    this._callbacks = config2.callbacks ?? {};
    let autoStart = config2.autoStart ?? true;
    if (config2.updater) this.addToUpdater(config2.updater);
    if (autoStart) this.start();
  }
  /**
   *    
   */
  get callbacks() {
    return this._callbacks;
  }
  /**
   *    
   */
  start() {
    if (this._running || !this.getUpdater()) return;
    this._running = true;
    this._paused = false;
    this._callbacks.onStart?.(this);
  }
  /**
   *   ( )
   */
  stop() {
    if (!this._running) return;
    this._running = false;
    this._callbacks.onStop?.(this);
    if (this._autoRemove) this.removeFromUpdater();
  }
  /**
   *    
   */
  pause() {
    if (!this._running || this._paused || !this.getUpdater()) return;
    this._paused = true;
    this._callbacks.onPause?.(this);
  }
  /**
   *     
   */
  resume() {
    if (!this._running || !this._paused || !this.getUpdater()) return;
    this._paused = false;
    this._callbacks.onResume?.(this);
  }
  /**
   *    
   */
  reset() {
    this._elapsed = 0;
    this._loopCount = this._initialLoopCount;
    this.stop();
  }
  /**
   *   ,   AnUpdater
   * @param dt -    
   */
  update(dt) {
    if (!this._running || this._paused) return;
    this._elapsed += dt;
    this._callbacks.onUpdate?.(this._elapsed);
    if (this._elapsed >= this._duration) {
      this._callbacks.onComplete?.(this);
      if (this._loopCount > 0) {
        this._loopCount--;
        this._elapsed = 0;
        this._callbacks.onStart?.(this);
      } else {
        this.stop();
      }
    }
  }
  // =====================
  //   
  // =====================
  /**   ( 0  1) */
  get progress() {
    return this._elapsed / this._duration;
  }
  /**    */
  get running() {
    return this._running;
  }
  /**     */
  get paused() {
    return this._paused;
  }
  /**     */
  get elapsed() {
    return this._elapsed;
  }
  /**     */
  get remaining() {
    return this._duration - this._elapsed;
  }
  terminate() {
    this._callbacks = {};
    this.removeFromUpdater();
  }
};

// angine/src/ui/AnFX.ts
init_define_AnParams();
var AnFX = class extends AnImage {
  constructor(config2) {
    super(config2);
    this.entranceTweenConfig = null;
    this.loopTweenConfig = null;
    this.exitTweenConfig = null;
    this.currentTween = null;
    this.isPlaying = false;
    this.autoTerminate = false;
    this.updater = null;
    if (config2.updater) this.updater = config2.updater;
    this.autoTerminate = config2.autoTerminate ?? true;
    if (config2.entranceTween)
      this.entranceTweenConfig = config2.entranceTween;
    if (config2.loopTween)
      this.loopTweenConfig = config2.loopTween;
    if (config2.exitTween)
      this.exitTweenConfig = config2.exitTween;
    this.addToCleanup(() => this.cleanupTween());
    if (config2.autoPlay !== false) {
      this.play();
    }
  }
  /**
   *   
   */
  play() {
    if (this.isPlaying) return;
    this.isPlaying = true;
    this.playEntrance();
  }
  /**
   *   
   */
  playEntrance() {
    if (!this.entranceTweenConfig) {
      this.playLoop();
      return;
    }
    this.cleanupTween();
    this.currentTween = new AnTween({
      ...this.entranceTweenConfig,
      target: this,
      updater: this.updater,
      callbacks: {
        ...this.entranceTweenConfig.callbacks,
        //       
        onComplete: () => {
          this.entranceTweenConfig?.callbacks?.onComplete?.(this.currentTween);
          this.playLoop();
        }
      }
    });
  }
  /**
   *   
   */
  playLoop() {
    if (!this.loopTweenConfig) {
      this.playExit();
      return;
    }
    this.cleanupTween();
    this.currentTween = new AnTween({
      ...this.loopTweenConfig,
      target: this,
      updater: this.updater,
      callbacks: {
        ...this.loopTweenConfig.callbacks,
        //       
        onComplete: () => {
          this.loopTweenConfig?.callbacks?.onComplete?.(this.currentTween);
          this.playExit();
        }
      }
    });
  }
  /**
   *   
   */
  playExit() {
    if (!this.exitTweenConfig) {
      this.finish();
      return;
    }
    this.cleanupTween();
    this.currentTween = new AnTween({
      ...this.exitTweenConfig,
      target: this,
      updater: this.updater,
      callbacks: {
        ...this.exitTweenConfig.callbacks,
        //       
        onComplete: () => {
          this.exitTweenConfig?.callbacks?.onComplete?.(this.currentTween);
          this.finish();
        }
      }
    });
  }
  /**
   *      
   */
  finish() {
    this.isPlaying = false;
    if (this.autoTerminate)
      this.terminate();
  }
  /**
   *  
   */
  cleanupTween() {
    if (this.currentTween) {
      this.currentTween.terminate();
      this.currentTween = null;
    }
  }
};

// games/packer/src/game/FieldSpecialsMixin.ts
init_define_AnParams();

// games/packer/src/game/Cell.ts
init_define_AnParams();
var Cell = class _Cell extends enhance(AnUIGroupElement).with(AnUpdatableMixin) {
  constructor(config2) {
    super(config2);
    this.modifierPic = null;
    this.highlightPic = null;
    this.highlightPicTween = null;
    this._gridPos = new GridPos(0, 0);
    this._block = null;
    this._modifiers = 0 /* None */;
    this.cellModifierLayer = null;
    if (config2.updater) this.addToUpdater(config2.updater);
    this._gridPos.set(config2.pos);
    const { x: x2, y: y2 } = config2.pos.toPixelPos();
    this.position.set(x2, y2);
    this.cellModifierLayer = config2.cellModifierLayer ?? null;
    if (config2.modifiers) {
      this._modifiers = 0 /* None */;
      for (const modifier of config2.modifiers)
        this._modifiers |= modifier;
    }
    this._grid = new AnImage({
      atlas: "atlases/game.ss.pixi.atlas",
      sprite: "./cell",
      anchor: AnAnchor.Center
    });
    this.addUIElement(this._grid);
    this._grid.alpha = G.UIBackgroundTransparent;
    this.highlightPic = new AnImage({
      atlas: "atlases/game.ss.pixi.atlas",
      sprite: "./cellHighlighted",
      anchor: AnAnchor.Center
    });
    this.addUIElement(this.highlightPic);
    this.highlightPic.visible = false;
    const tween = new AnTween({
      target: this,
      from: { alpha: 0, scale: { x: 0.5, y: 0.5 } },
      to: { alpha: 1, scale: { x: 1, y: 1 } },
      tolerance: 0.2,
      delay: (this._gridPos.row + this._gridPos.col) * 0.1,
      duration: 1.2,
      easing: AnEase.easeOutElastic,
      updater: this.getUpdater()
    });
    if (config2.onAnimInitialCellComplete)
      tween.callbacks.onComplete = config2.onAnimInitialCellComplete;
    this.updateVisualModifiers();
    this.addToCleanup(() => this.highlightPicTween?.terminate());
    this.addToCleanup(AnEvents.on(
      "storage:color:update",
      (e2) => this.onSettingsColorUpdate(e2.data.value)
    ).unsub);
  }
  onSettingsColorUpdate(color) {
    if (this.hasModifier(1 /* Paint */)) {
      this._grid.tint = _Cell.getCellPaintedColor(GameColorsDB[color].baseColorTint);
    }
  }
  /**      */
  get block() {
    return this._block;
  }
  /**     */
  set block(value) {
    this._block = value;
  }
  /**     */
  get modifiers() {
    return this._modifiers;
  }
  /**    */
  hasModifier(modifier) {
    return (this._modifiers & modifier) === modifier;
  }
  /**   */
  addModifier(modifier) {
    if (this.hasModifier(modifier)) return;
    if (modifier === 1 /* Paint */) {
      const tween = new AnTween({
        target: this,
        from: { alpha: 0, scale: { x: 0.5, y: 0.5 } },
        to: { alpha: 1, scale: { x: 1, y: 1 } },
        duration: 1.2,
        easing: AnEase.easeOutElastic,
        updater: this.getUpdater()
      });
    }
    this._modifiers |= modifier;
    this.updateVisualModifiers();
  }
  /**    */
  addModifiers(mods) {
    for (const mod of mods)
      this.addModifier(mod);
  }
  /**   */
  removeModifier(modifier) {
    if (!this.hasModifier(modifier)) return;
    this._modifiers &= ~modifier;
    this.updateVisualModifiers();
  }
  updateVisualModifiers() {
    if (this.hasModifier(1 /* Paint */)) {
      this._grid.changeTexture("./cellPainted", "atlases/game.ss.pixi.atlas");
      this._grid.alpha = 1;
      this.onSettingsColorUpdate(GameApp.self.gameData.color);
    } else {
      this._grid.changeTexture("./cell", "atlases/game.ss.pixi.atlas");
      this._grid.alpha = G.UIBackgroundTransparent;
    }
    if (this.hasModifier(2 /* Cage */)) {
      if (this.modifierPic) {
        this.terminateUIElement(this.modifierPic);
        this.modifierPic = null;
      }
      this.modifierPic = new AnImage({
        atlas: "atlases/game.ss.pixi.atlas",
        sprite: "./cellCage",
        anchor: AnAnchor.Center
      });
      this.addUIElement(this.modifierPic);
      this.cellModifierLayer?.attach(this.modifierPic);
    } else {
      if (this.modifierPic) {
        const modifierPic = this.modifierPic;
        const tween = new AnTween({
          target: modifierPic,
          from: { alpha: 4, rotation: 0, position: { x: modifierPic.x, y: modifierPic.y } },
          to: { alpha: 0, rotation: AnRnd.float(-2 * Math.PI, 2 * Math.PI), position: { x: modifierPic.x + AnRnd.float(-CellSize * 2.5, CellSize * 2.5), y: modifierPic.y + CellSize * 5 } },
          duration: 1,
          easing: AnEase.easeInBack,
          updater: this.getUpdater(),
          callbacks: {
            onComplete: () => this.terminateUIElement(modifierPic)
          }
        });
        this.modifierPic = null;
      }
    }
  }
  activateHighlight() {
    if (this.highlightPicTween) {
      this.highlightPicTween.terminate();
      this.highlightPicTween = null;
    }
    this.highlightPicTween = new AnTween({
      target: this.highlightPic,
      from: { alpha: 1, scale: { x: 1, y: 1 } },
      to: { alpha: 0, scale: { x: 0.7, y: 0.7 } },
      duration: 1,
      easing: AnEase.linear,
      updater: this.getUpdater(),
      callbacks: {
        onStart: () => this.highlightPic.visible = true,
        onComplete: () => {
          this.highlightPic.visible = false;
          this.highlightPicTween = null;
        }
      }
    });
  }
  static getCellPaintedColor(color) {
    return getSplitComplementaryColors(color).color2;
  }
};

// games/packer/src/game/GameTutorialMixin.ts
init_define_AnParams();

// games/packer/src/platform/Platform.ts
init_define_AnParams();
function forbidAnalyticsForPlatform() {
  return ["gamepix" /* GamePix */].includes(Platform.type);
}
var Platform = { type: "standalone" /* Standalone */, sdk: null, visualName: null };
var PlatformBase = class {
  constructor() {
    this._initialized = false;
    //      
    this.onLoadProgress = null;
    // ===  ===
    this._lastTimeShown = uptime();
    this._adsCooldownSec = G.adsCooldownMin * 60;
  }
  get initialized() {
    return this._initialized;
  }
  get visualName() {
    return null;
  }
  //      (    play   )
  get lastPrepareToPlayEnded() {
    return true;
  }
  //      
  modifyGameParams(G2) {
  }
  // ===  ===
  get playerName() {
    return "";
  }
  //      
  get playerLoggedIn() {
    return false;
  }
  get currentLanguage() {
    return null;
  }
  // ===   (    ) ===
  sendScoreToLeaderboard(boardID, score) {
  }
  //     
  get canShowAds() {
    const currentCooldown = uptime() - this._lastTimeShown;
    const result = currentCooldown > this._adsCooldownSec;
    if (true) AnLog.debug(`[canShowAds] \u0441 \u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0435\u0439 \u0440\u0435\u043A\u043B\u0430\u043C\u044B \u043F\u0440\u043E\u0448\u043B\u043E ${currentCooldown / 60} \u043C\u0438\u043D. (\u0442\u0435\u043A\u0443\u0449\u0438\u0439 \u043A\u0443\u043B\u043B\u0434\u0430\u0443\u043D ${this._adsCooldownSec / 60} \u043C\u0438\u043D.) ${result ? " \u0440\u0435\u043A\u043B\u0430\u043C\u0443 \u043C\u043E\u0436\u043D\u043E \u043F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u043E\u043F\u044F\u0442\u044C" : " \u0440\u0435\u043A\u043B\u0430\u043C\u0443 \u043D\u0435\u043B\u044C\u0437\u044F \u043F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C"}`);
    return result;
  }
  showAds(type, callbacks) {
    if (type === "Fullscreen" /* Fullscreen */)
      this._lastTimeShown = uptime();
  }
  // ===   (   ) ===
  async loadData() {
    throw new Error("\u041E\u0431\u043B\u0430\u0447\u043D\u044B\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u043D\u0435 \u0440\u0435\u0430\u043B\u0438\u0437\u043E\u0432\u0430\u043D\u044B");
  }
  async saveData(data) {
    throw new Error("\u041E\u0431\u043B\u0430\u0447\u043D\u044B\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u043D\u0435 \u0440\u0435\u0430\u043B\u0438\u0437\u043E\u0432\u0430\u043D\u044B");
  }
  async clearData() {
    throw new Error("\u041E\u0431\u043B\u0430\u0447\u043D\u044B\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u043D\u0435 \u0440\u0435\u0430\u043B\u0438\u0437\u043E\u0432\u0430\u043D\u044B");
  }
  // ===     ===
  reportEvent(event, data) {
  }
};

// games/packer/src/api/Analytics.ts
init_define_AnParams();
var import_gameanalytics = __toESM(require_GameAnalytics_node(), 1);
//! remove duplicate enums !
var GAME_KEY = "5686b74dfde74f7d94a65ec8bc63c784";
var SECRET_KEY = "5d0d624a01aca2785541970ec175a605f9383936";
var NO_ANALYTICS_IN_DEVMODE = true;
function forbidAnalytics() {
  return NO_ANALYTICS_IN_DEVMODE || forbidAnalyticsForPlatform();
}
function sdkName() {
  return String(Platform.type).toLowerCase();
}
var Analytics = class {
  static init(config2) {
    if (forbidAnalytics()) return;
    const ver = `${"playdeck"} ${"1.0.0"}`;
    if (true)
      AnLog.debug(`\u0410\u043D\u0430\u043B\u0438\u0442\u0438\u043A\u0430 \u0440\u0430\u0431\u043E\u0442\u0430\u0435\u0442: ${ver}`);
    import_gameanalytics.GameAnalytics.configureBuild(ver);
    import_gameanalytics.GameAnalytics.configureAvailableResourceCurrencies(config2.currencies);
    import_gameanalytics.GameAnalytics.configureAvailableResourceItemTypes(config2.itemTypes);
    import_gameanalytics.GameAnalytics.initialize(GAME_KEY, SECRET_KEY);
    if (true)
      import_gameanalytics.GameAnalytics.setEnabledInfoLog(true);
  }
  // *********************** ADS ***********************
  static onRewardedAdShow(placement) {
    if (forbidAnalytics()) return;
    import_gameanalytics.GameAnalytics.addAdEvent(2 /* Show */, 2 /* RewardedVideo */, sdkName(), placement);
  }
  static onRewardedAdReceived(placement) {
    if (forbidAnalytics()) return;
    import_gameanalytics.GameAnalytics.addAdEvent(4 /* RewardReceived */, 2 /* RewardedVideo */, sdkName(), placement);
  }
  static onRewardedAdError(placement) {
    if (forbidAnalytics()) return;
    import_gameanalytics.GameAnalytics.addAdEvent(3 /* FailedShow */, 2 /* RewardedVideo */, sdkName(), placement);
  }
  static onFullscreenAdShow(placement) {
    if (forbidAnalytics()) return;
    import_gameanalytics.GameAnalytics.addAdEvent(2 /* Show */, 4 /* Interstitial */, sdkName(), placement);
  }
  static onFullscreenAdError(placement) {
    if (forbidAnalytics()) return;
    import_gameanalytics.GameAnalytics.addAdEvent(3 /* FailedShow */, 4 /* Interstitial */, sdkName(), placement);
  }
  // *********************** RESOURCE ***********************
  static onGetResource(resource, amount, type, item) {
    if (forbidAnalytics()) return;
    import_gameanalytics.GameAnalytics.addResourceEvent(1 /* Source */, resource, amount, type, item);
  }
  // type -     (weapons)
  // item -    (big_sword)
  static onLostResource(resource, amount, type, item) {
    if (forbidAnalytics()) return;
    import_gameanalytics.GameAnalytics.addResourceEvent(2 /* Sink */, resource, amount, type, item);
  }
  // *********************** PROGRESS ***********************
  static onLevelStart(level) {
    if (forbidAnalytics()) return;
    import_gameanalytics.GameAnalytics.addProgressionEvent(1 /* Start */, level);
  }
  static onLevelFail(level, score) {
    if (forbidAnalytics()) return;
    import_gameanalytics.GameAnalytics.addProgressionEvent(3 /* Fail */, level, void 0, void 0, score);
  }
  static onLevelComplete(level, score) {
    if (forbidAnalytics()) return;
    import_gameanalytics.GameAnalytics.addProgressionEvent(2 /* Complete */, level, void 0, void 0, score);
  }
  // *********************** CUSTOM ***********************
  // The eventId is a hierarchy string that can consist of 
  // 1 - 5 segments separated by :. Each segment can have 
  // a max length of 32.
  // e.g: StartGame:ClassLevel1_5
  // 
  // value - result in sum & mean values being available.
  static onEvent(event, value) {
    if (forbidAnalytics()) return;
    import_gameanalytics.GameAnalytics.addDesignEvent(event, value);
  }
};

// games/packer/src/game/GameTutorialMixin.ts
function GameTutorialMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      if (!(this instanceof Game))
        throw new Error("GameTutorialMixin \u043C\u043E\u0436\u0435\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u0442\u043E\u043B\u044C\u043A\u043E \u0441 \u043A\u043B\u0430\u0441\u0441\u043E\u043C Game!");
    }
    onShowTutorial() {
      const game = this;
      game.onTutorialSelectSpecials();
      switch (game.tutorial) {
        case "Chains" /* Chains */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText(() => {
                const name = Platform.sdk ? Platform.sdk.playerName : "";
                const hello = AnLang.get(name.length ? "tutorialMakeChainsHelloName" : "tutorialMakeChainsHello");
                const message = `${name.length ? hello.replace("%%name%%", name) : hello} ${AnLang.get("tutorialMakeChains")}`;
                return message;
              });
              game.tutorialPropType = "prop_1";
              break;
            case 1:
              game.dialogue.showText("tutorialTryDiagonals");
              game.tutorialPropType = "prop_4";
              game.field.hideFocus();
              break;
            case 2:
              game.dialogue.showText("tutorialCompleteTheLevel");
              game.field.hideFocus();
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => {
                game.dialogue.hideText(() => {
                  game.showTutorialArrow(() => {
                    return { x: game.goalProgress.x + game.goalProgress.scaledWidth * 0.5 - scaled(40), y: game.goalProgress.y - scaled(30) };
                  }, -Math.PI / 6);
                });
              });
              break;
          }
          break;
        case "Bombs" /* Bombs */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("tutorialTryBombSpec");
              game.tutorialPropType = "prop_4";
              break;
            case 1:
              game.dialogue.showText("tutorialTryBombSpecAgain");
              game.tutorialPropType = "prop_2";
              game.field.hideFocus();
              break;
            case 2:
              game.dialogue.showText("tutorialCompleteTheBombLevel");
              game.field.hideFocus();
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => game.dialogue.hideText());
              break;
          }
          break;
        case "Rockets" /* Rockets */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("tutorialTryTwoRockets");
              game.tutorialPropType = "prop_6";
              break;
            case 1:
              game.dialogue.showText("tutorialSpecialChains");
              game.tutorialPropType = "prop_0";
              game.field.hideFocus();
              break;
            case 2:
              game.dialogue.showText("tutorialLevelWithTypesCollect");
              game.field.hideFocus();
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => {
                game.dialogue.hideText(() => {
                  game.showTutorialArrow(() => {
                    return { x: game.goalCounters[1].x, y: game.goalCounters[1].y - scaled(30) };
                  }, -Math.PI / 8);
                });
              });
              break;
          }
          break;
        case "Cages" /* Cages */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("tutorialCageRemove");
              game.tutorialPropType = "prop_1";
              break;
            case 1:
              game.dialogue.showText("tutorialCageRemoveMore");
              game.tutorialPropType = "prop_4";
              game.field.hideFocus();
              break;
            case 2:
              game.dialogue.showText("tutorialCageCompleteLevel");
              game.field.hideFocus();
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => game.dialogue.hideText());
              break;
          }
          break;
        case "Mirrors" /* Mirrors */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("tutorialChooseMirror");
              game.tutorialPropType = "prop_2";
              break;
            case 1:
              game.dialogue.showText("tutorialActivateRocketWithMirror");
              game.tutorialPropType = "prop_5";
              game.field.hideFocus();
              break;
            case 2:
              game.dialogue.showText("tutorialMirrorCompleteLevel");
              game.field.hideFocus();
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => game.dialogue.hideText());
              break;
          }
          break;
        case "Stones" /* Stones */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("tutorialHardStones");
              game.tutorialPropType = "prop_1";
              break;
            case 1:
              game.dialogue.showText("tutorialHardStones2");
              game.tutorialPropType = "prop_3";
              game.field.hideFocus();
              break;
            case 2:
              game.dialogue.showText("tutorialStonesCompleteLevel");
              game.field.hideFocus();
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => game.dialogue.hideText());
              break;
          }
          break;
        case "Hearts" /* Hearts */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("tutorialHeartGoal");
              game.tutorialPropType = "prop_5";
              break;
            case 1:
              game.dialogue.showText("tutorialHeartGoal2");
              game.tutorialPropType = "prop_6";
              game.field.hideFocus();
              break;
            case 2:
              game.dialogue.showText("tutorialHeartCompleteLevel");
              game.field.hideFocus();
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => game.dialogue.hideText());
              break;
          }
          break;
        case "Rainbows" /* Rainbows */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("tutorialRainbow");
              game.tutorialPropType = "prop_0";
              break;
            case 1:
              game.dialogue.showText("tutorialRainbow2");
              game.tutorialPropType = "prop_3";
              game.field.hideFocus();
              break;
            case 2:
              game.dialogue.showText("tutorialRainbowCompleteLevel");
              game.field.hideFocus();
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => game.dialogue.hideText());
              break;
          }
          break;
        case "Painted" /* Painted */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("tutorialPainted1");
              game.tutorialPropType = "prop_4";
              break;
            case 1:
              game.dialogue.showText("tutorialPainted2");
              game.tutorialPropType = "prop_5";
              game.field.hideFocus();
              break;
            case 2:
              game.dialogue.showText("tutorialPaintedCompleteLevel");
              game.field.hideFocus();
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => game.dialogue.hideText());
              break;
          }
          break;
        case "Chests" /* Chests */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("tutorialChest1");
              game.tutorialPropType = "prop_6";
              break;
            case 1:
              game.dialogue.showText(() => AnLang.get("tutorialChest2").replace("%%moves%%", G.chestBonusMovesCount.toString()));
              game.tutorialPropType = "prop_1";
              game.field.hideFocus();
              break;
            case 2:
              game.dialogue.showText(() => AnLang.get("tutorialChestCompleteLevel").replace("%%moves%%", G.chestDropEachMoves.toString()));
              game.field.hideFocus();
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => game.dialogue.hideText());
              break;
          }
          break;
        case "Dices" /* Dices */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("tutorialDice");
              game.tutorialPropType = "prop_0";
              break;
            case 1:
              game.dialogue.showText("tutorialDice2");
              game.tutorialPropType = "prop_0";
              game.field.hideFocus();
              break;
            case 2:
              game.dialogue.showText("tutorialDiceCompleteLevel");
              game.field.hideFocus();
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => game.dialogue.hideText());
              break;
          }
          break;
        ////////////////////////////////////////////////////////
        case "Train1" /* Train1 */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText(() => AnLang.get("trainingBigChainSpecial").replace("%%moves%%", G.specialBlockForLongChain.toString()));
              game.tutorialPropType = "prop_3";
              break;
            case 1:
              game.dialogue.showText("trainingBigChainSpecial2");
              game.field.hideFocus();
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => game.dialogue.hideText());
              break;
          }
          break;
        case "Train2" /* Train2 */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("trainingMenuBuy");
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => {
                game.dialogue.hideText(() => {
                  game.showTutorialArrow(() => {
                    return { x: game.buttonInfo.x - game.buttonInfo.width * 0.5, y: game.buttonInfo.y };
                  }, -Math.PI / 2);
                });
              });
              break;
          }
          break;
        case "Train3" /* Train3 */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("trainingInterestingFact");
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => game.dialogue.hideText());
              break;
          }
          break;
        case "Train4" /* Train4 */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("trainingSpecialActivate");
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => game.dialogue.hideText());
              break;
          }
          break;
        case "Train5" /* Train5 */:
          switch (game.tutorialStage) {
            case 0:
              game.dialogue.showText("trainingEnd");
              runAfterSafe(game.dialogue.calculateDisplayTime(), game, () => game.dialogue.hideText());
              break;
          }
          break;
      }
    }
    onTutorialSetFocusPanel() {
      const game = this;
      let tutorialEnding = false;
      let poses = [];
      switch (game.tutorial) {
        case "Chains" /* Chains */:
          switch (game.tutorialStage) {
            case 0:
              poses = [new GridPos(0, 1), new GridPos(1, 1), new GridPos(2, 1), new GridPos(2, 2), new GridPos(2, 3), new GridPos(3, 3)];
              break;
            case 1:
              poses = [new GridPos(0, 0), new GridPos(1, 0), new GridPos(2, 1), new GridPos(3, 2), new GridPos(4, 3), new GridPos(5, 2)];
              break;
            case 2:
              tutorialEnding = true;
              break;
          }
          break;
        case "Bombs" /* Bombs */:
          switch (game.tutorialStage) {
            case 0:
              poses = [new GridPos(1, 1), new GridPos(1, 2), new GridPos(1, 3), new GridPos(2, 4), new GridPos(3, 4), new GridPos(4, 5)];
              break;
            case 1:
              poses = [new GridPos(1, 3), new GridPos(2, 3), new GridPos(2, 4), new GridPos(3, 2), new GridPos(3, 4)];
              break;
            case 2:
              tutorialEnding = true;
              break;
          }
          break;
        case "Rockets" /* Rockets */:
          switch (game.tutorialStage) {
            case 0:
              poses = [new GridPos(1, 4), new GridPos(1, 5), new GridPos(2, 2), new GridPos(2, 4), new GridPos(3, 2), new GridPos(3, 3), new GridPos(4, 2), new GridPos(5, 1)];
              break;
            case 1:
              poses = [new GridPos(0, 0), new GridPos(0, 2), new GridPos(0, 3), new GridPos(1, 0), new GridPos(2, 1), new GridPos(3, 2), new GridPos(3, 3)];
              break;
            case 2:
              tutorialEnding = true;
              break;
          }
          break;
        case "Cages" /* Cages */:
          switch (game.tutorialStage) {
            case 0:
              poses = [new GridPos(0, 5), new GridPos(1, 4), new GridPos(1, 5), new GridPos(2, 3), new GridPos(2, 5)];
              break;
            case 1:
              poses = [new GridPos(2, 2), new GridPos(2, 4), new GridPos(2, 5), new GridPos(3, 3), new GridPos(3, 4), new GridPos(3, 5), new GridPos(4, 3), new GridPos(4, 4)];
              break;
            case 2:
              tutorialEnding = true;
              break;
          }
          break;
        case "Mirrors" /* Mirrors */:
          switch (game.tutorialStage) {
            case 0:
              poses = [new GridPos(1, 5), new GridPos(2, 4), new GridPos(3, 4), new GridPos(4, 2), new GridPos(4, 3)];
              break;
            case 1:
              poses = [new GridPos(0, 1), new GridPos(0, 3), new GridPos(0, 5), new GridPos(1, 0), new GridPos(1, 1), new GridPos(1, 2), new GridPos(1, 3), new GridPos(1, 5), new GridPos(2, 0)];
              break;
            case 2:
              tutorialEnding = true;
              break;
          }
          break;
        case "Stones" /* Stones */:
          switch (game.tutorialStage) {
            case 0:
              poses = [new GridPos(2, 0), new GridPos(2, 1), new GridPos(3, 0), new GridPos(3, 1), new GridPos(4, 1), new GridPos(4, 2), new GridPos(4, 3), new GridPos(4, 4), new GridPos(5, 3)];
              break;
            case 1:
              poses = [new GridPos(0, 0), new GridPos(0, 1), new GridPos(1, 0), new GridPos(1, 2), new GridPos(1, 3), new GridPos(1, 4), new GridPos(2, 0)];
              break;
            case 2:
              tutorialEnding = true;
              break;
          }
          break;
        case "Hearts" /* Hearts */:
          switch (game.tutorialStage) {
            case 0:
              poses = [new GridPos(2, 1), new GridPos(3, 1), new GridPos(3, 2), new GridPos(4, 3), new GridPos(4, 4), new GridPos(5, 4), new GridPos(5, 5)];
              break;
            case 1:
              poses = [new GridPos(0, 2), new GridPos(0, 3), new GridPos(0, 4), new GridPos(0, 5), new GridPos(1, 1), new GridPos(1, 2), new GridPos(2, 0), new GridPos(2, 1), new GridPos(2, 2)];
              break;
            case 2:
              tutorialEnding = true;
              break;
          }
          break;
        case "Rainbows" /* Rainbows */:
          switch (game.tutorialStage) {
            case 0:
              poses = [new GridPos(1, 3), new GridPos(2, 3), new GridPos(3, 4), new GridPos(4, 4)];
              break;
            case 1:
              poses = [new GridPos(1, 0), new GridPos(1, 1), new GridPos(1, 2), new GridPos(1, 5), new GridPos(2, 0), new GridPos(2, 3), new GridPos(2, 4), new GridPos(2, 5)];
              break;
            case 2:
              tutorialEnding = true;
              break;
          }
          break;
        case "Painted" /* Painted */:
          switch (game.tutorialStage) {
            case 0:
              poses = [new GridPos(3, 0), new GridPos(3, 1), new GridPos(3, 2), new GridPos(4, 2), new GridPos(5, 3)];
              break;
            case 1:
              poses = [new GridPos(0, 3), new GridPos(1, 0), new GridPos(1, 4), new GridPos(2, 0), new GridPos(2, 1), new GridPos(2, 3), new GridPos(3, 2)];
              break;
            case 2:
              tutorialEnding = true;
              break;
          }
          break;
        case "Chests" /* Chests */:
          switch (game.tutorialStage) {
            case 0:
              poses = [new GridPos(1, 1), new GridPos(2, 1), new GridPos(3, 2), new GridPos(3, 3), new GridPos(4, 0), new GridPos(4, 1), new GridPos(5, 0)];
              break;
            case 1:
              poses = [new GridPos(1, 2), new GridPos(1, 3), new GridPos(2, 1), new GridPos(3, 1), new GridPos(3, 2), new GridPos(3, 3), new GridPos(4, 3)];
              break;
            case 2:
              tutorialEnding = true;
              break;
          }
          break;
        case "Dices" /* Dices */:
          switch (game.tutorialStage) {
            case 0:
              poses = [new GridPos(0, 1), new GridPos(0, 2), new GridPos(1, 2), new GridPos(2, 3), new GridPos(3, 3), new GridPos(3, 4)];
              break;
            case 1:
              break;
            case 2:
              tutorialEnding = true;
              break;
          }
          break;
        case "Train1" /* Train1 */:
          switch (game.tutorialStage) {
            case 0:
              poses = [new GridPos(1, 2), new GridPos(1, 3), new GridPos(2, 1), new GridPos(2, 2), new GridPos(3, 1), new GridPos(4, 1), new GridPos(5, 0)];
              break;
            case 1:
              tutorialEnding = true;
              break;
          }
          break;
        case "Train2" /* Train2 */:
        case "Train3" /* Train3 */:
        case "Train4" /* Train4 */:
        case "Train5" /* Train5 */:
          tutorialEnding = true;
          break;
      }
      if (tutorialEnding) {
        game.field.showHintMarkers = true;
        game.field.forbidAllSpecBlocks = false;
      } else {
        if (poses.length) {
          game.field.showFocus(poses);
          game.field.fillHintMarkersAndShow(poses, true);
        }
        this.onCheckAndFixTutorial();
      }
      if (game.tutorial !== "None" /* None */)
        Analytics.onEvent(`tutorial:${game.tutorial}:stage_${game.tutorialStage}`);
      game.tutorialStage++;
    }
    //      
    onCheckAndFixTutorial() {
      const game = this;
      if (game.tutorial !== "None" /* None */) {
        game.field.setFocusPropBlocksToType(game.tutorialPropType);
        //!      
        if (game.tutorial === "Mirrors" /* Mirrors */ && game.tutorialStage === 1) {
          const cell = game.field.getCell(1, 3 + game.field.startPresetCol);
          const mirror = cell?.block;
          if (mirror && mirror.type !== "spec_mirror") {
            const cellUnder = game.field.getCell(2, 3 + game.field.startPresetCol);
            const mirrorUnder = cellUnder?.block;
            if (mirrorUnder && mirrorUnder.type === "spec_mirror") {
              cell.block = mirrorUnder;
              cellUnder.block = mirror;
              const pos = mirror.position.clone();
              mirror.position.set(mirrorUnder.x, mirrorUnder.y);
              mirrorUnder.position.set(pos.x, pos.y);
              mirror.syncGridPosWithPixelPos();
              mirrorUnder.syncGridPosWithPixelPos();
              mirror.setTypeNoAnim("prop_0");
            }
          }
          const cell2 = game.field.getCell(0, 5 + game.field.startPresetCol);
          const rocket = cell2?.block;
          if (rocket && rocket.type !== "spec_rocket_vertical") {
            const cellUnder = game.field.getCell(2, 5 + game.field.startPresetCol);
            const rocketUnder = cellUnder?.block;
            if (rocketUnder && rocketUnder.type === "spec_rocket_horizontal") {
              cell2.block = rocketUnder;
              cellUnder.block = rocket;
              const pos = rocket.position.clone();
              rocket.position.set(rocketUnder.x, rocketUnder.y);
              rocketUnder.position.set(pos.x, pos.y);
              rocket.syncGridPosWithPixelPos();
              rocketUnder.syncGridPosWithPixelPos();
              rocket.setTypeNoAnim("prop_0");
            }
          }
        }
        //!   
        if (game.tutorial === "Stones" /* Stones */ && game.tutorialStage === 1) {
          const cell = game.field.getCell(0, 0 + game.field.startPresetCol);
          const stone = cell?.block;
          if (stone && stone.type !== "spec_stone") {
            const cellUnder = game.field.getCell(1, 0 + game.field.startPresetCol);
            const stoneUnder = cellUnder?.block;
            if (stoneUnder && stoneUnder.type === "spec_stone") {
              cell.block = stoneUnder;
              cellUnder.block = stone;
              const pos = stone.position.clone();
              stone.position.set(stoneUnder.x, stoneUnder.y);
              stoneUnder.position.set(pos.x, pos.y);
              stone.syncGridPosWithPixelPos();
              stoneUnder.syncGridPosWithPixelPos();
              game.field.blocksHintMarkers.forEach((marker) => {
                if (AnMath.floatEqual(marker.x, cell.x) && AnMath.floatEqual(marker.y, cell.y)) {
                  marker.position.set(cellUnder.x, cellUnder.y);
                }
              });
            }
          }
        }
      }
    }
    //      
    onTutorialSelectSpecials() {
      const game = this;
      if (game.tutorial !== "None" /* None */) {
        game.field.setFocusSpecialBlocksHighlighted();
      }
    }
  };
}

// games/packer/src/game/FieldSpecialsMixin.ts
function FieldSpecialsMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      if (!(this instanceof Field))
        throw new Error("FieldSpecialsMixin \u043C\u043E\u0436\u0435\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u0442\u043E\u043B\u044C\u043A\u043E \u0441 \u043A\u043B\u0430\u0441\u0441\u043E\u043C Field!");
    }
    activateStone(stone, destroyFunc) {
      const field = this;
      const pixelPos = stone.gridPos.toPixelPos();
      const debrisCount = 10;
      stone.renderable = false;
      AnSounds.play(
        `sounds/spec_stone0${AnRnd.int(1, 3)}.snd.mp3`,
        0.6,
        AnMath.remapClamp(stone.gridPos.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
        AnRnd.float(0.9, 1.1)
      );
      const blastCount = 3;
      for (let i3 = 0; i3 < blastCount; ++i3) {
        const maxScale = AnRnd.float(2, 3);
        const blastFX = new AnFX({
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./fxBlastMini",
          anchor: AnAnchor.Center,
          loopTween: {
            from: {
              alpha: 0.7,
              scale: { x: 0.6, y: 0.6 }
            },
            to: {
              alpha: 0,
              scale: { x: maxScale, y: maxScale }
            },
            duration: AnRnd.float(1, 2),
            easing: AnEase.easeOut
          },
          updater: field.getUpdater()
        });
        blastFX.position.set(pixelPos.x + AnRnd.float(-CellHalfSize * 0.5, CellHalfSize * 0.5), pixelPos.y + AnRnd.float(-CellHalfSize * 0.5, CellHalfSize * 0.5));
        blastFX.blendMode = G.forceLowQulity ? "normal" : "add";
        field.fxLayer.attach(blastFX);
        field.addGraphics(blastFX);
      }
      for (let i3 = 0; i3 < debrisCount; ++i3) {
        const targetPosX = AnRnd.float(-CellSize * 2.5, CellSize * 2.5);
        const targetPosY = AnRnd.float(-CellSize * 2.5, CellSize * 2.5);
        const debrisFX = new AnFX({
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./fxStoneDeb" + AnRnd.int(0, 3),
          anchor: AnAnchor.Center,
          loopTween: {
            from: { alpha: 3, scale: { x: AnRnd.float(0.3, 0.6), y: AnRnd.float(0.3, 0.6) }, rotation: 0, position: { x: pixelPos.x, y: pixelPos.y } },
            to: { alpha: 0, scale: { x: AnRnd.float(0.5, 1.2), y: AnRnd.float(0.5, 1.2) }, rotation: AnRnd.float(-Math.PI, Math.PI), position: { x: pixelPos.x + targetPosX, y: pixelPos.y + targetPosY } },
            duration: AnRnd.float(1, 2.5) * 0.6,
            easing: AnEase.easeOut
          },
          updater: field.getUpdater()
        });
        field.animLayer.attach(debrisFX);
        field.addGraphics(debrisFX);
      }
      AnEvents.emit("gameplay:other:apply", { type: "spec_stone", score: 1 });
      destroyFunc?.();
    }
    activateHeart(heart, destroyFunc) {
      const field = this;
      const block = new Block({
        pos: heart.gridPos,
        type: "prop_heart",
        skipCreatingAnim: true,
        updater: field.getUpdater(),
        selectionLayer: field.selectionLayer,
        blockLayer: field.blockLayer
      });
      AnSounds.play(
        `sounds/spec_heart.snd.mp3`,
        0.6,
        AnMath.remapClamp(heart.gridPos.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
        AnRnd.float(0.9, 1.1)
      );
      field.cells[heart.gridPos.row][heart.gridPos.col].block = block;
      field.blocks.push(block);
      field.addUIElement(block);
      field.applyBlock(block);
      const pixelPos = heart.gridPos.toPixelPos();
      const debrisCount = 25;
      for (let i3 = 0; i3 < debrisCount; ++i3) {
        const targetPosX = AnRnd.float(-CellSize * 2.5, CellSize * 2.5);
        const targetPosY = AnRnd.float(-CellSize * 2.5, CellSize * 2.5);
        const debrisFX = new AnFX({
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./fxChainDeb" + AnRnd.int(0, 5),
          anchor: AnAnchor.Center,
          loopTween: {
            from: { alpha: 3, scale: { x: AnRnd.float(0.6, 1), y: AnRnd.float(0.6, 1) }, rotation: 0, position: { x: pixelPos.x, y: pixelPos.y } },
            to: { alpha: 0, scale: { x: AnRnd.float(1, 1.2), y: AnRnd.float(1, 1.2) }, rotation: AnRnd.float(-Math.PI, Math.PI), position: { x: pixelPos.x + targetPosX, y: pixelPos.y + targetPosY } },
            duration: AnRnd.float(1, 2.5) * 0.6,
            easing: AnEase.easeOut
          },
          updater: field.getUpdater()
        });
        field.animLayer.attach(debrisFX);
        field.addGraphics(debrisFX);
      }
      heart.renderable = false;
      destroyFunc?.();
    }
    activateDice(dice, destroyFunc) {
      if (!dice.activatedType) {
        destroyFunc?.();
        return;
      }
      const pos = dice.gridPos;
      AnSounds.play(
        `sounds/spec_dice.snd.mp3`,
        0.6,
        AnMath.remapClamp(pos.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
        AnRnd.float(0.9, 1.1)
      );
      const field = this;
      const affectedBlocks = [];
      for (let row = 0; row < field.rowsCount; row++) {
        for (let col = 0; col < field.colsCount; col++) {
          const cell = field.getCell(row, col);
          if (cell) {
            const block = cell.block;
            if (block && block.prop && !block.highlighted && block.type !== dice.activatedType && !cell.hasModifier(2 /* Cage */)) {
              const rndSeed = field.colRndSeed[col];
              if (rndSeed.seed_bool(0.3)) {
                block.highlighted = true;
                affectedBlocks.push(block);
              }
            }
          }
        }
      }
      if (!affectedBlocks.length) {
        destroyFunc?.();
        return;
      }
      shuffle(affectedBlocks);
      let currentIndex = 0;
      new AnTimer({
        duration: 0.05,
        loopCount: affectedBlocks.length - 1,
        updater: field.getUpdater(),
        callbacks: {
          onComplete: () => {
            const block = affectedBlocks[currentIndex];
            if (G.specialsSpreyPaint)
              block.activatedAndPainted = dice.activatedAndPainted;
            const pixelPos = block.gridPos.toPixelPos();
            const miniBlastCount = 1;
            for (let i3 = 0; i3 < miniBlastCount; ++i3) {
              const diceFX = new AnFX({
                atlas: "atlases/game.ss.pixi.atlas",
                sprite: "./spec_dice",
                anchor: AnAnchor.Center,
                entranceTween: {
                  from: {
                    alpha: 0,
                    //rotation: 0,
                    scale: { x: 0.3, y: 0.3 }
                  },
                  to: {
                    alpha: 0.5,
                    //rotation: Math.PI / 8,
                    scale: { x: 1.3, y: 1.3 }
                  },
                  duration: 1,
                  easing: AnEase.easeOutBack
                },
                exitTween: {
                  to: {
                    alpha: 0,
                    //rotation: 0,
                    scale: { x: 0.3, y: 0.3 }
                  },
                  duration: 1,
                  easing: AnEase.easeInElastic,
                  callbacks: {
                    onComplete: () => {
                      block.highlighted = false;
                    }
                  }
                },
                updater: field.getUpdater()
              });
              block.type = dice.activatedType;
              const offsetX = i3 === 0 ? 0 : AnRnd.float(-CellSize * 0.5, CellSize * 0.5);
              const offsetY = i3 === 0 ? 0 : AnRnd.float(-CellSize * 0.5, CellSize * 0.5);
              diceFX.position.set(pixelPos.x + offsetX, pixelPos.y + offsetY);
              field.addGraphics(diceFX);
            }
            currentIndex++;
            if (currentIndex === affectedBlocks.length) {
              destroyFunc?.();
            }
          }
        }
      });
    }
    activateMirror(mirror, destroyFunc) {
      if (!mirror.activatedBlocks || mirror.activatedBlocks.length === 0) {
        destroyFunc?.();
        return;
      }
      const field = this;
      const mirrorPos = mirror.gridPos;
      const selectedBlocksPoses = mirror.activatedBlocks.map((block) => block.gridPos.clone());
      const posToRemoveH = [];
      const posToRemoveV = [];
      for (const pos of selectedBlocksPoses) {
        const hCol = mirrorPos.col + (mirrorPos.col - pos.col);
        const hRow = pos.row;
        if (!field.isOutOfBounds(hRow, hCol))
          posToRemoveH.push(new GridPos(hRow, hCol));
        const vCol = pos.col;
        const vRow = mirrorPos.row + (mirrorPos.row - pos.row);
        if (!field.isOutOfBounds(vRow, vCol))
          posToRemoveV.push(new GridPos(vRow, vCol));
      }
      if (posToRemoveH.length === 0 && posToRemoveV.length === 0) {
        destroyFunc?.();
        return;
      }
      const createConnectionLine = (gridPosFrom, gridPosTo) => {
        const colors2 = [10478316, 10678776, 9892093, 6083821, 11335676, 8449017, 12253437];
        const posFrom = gridPosFrom.toPixelPos();
        const posTo = gridPosTo.toPixelPos();
        AnSounds.play(
          `sounds/spec_mirror.snd.mp3`,
          0.6,
          AnMath.remapClamp(gridPosFrom.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
          AnRnd.float(0.9, 1.1)
        );
        const dx = posTo.x - posFrom.x;
        const dy = posTo.y - posFrom.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        const lineScale = (distance + CellSize * 0.2) / 256;
        const rndSeed = field.colRndSeed[gridPosFrom.col];
        const lineFX = new AnFX(
          {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./selectLine",
            anchor: AnAnchor.Center,
            loopTween: {
              from: { alpha: 0.3, scale: { y: 0.3, x: lineScale } },
              to: { alpha: 3, scale: { y: 1, x: lineScale } },
              tolerance: 0.2,
              duration: (2 - rndSeed.seed_float(0, 0.5)) / 2,
              easing: AnEase.easeOutElastic
            },
            exitTween: {
              from: { alpha: 2, scale: { y: 1, x: lineScale } },
              to: { alpha: 0, scale: { y: 0.1, x: lineScale } },
              tolerance: 0.2,
              duration: 0.8,
              easing: AnEase.easeOut
            },
            tint: colors2[AnRnd.int(0, colors2.length - 1)],
            updater: field.getUpdater()
          }
        );
        lineFX.scale.set(lineScale, 1);
        lineFX.rotation = angle;
        lineFX.position.set(posFrom.x + dx / 2, posFrom.y + dy / 2);
        lineFX.blendMode = G.forceLowQulity ? "normal" : "add";
        field.addGraphics(lineFX);
        field.fxLayer.attach(lineFX);
      };
      const makeMirrorConnections = (positions, andCallDestroyFunc = false) => {
        let currentIndex = 0;
        new AnTimer({
          duration: 0.1,
          loopCount: positions.length - 1,
          updater: field.getUpdater(),
          callbacks: {
            onComplete: () => {
              const gridPos = positions[currentIndex];
              let prevGridPos;
              if (currentIndex > 0)
                prevGridPos = positions[currentIndex - 1];
              if (prevGridPos)
                createConnectionLine(gridPos, prevGridPos);
              else
                createConnectionLine(gridPos, mirrorPos);
              const cell = field.getCell(gridPos.row, gridPos.col);
              if (cell) {
                const block = cell.block;
                if (block && !block.highlighted && !cell.hasModifier(2 /* Cage */)) {
                  if (G.specialsSpreyPaint)
                    block.activatedAndPainted = mirror.activatedAndPainted;
                  block.highlighted = true;
                  const pixelPos = gridPos.toPixelPos();
                  const blastFX = new AnFX({
                    atlas: "atlases/game.ss.pixi.atlas",
                    sprite: "./fxBlastMini",
                    anchor: AnAnchor.Center,
                    loopTween: {
                      from: {
                        alpha: 0.7,
                        scale: { x: 0.6, y: 0.6 }
                      },
                      to: {
                        alpha: 0,
                        scale: { x: 2, y: 2 }
                      },
                      duration: 0.5,
                      easing: AnEase.easeOut,
                      callbacks: {
                        onComplete: () => {
                          if (block.special) block.activatedType = mirror.activatedType;
                          field.applyBlock(block);
                        }
                      }
                    },
                    updater: field.getUpdater()
                  });
                  blastFX.position.set(pixelPos.x, pixelPos.y);
                  blastFX.blendMode = G.forceLowQulity ? "normal" : "add";
                  field.fxLayer.attach(blastFX);
                  field.addGraphics(blastFX);
                }
              }
              currentIndex++;
              if (currentIndex === positions.length && andCallDestroyFunc) {
                destroyFunc?.();
              }
            }
          }
        });
      };
      const destroyInH = posToRemoveH.length > posToRemoveV.length;
      if (posToRemoveH.length)
        makeMirrorConnections(posToRemoveH, destroyInH);
      if (posToRemoveV.length)
        makeMirrorConnections(posToRemoveV, !destroyInH);
    }
    activateChest(block, destroyFunc) {
      const game = GameApp.self.game;
      const field = this;
      const pos = block.gridPos;
      AnSounds.play(
        `sounds/spec_chest.snd.mp3`,
        0.6,
        AnMath.remapClamp(pos.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
        AnRnd.float(0.9, 1.1)
      );
      let bonus = -1;
      do {
        bonus = field.specRndSeed.seed_int(0, 2);
      } while (bonus === field.chestLastBonus);
      field.chestLastBonus = bonus;
      if (game.tutorial === "Chests" /* Chests */) {
        if (game.tutorialStage === 1) bonus = 0;
        else if (game.tutorialStage === 2) bonus = 1;
      }
      let stayTime = 0.1;
      switch (bonus) {
        case 0:
          game.addMoves(G.chestBonusMovesCount);
          break;
        case 1:
          stayTime = 1;
          game.addCoins(G.chestBonusCoinsCount, block.gridPos);
          break;
        case 2:
          stayTime = 2;
          game.addActualProps(G.chestBonusPropsCount, block.gridPos);
          break;
      }
      block.setTypeNoAnim("spec_chest_opened");
      runAfterSafe(stayTime, field, () => destroyFunc?.());
    }
    activateRainbow(rainbow, destroyFunc) {
      if (!rainbow.activatedType) {
        AnLog.error(`activatedType \u043D\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D \u0434\u043B\u044F rainbow!`);
        destroyFunc?.();
        return;
      }
      const field = this;
      const pos = rainbow.gridPos;
      AnSounds.play(
        `sounds/spec_rainbow.snd.mp3`,
        0.6,
        AnMath.remapClamp(pos.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
        AnRnd.float(0.9, 1.1)
      );
      const affectedBlocks = [];
      for (let row = 0; row < field.rowsCount; row++) {
        for (let col = 0; col < field.colsCount; col++) {
          const cell = field.getCell(row, col);
          if (cell) {
            const block = cell.block;
            if (block && block.type === rainbow.activatedType && !block.highlighted && !cell.hasModifier(2 /* Cage */)) {
              block.highlighted = true;
              affectedBlocks.push(block);
            }
          }
        }
      }
      if (!affectedBlocks.length) {
        destroyFunc?.();
        return;
      }
      shuffle(affectedBlocks);
      const createRainbowLine = (id, rainbow2, affectedBlock) => {
        const rainbowColors = [16711680, 16744192, 16776960, 65280, 255, 4915330, 9699539];
        const posA = rainbow2.gridPos.toPixelPos();
        const posB = affectedBlock.gridPos.toPixelPos();
        const dx = posB.x - posA.x;
        const dy = posB.y - posA.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        const lineScale = (distance + CellSize * 0.25) / 256;
        const rndSeed = field.colRndSeed[affectedBlock.gridPos.col];
        const lineFX = new AnFX(
          {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./selectLine",
            anchor: AnAnchor.Center,
            loopTween: {
              from: { alpha: 0.3, scale: { y: 0.3, x: lineScale } },
              to: { alpha: 3, scale: { y: 1, x: lineScale } },
              tolerance: 0.2,
              duration: (2 - rndSeed.seed_float(0, 0.5)) / 2,
              delay: id * 0.1,
              easing: AnEase.easeOutElastic
            },
            exitTween: {
              from: { alpha: 2, scale: { y: 1, x: lineScale } },
              to: { alpha: 0, scale: { y: 0.1, x: lineScale } },
              tolerance: 0.2,
              duration: 0.5,
              easing: AnEase.easeOut,
              callbacks: {
                onComplete: () => {
                  if (G.specialsSpreyPaint)
                    affectedBlock.activatedAndPainted = rainbow2.activatedAndPainted;
                  if (affectedBlock.special) affectedBlock.activatedType = rainbow2.activatedType;
                  field.applyBlock(affectedBlock);
                  if (id === affectedBlocks.length - 1)
                    destroyFunc?.();
                }
              }
            },
            tint: rainbowColors[AnRnd.int(0, rainbowColors.length - 1)],
            updater: field.getUpdater()
          }
        );
        lineFX.scale.set(lineScale, 1);
        lineFX.rotation = angle;
        lineFX.position.set(posA.x + dx / 2, posA.y + dy / 2);
        lineFX.blendMode = G.forceLowQulity ? "normal" : "add";
        field.addGraphics(lineFX);
        field.fxLayer.attach(lineFX);
      };
      for (let i3 = 0; i3 < affectedBlocks.length; ++i3)
        createRainbowLine(i3, rainbow, affectedBlocks[i3]);
    }
    activateBomb(bomb, destroyFunc) {
      const field = this;
      const affectedBlocks = [];
      const gridPos = bomb.gridPos.clone();
      const pixelPos = gridPos.toPixelPos();
      AnSounds.play(
        `sounds/spec_bomb.snd.mp3`,
        0.6,
        AnMath.remapClamp(gridPos.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
        AnRnd.float(0.9, 1.1)
      );
      const blastFX = new AnFX({
        atlas: "atlases/game.ss.pixi.atlas",
        sprite: "./fxBlastBig",
        anchor: AnAnchor.Center,
        loopTween: {
          from: {
            alpha: 1,
            scale: {
              x: 0.2,
              y: 0.2
            }
          },
          to: {
            alpha: 0,
            scale: {
              x: 2,
              y: 2
            }
          },
          duration: 2,
          easing: AnEase.easeOut
        },
        updater: field.getUpdater()
      });
      blastFX.position.set(pixelPos.x, pixelPos.y);
      blastFX.blendMode = G.forceLowQulity ? "normal" : "add";
      field.fxLayer.attach(blastFX);
      field.addGraphics(blastFX);
      for (let row = gridPos.row - 1; row <= gridPos.row + 1; row++) {
        for (let col = gridPos.col - 1; col <= gridPos.col + 1; col++) {
          if (row === gridPos.row && col === gridPos.col) continue;
          const cell = field.getCell(row, col);
          if (cell) {
            const neighbor = cell.block;
            if (neighbor && !neighbor.highlighted && !cell.hasModifier(2 /* Cage */)) {
              neighbor.highlighted = true;
              affectedBlocks.push(neighbor);
            }
          }
        }
      }
      if (!affectedBlocks.length) {
        destroyFunc?.();
        return;
      }
      shuffle(affectedBlocks);
      let currentIndex = 0;
      const timer = new AnTimer({
        duration: 0.2,
        loopCount: affectedBlocks.length - 1,
        updater: field.getUpdater(),
        callbacks: {
          onComplete: () => {
            const block = affectedBlocks[currentIndex];
            if (G.specialsSpreyPaint)
              block.activatedAndPainted = bomb.activatedAndPainted;
            const pixelPos2 = block.gridPos.toPixelPos();
            const miniBlastCount = 3;
            for (let i3 = 0; i3 < miniBlastCount; ++i3) {
              const blastFX2 = new AnFX({
                atlas: "atlases/game.ss.pixi.atlas",
                sprite: "./fxBlastMini",
                anchor: AnAnchor.Center,
                loopTween: {
                  from: {
                    alpha: 0.7,
                    scale: {
                      x: 0.3,
                      y: 0.3
                    }
                  },
                  to: {
                    alpha: 0,
                    scale: {
                      x: 3,
                      y: 3
                    }
                  },
                  duration: 1.5,
                  easing: AnEase.easeOut
                },
                updater: field.getUpdater()
              });
              const offsetX = AnRnd.float(-CellSize * 0.3, CellSize * 0.3);
              const offsetY = AnRnd.float(-CellSize * 0.3, CellSize * 0.3);
              blastFX2.position.set(pixelPos2.x + offsetX, pixelPos2.y + offsetY);
              blastFX2.blendMode = G.forceLowQulity ? "normal" : "add";
              field.fxLayer.attach(blastFX2);
              field.addGraphics(blastFX2);
            }
            if (block.special) block.activatedType = bomb.activatedType;
            field.applyBlock(block);
            if (currentIndex === affectedBlocks.length - 1)
              destroyFunc?.();
            ++currentIndex;
          }
        }
      });
    }
    activateRocket(rocket, destroyFunc) {
      const field = this;
      const pos = rocket.gridPos;
      AnSounds.play(
        `sounds/spec_rocket.snd.mp3`,
        0.6,
        AnMath.remapClamp(pos.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
        AnRnd.float(0.9, 1.1)
      );
      let rowStep = 0;
      let colStep = 0;
      let rotationAngle = 0;
      switch (rocket.type) {
        case "spec_rocket_horizontal":
          colStep = 1;
          rotationAngle = Math.PI / 2;
          break;
        case "spec_rocket_vertical":
          rowStep = 1;
          rotationAngle = Math.PI;
          break;
        case "spec_rocket_diagonal1":
          rowStep = 1;
          colStep = 1;
          rotationAngle = 3 * Math.PI / 4;
          break;
        case "spec_rocket_diagonal2":
          rowStep = 1;
          colStep = -1;
          rotationAngle = -3 * Math.PI / 4;
          break;
      }
      const createRocketAnimation = (startRow, startCol, directionRow, directionCol, angle) => {
        const startPos = new GridPos(startRow, startCol).toPixelPos();
        let endRow = startRow;
        let endCol = startCol;
        while (!field.isOutOfBounds(endRow + directionRow, endCol + directionCol)) {
          endRow += directionRow;
          endCol += directionCol;
        }
        const endPos = new GridPos(endRow, endCol).toPixelPos();
        const duration = AnMath.distance(startPos, endPos) / CellSize * 0.1;
        let trailTimer = null;
        const rocketFX = new AnFX({
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./fxRocket",
          anchor: AnAnchor.Center,
          loopTween: {
            from: {
              position: {
                x: startPos.x,
                y: startPos.y
              }
            },
            to: {
              position: {
                x: endPos.x,
                y: endPos.y
              }
            },
            duration,
            easing: AnEase.linear,
            callbacks: {
              onComplete: () => trailTimer?.terminate()
            }
          },
          updater: field.getUpdater()
        });
        trailTimer = new AnTimer({
          duration: 0.025,
          updater: field.getUpdater(),
          loopCount: Infinity,
          callbacks: {
            onComplete: () => {
              const blastFX = new AnFX({
                atlas: "atlases/game.ss.pixi.atlas",
                sprite: "./fxBlastMini",
                anchor: AnAnchor.Center,
                loopTween: {
                  from: {
                    alpha: 0.7,
                    scale: {
                      x: 0.3,
                      y: 0.3
                    }
                  },
                  to: {
                    alpha: 0,
                    scale: {
                      x: 2,
                      y: 2
                    }
                  },
                  duration: 1,
                  easing: AnEase.easeOut
                },
                updater: field.getUpdater()
              });
              blastFX.position.set(rocketFX.x, rocketFX.y);
              blastFX.blendMode = G.forceLowQulity ? "normal" : "add";
              field.fxLayer.attach(blastFX);
              field.addGraphics(blastFX);
            }
          }
        });
        rocketFX.rotation = angle;
        rocketFX.scale.set(1.6, 1.6);
        field.addGraphics(rocketFX);
        field.animLayer.attach(rocketFX);
      };
      createRocketAnimation(pos.row, pos.col, rowStep, colStep, rotationAngle);
      createRocketAnimation(pos.row, pos.col, -rowStep, -colStep, rotationAngle + Math.PI);
      const startDirectionTimer = (rowDir, colDir) => {
        let step = 1;
        const timer = new AnTimer({
          duration: 0.1,
          loopCount: Infinity,
          updater: field.getUpdater(),
          callbacks: {
            onComplete: () => {
              const row = pos.row + rowDir * step;
              const col = pos.col + colDir * step;
              if (field.isOutOfBounds(row, col)) {
                timer.stop();
                return;
              }
              const cell = field.getCell(row, col);
              if (cell) {
                const block = cell.block;
                if (block && !block.highlighted && !cell.hasModifier(2 /* Cage */)) {
                  block.highlighted = true;
                  new AnTimer({
                    duration: 0.5,
                    updater: field.getUpdater(),
                    callbacks: {
                      onComplete: () => {
                        if (G.specialsSpreyPaint)
                          block.activatedAndPainted = rocket.activatedAndPainted;
                        if (block.special) block.activatedType = rocket.activatedType;
                        field.applyBlock(block);
                      }
                    }
                  });
                }
              }
              step++;
            }
          }
        });
      };
      startDirectionTimer(rowStep, colStep);
      startDirectionTimer(-rowStep, -colStep);
      destroyFunc?.();
    }
  };
}

// games/packer/src/game/FieldChainsMixin.ts
init_define_AnParams();

// node_modules/pixi-filters/lib/index.mjs
init_define_AnParams();

// node_modules/pixi-filters/lib/defaults/default2.mjs
init_define_AnParams();
var vertex5 = "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

// node_modules/pixi-filters/lib/defaults/default.mjs
init_define_AnParams();
var wgslVertex = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}";

// node_modules/pixi-filters/lib/kawase-blur/KawaseBlurFilter.mjs
init_define_AnParams();
init_lib();

// node_modules/pixi-filters/lib/kawase-blur/kawase-blur.mjs
init_define_AnParams();
var fragment7 = "\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    finalColor = color;\n}";

// node_modules/pixi-filters/lib/kawase-blur/kawase-blur2.mjs
init_define_AnParams();
var source7 = "struct KawaseBlurUniforms {\n  uOffset:vec2<f32>,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uOffset = kawaseBlurUniforms.uOffset;\n  var color: vec4<f32> = vec4<f32>(0.0);\n\n  // Sample top left pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y));\n  // Sample top right pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y));\n  // Sample bottom right pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y));\n  // Sample bottom left pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y));\n  // Average\n  color *= 0.25;\n\n  return color;\n}";

// node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp.mjs
init_define_AnParams();
var fragmentClamp = "\nprecision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uOffset;\n\nuniform vec4 uInputClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample top right pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    finalColor = color;\n}\n";

// node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp2.mjs
init_define_AnParams();
var sourceClamp = "struct KawaseBlurUniforms {\n  uOffset:vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uOffset = kawaseBlurUniforms.uOffset;\n  var color: vec4<f32> = vec4(0.0);\n\n  // Sample top left pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample top right pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample bottom right pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample bottom left pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Average\n  color *= 0.25;\n    \n  return color;\n}";

// node_modules/pixi-filters/lib/kawase-blur/KawaseBlurFilter.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _KawaseBlurFilter = class _KawaseBlurFilter2 extends Filter {
  /** @ignore */
  constructor(...args) {
    let options = args[0] ?? {};
    if (typeof options === "number" || Array.isArray(options)) {
      deprecation("6.0.0", "KawaseBlurFilter constructor params are now options object. See params: { strength, quality, clamp, pixelSize }");
      options = { strength: options };
      if (args[1] !== void 0)
        options.quality = args[1];
      if (args[2] !== void 0)
        options.clamp = args[2];
    }
    options = { ..._KawaseBlurFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram3 = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: options?.clamp ? sourceClamp : source7,
        entryPoint: "mainFragment"
      }
    });
    const glProgram3 = GlProgram.from({
      vertex: vertex5,
      fragment: options?.clamp ? fragmentClamp : fragment7,
      name: "kawase-blur-filter"
    });
    super({
      gpuProgram: gpuProgram3,
      glProgram: glProgram3,
      resources: {
        kawaseBlurUniforms: {
          uOffset: { value: new Float32Array(2), type: "vec2<f32>" }
        }
      }
    });
    __publicField(this, "uniforms");
    __publicField(this, "_pixelSize", { x: 0, y: 0 });
    __publicField(this, "_clamp");
    __publicField(this, "_kernels", []);
    __publicField(this, "_blur");
    __publicField(this, "_quality");
    this.uniforms = this.resources.kawaseBlurUniforms.uniforms;
    this.pixelSize = options.pixelSize ?? { x: 1, y: 1 };
    if (Array.isArray(options.strength)) {
      this.kernels = options.strength;
    } else if (typeof options.strength === "number") {
      this._blur = options.strength;
      this.quality = options.quality ?? 3;
    }
    this._clamp = !!options.clamp;
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    const uvX = this.pixelSizeX / input.source.width;
    const uvY = this.pixelSizeY / input.source.height;
    let offset;
    if (this._quality === 1 || this._blur === 0) {
      offset = this._kernels[0] + 0.5;
      this.uniforms.uOffset[0] = offset * uvX;
      this.uniforms.uOffset[1] = offset * uvY;
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      const renderTarget = TexturePool.getSameSizeTexture(input);
      let source22 = input;
      let target = renderTarget;
      let tmp;
      const last = this._quality - 1;
      for (let i3 = 0; i3 < last; i3++) {
        offset = this._kernels[i3] + 0.5;
        this.uniforms.uOffset[0] = offset * uvX;
        this.uniforms.uOffset[1] = offset * uvY;
        filterManager.applyFilter(this, source22, target, true);
        tmp = source22;
        source22 = target;
        target = tmp;
      }
      offset = this._kernels[last] + 0.5;
      this.uniforms.uOffset[0] = offset * uvX;
      this.uniforms.uOffset[1] = offset * uvY;
      filterManager.applyFilter(this, source22, output, clearMode);
      TexturePool.returnTexture(renderTarget);
    }
  }
  /**
    * The amount of blur, value greater than `0`.
    * @default 4
    */
  get strength() {
    return this._blur;
  }
  set strength(value) {
    this._blur = value;
    this._generateKernels();
  }
  /**
    * The quality of the filter, integer greater than `1`.
    * @default 3
    */
  get quality() {
    return this._quality;
  }
  set quality(value) {
    this._quality = Math.max(1, Math.round(value));
    this._generateKernels();
  }
  /**
    * The kernel size of the blur filter, for advanced usage
    * @default [0]
    */
  get kernels() {
    return this._kernels;
  }
  set kernels(value) {
    if (Array.isArray(value) && value.length > 0) {
      this._kernels = value;
      this._quality = value.length;
      this._blur = Math.max(...value);
    } else {
      this._kernels = [0];
      this._quality = 1;
    }
  }
  /**
    * The size of the pixels. Large size is blurrier. For advanced usage.
    * @default {x:1,y:1}
    */
  get pixelSize() {
    return this._pixelSize;
  }
  set pixelSize(value) {
    if (typeof value === "number") {
      this.pixelSizeX = this.pixelSizeY = value;
      return;
    }
    if (Array.isArray(value)) {
      this.pixelSizeX = value[0];
      this.pixelSizeY = value[1];
      return;
    }
    this._pixelSize = value;
  }
  /**
    * The size of the pixels on the `x` axis. Large size is blurrier. For advanced usage.
    * @default 1
    */
  get pixelSizeX() {
    return this.pixelSize.x;
  }
  set pixelSizeX(value) {
    this.pixelSize.x = value;
  }
  /**
    * The size of the pixels on the `y` axis. Large size is blurrier. For advanced usage.
    * @default 1
    */
  get pixelSizeY() {
    return this.pixelSize.y;
  }
  set pixelSizeY(value) {
    this.pixelSize.y = value;
  }
  /**
    * Get the if the filter is clamped
    * @default false
    */
  get clamp() {
    return this._clamp;
  }
  /** Update padding based on kernel data */
  _updatePadding() {
    this.padding = Math.ceil(this._kernels.reduce((acc, v2) => acc + v2 + 0.5, 0));
  }
  /** Auto generate kernels by blur & quality */
  _generateKernels() {
    const blur = this._blur;
    const quality = this._quality;
    const kernels = [blur];
    if (blur > 0) {
      let k2 = blur;
      const step = blur / quality;
      for (let i3 = 1; i3 < quality; i3++) {
        k2 -= step;
        kernels.push(k2);
      }
    }
    this._kernels = kernels;
    this._updatePadding();
  }
};
__publicField(_KawaseBlurFilter, "DEFAULT_OPTIONS", {
  strength: 4,
  quality: 3,
  clamp: false,
  pixelSize: { x: 1, y: 1 }
});
var KawaseBlurFilter = _KawaseBlurFilter;

// node_modules/pixi-filters/lib/drop-shadow/DropShadowFilter.mjs
init_define_AnParams();
init_lib();

// node_modules/pixi-filters/lib/drop-shadow/drop-shadow.mjs
init_define_AnParams();
var fragment8 = "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uAlpha;\nuniform vec3 uColor;\nuniform vec2 uOffset;\n\nuniform vec4 uInputSize;\n\nvoid main(void){\n    vec4 sample = texture(uTexture, vTextureCoord - uOffset * uInputSize.zw);\n\n    // Premultiply alpha\n    sample.rgb = uColor.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= uAlpha;\n\n    finalColor = sample;\n}";

// node_modules/pixi-filters/lib/drop-shadow/drop-shadow2.mjs
init_define_AnParams();
var source8 = "struct DropShadowUniforms {\n  uAlpha: f32,\n  uColor: vec3<f32>,\n  uOffset: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> dropShadowUniforms : DropShadowUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv - dropShadowUniforms.uOffset * gfu.uInputSize.zw);\n\n  // Premultiply alpha\n  color = vec4<f32>(vec3<f32>(dropShadowUniforms.uColor.rgb * color.a), color.a);\n  // alpha user alpha\n  color *= dropShadowUniforms.uAlpha;\n\n  return color;\n}";

// node_modules/pixi-filters/lib/drop-shadow/DropShadowFilter.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _DropShadowFilter = class _DropShadowFilter2 extends Filter {
  /**
   * @param options - Options for the DropShadowFilter constructor.
   */
  constructor(options) {
    options = { ..._DropShadowFilter2.DEFAULT_OPTIONS, ...options };
    const gpuProgram3 = GpuProgram.from({
      vertex: {
        source: wgslVertex,
        entryPoint: "mainVertex"
      },
      fragment: {
        source: source8,
        entryPoint: "mainFragment"
      }
    });
    const glProgram3 = GlProgram.from({
      vertex: vertex5,
      fragment: fragment8,
      name: "drop-shadow-filter"
    });
    super({
      gpuProgram: gpuProgram3,
      glProgram: glProgram3,
      resources: {
        dropShadowUniforms: {
          uAlpha: { value: options.alpha, type: "f32" },
          uColor: { value: new Float32Array(3), type: "vec3<f32>" },
          uOffset: { value: options.offset, type: "vec2<f32>" }
        }
      },
      resolution: options.resolution
    });
    __publicField2(this, "uniforms");
    __publicField2(this, "shadowOnly", false);
    __publicField2(this, "_color");
    __publicField2(this, "_blurFilter");
    __publicField2(this, "_basePass");
    this.uniforms = this.resources.dropShadowUniforms.uniforms;
    this._color = new Color();
    this.color = options.color ?? 0;
    this._blurFilter = new KawaseBlurFilter({
      strength: options.kernels ?? options.blur,
      quality: options.kernels ? void 0 : options.quality
    });
    this._basePass = new Filter({
      gpuProgram: GpuProgram.from({
        vertex: {
          source: wgslVertex,
          entryPoint: "mainVertex"
        },
        fragment: {
          source: `
                    @group(0) @binding(1) var uTexture: texture_2d<f32>; 
                    @group(0) @binding(2) var uSampler: sampler;
                    @fragment
                    fn mainFragment(
                        @builtin(position) position: vec4<f32>,
                        @location(0) uv : vec2<f32>
                    ) -> @location(0) vec4<f32> {
                        return textureSample(uTexture, uSampler, uv);
                    }
                    `,
          entryPoint: "mainFragment"
        }
      }),
      glProgram: GlProgram.from({
        vertex: vertex5,
        fragment: `
                in vec2 vTextureCoord;
                out vec4 finalColor;
                uniform sampler2D uTexture;

                void main(void){
                    finalColor = texture(uTexture, vTextureCoord);
                }
                `,
        name: "drop-shadow-filter"
      }),
      resources: {}
    });
    Object.assign(this, options);
  }
  /**
   * Override existing apply method in `Filter`
   * @override
   * @ignore
   */
  apply(filterManager, input, output, clearMode) {
    const renderTarget = TexturePool.getSameSizeTexture(input);
    filterManager.applyFilter(this, input, renderTarget, true);
    this._blurFilter.apply(filterManager, renderTarget, output, clearMode);
    if (!this.shadowOnly) {
      filterManager.applyFilter(this._basePass, input, output, false);
    }
    TexturePool.returnTexture(renderTarget);
  }
  /**
   * Set the offset position of the drop-shadow relative to the original image.
   * @default [4,4]
   */
  get offset() {
    return this.uniforms.uOffset;
  }
  set offset(value) {
    this.uniforms.uOffset = value;
    this._updatePadding();
  }
  /**
   * Set the offset position of the drop-shadow relative to the original image on the `x` axis
   * @default 4
   */
  get offsetX() {
    return this.offset.x;
  }
  set offsetX(value) {
    this.offset.x = value;
    this._updatePadding();
  }
  /**
   * Set the offset position of the drop-shadow relative to the original image on the `y` axis
   * @default 4
   */
  get offsetY() {
    return this.offset.y;
  }
  set offsetY(value) {
    this.offset.y = value;
    this._updatePadding();
  }
  /**
   * The color value of shadow.
   * @example [0.0, 0.0, 0.0] = 0x000000
   * @default 0x000000
   */
  get color() {
    return this._color.value;
  }
  set color(value) {
    this._color.setValue(value);
    const [r2, g2, b3] = this._color.toArray();
    this.uniforms.uColor[0] = r2;
    this.uniforms.uColor[1] = g2;
    this.uniforms.uColor[2] = b3;
  }
  /**
   * Coefficient for alpha multiplication
   * @default 1
   */
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(value) {
    this.uniforms.uAlpha = value;
  }
  /**
   * The strength of the shadow's blur.
   * @default 2
   */
  get blur() {
    return this._blurFilter.strength;
  }
  set blur(value) {
    this._blurFilter.strength = value;
    this._updatePadding();
  }
  /**
   * Sets the quality of the Blur Filter
   * @default 4
   */
  get quality() {
    return this._blurFilter.quality;
  }
  set quality(value) {
    this._blurFilter.quality = value;
    this._updatePadding();
  }
  /** Sets the kernels of the Blur Filter */
  get kernels() {
    return this._blurFilter.kernels;
  }
  set kernels(value) {
    this._blurFilter.kernels = value;
  }
  /**
   * Sets the pixelSize of the Kawase Blur filter
   * @default [1,1]
   */
  get pixelSize() {
    return this._blurFilter.pixelSize;
  }
  set pixelSize(value) {
    if (typeof value === "number") {
      value = { x: value, y: value };
    }
    if (Array.isArray(value)) {
      value = { x: value[0], y: value[1] };
    }
    this._blurFilter.pixelSize = value;
  }
  /**
   * Sets the pixelSize of the Kawase Blur filter on the `x` axis
   * @default 1
   */
  get pixelSizeX() {
    return this._blurFilter.pixelSizeX;
  }
  set pixelSizeX(value) {
    this._blurFilter.pixelSizeX = value;
  }
  /**
   * Sets the pixelSize of the Kawase Blur filter on the `y` axis
   * @default 1
   */
  get pixelSizeY() {
    return this._blurFilter.pixelSizeY;
  }
  set pixelSizeY(value) {
    this._blurFilter.pixelSizeY = value;
  }
  /**
   * Recalculate the proper padding amount.
   * @private
   */
  _updatePadding() {
    const offsetPadding = Math.max(
      Math.abs(this.offsetX),
      Math.abs(this.offsetY)
    );
    this.padding = offsetPadding + this.blur * 2 + this.quality * 4;
  }
};
__publicField2(_DropShadowFilter, "DEFAULT_OPTIONS", {
  offset: { x: 4, y: 4 },
  color: 0,
  alpha: 0.5,
  shadowOnly: false,
  kernels: void 0,
  blur: 2,
  quality: 3,
  pixelSize: { x: 1, y: 1 },
  resolution: 1
});
var DropShadowFilter = _DropShadowFilter;

// games/packer/src/game/FieldChainsMixin.ts
function FieldChainsMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      if (!(this instanceof Field))
        throw new Error("FieldChainsMixin \u043C\u043E\u0436\u0435\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u0442\u043E\u043B\u044C\u043A\u043E \u0441 \u043A\u043B\u0430\u0441\u0441\u043E\u043C Field!");
    }
    /**
     *        (  3 )
     *      
     * @returns    null,    
     */
    getMinChain() {
      const field = this;
      const visited = /* @__PURE__ */ new Set();
      const usedBlocks = /* @__PURE__ */ new Set();
      let minChain = null;
      const getNeighbors = (block) => {
        const neighbors = [];
        const { row, col } = block.gridPos;
        const directions = [
          //  
          { dr: -1, dc: 0 },
          // 
          { dr: 0, dc: 1 },
          // 
          { dr: 1, dc: 0 },
          // 
          { dr: 0, dc: -1 },
          // 
          //  
          { dr: -1, dc: 1 },
          // -
          { dr: 1, dc: 1 },
          // -
          { dr: 1, dc: -1 },
          // -
          { dr: -1, dc: -1 }
          // -
        ];
        for (const dir of directions) {
          const newRow = row + dir.dr;
          const newCol = col + dir.dc;
          const cell = field.getCell(newRow, newCol);
          if (cell && !cell.hasModifier(2 /* Cage */)) {
            const neighbor = cell.block;
            if (neighbor && neighbor.type === block.type && !visited.has(neighbor) && !neighbor.special) {
              neighbors.push(neighbor);
            }
          }
        }
        return neighbors;
      };
      for (const startBlock of field.blocks) {
        const startCell = field.getCell(startBlock.gridPos.row, startBlock.gridPos.col);
        if (startCell && startCell.hasModifier(2 /* Cage */)) continue;
        if (visited.has(startBlock)) continue;
        const blockKey = `${startBlock.gridPos.row},${startBlock.gridPos.col}`;
        if (usedBlocks.has(blockKey)) continue;
        const blockType = startBlock.type;
        const blocksOfType = field.blocks.filter((b3) => {
          const cell = field.getCell(b3.gridPos.row, b3.gridPos.col);
          return b3.type === blockType && !visited.has(b3) && cell && !cell.hasModifier(2 /* Cage */);
        });
        for (const currentBlock of blocksOfType) {
          if (visited.has(currentBlock)) continue;
          const stack = [];
          const initialNeighbors = getNeighbors(currentBlock);
          if (initialNeighbors.length > 0) {
            stack.push({
              block: currentBlock,
              path: [currentBlock],
              neighbors: initialNeighbors,
              index: 0
            });
            visited.add(currentBlock);
          }
          while (stack.length > 0) {
            const current = stack[stack.length - 1];
            if (current.index < current.neighbors.length) {
              const nextBlock = current.neighbors[current.index];
              current.index++;
              if (!visited.has(nextBlock)) {
                visited.add(nextBlock);
                const newPath = [...current.path, nextBlock];
                if (newPath.length >= 3) {
                  if (!minChain || newPath.length < minChain.length) {
                    minChain = newPath;
                    if (minChain.length === 3) {
                      for (const block of minChain) {
                        const key = `${block.gridPos.row},${block.gridPos.col}`;
                        usedBlocks.add(key);
                      }
                      return minChain;
                    }
                  }
                }
                if (newPath.length < 8) {
                  const nextNeighbors = getNeighbors(nextBlock);
                  if (nextNeighbors.length > 0) {
                    stack.push({
                      block: nextBlock,
                      path: newPath,
                      neighbors: nextNeighbors,
                      index: 0
                    });
                  }
                }
              }
            } else {
              stack.pop();
            }
          }
          if (stack.length === 0) {
            for (const block of visited) {
              const key = `${block.gridPos.row},${block.gridPos.col}`;
              if (!usedBlocks.has(key)) {
                visited.delete(block);
              }
            }
          }
        }
        visited.add(startBlock);
      }
      if (minChain) {
        for (const block of minChain) {
          const key = `${block.gridPos.row},${block.gridPos.col}`;
          usedBlocks.add(key);
        }
      }
      return minChain;
    }
    // ************************************************************ //
    getUniqueChainsForType(blockType) {
      const field = this;
      const allChains = [];
      const visited = /* @__PURE__ */ new Set();
      const usedBlocks = /* @__PURE__ */ new Set();
      const blocks = field.blocks.filter((b3) => b3.type === blockType);
      const getNeighbors = (currentBlock, visitedLocal) => {
        const neighbors = [];
        const row = currentBlock.gridPos.row;
        const col = currentBlock.gridPos.col;
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const newRow = row + dy;
            const newCol = col + dx;
            const cell = field.getCell(newRow, newCol);
            if (cell && !cell.hasModifier(2 /* Cage */)) {
              const neighbor = cell.block;
              if (neighbor && neighbor.type === blockType && !visitedLocal.has(neighbor)) {
                neighbors.push(neighbor);
              }
            }
          }
        }
        return neighbors;
      };
      const dfsChainBuilder = (currentBlock, path2, visitedLocal, chains, maxLengthRef) => {
        path2.push(currentBlock);
        visitedLocal.add(currentBlock);
        const neighbors = getNeighbors(currentBlock, visitedLocal);
        if (neighbors.length === 0) {
          if (path2.length >= 3) {
            if (path2.length > maxLengthRef.value) {
              maxLengthRef.value = path2.length;
              chains.length = 0;
              chains.push([...path2]);
            } else if (path2.length === maxLengthRef.value) {
              chains.push([...path2]);
            }
          }
        } else {
          for (const neighbor of neighbors) {
            dfsChainBuilder(neighbor, path2, visitedLocal, chains, maxLengthRef);
          }
        }
        path2.pop();
        visitedLocal.delete(currentBlock);
      };
      const findAllChainsFromBlock = (startBlock) => {
        const chains = [];
        const path2 = [];
        const maxLengthRef = { value: 0 };
        visited.add(startBlock);
        dfsChainBuilder(
          startBlock,
          path2,
          /* @__PURE__ */ new Set([startBlock]),
          chains,
          maxLengthRef
        );
        return chains;
      };
      for (const startBlock of blocks) {
        if (!visited.has(startBlock)) {
          const chainsFromBlock = findAllChainsFromBlock(startBlock);
          if (chainsFromBlock.length > 0) {
            const maxLength = Math.max(...chainsFromBlock.map((chain) => chain.length));
            const longestChains = chainsFromBlock.filter((chain) => chain.length === maxLength);
            allChains.push(...longestChains);
          }
        }
      }
      const result = [];
      allChains.sort((a2, b3) => b3.length - a2.length).forEach((chain) => {
        const hasOverlap = chain.some((block) => {
          const blockKey = `${block.gridPos.row},${block.gridPos.col} `;
          return usedBlocks.has(blockKey);
        });
        if (!hasOverlap) {
          result.push(chain);
          chain.forEach((block) => {
            const blockKey = `${block.gridPos.row},${block.gridPos.col} `;
            usedBlocks.add(blockKey);
          });
        }
      });
      return result;
    }
    visualizeChains(chains, debugContainer, options) {
      const field = this;
      const defaultOptions = {
        colors: [16711680, 65280, 255, 16776960, 16711935, 65535],
        lineWidth: 4,
        alpha: 0.7,
        showLabels: true,
        ...options
      };
      const dropShadowFilter = new DropShadowFilter();
      dropShadowFilter.offsetX = 2;
      dropShadowFilter.offsetY = 2;
      dropShadowFilter.color = 0;
      dropShadowFilter.alpha = 1;
      dropShadowFilter.blur = 2;
      dropShadowFilter.quality = 2;
      const graphics = debugContainer ?? new lib_exports.Graphics();
      field.addChild(graphics);
      this.debugGraphics = graphics;
      const fontSize = 25 * AnViewport.scale;
      chains.forEach((chain, chainIndex) => {
        if (chain.length < 3) return;
        const color = defaultOptions.colors[chainIndex % defaultOptions.colors.length];
        graphics.moveTo(0, 0);
        for (let i3 = 0; i3 < chain.length; i3++) {
          const pos = chain[i3].gridPos.toPixelPos();
          if (i3 === 0) {
            graphics.moveTo(pos.x, pos.y);
          } else {
            graphics.lineTo(pos.x, pos.y);
          }
          if (defaultOptions.showLabels) {
            const blockLabel = new lib_exports.Text({
              text: `${i3 + 1} 
[${chain[i3].gridPos.row},${chain[i3].gridPos.col}]`,
              style: {
                fontFamily: "Arial",
                fontSize,
                fill: color,
                fontWeight: "bold",
                align: "center"
              }
            });
            blockLabel.position.set(
              pos.x,
              pos.y - CellSize * 0.4 * AnViewport.scale
            );
            blockLabel.anchor.set(0.5, 1);
            blockLabel.filters = [dropShadowFilter];
            graphics.addChild(blockLabel);
          }
        }
        graphics.stroke({
          width: defaultOptions.lineWidth,
          color,
          alpha: defaultOptions.alpha
        });
        if (defaultOptions.showLabels) {
          const firstPos = chain[0].gridPos.toPixelPos();
          const chainLabel = new lib_exports.Text({
            text: `\u0426\u0435\u043F\u043E\u0447\u043A\u0430 ${chainIndex + 1} `,
            style: {
              fontFamily: "Arial",
              fontSize,
              fill: color,
              fontWeight: "bold"
              // dropShadow: true,
              // dropShadowColor: 0x000000,
              // dropShadowDistance: 1
            }
          });
          chainLabel.filters = [dropShadowFilter];
          chainLabel.position.set(
            firstPos.x,
            firstPos.y + CellSize * 0.4 * AnViewport.scale
          );
          chainLabel.anchor.set(0.5);
          graphics.addChild(chainLabel);
        }
      });
      return graphics;
    }
    /**
     *   
     */
    clearDebugGraphics() {
      if (this.debugGraphics) {
        const field = this;
        field.removeChild(this.debugGraphics);
        this.debugGraphics.destroy();
        this.debugGraphics = void 0;
      }
    }
  };
}

// games/packer/src/game/UIFocus.ts
init_define_AnParams();
var UIFocus = class extends enhance(AnUIElement).with(AnUpdatableMixin) {
  constructor(config2) {
    config2.anchor = config2.anchor ?? AnAnchor.TopLeft;
    super(config2);
    this.grayOverlay = new lib_exports.Graphics();
    this.addToCleanup(safeDestroyFunc4(this.grayOverlay));
    this._focusCells = config2.focusCells ?? [];
    this.startPresetCol = config2.startPresetCol ?? 0;
    for (let row = 0; row < config2.rows; row++) {
      for (let col = 0; col < config2.cols; col++) {
        const isFocused = this._focusCells.some((fc) => fc.row === row && fc.col + this.startPresetCol === col);
        if (!isFocused) {
          this.grayOverlay.rect(col * CellSize, row * CellSize, CellSize, CellSize);
          this.grayOverlay.fill({
            color: config2.backgroundColor ?? 0,
            alpha: config2.backgroundAlpha ?? 0.7
          });
        }
      }
    }
    const filters = [];
    if (config2.blurStrength || config2.useDropShadow) {
      if (config2.blurStrength) {
        const blurFilter = new KawaseBlurFilter();
        blurFilter.strength = config2.blurStrength;
        blurFilter.quality = 2;
        filters.push(blurFilter);
      }
      if (config2.useDropShadow) {
        const shadowFilter = new DropShadowFilter({
          alpha: 0.7,
          blur: 2,
          color: 2236962
        });
        filters.push(shadowFilter);
      }
      this.grayOverlay.filters = filters;
    }
    this.addGraphics(this.grayOverlay);
    this.cacheAsTexture({ resolution: 0.25, antialias: true });
  }
  get focusCells() {
    return this._focusCells;
  }
  /**
   *    ( )
   */
  clearFocus() {
    this._focusCells = [];
  }
  /**
   * ,      
   */
  isPointInFocus(x2, y2) {
    return this._focusCells.some(
      (cell) => x2 >= (cell.col + this.startPresetCol) * CellSize && x2 < (cell.col + this.startPresetCol + 1) * CellSize && y2 >= cell.row * CellSize && y2 < (cell.row + 1) * CellSize
    );
  }
  isPosInFocus(pos) {
    return this._focusCells.some(
      (cell) => cell.row === pos.row && cell.col + this.startPresetCol === pos.col
    );
  }
};

// games/packer/src/game/FieldBlockGenMixin.ts
init_define_AnParams();
function FieldBlockGenMixin(Base) {
  return class extends Base {
    constructor(...args) {
      super(...args);
      //     (    )
      //  * : ~35 %
      //  * : ~28 %
      //  * : ~18 %
      //  * : ~12 %
      //  * : ~7 %
      this.SpecBlockWeights = {
        "spec_bomb": 35,
        "spec_rocket_horizontal": 7,
        "spec_rocket_vertical": 7,
        "spec_rocket_diagonal1": 7,
        "spec_rocket_diagonal2": 7,
        //   = 28
        "spec_mirror": 18,
        "spec_rainbow": 12,
        "spec_dice": 7
      };
      if (!(this instanceof Field))
        throw new Error("FieldBlockGenMixin \u043C\u043E\u0436\u0435\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u0442\u043E\u043B\u044C\u043A\u043E \u0441 \u043A\u043B\u0430\u0441\u0441\u043E\u043C Field!");
    }
    tryToCreateBlocks() {
      const field = this;
      const game = GameApp.self.game;
      let anyCreating = false;
      const freeCols = [];
      for (let col = 0; col < field.colsCount; col++) {
        if (field.cells[0][col].block === null && field.getOccupiedBlockByGridPos(new GridPos(0, col)) === null) {
          freeCols.push(col);
        }
      }
      const genBlocks = [];
      if (freeCols.length && !field.forbidAllSpecBlocks) {
        shuffle(freeCols, field.specRndSeed);
        field.generators.forEach((gen) => {
          if (freeCols.length && game.currentMoves % gen.num === 0 && gen.last < field.genCounter) {
            gen.last = field.genCounter;
            genBlocks.push({ type: gen.type, num: freeCols.pop(), last: 0 });
          }
        });
      }
      const moreForbidSpecials = [];
      if (field.blocks.some((block) => block.type === "spec_dice")) moreForbidSpecials.push("spec_dice");
      for (let col = 0; col < field.colsCount; col++) {
        if (field.cells[0][col].block === null && field.getOccupiedBlockByGridPos(new GridPos(0, col)) === null) {
          anyCreating = true;
          let type;
          if (field.preset6x6 === null) {
            type = this.generateRandomBlockType(col, moreForbidSpecials);
          } else {
            const isInPresetArea = AnMath.inRange(col, field.startPresetCol, field.startPresetCol + field.presetWidth - 1);
            const hasEnoughBlocksBelow = field.getBlocksCountInColumn(col) >= field.rowsCount - field.presetHeight;
            const presetID = col - field.startPresetCol;
            const hasPresetData = field.preset6x6[presetID]?.length > 0;
            type = isInPresetArea && hasEnoughBlocksBelow && hasPresetData ? field.preset6x6[presetID].pop() : this.generateRandomBlockType(col, moreForbidSpecials);
          }
          const genType = genBlocks.find((gen) => gen.num === col);
          if (genType) {
            type = genType.type;
          }
          const block = new Block({
            theme: type.startsWith("prop") ? field.theme : void 0,
            pos: new GridPos(0, col),
            type,
            updater: field.getUpdater() ?? AnCore.updater,
            selectionLayer: field.selectionLayer,
            blockLayer: field.blockLayer
          });
          field.cells[0][col].block = block;
          block.updateGridPos(0, col);
          field.blocks.push(block);
          field.addUIElement(block);
        }
      }
      return anyCreating;
    }
    /**
     *      
     * 
     */
    generateRandomBlockType(col, moreForbidSpecials = []) {
      const field = this;
      const rndSeed = field.colRndSeed[col];
      let type = this.generateRandomPropBlockType(rndSeed, this.calcGoalsWeights());
      const allowedSpecs = BonusSpecBlockTypeArray.filter((type2) => !field.forbidSpecials.includes(type2) && !moreForbidSpecials.includes(type2));
      const maxEffectiveSpecs = 6;
      const clampedCount = Math.min(allowedSpecs.length, maxEffectiveSpecs);
      const adjustedDropChance = AnMath.remap(clampedCount, 0, maxEffectiveSpecs, G.specialBlockDropChance * 0.5, G.specialBlockDropChance);
      if (allowedSpecs.length > 0 && !field.forbidAllSpecBlocks && rndSeed.seed_bool(adjustedDropChance)) {
        const chosen = this.generateRandomSpecBlockType(rndSeed, allowedSpecs);
        if (chosen) {
          type = chosen;
        }
      } else {
        const chanceActions = [];
        chanceActions.push({ chance: G.propBlockDropChance, action: () => {
        } });
        for (const rule of field.rules) {
          if (rule.type === "DropRandomStones" /* DropRandomStones */)
            chanceActions.push({ chance: rule.num, action: () => type = "spec_stone" });
        }
        AnRnd.executeByChance(chanceActions, rndSeed);
      }
      return type;
    }
    generateRandomSpecBlockType(rndSeed, candidates) {
      let totalWeight = 0;
      for (const type of candidates)
        totalWeight += this.SpecBlockWeights[type] ?? 0;
      if (totalWeight <= 0) return "";
      const rand = rndSeed.seed_float(0, totalWeight);
      let acc = 0;
      for (const type of candidates) {
        const weight = this.SpecBlockWeights[type] ?? 0;
        acc += weight;
        if (rand < acc) {
          return type;
        }
      }
      return candidates[candidates.length - 1];
    }
    generateRandomPropBlockType(rndSeed, goalsWeights) {
      const result = PropBlockTypeArray[rndSeed.seed_int(0, PropBlockTypeArray.length - 1)];
      if (goalsWeights === void 0)
        return result;
      let totalWeight = 0;
      for (let i3 = 0; i3 < 7; ++i3) {
        const type = "prop_" + i3;
        totalWeight += goalsWeights[type] !== void 0 ? goalsWeights[type] : 1;
      }
      if (totalWeight <= 0) return result;
      const rand = rndSeed.seed_float(0, totalWeight);
      let acc = 0;
      for (let i3 = 0; i3 < 7; ++i3) {
        const type = "prop_" + i3;
        let weight = goalsWeights[type] !== void 0 ? goalsWeights[type] : 1;
        acc += weight;
        if (rand < acc) {
          return type;
        }
      }
      return result;
    }
    calcGoalsWeights() {
      const game = GameApp.self.game;
      if (game.mode === "typesCollect" /* TypesCollect */) {
        const goals = {};
        for (const counter of game.modeData.types) {
          if (PropBlockTypeArray.includes(counter.type) && counter.current < counter.total) {
            goals[counter.type] = AnMath.remapClamp(counter.current, 0, counter.total - G.maxChanceDropPropTypeCount, 1, G.maxChanceDropPropType);
          }
        }
        return goals;
      }
      return void 0;
    }
  };
}

// games/packer/src/game/Field.ts
var CellSize = 128;
var CellHalfSize = CellSize * 0.5;
var GridPos = class _GridPos {
  //   (X)
  constructor(row, col) {
    this.row = row;
    this.col = col;
  }
  toPixelPos(cellSize = CellSize) {
    return {
      x: this.col * cellSize + cellSize * 0.5,
      y: this.row * cellSize + cellSize * 0.5
    };
  }
  set(other) {
    this.row = other.row;
    this.col = other.col;
  }
  equal(other) {
    return this.row === other.row && this.col === other.col;
  }
  adjacent(other) {
    return Math.abs(this.row - other.row) <= 1 && Math.abs(this.col - other.col) <= 1;
  }
  clone() {
    return new _GridPos(this.row, this.col);
  }
  toString() {
    return `${this.row}x${this.col}`;
  }
};
var Field = class extends enhance(AnUIGroupElement).with(
  AnUpdatableMixin,
  FieldSpecialsMixin,
  FieldChainsMixin,
  FieldBlockGenMixin
) {
  constructor(config2) {
    config2.anchor = config2.anchor ?? AnAnchor.TopLeft;
    super(config2);
    this.colsCount = 8;
    this.rowsCount = 11;
    this.blocks = [];
    this.hintMinChain = null;
    this.blocksHintMarkers = [];
    this.playerRemoveFirstBlocks = false;
    //    
    this.forbidSpecials = [];
    //    (6x6   )
    this.presetWidth = 6;
    this.presetHeight = 6;
    this.startPresetCol = 0;
    this.selectedBlocks = [];
    this.selectionLines = [];
    this.selectionLineTweens = [];
    this.isSelecting = false;
    this.canSelectBlocks = false;
    //         (   )
    this.forbidSelectBlocks = false;
    //       
    this.forbidAllSpecBlocks = false;
    this.focusPanel = null;
    //    
    this.showHintMarkers = true;
    //      (    )
    this.lastLineRemoved = true;
    //   ,        
    this.genCounter = 0;
    //      ,     
    this.chestLastBonus = -1;
    this.colsCount = config2.colsCount ?? 8;
    this.rowsCount = config2.rowsCount ?? 11;
    this.startPresetCol = Math.floor((this.colsCount - this.presetWidth) / 2);
    this.theme = config2.theme ?? "toys" /* Toys */;
    this.rndseed = config2.rndseed ?? AnRnd.int(100, 1e4);
    this.colRndSeed = [];
    this.specRndSeed = new AnRnd("RNG" + (this.rndseed - 1).toString());
    for (let i3 = 0; i3 < this.colsCount; ++i3)
      this.colRndSeed.push(new AnRnd("RNG" + (this.rndseed + i3).toString()));
    this.preset6x6 = config2.preset6x6 ?? null;
    this.forbidSpecials = config2.forbidSpecials ?? [];
    this.generators = config2.generators ?? [];
    this.rules = config2.rules ?? [];
    if (config2.updater) this.addToUpdater(config2.updater);
    this.realWidth = CellSize * this.colsCount;
    this.realHeight = CellSize * this.rowsCount;
    this.addToUpdater(AnCore.updater);
    this.selectionLayer = new lib_exports.RenderLayer();
    this.blockLayer = new lib_exports.RenderLayer();
    this.cellModifierLayer = new lib_exports.RenderLayer();
    this.animLayer = new lib_exports.RenderLayer();
    this.fxLayer = new lib_exports.RenderLayer();
    this.cells = [];
    for (let row = 0; row < this.rowsCount; row++) {
      const newRow = [];
      for (let col = 0; col < this.colsCount; col++) {
        const cellPos = new GridPos(row, col);
        //!   ...     
        let isFocusCell = false;
        if (GameApp.self.game.tutorial === "Train1" /* Train1 */) {
          const poses = [new GridPos(1, 2), new GridPos(1, 3), new GridPos(2, 1), new GridPos(2, 2), new GridPos(3, 1), new GridPos(4, 1), new GridPos(5, 0)];
          poses.forEach((pos) => pos.col += this.startPresetCol);
          isFocusCell = poses.some((pos) => pos.row === row && pos.col === col);
        }
        const cellMods = [];
        for (const rule of this.rules) {
          switch (rule.type) {
            case "InitRandomCages" /* InitRandomCages */:
              if (!isFocusCell && this.specRndSeed.seed_bool(rule.num))
                cellMods.push(2 /* Cage */);
              break;
          }
        }
        if (config2.cellMod) {
          config2.cellMod.forEach((cellMod) => {
            if (cellMod.pos.col + this.startPresetCol === col && cellMod.pos.row === row)
              cellMods.push(...cellMod.mods);
          });
        }
        const cell = new Cell({
          pos: cellPos,
          updater: this.getUpdater() ?? AnCore.updater,
          //modifiers: !isFocusCell && this.specRndSeed.seed_bool(0.4) ? [CellModifier.Cage] : [CellModifier.None],
          //modifiers: row > this.rowsCount * 0.5 && (col >= Math.trunc(this.colsCount * 0.5 - 1) && col < Math.trunc(this.colsCount * 0.5 + 1)) ? [CellModifier.Paint] : [CellModifier.None],
          modifiers: cellMods,
          cellModifierLayer: this.cellModifierLayer,
          onAnimInitialCellComplete: row === 0 && col === this.colsCount - 1 ? () => this.onAnimInitialCellComplete() : void 0
        });
        newRow.push(cell);
        this.addUIElement(cell);
      }
      this.cells[row] = newRow;
    }
    this.addGraphics(this.selectionLayer);
    this.addGraphics(this.blockLayer);
    this.addGraphics(this.cellModifierLayer);
    this.addGraphics(this.animLayer);
    this.addGraphics(this.fxLayer);
    this.hintMarkersTimer = new AnTimer({
      duration: 5,
      autoStart: false,
      autoRemove: false,
      updater: this.getUpdater(),
      loopCount: 0,
      callbacks: {
        onComplete: () => this.makeHintMarkers()
      }
    });
    this.addToCleanup(() => this.hintMarkersTimer.terminate());
    this.addToCleanup(AnEvents.on(this.controlsRouter + "controls:pointerdown" /* PointerDown */, this.onSelectionStart.bind(this)).unsub);
    this.addToCleanup(AnEvents.on(this.controlsRouter + "controls:pointermove" /* PointerMove */, this.onSelectionMove.bind(this)).unsub);
    this.addToCleanup(AnEvents.on(this.controlsRouter + "controls:pointerup" /* PointerUp */, this.onSelectionEnd.bind(this)).unsub);
    this.addToCleanup(AnEvents.on(
      "storage:theme:update",
      (e2) => this.theme = e2.data.value
    ).unsub);
  }
  get focusPanelShowed() {
    return this.focusPanel !== null;
  }
  hideFocus() {
    if (!this.focusPanel) return;
    const focusPanel = this.focusPanel;
    new AnTween({
      target: this.focusPanel,
      from: { alpha: 1 },
      to: { alpha: 0 },
      duration: 1,
      easing: AnEase.easeOut,
      updater: this.getUpdater(),
      callbacks: {
        onComplete: () => {
          this.terminateUIElement("focusPanel");
        }
      }
    });
    this.focusPanel = null;
  }
  showFocus(focusCells) {
    if (this.focusPanel) {
      this.hideFocus();
    }
    this.focusPanel = this.addUIElement(
      "focusPanel",
      new UIFocus({
        rows: this.rowsCount,
        cols: this.colsCount,
        startPresetCol: this.startPresetCol,
        focusCells,
        backgroundColor: 3355443,
        backgroundAlpha: 0.5,
        blurStrength: 8,
        useDropShadow: true
      })
    );
    this.focusPanel.alpha = 0;
    this.animLayer.attach(this.focusPanel);
    new AnTween({
      target: this.focusPanel,
      from: { alpha: 0 },
      to: { alpha: 1 },
      duration: 1,
      easing: AnEase.easeOut,
      updater: this.getUpdater()
    });
  }
  //         
  getCell(row, col) {
    return this.isOutOfBounds(row, col) ? null : this.cells[row][col];
  }
  onSelectionStart(e2) {
    if (this.isSelecting || !this.canSelectBlocks || this.forbidSelectBlocks) return;
    const pos = this.getGridPositionFromPixelPos(new lib_exports.Point(e2.data.x, e2.data.y));
    if (pos && (!this.focusPanel || this.focusPanel.isPosInFocus(pos))) {
      const cell = this.getCell(pos.row, pos.col);
      if (cell) {
        const block = cell.block;
        if (block) {
          if (block.prop && !cell.hasModifier(2 /* Cage */)) {
            AnControls.vibrate();
            this.isSelecting = true;
            this.selectedBlocks = [block];
            block.highlighted = true;
            block.selected = true;
            AnSounds.play(
              `sounds/select.snd.mp3`,
              0.6,
              AnMath.remapClamp(block.gridPos.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
              1
            );
          } else {
            //!    (
            const game = GameApp.self.game;
            if (game.tutorial === "Bombs" /* Bombs */) {
              if (game.tutorialStage < 3) {
                const pos2 = e2.data;
                AnSounds.play(
                  `sounds/buy_no.snd.mp3`,
                  0.6
                );
                game.showTip(
                  AnLang.get("tutorialTryBombSpec_chainHint" + (game.tutorialStage === 2 ? "2" : "")),
                  { x: pos2.x, y: pos2.y - scaled(CellHalfSize) * 1.8 },
                  16777215
                );
              }
            }
          }
        }
      }
    }
  }
  onSelectionMove(e2) {
    if (!this.isSelecting) return;
    if (G.useCancelSelectionByTop) {
      if (e2.data.y < this.y - scaled(50)) {
        this.clearSelectionLines();
        this.selectedBlocks.forEach((block) => {
          block.highlighted = false;
          block.selected = false;
        });
        this.selectedBlocks = [];
        this.isSelecting = false;
        return;
      }
    }
    const pixelPos = new lib_exports.Point(e2.data.x, e2.data.y);
    const pos = this.getGridPositionFromPixelPos(pixelPos);
    if (!pos || this.focusPanel && !this.focusPanel.isPosInFocus(pos)) return;
    const cell = this.getCell(pos.row, pos.col);
    if (!cell) return;
    if (this.selectedBlocks.length > 1) {
      const localPixelPos = this.toLocal(pixelPos);
      const prevBlock = this.selectedBlocks[this.selectedBlocks.length - 2];
      const prevBlockPixelPos = prevBlock.gridPos.toPixelPos();
      if (prevBlock.gridPos.row === pos.row && prevBlock.gridPos.col === pos.col && AnMath.distance(prevBlockPixelPos, localPixelPos) < CellHalfSize * 0.6) {
        const removedBlock = this.selectedBlocks.pop();
        removedBlock.highlighted = false;
        removedBlock.selected = false;
        if (this.selectionLines.length > 0) {
          const lastLine = this.selectionLines.pop();
          this.selectionLineTweens.pop()?.terminate();
          this.terminateUIElement(lastLine);
        }
        return;
      }
    }
    const currentBlock = cell.block;
    const lastBlock = this.selectedBlocks[this.selectedBlocks.length - 1];
    if (currentBlock && currentBlock.type === lastBlock.type && !this.selectedBlocks.includes(currentBlock) && currentBlock.gridPos.adjacent(lastBlock.gridPos) && !cell.hasModifier(2 /* Cage */)) {
      if (this.selectedBlocks.length >= 2) {
        const lastPos = lastBlock.gridPos;
        const currentPos = currentBlock.gridPos;
        const isCurrentDiagonal = Math.abs(lastPos.row - currentPos.row) === 1 && Math.abs(lastPos.col - currentPos.col) === 1;
        if (isCurrentDiagonal) {
          for (let i3 = 0; i3 < this.selectedBlocks.length - 2; i3++) {
            const pos1 = this.selectedBlocks[i3].gridPos;
            const pos2 = this.selectedBlocks[i3 + 1].gridPos;
            const isPrevDiagonal = Math.abs(pos1.row - pos2.row) === 1 && Math.abs(pos1.col - pos2.col) === 1;
            if (isPrevDiagonal) {
              if (lastPos.row !== pos1.row && lastPos.row !== pos2.row && currentPos.row !== pos1.row && currentPos.row !== pos2.row || lastPos.col !== pos1.col && lastPos.col !== pos2.col && currentPos.col !== pos1.col && currentPos.col !== pos2.col) {
                continue;
              }
              const centerRow = (pos1.row + pos2.row) / 2;
              const centerCol = (pos1.col + pos2.col) / 2;
              const currentCenterRow = (lastPos.row + currentPos.row) / 2;
              const currentCenterCol = (lastPos.col + currentPos.col) / 2;
              if (Math.abs(centerRow - currentCenterRow) < 0.1 && Math.abs(centerCol - currentCenterCol) < 0.1) {
                return;
              }
            }
          }
        }
      }
      AnControls.vibrate();
      this.selectedBlocks.push(currentBlock);
      currentBlock.highlighted = true;
      currentBlock.selected = true;
      this.createSelectionLine(lastBlock, currentBlock);
      AnSounds.play(
        `sounds/select.snd.mp3`,
        0.6,
        AnMath.remapClamp(currentBlock.gridPos.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
        Math.min(4, 1 + this.selectedBlocks.length * 0.1)
      );
    }
  }
  createSelectionLine(lastBlock, currentBlock) {
    const posA = lastBlock.gridPos.toPixelPos();
    const posB = currentBlock.gridPos.toPixelPos();
    const dx = posB.x - posA.x;
    const dy = posB.y - posA.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    const line = new AnImage({
      atlas: "atlases/game.ss.pixi.atlas",
      sprite: "./selectLine",
      anchor: AnAnchor.Center
    });
    const lineScale = (distance + CellSize * 0.25) / 256;
    line.scale.set(lineScale, 1);
    line.rotation = angle;
    line.position.set(posA.x + dx / 2, posA.y + dy / 2);
    line.blendMode = G.forceLowQulity ? "normal" : "add";
    const lineAlpha = 1;
    const addToFront = false;
    this.addUIElement(line);
    this.selectionLines.push(line);
    if (addToFront)
      this.fxLayer.attach(line);
    else
      this.selectionLayer.attach(line);
    const tween = new AnTween({
      target: line,
      from: { alpha: lineAlpha * 0.9, scale: { y: 0.7, x: lineScale } },
      to: { alpha: lineAlpha, scale: { y: 1, x: lineScale } },
      tolerance: 0.2,
      duration: 2 - AnRnd.float(0, 0.5),
      delay: AnRnd.float(0, 0.3),
      easing: AnEase.easeInOut,
      updater: this.getUpdater(),
      repeat: Infinity,
      reverse: true
    });
    this.selectionLineTweens.push(tween);
  }
  onSelectionEnd(e2) {
    if (!this.isSelecting || this.selectedBlocks.length === 0) return;
    if (this.selectedBlocks.length >= 3) {
      const lastChainBlockPos = {
        x: AnControls.pointerX,
        y: AnControls.pointerY
      };
      const chainLength = this.selectedBlocks.length;
      if (this.focusPanel)
        this.addFocusCellsToSelection();
      this.applySelectedBlocks();
      if (G.removeLastLineAfterMove)
        this.lastLineRemoved = false;
      else
        this.removeLastLineBlocks();
      this.clearHintMarkers();
      if (G.stonesCrushBellowBlock)
        this.stonesCrushBellowBlock();
      AnEvents.emit("gameplay:player:makeMove", { lastChainBlockPos, chainLength });
      if (G.dev_showAllPossibleChains)
        this.clearDebugGraphics();
    } else {
      this.selectedBlocks.forEach((block) => {
        block.highlighted = false;
        block.selected = false;
      });
    }
    this.clearSelectionLines();
    this.selectedBlocks = [];
    this.isSelecting = false;
  }
  cellInSelection(cell) {
    return this.selectedBlocks.some((block) => block.gridPos.row === cell.row && block.gridPos.col === cell.col);
  }
  addFocusCellsToSelection() {
    const focusCells = this.focusPanel?.focusCells;
    if (focusCells) {
      for (const cell of focusCells) {
        const pos = new GridPos(cell.row, cell.col + this.startPresetCol);
        if (!this.cellInSelection(pos)) {
          const cell2 = this.getCell(pos.row, pos.col);
          const block = cell2?.block;
          if (cell2 && !cell2.hasModifier(2 /* Cage */) && block && !block.special) {
            block.selected = true;
            block.highlighted = true;
            this.selectedBlocks.push(block);
          }
        }
      }
    }
  }
  setFocusPropBlocksToType(type) {
    const focusCells = this.focusPanel?.focusCells;
    if (focusCells) {
      for (const cell of focusCells) {
        const pos = new GridPos(cell.row, cell.col + this.startPresetCol);
        if (!this.cellInSelection(pos)) {
          const cell2 = this.getCell(pos.row, pos.col);
          const block = cell2?.block;
          if (cell2 && !cell2.hasModifier(2 /* Cage */) && block && !block.special)
            block.setTypeNoAnim(type);
        }
      }
    }
  }
  setFocusSpecialBlocksHighlighted() {
    const focusCells = this.focusPanel?.focusCells;
    if (focusCells) {
      for (const cell of focusCells) {
        const pos = new GridPos(cell.row, cell.col + this.startPresetCol);
        if (!this.cellInSelection(pos)) {
          const cell2 = this.getCell(pos.row, pos.col);
          const block = cell2?.block;
          if (block && block.special && !block.highlighted) {
            block.highlighted = true;
            this.applyBlock(block);
          }
        }
      }
    }
  }
  countCages() {
    let count2 = 0;
    for (let col = 0; col < this.colsCount; ++col)
      for (let row = 0; row < this.rowsCount; ++row)
        if (this.getCell(row, col)?.hasModifier(2 /* Cage */)) ++count2;
    return count2;
  }
  stonesCrushBellowBlock() {
    for (let col = 0; col < this.colsCount; ++col) {
      for (let row = this.rowsCount - 1; row >= 0; --row) {
        const block = this.getCell(row, col)?.block;
        if (!block || block.removed || block.highlighted)
          break;
        if (block.specialStone) {
          const bellowBlock = this.getCell(row + 1, col)?.block;
          if (bellowBlock && !bellowBlock.specialStone && !bellowBlock.highlighted) {
            this.applyBlock(bellowBlock, true);
            break;
          }
        }
      }
    }
  }
  removeLastLineBlocks() {
    for (let col = 0; col < this.colsCount; col++) {
      const block = this.getCell(this.rowsCount - 1, col)?.block;
      if (block && !this.selectedBlocks.includes(block) && !block.highlighted && !block.specialStone) {
        this.applyBlock(block, true);
      }
    }
  }
  dropAllBlocks() {
    for (let col = 0; col < this.colsCount; ++col) {
      for (let row = 0; row < this.rowsCount; ++row) {
        const cell = this.getCell(row, col);
        if (cell && cell.block) {
          this.applyBlock(cell.block, true);
        }
      }
    }
  }
  applySelectedBlocks() {
    this.playerRemoveFirstBlocks = true;
    const blocksToRemove = this.selectedBlocks;
    const chainLength = this.selectedBlocks.length;
    let activatedAndPainted = blocksToRemove.some((block) => this.getCell(block.gridPos.row, block.gridPos.col)?.hasModifier(1 /* Paint */));
    let minBlockByRow = blocksToRemove[0];
    let minBlockID = 0;
    for (let i3 = 0; i3 < blocksToRemove.length; ++i3) {
      const block = blocksToRemove[i3];
      if (block.gridPos.row < minBlockByRow.gridPos.row) {
        minBlockByRow = block;
        minBlockID = i3;
      }
      block.activatedAndPainted = activatedAndPainted;
      this.applySpecialsAroundBlock(block);
      this.applyCellModifiersAroundBlock(block);
    }
    let specialCreateType;
    let specialCreateID;
    if (!this.forbidAllSpecBlocks && chainLength >= G.specialBlockForLongChain) {
      const moreForbidSpecials = ["spec_chest"];
      const allowedSpecs = BonusSpecBlockTypeArray.filter((type) => !this.forbidSpecials.includes(type) && !moreForbidSpecials.includes(type));
      if (allowedSpecs.length) {
        specialCreateType = this.generateRandomSpecBlockType(this.specRndSeed, allowedSpecs);
        //!    :(
        const game = GameApp.self.game;
        if (game.tutorial === "Train1" /* Train1 */ && game.tutorialStage === 1)
          specialCreateType = "spec_rocket_diagonal1";
        specialCreateID = minBlockID;
      }
    }
    let currentIndex = 0;
    const removalTimer = new AnTimer({
      duration: 0.1,
      loopCount: blocksToRemove.length - 1,
      //     
      updater: this.getUpdater(),
      callbacks: {
        onComplete: () => {
          const block = blocksToRemove[currentIndex];
          const blockGridPos = block.gridPos.clone();
          this.applyBlock(block, false, true);
          if (specialCreateID === currentIndex && specialCreateType) {
            const block2 = new Block({
              pos: blockGridPos.clone(),
              type: specialCreateType,
              updater: this.getUpdater() ?? AnCore.updater,
              selectionLayer: this.selectionLayer,
              blockLayer: this.blockLayer,
              makeMarkableAnim: true,
              delayCreatingAnim: 0.5
            });
            this.cells[blockGridPos.row][blockGridPos.col].block = block2;
            block2.updateGridPos(blockGridPos.row, blockGridPos.col);
            this.blocks.push(block2);
            this.addUIElement(block2);
            const pixelPos = blockGridPos.toPixelPos();
            const blastFX = new AnFX({
              atlas: "atlases/game.ss.pixi.atlas",
              sprite: "./sparkleGlow",
              anchor: AnAnchor.Center,
              loopTween: {
                from: {
                  alpha: 4,
                  scale: {
                    x: 0.4,
                    y: 0.4
                  }
                },
                to: {
                  alpha: 0,
                  scale: {
                    x: 2.5,
                    y: 2.5
                  }
                },
                duration: 1.5,
                easing: AnEase.easeOut
              },
              updater: this.getUpdater()
            });
            blastFX.position.set(pixelPos.x, pixelPos.y);
            blastFX.blendMode = G.forceLowQulity ? "normal" : "add";
            this.fxLayer.attach(blastFX);
            this.addGraphics(blastFX);
          }
          currentIndex++;
        }
      }
    });
  }
  applySpecialsAroundBlock(block) {
    const pos = block.gridPos;
    const specials = [];
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        if (!G.applySpecialsByDiagonals && dx !== 0 && dy !== 0) continue;
        const row = pos.row + dy;
        const col = pos.col + dx;
        const cell = this.getCell(row, col);
        if (cell && !cell.hasModifier(2 /* Cage */)) {
          const block2 = cell.block;
          if (block2 && !block2.highlighted && block2.special && block2.canMove)
            specials.push(block2);
        }
      }
    }
    for (const special of specials) {
      special.highlighted = true;
      special.activatedType = block.type;
      special.activatedBlocks = this.selectedBlocks;
      if (G.specialsSpreyPaint)
        special.activatedAndPainted = block.activatedAndPainted;
      const removalTimer = new AnTimer({
        duration: 0.2,
        updater: this.getUpdater(),
        callbacks: {
          onComplete: () => this.applyBlock(special, false, true)
        }
      });
    }
  }
  applyCellModifiersAroundBlock(block) {
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        if (!G.applyCellModifiersByDiagonals && dx !== 0 && dy !== 0) continue;
        const row = block.gridPos.row + dy;
        const col = block.gridPos.col + dx;
        const cell = this.getCell(row, col);
        if (cell) {
          if (cell.hasModifier(2 /* Cage */)) {
            AnSounds.play(
              `sounds/cage.snd.mp3`,
              0.6,
              AnMath.remapClamp(col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
              AnRnd.float(0.9, 1.1)
            );
            cell.removeModifier(2 /* Cage */);
            AnEvents.emit("gameplay:other:apply", { type: "cellCage", score: 1 });
          }
        }
      }
    }
  }
  applyBlock(block, removeOnly = false, fromPlayerSelection = false) {
    if (block.destroyed || block.removed) {
      AnLog.error(`block \u0443\u0436\u0435 \u0443\u043D\u0438\u0447\u0442\u043E\u0436\u0435\u043D! [${block.type}]`);
      return;
    }
    let emitApplyEvent = () => {
      this.removeBlock(block);
      AnEvents.emit("gameplay:block:apply", { block, globalPos: block.getGlobalPosition(), removeOnly, fromPlayerSelection });
    };
    if (!removeOnly) {
      const cell = this.getCell(block.gridPos.row, block.gridPos.col);
      if (cell) {
        if (block.activatedAndPainted && !cell.hasModifier(1 /* Paint */)) {
          AnSounds.play(
            `sounds/paint.snd.mp3`,
            0.6,
            AnMath.remapClamp(block.gridPos.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
            AnRnd.float(0.9, 1.1)
          );
          cell.addModifier(1 /* Paint */);
          AnEvents.emit("gameplay:other:apply", { type: "cellPainted", score: 1 });
        }
        cell.activateHighlight();
      }
    }
    if (!removeOnly && block.special) {
      if (block.specialRocket)
        this.activateRocket(block, emitApplyEvent);
      if (block.specialBomb)
        this.activateBomb(block, emitApplyEvent);
      if (block.specialRainbow)
        this.activateRainbow(block, emitApplyEvent);
      if (block.specialDice)
        this.activateDice(block, emitApplyEvent);
      if (block.specialMirror)
        this.activateMirror(block, emitApplyEvent);
      if (block.specialChest)
        this.activateChest(block, emitApplyEvent);
      if (block.specialStone)
        this.activateStone(block, emitApplyEvent);
      if (block.specialHeart)
        this.activateHeart(block, emitApplyEvent);
      if (!fromPlayerSelection) {
        AnSounds.play(
          `sounds/combo.snd.mp3`,
          0.6
        );
        const pixelPos = block.gridPos.toPixelPos();
        pixelPos.x += AnRnd.float(-CellHalfSize, +CellHalfSize);
        pixelPos.y += AnRnd.float(-CellHalfSize, +CellHalfSize);
        GameApp.self.game.showTip(AnLang.get("chainCombo"), { x: pixelPos.x * this.scale.x + this.x, y: pixelPos.y * this.scale.y + this.y });
      }
    } else
      emitApplyEvent();
  }
  removeBlock(block) {
    const pos = block.gridPos;
    if (block.removed) {
      AnLog.error(`removeBlock: block.removed = true, \u0437\u043D\u0430\u0447\u0438\u0442 \u043F\u043E\u0432\u0442\u043E\u0440\u043D\u043E\u0435 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0435 \u0443\u0436\u0435 \u0443\u0434\u0430\u043B\u0435\u043D\u043D\u043E\u0433\u043E \u0431\u043B\u043E\u043A\u0430!`);
      return;
    }
    if (!this.isOutOfBounds(pos.row, pos.col))
      this.cells[pos.row][pos.col].block = null;
    block.markAsRemoved();
    removeByValue(this.blocks, block);
    this.removeUIElement(block);
  }
  clearSelectionLines() {
    this.selectionLines.forEach((line) => this.terminateUIElement(line));
    this.selectionLineTweens.forEach((tween) => tween.terminate());
    this.selectionLines = [];
    this.selectionLineTweens = [];
  }
  //  null      
  getGridPositionFromPixelPos(pointer) {
    const localPoint = this.toLocal(pointer);
    const col = Math.floor(localPoint.x / CellSize);
    const row = Math.floor(localPoint.y / CellSize);
    return col < 0 || col >= this.colsCount || row < 0 || row >= this.rowsCount ? null : new GridPos(row, col);
  }
  onAnimInitialCellComplete() {
    this.tryToCreateBlocks();
    new AnTask({
      handler: () => this.updateBlocks(),
      updater: this.getUpdater()
    });
  }
  /**
   *      
   * @param col  
   * @returns    
   */
  getBlocksCountInColumn(col) {
    if (!AnMath.inRange(col, 0, this.colsCount - 1))
      return -1;
    let count2 = 0;
    for (const block of this.blocks)
      if (block.gridPos.col === col)
        ++count2;
    return count2;
  }
  // private generateRandomBlockType(col: number): BlockType
  // {
  // 	//return "prop_1";
  // 	const rndSeed = this.colRndSeed[col];
  // 	let type = ("prop_" + rndSeed.seed_int(0, 6)) as BlockType;
  // 	if (rndSeed.seed_bool(0.1)) //   
  // 	{
  // 		//   
  // 		const specBlockTypes = SpecBlockTypeArray.filter((item) => !this.forbidSpecials.includes(item));
  // 		type = specBlockTypes[rndSeed.seed_int(0, specBlockTypes.length - 1)] as BlockType;
  // 	}
  // 	return type;
  // }
  //      -   (     ) 
  getOccupiedBlockByGridPos(pos, self2) {
    for (const block of this.blocks)
      if (block !== self2 && pos.equal(block.gridPos))
        return block;
    return null;
  }
  isOutOfBounds(row, col) {
    return row < 0 || row >= this.rowsCount || col < 0 || col >= this.colsCount;
  }
  updateBlocks() {
    let anyUpdates = this.tryToCreateBlocks();
    this.updateCells();
    for (let col = 0; col < this.colsCount; ++col) {
      for (let row = this.rowsCount - 2; row >= 0; --row) {
        const cell = this.getCell(row, col);
        if (cell?.block) {
          const block = cell?.block;
          if (block.canMoveNotHighlighted && !block.moving) {
            let targetRow = row;
            const blocksBelow = [];
            while (targetRow + 1 < this.rowsCount) {
              const cell2 = this.getCell(targetRow + 1, col);
              if (cell2 && cell2.block) blocksBelow.push(cell2.block);
              targetRow++;
            }
            if (blocksBelow.length) {
              const upperBlock = blocksBelow.reduce(
                (minBlock, currentBlock) => currentBlock.targetPos.row < minBlock.targetPos.row ? currentBlock : minBlock,
                blocksBelow[0]
              );
              targetRow = upperBlock.targetPos.row - 1;
            }
            if (targetRow !== row) {
              anyUpdates = true;
              block.moveTo(new GridPos(targetRow, block.gridPos.col), !this.playerRemoveFirstBlocks);
            }
          }
        }
      }
    }
    for (const block of this.blocks)
      if (block.moving || !block.canMove || block.highlighted && (!block.selected || !this.isSelecting)) {
        anyUpdates = true;
        break;
      }
    const fieldAnyUpdates = this.blocks.length > 0 && !anyUpdates;
    const canSelectBlocks = fieldAnyUpdates && (!G.removeLastLineAfterMove || this.lastLineRemoved);
    if (G.removeLastLineAfterMove) {
      if (fieldAnyUpdates && !this.lastLineRemoved) {
        this.lastLineRemoved = true;
        this.removeLastLineBlocks();
        return;
      }
    }
    if (this.canSelectBlocks !== canSelectBlocks) {
      if (canSelectBlocks) {
        let minChain = this.getMinChain();
        if (minChain) {
          AnEvents.emit("gameplay:field:readyForNextMove");
          if (this.showHintMarkers) {
            this.hintMinChain = minChain;
            this.hintMarkersTimer.start();
          }
        } else {
          AnSounds.play(
            `sounds/no_moves.snd.mp3`,
            0.6
          );
          AnEvents.emit("gameplay:field:noMoves");
          this.playerRemoveFirstBlocks = false;
          this.clearHintMarkers();
          this.clearSelectionLines();
          this.dropAllBlocks();
          return;
        }
        if (G.dev_showAllPossibleChains) {
          const chains = /* @__PURE__ */ new Map();
          for (let t2 = 0; t2 < 7; ++t2) {
            const type = "prop_" + t2;
            chains.set(t2, this.getUniqueChainsForType(type));
          }
          this.clearDebugGraphics();
          chains.forEach((chains2) => this.debugGraphics = this.visualizeChains(chains2, this.debugGraphics));
        }
      }
      this.canSelectBlocks = canSelectBlocks;
    }
  }
  clearHintMarkers() {
    this.hintMarkersTimer.reset();
    this.hintMinChain = null;
    for (const hint of this.blocksHintMarkers)
      hint.terminate();
    this.blocksHintMarkers = [];
  }
  //      
  fillHintMarkersAndShow(cellsPos, excludeSpecialsAndCellMods = false) {
    for (const cellPos of cellsPos) {
      const cell = this.getCell(cellPos.row, cellPos.col + this.startPresetCol);
      const block = cell?.block;
      if (cell && block && (!excludeSpecialsAndCellMods || !block.special && !cell.hasModifier(2 /* Cage */))) {
        if (!this.hintMinChain) this.hintMinChain = [];
        this.hintMinChain.push(block);
      }
    }
    if (this.hintMinChain)
      this.makeHintMarkers();
  }
  //     
  makeHintMarkers() {
    if (!this.hintMinChain) return;
    for (const block of this.hintMinChain) {
      const markerFX = new AnFX({
        atlas: "atlases/game.ss.pixi.atlas",
        sprite: "./hintHalo",
        anchor: AnAnchor.Center,
        // entranceTween: {
        // 	from: { alpha: 0, scale: { x: 0.1, y: 0.1 } },
        // 	to: { alpha: 1, scale: { x: 1, y: 1 } },
        // 	duration: 0.5,
        // 	easing: AnEase.easeOut,
        // },
        loopTween: {
          from: { alpha: 1.5, scale: { x: 0.3, y: 0.3 } },
          to: { alpha: 0, scale: { x: 2, y: 2 } },
          duration: 3,
          easing: AnEase.easeOut,
          repeat: Infinity
        },
        autoTerminate: false,
        updater: this.getUpdater()
      });
      markerFX.blendMode = G.forceLowQulity ? "normal" : "add";
      this.fxLayer.attach(markerFX);
      this.addGraphics(markerFX);
      const pixelPos = block.gridPos.toPixelPos();
      markerFX.position.set(pixelPos.x, pixelPos.y);
      this.blocksHintMarkers.push(markerFX);
    }
  }
  updateCells() {
    for (let col = 0; col < this.colsCount; ++col)
      for (let row = 0; row < this.rowsCount; ++row)
        this.cells[row][col].block = null;
    for (const block of this.blocks) {
      const gridPos = block.gridPos;
      if (!this.isOutOfBounds(gridPos.row, gridPos.col))
        this.cells[gridPos.row][gridPos.col].block = block;
    }
  }
  get scaledCellSize() {
    return this.scaledWidth / this.colsCount;
  }
  terminate() {
    this.clearDebugGraphics();
    this.clearHintMarkers();
    this.clearSelectionLines();
    super.terminate();
  }
};

// angine/src/ui/AnCounter.ts
init_define_AnParams();
var AnCounter = class extends AnUIGroupElement {
  constructor(config2) {
    super(config2);
    this._currentCount = 0;
    this._maxCount = 100;
    this.counterOffset = 5;
    this.layout = config2.layout ?? "horizontal" /* Horizontal */;
    this._displayMode = config2.displayMode ?? "counter" /* Counter */;
    this.statusChange = config2.statusChange ?? "zero" /* Zero */;
    this._maxCount = config2.maxCount ?? config2.currentCount;
    this._currentCount = config2.currentCount;
    this.mainIcon = this.addUIElement(
      "mainIcon",
      new AnImage({
        ...config2.mainIcon,
        anchor: AnAnchor.TopLeft
      })
    );
    this.labelCounter = this.addUIElement(
      "counter",
      new AnLabel({
        text: {
          ...config2.labelTextStyle,
          textSource: () => this._currentCount.toString(),
          textAlign: this.layout === "horizontal" /* Horizontal */ ? "left" /* Left */ : "center" /* Center */,
          autoUpdateLang: false
        },
        //backgroundColor: 0x333333,
        labelAlign: this.layout === "horizontal" /* Horizontal */ ? "left" /* Left */ : "center" /* Center */,
        anchor: this.layout === "horizontal" /* Horizontal */ ? AnAnchor.LeftCenter : AnAnchor.TopCenter
      })
    );
    this.labelCounter.visible = this._displayMode === "counter" /* Counter */;
    if (config2.statusIcon) {
      this.statusIcon = this.addUIElement(
        "statusIcon",
        new AnImage({
          ...config2.statusIcon,
          anchor: this.layout === "horizontal" /* Horizontal */ ? AnAnchor.LeftCenter : AnAnchor.TopCenter
        })
      );
      this.statusIconSizeFactor = config2.statusIconSizeFactor ?? 1;
      this.statusIcon.visible = this._displayMode === "status" /* Status */;
    }
    this.defaultResizeStrategy = () => {
      const counterOffsetScaled = scaled(this.counterOffset);
      if (this.layout === "horizontal" /* Horizontal */) {
        this.mainIcon.width = this.mainIcon.realWidth * (this.scaledHeight / this.mainIcon.realHeight);
        this.mainIcon.height = this.scaledHeight;
        this.mainIcon.position.set(0, 0);
        this.labelCounter.scaledWidth = this.scaledWidth - (this.mainIcon.width + counterOffsetScaled);
        this.labelCounter.scaledHeight = this.scaledHeight;
        this.labelCounter.applyDefaultResizeStrategy();
        this.labelCounter.position.set(this.mainIcon.width + counterOffsetScaled, this.mainIcon.height * 0.5);
        if (this.statusIcon) {
          this.statusIcon.width = this.scaledHeight * 0.5;
          this.statusIcon.height = this.scaledHeight * 0.5;
          this.statusIcon.position.set(this.labelCounter.x, this.labelCounter.y);
        }
      } else {
        this.mainIcon.width = this.scaledWidth;
        this.mainIcon.height = this.mainIcon.realHeight * (this.scaledWidth / this.mainIcon.realWidth);
        this.mainIcon.position.set(0, 0);
        this.labelCounter.scaledWidth = this.scaledWidth;
        this.labelCounter.scaledHeight = this.scaledHeight - (this.mainIcon.height + counterOffsetScaled);
        this.labelCounter.applyDefaultResizeStrategy();
        this.labelCounter.position.set(this.mainIcon.width * 0.5, this.mainIcon.height + counterOffsetScaled - this.labelCounter.scaledHeight * 0.3);
        if (this.statusIcon) {
          this.statusIcon.width = this.scaledWidth * 0.5;
          this.statusIcon.height = this.scaledWidth * 0.5;
          this.statusIcon.position.set(this.labelCounter.x, this.labelCounter.y);
        }
      }
    };
    this.configResizeStrategy(config2.resizeStrategy);
  }
  get nopadScaledWidth() {
    return this.mainIcon.width + scaled(this.counterOffset) + this.labelCounter.getTextWidth();
  }
  getMainIconGlobalPos() {
    const globalIconPos = this.mainIcon.getGlobalPosition();
    return new lib_exports.Point(globalIconPos.x + this.mainIcon.width * 0.5, globalIconPos.y + this.mainIcon.height * 0.5);
  }
  modify(value = 1) {
    this._currentCount = Math.min(this._currentCount + value, this._maxCount);
    if (this._currentCount < 0) this._currentCount = 0;
    this.updateCounter();
  }
  set(current = 0) {
    this._currentCount = Math.min(current, this._maxCount);
    if (this._currentCount < 0) this._currentCount = 0;
    this.updateCounter();
  }
  updateTextColor(color) {
    this.labelCounter.textColor = color;
  }
  get currentCount() {
    return this._currentCount;
  }
  set displayMode(mode) {
    this._displayMode = mode;
    this.labelCounter.visible = this._displayMode === "counter" /* Counter */;
    if (this.statusIcon)
      this.statusIcon.visible = this._displayMode === "status" /* Status */;
  }
  get finished() {
    return this.statusIcon?.visible ?? false;
  }
  updateCounter() {
    if (this.labelCounter) {
      this.labelCounter.updateText();
    }
    if (this._displayMode === "counter" /* Counter */ && (this.statusChange === "zero" /* Zero */ && this._currentCount === 0 || this.statusChange === "max" /* Max */ && this._currentCount === this._maxCount)) {
      this.displayMode = "status" /* Status */;
      this.onShowStatus();
    }
  }
  onShowStatus() {
  }
  terminate() {
    super.terminate();
  }
};

// games/packer/src/game/UIGoalProgress.ts
init_define_AnParams();
var UIGoalProgress = class extends enhance(AnUIGroupElement).with(AnUpdatableMixin) {
  constructor(config2) {
    config2.anchor = config2.anchor ?? AnAnchor.Center;
    super(config2);
    this.labelTween = null;
    this.isGoalReachedLast = false;
    const strTotalCount = config2.totalCount.toString();
    this.totalCount = config2.totalCount;
    this.progressBar = this.addUIElement(
      "progressBar",
      new AnProgressBar({
        value: 0,
        anchor: AnAnchor.Center,
        foreground: {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./button",
          slice9: {
            left: 20,
            right: 20,
            top: 20,
            bottom: 20
          }
        },
        background: {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./buttonHover",
          slice9: {
            left: 20,
            right: 20,
            top: 20,
            bottom: 20
          }
        }
      })
    );
    this.labelCurrentScore = this.addUIElement(
      "currentScoreLabel",
      new AnLabel({
        text: {
          textSource: "0",
          fontName: "mainFont",
          fontSize: 50,
          textAlign: "center" /* Center */,
          autoUpdateLang: false,
          shadowAlpha: 0.7
        },
        //backgroundColor: 0x333333,
        labelAlign: "center" /* Center */,
        anchor: AnAnchor.Center
      })
    );
    this.labelTotalScore = this.addUIElement(
      "totalScoreLabel",
      new AnLabel({
        text: {
          textSource: strTotalCount,
          fontName: "mainFont",
          fontSize: 50,
          textAlign: "center" /* Center */,
          autoUpdateLang: false,
          shadowAlpha: 0.7
        },
        //backgroundColor: 0x333333,
        labelAlign: "center" /* Center */,
        anchor: AnAnchor.Center
      })
    );
    this.defaultResizeStrategy = () => {
      const scoreWidth = scaled(26 * strTotalCount.length);
      const scorePadding = scaled(5);
      const scoreOffsetY = -scaled(AnUI.styleParams.shadowOffset);
      this.progressBar.scaledWidth = this.scaledWidth - (scoreWidth + scorePadding) * 2;
      this.progressBar.scaledHeight = this.scaledHeight * 0.7;
      this.progressBar.applyDefaultResizeStrategy();
      this.progressBar.position.set(scoreWidth + scorePadding + this.progressBar.scaledWidth * 0.5, this.progressBar.scaledHeight * 0.5);
      this.labelCurrentScore.scaledWidth = scoreWidth;
      this.labelCurrentScore.scaledHeight = this.progressBar.scaledHeight * 2;
      this.labelCurrentScore.applyDefaultResizeStrategy();
      this.labelCurrentScore.position.set(this.progressBar.left - scorePadding - scoreWidth * 0.5, this.progressBar.y + scoreOffsetY);
      this.labelTotalScore.scaledWidth = scoreWidth;
      this.labelTotalScore.scaledHeight = this.progressBar.scaledHeight * 2;
      this.labelTotalScore.applyDefaultResizeStrategy();
      this.labelTotalScore.position.set(this.progressBar.right + scorePadding + scoreWidth * 0.5, this.progressBar.y + scoreOffsetY);
    };
    this.configResizeStrategy(config2.resizeStrategy);
  }
  getGoalGlobalPos() {
    const globalLabelPos = this.labelCurrentScore.getGlobalPosition();
    return new lib_exports.Point(globalLabelPos.x + this.labelCurrentScore.scaledWidth * 0.5, globalLabelPos.y);
  }
  updateValue(currentValue, withAnim = true) {
    const current = Math.min(currentValue, this.totalCount);
    this.progressBar.value = current / this.totalCount;
    this.labelCurrentScore.setText(current.toString());
    this.labelTotalScore.updateText();
    if (AnMath.floatEqual(current, this.totalCount) && !this.isGoalReachedLast) {
      this.isGoalReachedLast = true;
      AnSounds.play(
        `sounds/goal.snd.mp3`,
        0.6
      );
    }
    if (withAnim) {
      if (this.labelTween) {
        this.labelTween.terminate();
        this.labelTween = null;
      }
      this.labelTween = new AnTween({
        target: this.labelCurrentScore,
        from: { scale: { x: 1.5, y: 1.5 }, tint: 65280 },
        to: { scale: { x: 1, y: 1 }, tint: 16777215 },
        duration: 1,
        easing: AnEase.easeOutBounce,
        updater: this.getUpdater(),
        autoRemove: true,
        callbacks: {
          onComplete: () => this.labelTween = null
        }
      });
    }
  }
  update(dt) {
    super.update(dt);
    this.progressBar.update(dt);
  }
};

// games/packer/src/game/UIGoalCounter.ts
init_define_AnParams();
var UIGoalCounter = class extends enhance(AnCounter).with(AnUpdatableMixin) {
  constructor(config2) {
    const iconConfig = {
      ...config2.mainIcon,
      atlas: "atlases/game.ss.pixi.atlas",
      sprite: "./" + config2.iconType + (config2.iconType.startsWith("prop") && config2.iconType !== "prop_heart" ? "_" + config2.blockTheme : "")
    };
    const iconStatusConfig = {
      ...config2.statusIcon,
      atlas: "atlases/game.ss.pixi.atlas",
      sprite: "./v"
    };
    super({
      ...config2,
      labelTextStyle: {
        fontName: "mainFont",
        fontSize: 60,
        shadowAlpha: 0.7,
        shadowOffsetX: 2,
        shadowOffsetY: 2
      },
      mainIcon: iconConfig,
      statusIcon: iconStatusConfig,
      layout: "horizontal" /* Horizontal */
    });
    this.labelTween = null;
    this._iconType = config2.iconType ?? "star_mod";
    this._blockTheme = config2.blockTheme ?? "toys" /* Toys */;
    this.addToCleanup(AnEvents.on(
      "storage:theme:update",
      (e2) => this.onSettingsThemeUpdate(e2.data.value)
    ).unsub);
    this.addToCleanup(AnEvents.on(
      "storage:color:update",
      (e2) => this.onSettingsColorUpdate(e2.data.value)
    ).unsub);
    this.onSettingsColorUpdate(GameApp.self.gameData.color);
  }
  onSettingsColorUpdate(color) {
    if (this._iconType === "cellPainted") {
      this.mainIcon.tint = Cell.getCellPaintedColor(GameColorsDB[color].baseColorTint);
    }
  }
  onSettingsThemeUpdate(theme) {
    this._blockTheme = theme;
    if (this._iconType.startsWith("prop_") && this._iconType != "prop_heart") {
      this.mainIcon.changeTexture("./" + this._iconType.split("_", 2).join("_") + `_${this._blockTheme}`, "atlases/game.ss.pixi.atlas");
    }
  }
  /**
   *   ,    
   */
  get iconType() {
    return this._iconType;
  }
  onShowStatus() {
    super.onShowStatus();
    AnSounds.play(
      `sounds/goal.snd.mp3`,
      0.6
    );
  }
  setTextColor(color) {
    this.elements["counter"].tint = color;
  }
  updateValue(current, withAnim = true) {
    const lastCounterVisible = this.elements["counter"].visible;
    this.set(current);
    if (withAnim) {
      if (this.elements["counter"].visible) {
        if (this.labelTween) {
          this.labelTween.terminate();
          this.labelTween = null;
        }
        this.labelTween = new AnTween({
          target: this.elements["counter"],
          from: { scale: { x: 1.25, y: 1.25 }, tint: 65280 },
          to: { scale: { x: 1, y: 1 }, tint: 16777215 },
          duration: 2,
          easing: AnEase.easeInOutBack,
          updater: this.getUpdater(),
          autoRemove: true,
          callbacks: {
            onComplete: () => this.labelTween = null
          }
        });
      } else if (lastCounterVisible) {
        if (this.labelTween) {
          this.labelTween.terminate();
          this.labelTween = null;
        }
        this.labelTween = new AnTween({
          target: this.elements["statusIcon"],
          from: { scale: { x: 0.3, y: 0.3 }, tint: 65280 },
          to: { scale: { x: 0.5, y: 0.5 }, tint: 16777215 },
          duration: 2,
          easing: AnEase.easeOutElastic,
          updater: this.getUpdater(),
          autoRemove: true,
          callbacks: {
            onComplete: () => this.labelTween = null
          }
        });
      }
    }
  }
};

// games/packer/src/game/UIBigTitle.ts
init_define_AnParams();
var UIBigTitle = class extends enhance(AnUIGroupElement).with(AnUpdatableMixin) {
  constructor(config2) {
    super(config2);
    this.bgTween = null;
    this.labelTween = null;
    if (config2.updater) this.addToUpdater(config2.updater);
    this.appearDuration = config2.appearDuration ?? 1;
    this.disappearDuration = config2.disappearDuration ?? 1.5;
    this.appearDelay = config2.appearDelay ?? 0.3;
    this.stayDelay = config2.stayDelay ?? 3;
    this.callbacks = config2.callbacks ?? {};
    this.background = this.addUIElement(
      "background",
      new AnImage({
        ...config2.background,
        anchor: AnAnchor.Center
      })
    );
    this.labelText = this.addUIElement(
      "labelText",
      new AnLabel({
        ...config2.labelText,
        anchor: AnAnchor.Center
      })
    );
    this.addToCleanup(() => this.cleanupTweens());
    this.defaultResizeStrategy = () => {
      this.background.setScaledSize(this.scaledWidth, this.scaledHeight);
      this.labelText.setScaledSize(this.scaledWidth, this.scaledHeight);
      this.background.applyDefaultResizeStrategy();
      this.labelText.applyDefaultResizeStrategy();
      this.background.position.set(this.scaledWidth * 0.5, this.scaledHeight * 0.5);
      this.labelText.position.set(this.scaledWidth * 0.5, this.scaledHeight * 0.5);
    };
    this.configResizeStrategy(config2.resizeStrategy);
  }
  startAnimation() {
    this.bgTween = new AnTween({
      target: this.background,
      from: { scale: { x: 0.1, y: 1 }, alpha: 0 },
      to: { scale: { x: 1, y: 1 }, alpha: 0.9 },
      delay: this.appearDelay,
      duration: this.appearDuration * 1.4,
      easing: AnEase.easeOut,
      updater: this.getUpdater(),
      autoRemove: true,
      callbacks: {
        onComplete: () => {
          this.bgTween = new AnTween({
            target: this.background,
            to: { scale: { x: 0.1, y: 1 }, alpha: 0 },
            from: { scale: { x: 1, y: 1 }, alpha: 0.9 },
            delay: this.stayDelay,
            duration: this.disappearDuration,
            easing: AnEase.easeInBack,
            updater: this.getUpdater(),
            autoRemove: true,
            callbacks: {
              onComplete: () => {
                this.bgTween?.terminate();
                this.bgTween = null;
                this.callbacks.onComplete?.();
              }
            }
          });
        }
      }
    });
    this.labelTween = new AnTween({
      target: this.labelText,
      from: { scale: { x: 0.8, y: 0.8 }, alpha: 0 },
      to: { scale: { x: 1, y: 1 }, alpha: 1 },
      delay: this.appearDelay,
      duration: this.appearDuration,
      easing: AnEase.easeOutBack,
      updater: this.getUpdater(),
      autoRemove: true,
      callbacks: {
        onComplete: () => {
          this.labelTween = new AnTween({
            target: this.labelText,
            to: { scale: { x: 0.8, y: 0.8 }, alpha: 0 },
            from: { scale: { x: 1, y: 1 }, alpha: 1 },
            delay: this.stayDelay,
            duration: this.disappearDuration,
            easing: AnEase.easeInElastic,
            updater: this.getUpdater(),
            autoRemove: true,
            callbacks: {
              onComplete: () => {
                this.labelTween?.terminate();
                this.labelTween = null;
              }
            }
          });
        }
      }
    });
  }
  cleanupTweens() {
    if (this.bgTween) {
      this.bgTween.terminate();
      this.bgTween = null;
    }
    if (this.labelTween) {
      this.labelTween.terminate();
      this.labelTween = null;
    }
  }
};

// games/packer/src/game/UIDialogue.ts
init_define_AnParams();

// angine/src/ui/AnDialogue.ts
init_define_AnParams();
var AnDialogue = class extends enhance(AnUIElement).with(AnUpdatableMixin) {
  constructor(config2) {
    super(config2);
    this.tokensLabelsIn = [];
    this.tokensTweensIn = [];
    this.tokensLabelsOut = [];
    this.tokensTweensOut = [];
    this.spaceSize = config2.text.fontSize ? config2.text.fontSize * 0.15 : 10;
    this.labelConfig = { ...config2 };
    this.speedFactor = config2.speedFactor ?? 1;
    this.baseRealWidth = config2.baseRealWidth ?? 800;
    this.callbacks = config2.callbacks ?? {};
    this.tokensContainer = new lib_exports.Container();
    this.addGraphics(this.tokensContainer);
    this.prepareTokens();
    this.defaultResizeStrategy = () => {
      const scaleX = this.scaledWidth / this.realWidth;
      const scaleY = this.scaledHeight / this.realHeight;
      const finalScale = Math.min(scaleX, scaleY);
      this.anchorContainer.scale.set(finalScale);
    };
    this.configResizeStrategy(config2.resizeStrategy);
    this.addToCleanup(AnEvents.on("settings:changed:lang", () => this.updateTextLang()).unsub);
  }
  updateTextLang() {
    if (this.tokensTweensIn.length === 0 && this.tokensTweensOut.length === 0 && this.tokensLabelsIn.length === 0 && this.tokensLabelsOut.length === 0)
      return;
    this.cleanUp();
    this.prepareTokens();
    this.startAnimation();
  }
  prepareTokens() {
    const allText = AnText.textSourceResolver(this.labelConfig.text.textSource, this.labelConfig.text.autoUpdateLang ?? true);
    const tokenizeText = function(text) {
      return text.split(/(\s+|[\w-A-Z]+[.,;:!?]*)/i).filter((token) => token.length > 0);
    };
    const tokenStrings = tokenizeText(allText);
    this.exitAnimation();
    for (const labelOut of this.tokensLabelsOut)
      labelOut.visible = false;
    let currentX = 0, currentY = 0;
    let lineHeight = 0;
    for (const token of tokenStrings) {
      if (token === "|") {
        currentX = 0;
        currentY += lineHeight;
        continue;
      }
      if (token === " ") {
        if (currentX !== 0) {
          currentX += this.spaceSize;
          if (currentX >= this.baseRealWidth) {
            currentX = 0;
            currentY += lineHeight;
          }
        }
        continue;
      }
      const label = new AnLabel({
        ...this.labelConfig,
        text: { ...this.labelConfig.text, textSource: token, autoUpdateLang: false },
        // backgroundColor: 0xff0000,
        // backgroundAlpha: 0.5,
        anchor: AnAnchor.Center
      });
      if (lineHeight === 0) lineHeight = label.height * 0.8;
      label.alpha = 0;
      label.position.set(currentX + label.width * 0.5, currentY + label.height * 0.5 - label.textOffsetY);
      label.updateShadowRealPixels();
      this.tokensContainer.addChild(label);
      this.tokensLabelsIn.push(label);
      currentX += label.width;
      if (currentX >= this.baseRealWidth) {
        currentX = 0;
        currentY += lineHeight;
      }
    }
    this.realWidth = this.tokensContainer.width;
    this.realHeight = this.tokensContainer.height;
    for (const labelOut of this.tokensLabelsOut)
      labelOut.visible = true;
  }
  get labelsCount() {
    return this.tokensLabelsOut.length;
  }
  get textSource() {
    return this.labelConfig.text.textSource;
  }
  set textSource(textSource) {
    this.labelConfig.text.textSource = textSource;
    this.prepareTokens();
  }
  calculateDisplayTime() {
    const allText = AnText.textSourceResolver(this.labelConfig.text.textSource, this.labelConfig.text.autoUpdateLang ?? true);
    return calculateDialogDisplayTime(allText, 120);
  }
  calculateDelay(token) {
    if (/^[.,;:]$/.test(token))
      return AnRnd.float(0.6, 1) * this.speedFactor;
    if (/[.!?]$/.test(token))
      return AnRnd.float(2, 3) * this.speedFactor;
    return AnRnd.float(0.2, 0.6) * this.speedFactor;
  }
  startAnimation(onComplete, onShowNextWord) {
    let i3 = 0;
    let delay2 = 0;
    for (const label of this.tokensLabelsIn) {
      const tween = new AnTween({
        target: label,
        from: { alpha: 0, scale: { x: 0.8, y: 0.8 }, rotation: Math.PI / 40, position: { x: label.x, y: label.y + 50 } },
        to: { alpha: 1, scale: { x: 1, y: 1 }, rotation: 0, position: { x: label.x, y: label.y } },
        duration: 2 * this.speedFactor,
        delay: delay2,
        easing: AnEase.easeOutBack,
        updater: this.getUpdater(),
        autoRemove: true,
        callbacks: {
          onComplete: () => {
            removeByValue(this.tokensTweensIn, tween);
            onShowNextWord?.();
            if (i3 === this.tokensLabelsIn.length - 1) onComplete?.();
          }
        }
      });
      this.tokensTweensIn.push(tween);
      delay2 += this.calculateDelay(label.getText());
      ++i3;
    }
  }
  exitAnimation(onComplete) {
    let i3 = 0;
    for (const label of this.tokensLabelsIn) {
      const tween = new AnTween({
        target: label,
        //from: { alpha: 0, scale: { x: 0.8, y: 0.8 }, rotation: Math.PI / 40, position: { x: label.x, y: label.y + 50 } },
        to: { alpha: 0, scale: { x: 0.8, y: 0.4 }, rotation: Math.PI / 20, position: { x: label.x, y: label.y - 20 } },
        duration: 1 * this.speedFactor,
        delay: 0.1 * i3 * this.speedFactor,
        easing: AnEase.easeIn,
        updater: this.getUpdater(),
        autoRemove: true,
        callbacks: {
          onComplete: () => {
            removeByValue(this.tokensLabelsOut, label);
            label.terminate();
            removeByValue(this.tokensTweensOut, tween);
            if (i3 === this.tokensLabelsOut.length - 1) onComplete?.();
          }
        }
      });
      this.tokensLabelsOut.push(label);
      this.tokensTweensOut.push(tween);
      ++i3;
    }
    if (this.tokensLabelsIn.length) this.tokensLabelsIn = [];
    this.cleanUp(true);
  }
  terminate() {
    this.cleanUp();
    super.terminate();
  }
  cleanUp(onlyIn = false) {
    for (const tween of this.tokensTweensIn) tween.terminate();
    for (const label of this.tokensLabelsIn) label.terminate();
    this.tokensTweensIn = [];
    this.tokensLabelsIn = [];
    if (!onlyIn) {
      for (const tween of this.tokensTweensOut) tween.terminate();
      for (const label of this.tokensLabelsOut) label.terminate();
      this.tokensTweensOut = [];
      this.tokensLabelsOut = [];
    }
  }
};

// games/packer/src/game/UIDialogue.ts
var UIDialogue = class extends enhance(AnUIGroupElement).with(AnUpdatableMixin) {
  constructor(config2) {
    super(config2);
    this.background = null;
    this.callbacks = config2.callbacks ?? {};
    const useBackground = config2.useBackground ?? true;
    if (useBackground) {
      this.background = this.addUIElement(
        "background",
        new AnImage({
          anchor: AnAnchor.Center,
          //tint: 0x333333,
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./gradEdges",
          slice9: {
            left: 32,
            right: 32,
            top: 32,
            bottom: 32
          }
        })
      );
      this.background.scale9Adopt = config2.bgScale9Adopt ?? 1;
    }
    this.dialogue = this.addUIElement(
      "dialogue",
      new AnDialogue({
        text: {
          textSource: "...",
          fontName: "mainFont",
          fontSize: config2.fontSize ?? 60,
          textAlign: "center" /* Center */,
          autoUpdateLang: true,
          shadowAlpha: 0.6,
          shadowOffsetX: 3,
          shadowOffsetY: 3
        },
        anchor: AnAnchor.Center,
        speedFactor: 0.4,
        baseRealWidth: config2.baseRealWidth ?? 1200
      })
    );
    this.defaultResizeStrategy = () => {
      this.background?.setScaledSize(this.scaledWidth, this.scaledHeight);
      const fitRect = AnMath.fitRectangleToRectangle(this.scaledWidth, this.scaledHeight, this.dialogue.realWidth, this.dialogue.realHeight);
      this.dialogue.setScaledSize(fitRect.width * 0.9, fitRect.height * 0.9);
      this.background?.applyDefaultResizeStrategy();
      this.dialogue.applyDefaultResizeStrategy();
      this.background?.position.set(this.scaledWidth * 0.5, this.scaledHeight * 0.5);
      this.dialogue.position.set(this.scaledWidth * 0.5, this.scaledHeight * 0.5);
    };
    this.configResizeStrategy(config2.resizeStrategy);
  }
  showText(textSource) {
    this.dialogue.textSource = textSource;
    this.applyResizeStrategy();
    if (!this.visible) {
      this.visible = true;
      if (this.background) {
        new AnTween({
          target: this.background,
          from: { scale: { x: 0.1, y: 1 }, alpha: 0 },
          to: { scale: { x: 1, y: 1 }, alpha: 0.95 },
          duration: 1,
          easing: AnEase.easeOut,
          updater: this.getUpdater(),
          autoRemove: true,
          callbacks: {
            onComplete: () => {
            }
          }
        });
      }
    }
    if (!this.dialogue.getUpdater())
      this.dialogue.addToUpdater(this.getUpdater());
    runAfterSafe(0.8, this, () => this.dialogue.startAnimation(void 0, () => {
      AnSounds.play(
        `sounds/type0${AnRnd.int(1, 6)}.snd.mp3`,
        AnRnd.float(0.4, 0.6),
        0,
        AnRnd.float(0.9, 1.1)
      );
    }));
  }
  calculateDisplayTime() {
    return this.dialogue.calculateDisplayTime();
  }
  hideText(onComplete) {
    if (this.visible) {
      if (this.background) {
        new AnTween({
          target: this.background,
          to: { scale: { x: 0.1, y: 1 }, alpha: 0 },
          from: { scale: { x: 1, y: 1 }, alpha: 0.95 },
          duration: 1,
          delay: this.dialogue.labelsCount * 0.1 * 0.3,
          easing: AnEase.easeOut,
          updater: this.getUpdater(),
          autoRemove: true,
          callbacks: {
            onComplete: () => {
              this.visible = false;
              onComplete?.();
            }
          }
        });
      }
    }
    runAfterSafe(0.1, this, () => this.dialogue.exitAnimation());
  }
};

// games/packer/src/game/MenuResult.ts
init_define_AnParams();

// games/packer/src/game/UITip.ts
init_define_AnParams();
var UITip = class extends enhance(AnUIGroupElement).with(AnUpdatableMixin) {
  constructor(config2) {
    super(config2);
    this.bgTween = null;
    this.labelTween = null;
    if (config2.updater) this.addToUpdater(config2.updater);
    this.appearDuration = config2.appearDuration ?? 2;
    this.disappearDuration = config2.disappearDuration ?? 0.5;
    this.appearDelay = config2.appearDelay ?? 0;
    this.stayDelay = config2.stayDelay ?? 2;
    this.backgroundAlpha = config2.backgroundAlpha ?? 0.9;
    this.callbacks = config2.callbacks ?? {};
    this.background = this.addUIElement(
      "background",
      new AnImage({
        ...config2.background,
        anchor: AnAnchor.Center
      })
    );
    this.labelText = this.addUIElement(
      "labelText",
      new AnLabel({
        ...config2.labelText,
        anchor: AnAnchor.Center
      })
    );
    this.addToCleanup(() => this.cleanupTweens());
    this.defaultResizeStrategy = () => {
      this.background.setScaledSize(this.scaledWidth, this.scaledHeight);
      this.labelText.setScaledSize(this.scaledWidth, this.scaledHeight);
      this.background.applyDefaultResizeStrategy();
      this.labelText.applyDefaultResizeStrategy();
      this.background.position.set(this.scaledWidth * 0.5, this.scaledHeight * 0.5);
      this.labelText.position.set(this.scaledWidth * 0.5, this.scaledHeight * 0.5);
    };
    this.configResizeStrategy(config2.resizeStrategy);
  }
  startAnimation() {
    this.bgTween = new AnTween({
      target: this.background,
      from: { scale: { x: 0.1, y: 1 }, alpha: 0 },
      to: { scale: { x: 1, y: 1 }, alpha: this.backgroundAlpha },
      delay: this.appearDelay,
      duration: this.appearDuration,
      easing: AnEase.easeOutElastic,
      updater: this.getUpdater(),
      autoRemove: true,
      callbacks: {
        onComplete: () => {
          this.bgTween = new AnTween({
            target: this.background,
            to: { scale: { x: 0.1, y: 1 }, alpha: 0 },
            from: { scale: { x: 1, y: 1 }, alpha: this.backgroundAlpha },
            delay: this.stayDelay,
            duration: this.disappearDuration,
            easing: AnEase.easeInBack,
            updater: this.getUpdater(),
            autoRemove: true,
            callbacks: {
              onComplete: () => {
                this.bgTween?.terminate();
                this.bgTween = null;
                this.callbacks.onComplete?.();
              }
            }
          });
        }
      }
    });
    this.labelTween = new AnTween({
      target: this.labelText,
      from: { scale: { x: 0.8, y: 0.8 }, alpha: 0, rotation: -5 * AnMath.toRad },
      to: { scale: { x: 1, y: 1 }, alpha: 1, rotation: 0 * AnMath.toRad },
      delay: this.appearDelay,
      duration: this.appearDuration,
      easing: AnEase.easeOutElastic,
      updater: this.getUpdater(),
      autoRemove: true,
      callbacks: {
        onComplete: () => {
          this.labelTween = new AnTween({
            target: this.labelText,
            to: { scale: { x: 0.5, y: 0.5 }, alpha: 0 },
            from: { scale: { x: 1, y: 1 }, alpha: 1 },
            delay: this.stayDelay,
            duration: this.disappearDuration,
            easing: AnEase.easeInBack,
            updater: this.getUpdater(),
            autoRemove: true,
            callbacks: {
              onComplete: () => {
                this.labelTween?.terminate();
                this.labelTween = null;
              }
            }
          });
        }
      }
    });
  }
  cleanupTweens() {
    if (this.bgTween) {
      this.bgTween.terminate();
      this.bgTween = null;
    }
    if (this.labelTween) {
      this.labelTween.terminate();
      this.labelTween = null;
    }
  }
};

// games/packer/src/game/MenuResult.ts
var MenuResult = class extends AnMenu {
  constructor(config2) {
    super(config2);
    this.starsBG = [];
    this.starsEarned = [];
    this.buttons = [];
    this.coinTweens = [];
    this.lastTip = null;
    this.callbacks = config2.callbacks ?? {};
    this.state = config2.state;
    this.activeStars = config2.activeStars ?? 0;
    this.totalStars = config2.totalStars ?? 0;
    this.rewardCoins = config2.rewardCoins ?? 0;
    this.totalCoins = config2.totalCoins ?? 0;
    this.addToCleanup(() => {
      this.coinTweens.forEach((tween) => tween.terminate());
    });
  }
  start() {
    this.createUI();
    this.resizeUI();
    this.show();
    Platform.sdk?.reportEvent("GameplayStop" /* GameplayStop */);
    AnEvents.emit(`ui:menuResult:started`);
  }
  createUI() {
    const background = this.addUIElement(
      "background",
      new AnImage(
        {
          sprite: "images/hoverbg.tex.pixi.jpg",
          anchor: AnAnchor.TopLeft,
          resizeStrategy: () => {
            background.position.set(0, 0);
            background.scaledWidth = AnViewport.width;
            background.scaledHeight = AnViewport.height;
            background.applyDefaultResizeStrategy();
          }
        }
      )
    );
    background.tint = 11244671;
    this.title = this.addUIElement(
      "title",
      new AnLabel({
        text: {
          textSource: this.state === "win" /* Win */ ? "menuResultWin" : "menuResultLose",
          fontName: "mainFont",
          fontSize: 120,
          textAlign: "center" /* Center */,
          autoUpdateLang: true,
          shadowAlpha: 0.7
          //anchor: AnAnchor.TopLeft,
        },
        //backgroundColor: 0x333333,
        labelAlign: "center" /* Center */,
        anchor: AnAnchor.Center,
        resizeStrategy: () => {
          this.title.applyDefaultResizeStrategy();
          this.title.position.set(AnViewport.halfWidth, scaled(200));
        }
      })
    );
    const counterHeight = 70;
    const counterWidth = 200;
    this.starsCounter = this.addUIElement(
      "starsCounter",
      new UIGoalCounter(
        {
          currentCount: this.totalStars,
          maxCount: Infinity,
          iconType: "star_mod",
          anchor: AnAnchor.LeftCenter,
          layout: "vertical" /* Vertical */,
          resizeStrategy: () => {
            this.starsCounter.scaledWidth = scaled(counterWidth);
            this.starsCounter.scaledHeight = scaled(counterHeight);
            this.starsCounter.applyDefaultResizeStrategy();
            this.starsCounter.position.set(AnViewport.halfWidth - this.starsCounter.width - scaled(90), scaled(counterHeight * 0.7));
          }
        }
      )
    );
    this.coinsCounter = this.addUIElement(
      "coinsCounter",
      new UIGoalCounter(
        {
          currentCount: this.totalCoins,
          maxCount: Infinity,
          iconType: "coin_mod",
          anchor: AnAnchor.LeftCenter,
          layout: "vertical" /* Vertical */,
          resizeStrategy: () => {
            this.coinsCounter.scaledWidth = scaled(counterWidth);
            this.coinsCounter.scaledHeight = scaled(counterHeight);
            this.coinsCounter.applyDefaultResizeStrategy();
            this.coinsCounter.position.set(AnViewport.halfWidth + scaled(90), scaled(counterHeight * 0.7));
          }
        }
      )
    );
    for (let i3 = 0; i3 < 3; i3++) {
      const starBG = this.addUIElement(
        "starBG" + i3,
        new AnImage(
          {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./roundStarGrey",
            anchor: AnAnchor.Center,
            resizeStrategy: () => {
              starBG.scaledWidth = scaled(200);
              starBG.scaledHeight = scaled(200);
              starBG.applyDefaultResizeStrategy();
              starBG.position.set(AnViewport.halfWidth + (i3 - 1) * (starBG.scaledWidth * 1.2), this.title.y + scaled(180));
            }
          }
        )
      );
      this.starsBG.push(starBG);
    }
    for (let i3 = 0; i3 < this.activeStars; i3++) {
      const star = this.addUIElement(
        "star" + i3,
        new AnImage(
          {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./roundStar",
            anchor: AnAnchor.Center,
            resizeStrategy: () => {
              star.scaledWidth = scaled(200);
              star.scaledHeight = scaled(200);
              star.applyDefaultResizeStrategy();
              star.position.set(AnViewport.halfWidth + (i3 - 1) * (star.scaledWidth * 1.2), this.title.y + scaled(180));
            }
          }
        )
      );
      this.starsEarned.push(star);
    }
    const rewardGap = 30;
    this.rewardText = this.addUIElement(
      "reward",
      new AnLabel({
        text: {
          textSource: "menuResultReward",
          fontName: "mainFont",
          fontSize: 80,
          textAlign: "center" /* Center */,
          autoUpdateLang: true,
          shadowAlpha: 0.7
          //anchor: AnAnchor.TopLeft,
        },
        //backgroundColor: 0x333333,
        labelAlign: "center" /* Center */,
        anchor: AnAnchor.Center,
        resizeStrategy: () => {
          this.rewardCounter.scaledWidth = scaled(counterWidth);
          this.rewardCounter.scaledHeight = scaled(counterHeight);
          this.rewardCounter.applyDefaultResizeStrategy();
          this.rewardText.applyDefaultResizeStrategy();
          this.rewardText.position.set(AnViewport.halfWidth - (this.rewardText.scaledWidth + this.rewardCounter.width) * 0.5 + this.rewardText.scaledWidth * 0.5 - scaled(rewardGap) * 0.5, this.starsBG[0].bottom + scaled(100));
          this.rewardCounter.position.set(this.rewardText.right + scaled(rewardGap), this.starsBG[0].bottom + scaled(100));
        }
      })
    );
    this.rewardCounter = this.addUIElement(
      "rewardCounter",
      new UIGoalCounter(
        {
          currentCount: this.rewardCoins,
          maxCount: Infinity,
          iconType: "coin_mod",
          anchor: AnAnchor.LeftCenter,
          layout: "vertical" /* Vertical */,
          resizeStrategy: () => {
          }
        }
      )
    );
    if (this.rewardCoins === 0) {
      this.rewardCounter.visible = this.rewardText.visible = false;
    }
    const ResultButtonsWin = ["DoubleReward", "NextLevel"];
    const ResultButtonsLose = ["MoreMoves", "Restart"];
    const ResultButtons = this.state === "win" /* Win */ ? ResultButtonsWin : ResultButtonsLose;
    const iconNames = {
      "MoreMoves": "ads_ico",
      "DoubleReward": "ads_ico",
      "NextLevel": "next_ico",
      "Restart": "restart_ico"
    };
    const callbacks = {
      "MoreMoves": () => this.onButtonMoreMoves(),
      "DoubleReward": () => this.onButtonDoubleReward(),
      "NextLevel": () => this.onButtonNextLevel(),
      "Restart": () => this.onButtonRestart()
    };
    for (let i3 = 0; i3 < ResultButtons.length; i3++) {
      const button = this.addUIElement(
        "button" + ResultButtons[i3],
        new AnButton({
          sprite: {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./button",
            slice9: {
              left: 20,
              right: 20,
              top: 20,
              bottom: 20
            }
          },
          icon: {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./" + iconNames[ResultButtons[i3]]
          },
          iconAlign: "left" /* Left */,
          iconScale: { x: 0.9, y: 0.9 },
          // hoverSprite: {
          // 	atlas: 'atlases/game.ss.pixi.atlas',
          // 	sprite: './buttonHover',
          // 	slice9: {
          // 		left: 20, right: 20, top: 20, bottom: 20
          // 	}
          // },
          labelText: {
            text: {
              textSource: ResultButtons[i3] === "MoreMoves" ? () => AnLang.get("menuResult" + ResultButtons[i3]).replace("%%moves%%", G.continueMoreMoves.toString()) : "menuResult" + ResultButtons[i3],
              fontName: "mainFont",
              fontSize: 70,
              textAlign: "center" /* Center */,
              color: 3355443
            },
            // backgroundColor: 0x333333,
            // backgroundAlpha: 0.7,
            labelAlign: "center" /* Center */,
            anchor: AnAnchor.Center
          },
          labelTextOffset: { x: 0, y: -3 },
          //labelTextColorHover: 0xffffff,
          padding: 5,
          anchor: AnAnchor.Center,
          controlsRouter: this.controlsRouter,
          resizeStrategy: () => {
            const moreOffsetY = ResultButtons[i3] === "NextLevel" && !G.btnDoubleReward || ResultButtons[i3] === "Restart" && !G.btnMoreMoves ? 45 : 0;
            const buttonsOffsetY = 130 + moreOffsetY;
            const buttonsPosStartY = AnViewport.height - scaled(buttonsOffsetY) * ResultButtons.length + scaled(45);
            button.scaledHeight = scaled(90);
            button.scaledWidth = scaled(430);
            button.applyDefaultResizeStrategy();
            button.position.set(AnViewport.halfWidth, buttonsPosStartY + i3 * scaled(buttonsOffsetY));
          },
          callbacks: {
            onClick: callbacks[ResultButtons[i3]]
          }
        })
      );
      this.buttons.push(button);
      if (ResultButtons[i3] === "DoubleReward")
        button.visible = G.btnDoubleReward;
      if (ResultButtons[i3] === "MoreMoves")
        button.visible = G.btnMoreMoves;
    }
  }
  showTip(text, color = 16777215, appearDelay = 0, stayDelay = 0) {
    const pos = {
      x: AnViewport.halfWidth,
      y: AnViewport.halfHeight
    };
    if (this.lastTip)
      this.terminateUIElement(this.lastTip);
    const fontSize = 40;
    const lenFactor = text.length * scaled(fontSize);
    const tip = this.addUIElement(new UITip({
      updater: this.getUpdater(),
      appearDelay,
      stayDelay,
      backgroundAlpha: 1,
      background: {
        atlas: "atlases/game.ss.pixi.atlas",
        sprite: "./greySpot2"
      },
      labelText: {
        text: {
          textSource: text,
          autoUpdateLang: false,
          fontName: "mainFont",
          fontSize: 75,
          textAlign: "center" /* Center */,
          shadowAlpha: 0.7,
          shadowOffsetX: 4,
          shadowOffsetY: 4,
          color
        },
        labelAlign: "center" /* Center */
      },
      anchor: AnAnchor.Center,
      resizeStrategy: () => {
        const scaledFactor = 1;
        tip.scaledWidth = lenFactor * scaledFactor;
        tip.scaledHeight = scaled(fontSize * 3) * scaledFactor;
        tip.applyDefaultResizeStrategy();
        tip.position.set(pos.x, pos.y);
      },
      callbacks: {
        onComplete: () => {
          this.terminateUIElement(tip);
          this.lastTip = null;
        }
      }
    }));
    this.lastTip = tip;
    tip.applyResizeStrategy();
    tip.startAnimation();
  }
  tryToShowFullscreenAds(doNext, placement) {
    let doNextExecute = false;
    if (!Platform.sdk || !Platform.sdk.canShowAds) {
      doNext();
      return;
    }
    Platform.sdk.showAds("Fullscreen" /* Fullscreen */, {
      onOpen: () => {
        Analytics.onFullscreenAdShow(placement);
        GameApp.self.paused = true;
      },
      onClose: () => {
        GameApp.self.paused = false;
        if (!doNextExecute) {
          doNextExecute = true;
          doNext();
        }
      },
      onError: () => {
        Analytics.onFullscreenAdError(placement);
        GameApp.self.paused = false;
        if (true) AnLog.debug(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F FullscreenAds`);
        if (!doNextExecute) {
          doNextExecute = true;
          doNext();
        }
      }
    });
  }
  onButtonRestart() {
    Analytics.onEvent("ResultMenuRestart");
    this.tryToShowFullscreenAds(() => {
      AnRender2D.addToFront(new AnFader({
        type: "in",
        duration: 1,
        callbacks: {
          onComplete: () => {
            this.callbacks.onGameRestart?.();
            AnRender2D.addToFront(new AnFader({ type: "out", duration: 2 }));
            Platform.sdk?.reportEvent("GameplayStart" /* GameplayStart */);
          }
        }
      }));
      this.hide();
    }, "ButtonRestart");
  }
  onButtonDoubleReward() {
    const button = this.elements["buttonDoubleReward"];
    Analytics.onEvent("ResultMenuDoubleReward");
    if (!Platform.sdk) {
      this.showTip(AnLang.get("adsError"));
      return;
    }
    Platform.sdk.showAds("Rewarded" /* Rewarded */, {
      onOpen: () => {
        Analytics.onRewardedAdShow("ButtonDoubleReward");
        GameApp.self.paused = true;
      },
      onClose: () => {
        GameApp.self.paused = false;
      },
      onCloseRewarded: () => {
        Analytics.onRewardedAdReceived("ButtonDoubleReward");
        GameApp.self.paused = false;
        if (button) {
          button.enabled = false;
        }
        this.rewardText.setText("menuResultReward2x");
        this.rewardCounter.set(this.rewardCoins * 2);
        this.rewardCounter.setTextColor(65280);
        GameApp.self.gameData.coins += this.rewardCoins;
        Analytics.onGetResource("coins", this.rewardCoins, "reward2X", "coins");
        this.runCoinsAnims();
        AnSounds.play(
          `sounds/info.snd.mp3`,
          0.6
        );
        AnSounds.play(
          `sounds/cheer.snd.mp3`,
          0.6
        );
        this.applyResizeStrategy();
      },
      onError: () => {
        GameApp.self.paused = false;
        Analytics.onRewardedAdError("ButtonDoubleReward");
        this.showTip(AnLang.get("adsError"));
      }
    });
  }
  onButtonMoreMoves() {
    Analytics.onEvent("ResultMenuMoreMoves");
    if (!Platform.sdk) {
      this.showTip(AnLang.get("adsError"));
      return;
    }
    Platform.sdk.showAds("Rewarded" /* Rewarded */, {
      onOpen: () => {
        Analytics.onRewardedAdShow("ButtonMoreMoves");
        GameApp.self.paused = true;
      },
      onClose: () => {
        GameApp.self.paused = false;
      },
      onCloseRewarded: () => {
        Analytics.onRewardedAdReceived("ButtonMoreMoves");
        GameApp.self.paused = false;
        this.callbacks.onGameContinue?.();
        this.hide();
      },
      onError: () => {
        GameApp.self.paused = false;
        Analytics.onRewardedAdError("ButtonMoreMoves");
        this.showTip(AnLang.get("adsError"));
      }
    });
  }
  onButtonNextLevel() {
    Analytics.onEvent("ResultMenuNextLevel");
    this.tryToShowFullscreenAds(() => {
      AnRender2D.addToFront(new AnFader({
        type: "in",
        duration: 2,
        callbacks: {
          onComplete: () => {
            GameApp.self.runNextGame();
          }
        }
      }));
      this.hide();
    }, "ButtonNextLevel");
  }
  createEntranceTweens() {
    const tweens = [];
    tweens.push(new AnTween({
      target: this.elements["background"],
      from: { alpha: 0 },
      to: { alpha: 0.95 },
      duration: 2,
      easing: AnEase.easeOut
    }));
    let titleSndPlayed = false;
    tweens.push(new AnTween({
      target: this.title,
      from: { alpha: 0, position: { x: this.title.x, y: this.title.y + scaled(100) } },
      to: { alpha: 1, position: { x: this.title.x, y: this.title.y } },
      delay: 1,
      duration: 3,
      easing: AnEase.easeOutElastic,
      callbacks: {
        onUpdate: (tween, progress) => {
          if (progress > 0.5 && !titleSndPlayed) {
            titleSndPlayed = true;
            AnSounds.play(
              this.state === "win" /* Win */ ? `sounds/win.snd.mp3` : `sounds/lose.snd.mp3`,
              0.6
            );
          }
        }
      }
    }));
    tweens.push(new AnTween({
      target: this.starsCounter,
      from: { alpha: 0, position: { x: this.starsCounter.x, y: this.starsCounter.y - scaled(100) } },
      to: { alpha: 1, position: { x: this.starsCounter.x, y: this.starsCounter.y } },
      delay: 1.5,
      duration: 1,
      easing: AnEase.easeOutBack
    }));
    tweens.push(new AnTween({
      target: this.coinsCounter,
      from: { alpha: 0, position: { x: this.coinsCounter.x, y: this.coinsCounter.y - scaled(100) } },
      to: { alpha: 1, position: { x: this.coinsCounter.x, y: this.coinsCounter.y } },
      delay: 2,
      duration: 1,
      easing: AnEase.easeOutBack
    }));
    if (this.rewardCoins !== 0) {
      tweens.push(new AnTween({
        target: this.rewardText,
        from: { alpha: 0, position: { x: this.rewardText.x - scaled(100), y: this.rewardText.y } },
        to: { alpha: 1, position: { x: this.rewardText.x, y: this.rewardText.y } },
        delay: 2,
        duration: 1.5,
        tolerance: 0.1,
        easing: AnEase.easeOutBack
      }));
      tweens.push(new AnTween({
        target: this.rewardCounter,
        from: { alpha: 0, position: { x: this.rewardCounter.x + scaled(100), y: this.rewardCounter.y } },
        to: { alpha: 1, position: { x: this.rewardCounter.x, y: this.rewardCounter.y } },
        delay: 2,
        duration: 1.5,
        tolerance: 0.1,
        easing: AnEase.easeOutBack,
        callbacks: {
          onComplete: () => this.runCoinsAnims()
        }
      }));
    }
    for (let i3 = 0; i3 < this.starsBG.length; i3++) {
      tweens.push(new AnTween({
        target: this.starsBG[i3],
        from: { alpha: 0, scale: { x: 0.8, y: 0.8 } },
        to: { alpha: 1, scale: { x: 1, y: 1 } },
        delay: 2 + i3 * 0.2,
        duration: 1.5,
        easing: AnEase.easeOut
      }));
    }
    for (let i3 = 0; i3 < this.starsEarned.length; i3++) {
      tweens.push(new AnTween({
        target: this.starsEarned[i3],
        from: { alpha: 0, scale: { x: 2, y: 2 } },
        to: { alpha: 1, scale: { x: 1, y: 1 } },
        delay: 3 + i3 * 0.4,
        duration: 1.5,
        easing: AnEase.easeOutBounce,
        callbacks: {
          onStart: () => {
            AnSounds.play(
              `sounds/star.snd.mp3`,
              0.6
            );
          },
          onComplete: () => {
            this.starsCounter.updateValue(this.starsCounter.currentCount + 1);
          }
        }
      }));
    }
    for (let i3 = 0; i3 < this.buttons.length; i3++) {
      tweens.push(new AnTween({
        target: this.buttons[i3],
        from: { alpha: 0, position: { x: this.buttons[i3].x + scaled(150) * (AnMath.isEven(i3) ? 1 : -1), y: this.buttons[i3].y } },
        to: { alpha: 1, position: { x: this.buttons[i3].x, y: this.buttons[i3].y } },
        delay: 3,
        // + i * 0.4,
        duration: 1,
        easing: AnEase.easeOutBack
      }));
    }
    if (this.state === "win" /* Win */) {
      runAfterSafe(2, this, () => {
        AnSounds.play(
          `sounds/cheer.snd.mp3`,
          0.6
        );
      });
    }
    return tweens;
  }
  runCoinsAnims() {
    const chunkValue = Math.trunc(this.rewardCoins * 0.2);
    const totalChunks = Math.ceil(this.rewardCoins / chunkValue);
    for (let i3 = 0; i3 < totalChunks; ++i3) {
      const coinValue = i3 === totalChunks - 1 ? this.rewardCoins - chunkValue * i3 : chunkValue;
      const posStart = this.rewardCounter.getMainIconGlobalPos();
      const posEnd = this.coinsCounter.getMainIconGlobalPos();
      const coin = this.addUIElement(new AnImage({
        atlas: "atlases/game.ss.pixi.atlas",
        sprite: "./coin_mod",
        anchor: AnAnchor.Center,
        resizeStrategy: () => {
          coin.scaledWidth = scaled(70);
          coin.scaledHeight = scaled(70);
          coin.applyDefaultResizeStrategy();
        }
      }));
      coin.applyResizeStrategy();
      coin.visible = false;
      let starsSndPlayed = false;
      const tween = new AnTween({
        target: coin,
        from: { alpha: 0.5, position: { x: posStart.x, y: posStart.y } },
        to: { alpha: 1, position: { x: posEnd.x, y: posEnd.y } },
        delay: 1 + i3 * 0.3,
        duration: 0.7,
        tolerance: 0.3,
        easing: AnEase.easeOutBack,
        updater: this.getUpdater(),
        callbacks: {
          onStart: () => {
            coin.visible = true;
          },
          onUpdate: (tween2, progress) => {
            if (progress > 0.5 && !starsSndPlayed) {
              starsSndPlayed = true;
              AnSounds.play(
                `sounds/coin.snd.mp3`,
                AnRnd.float(0.4, 0.6) * 0.5,
                0,
                AnRnd.float(0.9, 1.1)
              );
            }
          },
          onComplete: () => {
            removeByValue(this.coinTweens, tween);
            const tweenOut = new AnTween(
              {
                target: coin,
                to: { alpha: 0, scale: { x: 0.5, y: 0.5 } },
                tolerance: 0.01,
                duration: 0.8,
                easing: AnEase.easeInBack,
                updater: this.getUpdater(),
                callbacks: {
                  onComplete: () => {
                    this.coinsCounter.updateValue(this.coinsCounter.currentCount + coinValue);
                    this.terminateUIElement(coin);
                    removeByValue(this.coinTweens, tweenOut);
                  }
                }
              }
            );
            this.coinTweens.push(tweenOut);
          }
        }
      });
      this.coinTweens.push(tween);
    }
  }
  createExitTweens() {
    const tweens = [];
    tweens.push(new AnTween({
      target: this.elements["background"],
      to: { alpha: 0 },
      from: { alpha: 0.95 },
      duration: 2.1,
      easing: AnEase.easeOut,
      tags: ["terminate"]
    }));
    tweens.push(new AnTween({
      target: this.title,
      to: { alpha: 0, position: { x: this.title.x, y: this.title.y - scaled(100) } },
      from: { alpha: 1, position: { x: this.title.x, y: this.title.y } },
      duration: 0.8,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.starsCounter,
      to: { alpha: 0, position: { x: this.starsCounter.x, y: this.starsCounter.y - scaled(200) } },
      from: { alpha: 1, position: { x: this.starsCounter.x, y: this.starsCounter.y } },
      duration: 0.8,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.coinsCounter,
      to: { alpha: 0, position: { x: this.coinsCounter.x, y: this.coinsCounter.y - scaled(200) } },
      from: { alpha: 1, position: { x: this.coinsCounter.x, y: this.coinsCounter.y } },
      duration: 0.8,
      easing: AnEase.easeOut
    }));
    if (this.rewardCoins !== 0) {
      tweens.push(new AnTween({
        target: this.rewardText,
        to: { alpha: 0, position: { x: this.rewardText.x - scaled(100), y: this.rewardText.y } },
        from: { alpha: 1, position: { x: this.rewardText.x, y: this.rewardText.y } },
        duration: 1.5,
        easing: AnEase.easeOut
      }));
      tweens.push(new AnTween({
        target: this.rewardCounter,
        to: { alpha: 0, position: { x: this.rewardCounter.x + scaled(100), y: this.rewardCounter.y } },
        from: { alpha: 1, position: { x: this.rewardCounter.x, y: this.rewardCounter.y } },
        duration: 1.5,
        easing: AnEase.easeOut
      }));
    }
    for (let i3 = 0; i3 < this.starsBG.length; i3++) {
      tweens.push(new AnTween({
        target: this.starsBG[i3],
        to: { alpha: 0, scale: { x: 0.8, y: 0.8 } },
        from: { alpha: 1, scale: { x: 1, y: 1 } },
        duration: 2,
        easing: AnEase.easeOut
      }));
    }
    for (let i3 = 0; i3 < this.starsEarned.length; i3++) {
      tweens.push(new AnTween({
        target: this.starsEarned[i3],
        to: { alpha: 0, scale: { x: 0.8, y: 0.8 } },
        from: { alpha: 1, scale: { x: 1, y: 1 } },
        duration: 1,
        easing: AnEase.easeInBack
      }));
    }
    for (let i3 = 0; i3 < this.buttons.length; i3++) {
      tweens.push(new AnTween({
        target: this.buttons[i3],
        to: { alpha: 0, position: { x: this.buttons[i3].x + scaled(150) * (AnMath.isEven(i3) ? 1 : -1), y: this.buttons[i3].y } },
        from: { alpha: 1, position: { x: this.buttons[i3].x, y: this.buttons[i3].y } },
        duration: 0.5,
        easing: AnEase.easeOut
      }));
    }
    return tweens;
  }
};

// angine/src/ui/AnBorder.ts
init_define_AnParams();
var AnBorder = class extends enhance(AnUIElement).with(AnUpdatableMixin) {
  constructor(config2) {
    super(config2);
    this.dashCurrentOffset = 0;
    this.graphics = null;
    this.type = config2.type ?? "dashed" /* Dashed */;
    this.dashSize = config2.dashSize ?? 15;
    this.dashGap = config2.dashGap ?? 8;
    this.dashWidth = config2.dashWidth ?? 3;
    this.dashSpeed = config2.dashSpeed ?? 10;
    this.dashAnimCW = config2.dashAnimCW ?? true;
    if (this.type == "dashed" /* Dashed */) {
      this.graphics = new lib_exports.Graphics();
      this.addToCleanup(safeDestroyFunc4(this.graphics));
      this.graphics.alpha = config2.alpha ?? 1;
      this.addGraphics(this.graphics);
      if (true) this.graphics.label = "anim rect";
    } else
      notImplemented();
    this.defaultResizeStrategy = () => {
      this.rebuldGraphics();
    };
    this.configResizeStrategy(config2.resizeStrategy);
  }
  drawDashedLine(x1, y1, x2, y2, dash, gap) {
    if (!this.graphics) return;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist === 0) return;
    const normalX = dx / dist;
    const normalY = dy / dist;
    const patternLength = dash + gap;
    let position = 0;
    let isDrawing = true;
    let phase = this.dashCurrentOffset;
    while (phase >= patternLength) {
      phase -= patternLength;
    }
    if (phase < dash) {
      isDrawing = true;
      const partialDash = dash - phase;
      const drawLength = Math.min(partialDash, dist);
      const endX = x1 + normalX * drawLength;
      const endY = y1 + normalY * drawLength;
      this.graphics.moveTo(x1, y1);
      this.graphics.lineTo(endX, endY);
      position = drawLength;
      isDrawing = false;
    } else {
      isDrawing = false;
      const partialGap = patternLength - phase;
      const skipLength = Math.min(partialGap, dist);
      const endX = x1 + normalX * skipLength;
      const endY = y1 + normalY * skipLength;
      this.graphics.moveTo(endX, endY);
      position = skipLength;
      isDrawing = true;
    }
    while (position < dist) {
      const segmentLength = isDrawing ? dash : gap;
      const remaining = dist - position;
      if (remaining <= 0) break;
      const drawLength = Math.min(segmentLength, remaining);
      const endX = x1 + normalX * (position + drawLength);
      const endY = y1 + normalY * (position + drawLength);
      if (isDrawing) {
        this.graphics.lineTo(endX, endY);
      } else {
        this.graphics.moveTo(endX, endY);
      }
      position += drawLength;
      isDrawing = !isDrawing;
    }
  }
  rebuldGraphics(dt = 0) {
    if (!this.graphics || !this.visible) return;
    this.graphics.clear();
    if (this.type === "dashed" /* Dashed */) {
      const dash = scaled(this.dashSize);
      const gap = scaled(this.dashGap);
      const patternLength = dash + gap;
      if (this.dashAnimCW) {
        this.dashCurrentOffset -= this.dashSpeed * dt;
        if (this.dashCurrentOffset < 0) {
          this.dashCurrentOffset += patternLength;
        }
      } else {
        this.dashCurrentOffset += this.dashSpeed * dt;
        if (this.dashCurrentOffset >= patternLength) {
          this.dashCurrentOffset -= patternLength;
        }
      }
      this.drawDashedLine(0, 0, this.scaledWidth, 0, dash, gap);
      this.drawDashedLine(this.scaledWidth, 0, this.scaledWidth, this.scaledHeight, dash, gap);
      this.drawDashedLine(this.scaledWidth, this.scaledHeight, 0, this.scaledHeight, dash, gap);
      this.drawDashedLine(0, this.scaledHeight, 0, 0, dash, gap);
      this.graphics.stroke({ color: 16777215, width: this.dashWidth });
    } else
      notImplemented();
  }
  update(dt) {
    super.update(dt);
    this.rebuldGraphics(dt);
  }
};

// games/packer/src/game/MenuSystem.ts
init_define_AnParams();

// games/packer/src/game/UIShopButton.ts
init_define_AnParams();
var UIShopButton = class extends AnButton {
  constructor(config2) {
    const isThemeButton = config2.theme !== void 0;
    if (!isThemeButton) {
      config2 = {
        ...config2,
        icon: {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./colorChoose",
          tint: GameColorsDB[config2.color].shopColorTint ?? GameColorsDB[config2.color].baseColorTint
        },
        iconScale: { x: 0.55, y: 0.95 }
      };
    }
    super(config2);
    this.isThemeButton = false;
    this.themeIcons = [];
    this.isThemeButton = isThemeButton;
    if (isThemeButton)
      this.addThemeIcons(config2.theme);
    this.coinsCounter = this.addUIElement(
      "coinsCounter",
      new UIGoalCounter(
        {
          currentCount: 0,
          maxCount: Infinity,
          iconType: "coin_mod",
          anchor: AnAnchor.LeftCenter,
          layout: "horizontal" /* Horizontal */,
          resizeStrategy: () => {
            this.coinsCounter.scaledWidth = this.scaledWidth * 0.9;
            this.coinsCounter.scaledHeight = this.scaledHeight * 0.5;
            this.coinsCounter.applyDefaultResizeStrategy();
            this.coinsCounter.position.set(this.scaledWidth * 0.5 - this.coinsCounter.width * 0.5, this.scaledHeight * 0.5);
          }
        }
      )
    );
    this.title = this.addUIElement(
      "title",
      new AnLabel({
        text: {
          textSource: () => "???",
          fontName: "mainFont",
          fontSize: 60,
          textAlign: "center" /* Center */,
          autoUpdateLang: false,
          shadowAlpha: 0.7
          //anchor: AnAnchor.TopLeft,
        },
        //backgroundColor: 0x333333,
        labelAlign: "center" /* Center */,
        anchor: AnAnchor.Center,
        resizeStrategy: () => {
          this.title.scaledWidth = this.scaledWidth;
          this.title.scaledHeight = this.scaledHeight;
          this.title.applyDefaultResizeStrategy();
          this.title.position.set(this.scaledWidth * 0.5, this.scaledHeight * 0.5);
        }
      })
    );
    this.selector = this.addUIElement(
      "selector",
      new AnImage(
        {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: `./selItem`,
          anchor: AnAnchor.Center,
          slice9: {
            left: 40,
            right: 40,
            top: 40,
            bottom: 40
          },
          resizeStrategy: () => {
            this.selector.scaledWidth = this.scaledWidth + scaled(20);
            this.selector.scaledHeight = this.scaledHeight + scaled(20);
            this.selector.scale9Adopt = AnViewport.scale * 0.7;
            this.selector.applyDefaultResizeStrategy();
            this.selector.position.set(this.scaledWidth * 0.5, this.scaledHeight * 0.5);
          }
        }
      )
    );
    this.selector.tint = 1170688;
  }
  addThemeIcons(theme) {
    const propCount = PropBlockTypeArray.length;
    for (let i3 = 0; i3 < propCount; ++i3) {
      const icon = this.addUIElement(
        "icon" + i3,
        new AnImage(
          {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: `./prop_${i3}_${theme}`,
            anchor: AnAnchor.Center,
            resizeStrategy: () => {
              const paddingFactor = 1;
              const iconSize = paddingFactor * this.scaledHeight * 0.7;
              icon.scaledWidth = iconSize;
              icon.scaledHeight = iconSize;
              icon.applyDefaultResizeStrategy();
              icon.y = this.scaledHeight * 0.5;
              icon.x = getSpriteXCentralDistribution(i3, iconSize, this.scaledWidth * paddingFactor, propCount, -1) + 0.5 * (this.scaledWidth * (1 - paddingFactor));
            }
          }
        )
      );
      this.themeIcons.push(icon);
    }
  }
  showAsUnlocked(showSelector = false) {
    this.sprite.changeTexture("./button", "atlases/game.ss.pixi.atlas");
    this.coinsCounter.visible = false;
    this.selector.visible = showSelector;
    if (this.icon) {
      this.icon.alpha = 1;
      this.icon.visible = true;
    }
    this.title.visible = false;
    if (this.themeIcons.length)
      for (const theme of this.themeIcons) {
        theme.visible = true;
        theme.alpha = 1;
      }
  }
  showAsItemToBuy(cost, totalCoins) {
    this.sprite.changeTexture("./buttonHover", "atlases/game.ss.pixi.atlas");
    this.coinsCounter.visible = true;
    this.coinsCounter.updateValue(cost, false);
    this.coinsCounter.updateTextColor(cost > totalCoins ? 16728116 : 16777215);
    this.selector.visible = false;
    if (this.icon) {
      this.icon.alpha = 0.5;
      this.icon.visible = true;
    }
    this.title.visible = false;
    if (this.themeIcons.length)
      for (const theme of this.themeIcons) {
        theme.visible = true;
        theme.alpha = 0.1;
      }
  }
  showAsLocked() {
    this.sprite.changeTexture("./buttonHover", "atlases/game.ss.pixi.atlas");
    this.coinsCounter.visible = false;
    if (this.icon) this.icon.visible = false;
    this.title.visible = true;
    this.selector.visible = false;
    if (this.themeIcons.length)
      for (const theme of this.themeIcons)
        theme.visible = false;
  }
};

// games/packer/src/game/MenuConfirm.ts
init_define_AnParams();
var MenuConfirm = class extends AnMenu {
  constructor(config2) {
    super(config2);
    this.forceWait = false;
    this.forceWaitCnt = 10;
    this.callbacks = config2.callbacks ?? {};
    this.text = config2.text;
    this.confirmText = config2.confirmText;
    this.cancelText = config2.cancelText;
    this.forceWait = config2.forceWait ?? false;
    this.addToCleanup(AnEvents.on("ui:menuResult:started", () => this.hide()).unsub);
  }
  start() {
    this.createUI();
    this.resizeUI();
    this.show();
  }
  createUI() {
    this.background = this.addUIElement(
      "background",
      new AnImage({
        sprite: "images/hoverbg.tex.pixi.jpg",
        anchor: AnAnchor.TopLeft,
        resizeStrategy: () => {
          this.background.position.set(0, 0);
          this.background.scaledWidth = AnViewport.width;
          this.background.scaledHeight = AnViewport.height;
          this.background.applyDefaultResizeStrategy();
        }
      })
    );
    this.background.tint = 16711680;
    this.title = this.addUIElement(
      "title",
      new AnLabel({
        text: {
          textSource: this.text,
          fontName: "mainFont",
          fontSize: 80,
          textAlign: "center" /* Center */,
          autoUpdateLang: true,
          shadowAlpha: 0.7,
          shadowOffsetX: 5,
          shadowOffsetY: 5,
          wordWarp: true
        },
        labelAlign: "center" /* Center */,
        anchor: AnAnchor.Center,
        resizeStrategy: () => {
          this.title.scaledWidth = Math.min(AnViewport.width, AnViewport.height) * 0.9;
          this.title.applyDefaultResizeStrategy();
          this.title.position.set(AnViewport.halfWidth, AnViewport.halfHeight - scaled(200));
        }
      })
    );
    if (this.confirmText) {
      this.buttonConfirm = this.addUIElement(
        "buttonConfirm",
        new AnButton({
          sprite: {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./button",
            slice9: {
              left: 20,
              right: 20,
              top: 20,
              bottom: 20
            }
          },
          labelText: {
            text: {
              textSource: this.confirmText,
              fontName: "mainFont",
              fontSize: 70,
              textAlign: "center" /* Center */,
              color: 3355443
            },
            labelAlign: "center" /* Center */,
            anchor: AnAnchor.Center
          },
          //labelTextOffset: { x: 0, y: -3 },
          padding: 5,
          anchor: AnAnchor.Center,
          controlsRouter: this.controlsRouter,
          resizeStrategy: () => {
            this.buttonConfirm.scaledHeight = scaled(90);
            this.buttonConfirm.scaledWidth = scaled(300);
            this.buttonConfirm.applyDefaultResizeStrategy();
            this.buttonConfirm.position.set(
              AnViewport.halfWidth - this.buttonConfirm.scaledWidth * 0.625,
              AnViewport.halfHeight + scaled(200)
            );
          },
          callbacks: {
            onClick: () => this.onConfirm()
          }
        })
      );
      if (this.forceWait) {
        this.buttonConfirm.enabled = false;
        this.startForceWaitCounter(3);
      }
    }
    if (this.cancelText) {
      this.buttonCancel = this.addUIElement(
        "buttonCancel",
        new AnButton({
          sprite: {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./button",
            slice9: {
              left: 20,
              right: 20,
              top: 20,
              bottom: 20
            }
          },
          labelText: {
            text: {
              textSource: this.cancelText,
              fontName: "mainFont",
              fontSize: 70,
              textAlign: "center" /* Center */,
              color: 3355443
            },
            labelAlign: "center" /* Center */,
            anchor: AnAnchor.Center
          },
          padding: 5,
          anchor: AnAnchor.Center,
          controlsRouter: this.controlsRouter,
          resizeStrategy: () => {
            this.buttonCancel.scaledHeight = scaled(90);
            this.buttonCancel.scaledWidth = scaled(300);
            this.buttonCancel.applyDefaultResizeStrategy();
            this.buttonCancel.position.set(
              AnViewport.halfWidth + this.buttonCancel.scaledWidth * 0.625,
              AnViewport.halfHeight + scaled(200)
            );
          },
          callbacks: {
            onClick: () => this.onCancel()
          }
        })
      );
    }
  }
  startForceWaitCounter(sec) {
    if (sec < 0) {
      this.buttonConfirm.enabled = true;
      this.buttonConfirm.setText(this.confirmText);
      return;
    }
    this.buttonConfirm.setText(() => AnLang.get(this.confirmText) + ` (${sec})`);
    runAfterSafe(1, this.buttonConfirm, () => this.startForceWaitCounter(sec - 1));
  }
  onConfirm() {
    this.callbacks.onConfirm?.();
    this.hide();
  }
  onCancel() {
    this.callbacks.onCancel?.();
    this.hide();
  }
  createEntranceTweens() {
    const tweens = [];
    tweens.push(new AnTween({
      target: this.background,
      from: { alpha: 0 },
      to: { alpha: 0.95 },
      duration: 0.5,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.title,
      from: { alpha: 0, position: { x: this.title.x, y: this.title.y - scaled(50) } },
      to: { alpha: 1, position: { x: this.title.x, y: this.title.y } },
      delay: 0.2,
      duration: 1,
      easing: AnEase.easeOutBack
    }));
    tweens.push(new AnTween({
      target: this.buttonConfirm,
      from: { alpha: 0, position: { x: this.buttonConfirm.x - scaled(100), y: this.buttonConfirm.y } },
      to: { alpha: 1, position: { x: this.buttonConfirm.x, y: this.buttonConfirm.y } },
      delay: 0.4,
      duration: 1,
      easing: AnEase.easeOutBack
    }));
    tweens.push(new AnTween({
      target: this.buttonCancel,
      from: { alpha: 0, position: { x: this.buttonCancel.x + scaled(100), y: this.buttonCancel.y } },
      to: { alpha: 1, position: { x: this.buttonCancel.x, y: this.buttonCancel.y } },
      delay: 0.5,
      duration: 1,
      easing: AnEase.easeOutBack
    }));
    return tweens;
  }
  createExitTweens() {
    const tweens = [];
    tweens.push(new AnTween({
      target: this.title,
      to: { alpha: 0, position: { x: this.title.x, y: this.title.y - scaled(50) } },
      from: { alpha: 1, position: { x: this.title.x, y: this.title.y } },
      duration: 0.5,
      easing: AnEase.easeIn
    }));
    tweens.push(new AnTween({
      target: this.buttonConfirm,
      to: { alpha: 0, position: { x: this.buttonConfirm.x - scaled(100), y: this.buttonConfirm.y } },
      from: { alpha: 1, position: { x: this.buttonConfirm.x, y: this.buttonConfirm.y } },
      duration: 0.5,
      easing: AnEase.easeIn
    }));
    tweens.push(new AnTween({
      target: this.buttonCancel,
      to: { alpha: 0, position: { x: this.buttonCancel.x + scaled(100), y: this.buttonCancel.y } },
      from: { alpha: 1, position: { x: this.buttonCancel.x, y: this.buttonCancel.y } },
      duration: 0.5,
      easing: AnEase.easeIn
    }));
    tweens.push(new AnTween({
      target: this.background,
      to: { alpha: 0 },
      from: { alpha: 0.95 },
      delay: 0.3,
      duration: 0.5,
      easing: AnEase.easeIn,
      tags: ["terminate"]
      // callbacks: {
      // 	onComplete: () => this.terminate()
      // }
    }));
    return tweens;
  }
};

// games/packer/src/game/MenuSystem.ts
var MenuSystem = class extends AnMenu {
  constructor(config2) {
    super(config2);
    this.buttonOptions = [];
    this.buttonColors = [];
    this.buttonThemes = [];
    //   
    this.isDragging = false;
    this.dragStartY = 0;
    this.initialMenuY = 0;
    this.scrollValue = null;
    this.lastTip = null;
    this.callbacks = config2.callbacks ?? {};
    this.addToCleanup(AnEvents.on("ui:menuResult:started", () => this.hide()).unsub);
  }
  start() {
    this.createUI();
    this.resizeUI();
    this.setupScrollHandlers();
    this.show();
    Platform.sdk?.reportEvent("GameplayStop" /* GameplayStop */);
  }
  getPadding() {
    const menuPadding = 30;
    return scaled(menuPadding);
  }
  createUI() {
    const buttonSize = 60;
    const background = this.addUIElement(
      "background",
      new AnImage(
        {
          sprite: "images/hoverbg.tex.pixi.jpg",
          anchor: AnAnchor.TopLeft,
          resizeStrategy: () => {
            background.position.set(0, -this.y);
            background.scaledWidth = AnViewport.width;
            background.scaledHeight = AnViewport.height;
            background.applyDefaultResizeStrategy();
          }
        }
      )
    );
    background.tint = 11244671;
    this.title = this.addUIElement(
      "title",
      new AnLabel({
        text: {
          textSource: () => AnLang.get("menuSystemLevelTitle").replace("%%level%%", GameApp.self.gameData.level.toString()),
          fontName: "mainFont",
          fontSize: 120,
          textAlign: "center" /* Center */,
          autoUpdateLang: true,
          shadowAlpha: 0.7
          //anchor: AnAnchor.TopLeft,
        },
        //backgroundColor: 0x333333,
        labelAlign: "center" /* Center */,
        anchor: AnAnchor.Center,
        resizeStrategy: () => {
          this.title.applyDefaultResizeStrategy();
          this.title.position.set(AnViewport.halfWidth, this.title.height * 0.6);
        }
      })
    );
    const counterHeight = 70;
    const counterWidth = 200;
    this.starsCounter = this.addUIElement(
      "starsCounter",
      new UIGoalCounter(
        {
          currentCount: GameApp.self.gameData.stars,
          maxCount: Infinity,
          statusChange: "max" /* Max */,
          iconType: "star_mod",
          anchor: AnAnchor.LeftCenter,
          layout: "vertical" /* Vertical */,
          resizeStrategy: () => {
            this.starsCounter.set(GameApp.self.gameData.stars);
            this.starsCounter.scaledWidth = scaled(counterWidth);
            this.starsCounter.scaledHeight = scaled(counterHeight);
            this.starsCounter.applyDefaultResizeStrategy();
            this.starsCounter.position.set(AnViewport.halfWidth - this.starsCounter.width - scaled(90), this.title.y + this.title.scaledHeight);
          }
        }
      )
    );
    this.coinsCounter = this.addUIElement(
      "coinsCounter",
      new UIGoalCounter(
        {
          currentCount: GameApp.self.gameData.coins,
          maxCount: Infinity,
          statusChange: "max" /* Max */,
          iconType: "coin_mod",
          anchor: AnAnchor.LeftCenter,
          layout: "vertical" /* Vertical */,
          resizeStrategy: () => {
            this.coinsCounter.set(GameApp.self.gameData.coins);
            this.coinsCounter.scaledWidth = scaled(counterWidth);
            this.coinsCounter.scaledHeight = scaled(counterHeight);
            this.coinsCounter.applyDefaultResizeStrategy();
            this.coinsCounter.position.set(AnViewport.halfWidth + scaled(90), this.title.y + this.title.scaledHeight);
          }
        }
      )
    );
    const OptionButtons = ["optLang", "optSound", "optMusic", "optReset"];
    let optButtonY = 0;
    for (let i3 = 0; i3 < OptionButtons.length; ++i3) {
      const button = this.addUIElement(
        "button_" + OptionButtons[i3],
        new AnButton({
          sprite: {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./button",
            slice9: {
              left: 20,
              right: 20,
              top: 20,
              bottom: 20
            }
          },
          icon: {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./optButtonsIco00" + this.getOptButtonIconVar(OptionButtons[i3])
          },
          iconScale: { x: 0.8, y: 0.8 },
          anchor: AnAnchor.Center,
          controlsRouter: this.controlsRouter,
          resizeStrategy: () => {
            const menuWidth = Math.min(AnViewport.width, AnViewport.height);
            const padding = this.getPadding();
            button.scaledHeight = scaled(buttonSize * 1.5);
            button.scaledWidth = scaled(buttonSize * 1.5);
            button.applyDefaultResizeStrategy();
            button.position.set(AnViewport.halfWidth - menuWidth * 0.5 + getSpriteXCentralDistribution(i3, button.scaledWidth, menuWidth, 4, padding * 3), this.coinsCounter.y + this.coinsCounter.scaledHeight * 1.6);
          },
          callbacks: {
            onClick: () => {
              this.onOptButtonClick(OptionButtons[i3]);
              button.setIcon("./optButtonsIco00" + this.getOptButtonIconVar(OptionButtons[i3]), "atlases/game.ss.pixi.atlas");
            }
          }
        })
      );
      this.buttonOptions.push(button);
    }
    this.titleColor = this.addUIElement(
      "titleColor",
      new AnLabel({
        text: {
          textSource: () => AnLang.get("menuSystemColorTitle") + ": " + AnLang.get("game" + GameApp.self.gameData.color),
          fontName: "mainFont",
          fontSize: 60,
          textAlign: "center" /* Center */,
          autoUpdateLang: true,
          shadowAlpha: 0.7
          //anchor: AnAnchor.TopLeft,
        },
        //backgroundColor: 0x333333,
        labelAlign: "center" /* Center */,
        anchor: AnAnchor.Center,
        resizeStrategy: () => {
          this.titleColor.applyDefaultResizeStrategy();
          this.titleColor.position.set(AnViewport.halfWidth, this.coinsCounter.y + this.coinsCounter.scaledHeight * 3);
        }
      })
    );
    const buttonsPadding = this.getPadding();
    const colorButtonsCount = gameColorsArray.length;
    const colorButtonsW = 150;
    const colorButtonsH = 90;
    let lastColorButtonY = 0;
    for (let i3 = 0; i3 < colorButtonsCount; ++i3) {
      const id = gameColorsArray[i3];
      const button = this.addUIElement(
        //"button_" + OptionButtons[i],
        new UIShopButton({
          id: i3,
          color: gameColorsArray[i3],
          sprite: {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./buttonHover",
            slice9: {
              left: 20,
              right: 20,
              top: 50,
              bottom: 20
            }
          },
          spriteAdoptSlice9Factor: 0.8,
          anchor: AnAnchor.Center,
          controlsRouter: this.controlsRouter,
          resizeStrategy: () => {
            const menuWidth = Math.min(AnViewport.width, AnViewport.height);
            const padding = scaled(buttonsPadding);
            button.scaledWidth = scaled(colorButtonsW);
            button.scaledHeight = scaled(colorButtonsH);
            const maxCntPerRow = Math.floor((menuWidth - padding) / (button.scaledWidth + padding));
            const row = Math.floor(i3 / maxCntPerRow);
            button.applyDefaultResizeStrategy();
            const colorButtonY = this.titleColor.y + this.titleColor.scaledHeight + padding + row * (button.scaledHeight + padding);
            button.position.set(
              AnViewport.halfWidth - menuWidth * 0.5 + getSpriteXCentralDistribution(i3 % maxCntPerRow, button.scaledWidth, menuWidth, maxCntPerRow, padding),
              colorButtonY
            );
            if (i3 <= GameApp.self.gameData.lastUnlockedColor) button.showAsUnlocked(GameApp.self.gameData.color === gameColorsArray[i3]);
            else if (i3 === GameApp.self.gameData.lastUnlockedColor + 1) button.showAsItemToBuy(G.calcColorCostByID(i3), GameApp.self.gameData.coins);
            else
              button.showAsLocked();
            if (i3 > GameApp.self.gameData.lastUnlockedColor + 1 + G.shopShowForwardColorItems)
              button.visible = false;
            else {
              button.visible = true;
              lastColorButtonY = colorButtonY;
            }
          },
          callbacks: {
            onClick: () => this.onItemButtonClick("color", i3)
          }
        })
      );
      this.buttonColors.push(button);
    }
    this.titleTheme = this.addUIElement(
      "titleTheme",
      new AnLabel({
        text: {
          textSource: () => AnLang.get("menuSystemThemeTitle") + ": " + AnLang.get("gameTheme" + capitalize(GameApp.self.gameData.theme)),
          fontName: "mainFont",
          fontSize: 60,
          textAlign: "center" /* Center */,
          autoUpdateLang: true,
          shadowAlpha: 0.7
          //anchor: AnAnchor.TopLeft,
        },
        //backgroundColor: 0x333333,
        labelAlign: "center" /* Center */,
        anchor: AnAnchor.Center,
        resizeStrategy: () => {
          this.titleTheme.applyDefaultResizeStrategy();
          this.titleTheme.position.set(AnViewport.halfWidth, lastColorButtonY + scaled(100));
        }
      })
    );
    const themeButtonsCount = gameThemesArray.length;
    const themeButtonsW = 400;
    const themeButtonsH = 150;
    let lastThemeButtonY = 0;
    for (let i3 = 0; i3 < themeButtonsCount; ++i3) {
      const button = this.addUIElement(
        //"button_" + OptionButtons[i],
        new UIShopButton({
          id: i3,
          theme: gameThemesArray[i3],
          sprite: {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./buttonHover",
            slice9: {
              left: 20,
              right: 20,
              top: 50,
              bottom: 20
            }
          },
          spriteAdoptSlice9Factor: 0.8,
          //iconScale: { x: 0.5, y: 0.5 },
          anchor: AnAnchor.Center,
          controlsRouter: this.controlsRouter,
          resizeStrategy: () => {
            const menuWidth = Math.min(AnViewport.width, AnViewport.height);
            const padding = scaled(buttonsPadding);
            button.scaledWidth = scaled(themeButtonsW);
            button.scaledHeight = scaled(themeButtonsH);
            const maxCntPerRow = Math.floor((menuWidth - padding) / button.scaledWidth);
            const row = Math.floor(i3 / maxCntPerRow);
            button.applyDefaultResizeStrategy();
            const themeButtonY = this.titleTheme.y + this.titleTheme.scaledHeight + padding * 3 + row * (button.scaledHeight + padding);
            button.position.set(
              AnViewport.halfWidth - menuWidth * 0.5 + getSpriteXCentralDistribution(i3 % maxCntPerRow, button.scaledWidth, menuWidth, maxCntPerRow, padding),
              themeButtonY
            );
            if (i3 <= GameApp.self.gameData.lastUnlockedTheme) button.showAsUnlocked(GameApp.self.gameData.theme === gameThemesArray[i3]);
            else if (i3 === GameApp.self.gameData.lastUnlockedTheme + 1) button.showAsItemToBuy(G.calcThemeCostByID(i3), GameApp.self.gameData.coins);
            else
              button.showAsLocked();
            if (i3 > GameApp.self.gameData.lastUnlockedTheme + 1 + G.shopShowForwardThemeItems)
              button.visible = false;
            else {
              button.visible = true;
              lastThemeButtonY = themeButtonY;
            }
          },
          callbacks: {
            onClick: () => this.onItemButtonClick("theme", i3)
          }
        })
      );
      this.buttonThemes.push(button);
    }
    this.buttonMoreGames = this.addUIElement(
      "buttonMoreGames",
      new AnButton({
        sprite: {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./button",
          slice9: {
            left: 20,
            right: 20,
            top: 20,
            bottom: 20
          }
        },
        icon: {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./next_ico"
        },
        iconAlign: "left" /* Left */,
        iconScale: { x: 0.9, y: 0.9 },
        labelText: {
          text: {
            textSource: "buttonMoreGames",
            fontName: "mainFont",
            fontSize: 70,
            textAlign: "center" /* Center */,
            //autoUpdateLang: false,
            //shadowAlpha: 0.7,
            color: 3355443
          },
          // backgroundColor: 0x333333,
          // backgroundAlpha: 0.7,
          labelAlign: "center" /* Center */,
          anchor: AnAnchor.Center
        },
        labelTextOffset: { x: 0, y: -3 },
        //labelTextColorHover: 0xffffff,
        padding: 5,
        anchor: AnAnchor.Center,
        controlsRouter: this.controlsRouter,
        resizeStrategy: () => {
          const padding = this.getPadding();
          this.buttonMoreGames.scaledWidth = scaled(500);
          this.buttonMoreGames.scaledHeight = scaled(100);
          this.buttonMoreGames.applyDefaultResizeStrategy();
          this.buttonMoreGames.position.set(AnViewport.halfWidth, lastThemeButtonY + scaled(220));
        },
        callbacks: {
          onClick: () => this.onMoreGamesButtonClick()
        }
      })
    );
    this.buttonMoreGames.visible = G.moreGamesURL.length > 0;
    this.copyrightText = this.addUIElement(
      "copyrightText",
      new AnLabel({
        text: {
          //textSource: () => "CHAIN & GAIN\ncreated by\nOLEG ANTIPOV (C) 2025\nver. 1.0.0 [SA]",
          textSource: () => AnLang.get("menuSystemCopyright").replace("%%version%%", Platform.visualName ? `${"1.0.0"} [${Platform.visualName}]` : AnCore.fullGameVersion),
          fontName: "mainFont",
          fontSize: 60,
          textAlign: "center" /* Center */,
          autoUpdateLang: true,
          shadowAlpha: 0.7
          //anchor: AnAnchor.TopLeft,
        },
        //backgroundColor: 0x333333,
        labelAlign: "center" /* Center */,
        anchor: AnAnchor.Center,
        resizeStrategy: () => {
          this.copyrightText.applyDefaultResizeStrategy();
          this.copyrightText.position.set(AnViewport.halfWidth, this.buttonMoreGames.y + (this.buttonMoreGames.visible ? scaled(250) : scaled(50)));
        }
      })
    );
    this.buttonClose = this.addUIElement(
      "buttonClose",
      new AnButton({
        sprite: {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./button",
          slice9: {
            left: 20,
            right: 20,
            top: 20,
            bottom: 20
          }
        },
        icon: {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./closeIcon"
        },
        iconScale: { x: 0.7, y: 0.7 },
        anchor: AnAnchor.Center,
        controlsRouter: this.controlsRouter,
        resizeStrategy: () => {
          const padding = this.getPadding();
          this.buttonClose.scaledHeight = scaled(buttonSize);
          this.buttonClose.scaledWidth = scaled(buttonSize);
          this.buttonClose.applyDefaultResizeStrategy();
          this.buttonClose.position.set(AnViewport.width - this.buttonClose.scaledWidth * 0.5 - padding, this.buttonClose.scaledHeight * 0.5 + padding);
        },
        callbacks: {
          onClick: () => {
            AnSounds.play(
              `sounds/menu.snd.mp3`,
              0.6
            );
            this.hide();
            Platform.sdk?.reportEvent("GameplayStart" /* GameplayStart */);
            this.scrollValue = null;
          }
        }
      })
    );
  }
  onMoreGamesButtonClick() {
    if (G.moreGamesURL.length > 0) {
      Analytics.onEvent("MoreGamesButtonClick");
      openURL(G.moreGamesURL);
    }
  }
  //      
  //! , 
  getOptButtonIconVar(opt) {
    let vol = 0;
    switch (opt) {
      case "optLang":
        if (GameApp.self.gameData.language === "ru") return "09";
        return "10";
      // en
      //break;
      case "optSound":
        vol = GameApp.self.gameData.soundVolume;
        if (AnMath.floatEqual(vol, 0)) return "05";
        else if (AnMath.floatEqual(vol, 30)) return "06";
        else if (AnMath.floatEqual(vol, 60)) return "07";
        return "08";
      //break;
      case "optMusic":
        vol = GameApp.self.gameData.musicVolume;
        if (AnMath.floatEqual(vol, 0)) return "01";
        else if (AnMath.floatEqual(vol, 30)) return "02";
        else if (AnMath.floatEqual(vol, 60)) return "03";
        return "04";
    }
    return "11";
  }
  showTip(text, color = 16777215, appearDelay = 0, stayDelay = 0) {
    const pos = {
      x: AnViewport.halfWidth,
      y: scaled(100)
    };
    if (this.lastTip)
      this.terminateUIElement(this.lastTip);
    const fontSize = 40;
    const lenFactor = text.length * scaled(fontSize);
    const tip = this.addUIElement(new UITip({
      updater: this.getUpdater(),
      appearDelay,
      stayDelay,
      backgroundAlpha: 1,
      background: {
        atlas: "atlases/game.ss.pixi.atlas",
        sprite: "./greySpot2"
      },
      labelText: {
        text: {
          textSource: text,
          autoUpdateLang: false,
          fontName: "mainFont",
          fontSize: 90,
          textAlign: "center" /* Center */,
          shadowAlpha: 0.7,
          shadowOffsetX: 4,
          shadowOffsetY: 4,
          color
        },
        labelAlign: "center" /* Center */
      },
      anchor: AnAnchor.Center,
      resizeStrategy: () => {
        const scaledFactor = 1.75;
        tip.scaledWidth = lenFactor * scaledFactor;
        tip.scaledHeight = scaled(fontSize * 2) * scaledFactor;
        tip.applyDefaultResizeStrategy();
        const halfWidth = tip.scaledWidth / 2;
        const halfHeight = tip.scaledHeight / 2;
        const minX = halfWidth;
        const maxX = AnViewport.width - halfWidth;
        const minY = halfHeight;
        const maxY = AnViewport.height - halfHeight;
        const clampedX = Math.max(minX, Math.min(maxX, pos.x));
        const clampedY = Math.max(minY, Math.min(maxY, pos.y));
        const offset = {
          x: clampedX - pos.x,
          y: clampedY - pos.y
        };
        tip.position.set(pos.x + offset.x, pos.y + offset.y);
      },
      callbacks: {
        onComplete: () => {
          this.terminateUIElement(tip);
          this.lastTip = null;
        }
      }
    }));
    this.lastTip = tip;
    tip.applyResizeStrategy();
    tip.startAnimation();
  }
  onOptButtonClick(buttonId) {
    const gameData = GameApp.self.gameData;
    switch (buttonId) {
      case "optLang":
        gameData.language = getNextElement(AnLang.loadedLanguages, AnLang.currentLanguage);
        if (true) AnLog.debug(`language: ${gameData.language}`);
        this.showTip(AnLang.get(`OptLang${gameData.language.toUpperCase()}`));
        break;
      case "optSound":
        gameData.soundVolume = AnMath.floatEqual(gameData.soundVolume, 0) ? 30 : AnMath.floatEqual(gameData.soundVolume, 30) ? 60 : AnMath.floatEqual(gameData.soundVolume, 60) ? 100 : 0;
        AnSounds.play(
          `sounds/stone.snd.mp3`,
          0.6
        );
        if (true) AnLog.debug(`soundVolume: ${gameData.soundVolume}`);
        {
          const textID = gameData.soundVolume !== 0 ? `OptSound` : `OptSoundNo`;
          const textAppend = gameData.soundVolume !== 0 ? `: ${gameData.soundVolume}%` : ``;
          this.showTip(AnLang.get(textID) + textAppend);
        }
        break;
      case "optMusic":
        gameData.musicVolume = AnMath.floatEqual(gameData.musicVolume, 0) ? 30 : AnMath.floatEqual(gameData.musicVolume, 30) ? 60 : AnMath.floatEqual(gameData.musicVolume, 60) ? 100 : 0;
        if (true) AnLog.debug(`musicVolume: ${gameData.musicVolume}`);
        {
          const textID = gameData.musicVolume !== 0 ? `OptMusic` : `OptMusicNo`;
          const textAppend = gameData.musicVolume !== 0 ? `: ${gameData.musicVolume}%` : ``;
          this.showTip(AnLang.get(textID) + textAppend);
        }
        break;
      case "optReset":
        AnSounds.play(
          `sounds/buy_no.snd.mp3`,
          0.4
        );
        AnSounds.play(
          `sounds/lose.snd.mp3`,
          0.4
        );
        const confirmMenu = new MenuConfirm({
          text: "OptResetAllWarn",
          confirmText: "confirmReset",
          cancelText: "cancelReset",
          forceWait: true,
          callbacks: {
            onConfirm: () => {
              this.hide();
              GameApp.self.fullReset();
            },
            onCancel: () => {
            }
          }
        });
        confirmMenu.start();
        break;
    }
  }
  onItemButtonClick(type, index) {
    const gameData = GameApp.self.gameData;
    const config2 = {
      theme: {
        lastUnlocked: gameData.lastUnlockedTheme,
        setCurrent: (value) => {
          gameData.theme = value;
          this.titleTheme.updateText();
        },
        array: gameThemesArray,
        calcCost: G.calcThemeCostByID,
        updateUnlocked: (value) => gameData.lastUnlockedTheme = value
      },
      color: {
        lastUnlocked: gameData.lastUnlockedColor,
        setCurrent: (value) => {
          gameData.color = value;
          this.titleColor.updateText();
        },
        array: gameColorsArray,
        calcCost: G.calcColorCostByID,
        updateUnlocked: (value) => gameData.lastUnlockedColor = value
      }
    }[type];
    const { lastUnlocked, setCurrent, array, calcCost, updateUnlocked } = config2;
    if (index <= lastUnlocked) {
      setCurrent(array[index]);
      this.applyResizeStrategy();
      this.syncScroll();
    } else {
      if (index === lastUnlocked + 1) {
        const cost = calcCost(index);
        if (cost <= gameData.coins) {
          AnSounds.play(
            `sounds/buy.snd.mp3`,
            0.6
          );
          Analytics.onLostResource("coins", cost, type, index.toString());
          updateUnlocked(lastUnlocked + 1);
          gameData.coins -= cost;
          setCurrent(array[index]);
          this.applyResizeStrategy();
          this.syncScroll();
        } else {
          AnSounds.play(
            `sounds/buy_no.snd.mp3`,
            0.6
          );
        }
      } else {
      }
    }
  }
  createEntranceTweens() {
    const tweens = [];
    tweens.push(new AnTween({
      target: this.elements["background"],
      from: { alpha: 0 },
      to: { alpha: 0.95 },
      duration: 2,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.buttonClose,
      from: { alpha: 0, position: { x: this.buttonClose.x + scaled(150), y: this.buttonClose.y } },
      to: { alpha: 1, position: { x: this.buttonClose.x, y: this.buttonClose.y } },
      delay: 0.5,
      duration: 0.5,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.title,
      from: { alpha: 0, position: { x: this.title.x, y: this.title.y - scaled(50) } },
      to: { alpha: 1, position: { x: this.title.x, y: this.title.y } },
      delay: 0,
      duration: 3,
      easing: AnEase.easeOutElastic
    }));
    tweens.push(new AnTween({
      target: this.starsCounter,
      from: { alpha: 0, position: { x: this.starsCounter.x - scaled(100), y: this.starsCounter.y } },
      to: { alpha: 1, position: { x: this.starsCounter.x, y: this.starsCounter.y } },
      delay: 0,
      duration: 1,
      easing: AnEase.easeOutBack
    }));
    tweens.push(new AnTween({
      target: this.coinsCounter,
      from: { alpha: 0, position: { x: this.coinsCounter.x + scaled(100), y: this.coinsCounter.y } },
      to: { alpha: 1, position: { x: this.coinsCounter.x, y: this.coinsCounter.y } },
      delay: 0,
      duration: 1,
      easing: AnEase.easeOutBack
    }));
    for (let i3 = 0; i3 < this.buttonOptions.length; i3++) {
      tweens.push(new AnTween({
        target: this.buttonOptions[i3],
        from: { alpha: 0, position: { x: this.buttonOptions[i3].x + scaled(150) * (AnMath.isEven(i3) ? 1 : -1), y: this.buttonOptions[i3].y } },
        to: { alpha: 1, position: { x: this.buttonOptions[i3].x, y: this.buttonOptions[i3].y } },
        delay: i3 * 0.1,
        duration: 1,
        easing: AnEase.easeOutBack
      }));
    }
    for (let i3 = 0; i3 < this.buttonColors.length; i3++) {
      tweens.push(new AnTween({
        target: this.buttonColors[i3],
        from: { alpha: 0, position: { x: this.buttonColors[i3].x + scaled(150) * (AnMath.isEven(i3) ? 1 : -1), y: this.buttonColors[i3].y } },
        to: { alpha: 1, position: { x: this.buttonColors[i3].x, y: this.buttonColors[i3].y } },
        delay: i3 * 0.05,
        duration: 1,
        easing: AnEase.easeOutBack
      }));
    }
    for (let i3 = 0; i3 < this.buttonThemes.length; i3++) {
      tweens.push(new AnTween({
        target: this.buttonThemes[i3],
        from: { alpha: 0, position: { x: this.buttonThemes[i3].x + scaled(150) * (AnMath.isEven(i3) ? 1 : -1), y: this.buttonThemes[i3].y } },
        to: { alpha: 1, position: { x: this.buttonThemes[i3].x, y: this.buttonThemes[i3].y } },
        delay: i3 * 0.05,
        duration: 1,
        easing: AnEase.easeOutBack
      }));
    }
    tweens.push(new AnTween({
      target: this.titleColor,
      from: { alpha: 0, position: { x: this.titleColor.x - scaled(50), y: this.titleColor.y } },
      to: { alpha: 1, position: { x: this.titleColor.x, y: this.titleColor.y } },
      delay: 0,
      duration: 3,
      easing: AnEase.easeOutElastic
    }));
    tweens.push(new AnTween({
      target: this.titleTheme,
      from: { alpha: 0, position: { x: this.titleTheme.x + scaled(50), y: this.titleTheme.y } },
      to: { alpha: 1, position: { x: this.titleTheme.x, y: this.titleTheme.y } },
      delay: 0,
      duration: 3,
      easing: AnEase.easeOutElastic
    }));
    tweens.push(new AnTween({
      target: this.buttonMoreGames,
      from: { alpha: 0, position: { x: this.buttonMoreGames.x - scaled(150), y: this.buttonMoreGames.y } },
      to: { alpha: 1, position: { x: this.buttonMoreGames.x, y: this.buttonMoreGames.y } },
      delay: 0,
      duration: 3,
      easing: AnEase.easeOutElastic
    }));
    tweens.push(new AnTween({
      target: this.copyrightText,
      from: { alpha: 0, position: { x: this.copyrightText.x + scaled(150), y: this.copyrightText.y } },
      to: { alpha: 1, position: { x: this.copyrightText.x, y: this.copyrightText.y } },
      delay: 0,
      duration: 3,
      easing: AnEase.easeOutElastic
    }));
    return tweens;
  }
  createExitTweens() {
    const tweens = [];
    tweens.push(new AnTween({
      target: this.elements["background"],
      to: { alpha: 0 },
      from: { alpha: 0.95 },
      duration: 2.1,
      easing: AnEase.easeOut,
      tags: ["terminate"]
    }));
    tweens.push(new AnTween({
      target: this.buttonClose,
      to: { alpha: 0, position: { x: this.buttonClose.x + scaled(150), y: this.buttonClose.y } },
      from: { alpha: 1, position: { x: this.buttonClose.x, y: this.buttonClose.y } },
      delay: 0.5,
      duration: 0.5,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.title,
      to: { alpha: 0, position: { x: this.title.x, y: this.title.y - scaled(50) } },
      from: { alpha: 1, position: { x: this.title.x, y: this.title.y } },
      delay: 0,
      duration: 0.8,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.starsCounter,
      to: { alpha: 0, position: { x: this.starsCounter.x - scaled(100), y: this.starsCounter.y } },
      from: { alpha: 1, position: { x: this.starsCounter.x, y: this.starsCounter.y } },
      delay: 0,
      duration: 0.8,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.coinsCounter,
      to: { alpha: 0, position: { x: this.coinsCounter.x + scaled(100), y: this.coinsCounter.y } },
      from: { alpha: 1, position: { x: this.coinsCounter.x, y: this.coinsCounter.y } },
      delay: 0,
      duration: 0.8,
      easing: AnEase.easeOut
    }));
    for (let i3 = 0; i3 < this.buttonOptions.length; i3++) {
      tweens.push(new AnTween({
        target: this.buttonOptions[i3],
        to: { alpha: 0, position: { x: this.buttonOptions[i3].x + scaled(150) * (AnMath.isEven(i3) ? 1 : -1), y: this.buttonOptions[i3].y } },
        from: { alpha: 1, position: { x: this.buttonOptions[i3].x, y: this.buttonOptions[i3].y } },
        delay: i3 * 0.05,
        duration: 0.5,
        easing: AnEase.easeOut
      }));
    }
    for (let i3 = 0; i3 < this.buttonColors.length; i3++) {
      tweens.push(new AnTween({
        target: this.buttonColors[i3],
        to: { alpha: 0, position: { x: this.buttonColors[i3].x + scaled(150) * (AnMath.isEven(i3) ? 1 : -1), y: this.buttonColors[i3].y } },
        from: { alpha: 1, position: { x: this.buttonColors[i3].x, y: this.buttonColors[i3].y } },
        delay: i3 * 0.025,
        duration: 0.5,
        easing: AnEase.easeOut
      }));
    }
    for (let i3 = 0; i3 < this.buttonThemes.length; i3++) {
      tweens.push(new AnTween({
        target: this.buttonThemes[i3],
        to: { alpha: 0, position: { x: this.buttonThemes[i3].x + scaled(150) * (AnMath.isEven(i3) ? 1 : -1), y: this.buttonThemes[i3].y } },
        from: { alpha: 1, position: { x: this.buttonThemes[i3].x, y: this.buttonThemes[i3].y } },
        delay: i3 * 0.025,
        duration: 0.5,
        easing: AnEase.easeOut
      }));
    }
    tweens.push(new AnTween({
      target: this.titleColor,
      to: { alpha: 0, position: { x: this.titleColor.x - scaled(50), y: this.titleColor.y } },
      from: { alpha: 1, position: { x: this.titleColor.x, y: this.titleColor.y } },
      delay: 0,
      duration: 1,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.titleTheme,
      to: { alpha: 0, position: { x: this.titleTheme.x + scaled(50), y: this.titleTheme.y } },
      from: { alpha: 1, position: { x: this.titleTheme.x, y: this.titleTheme.y } },
      delay: 0,
      duration: 1,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.buttonMoreGames,
      to: { alpha: 0, position: { x: this.buttonMoreGames.x - scaled(150), y: this.buttonMoreGames.y } },
      from: { alpha: 1, position: { x: this.buttonMoreGames.x, y: this.buttonMoreGames.y } },
      delay: 0,
      duration: 1,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.copyrightText,
      to: { alpha: 0, position: { x: this.copyrightText.x + scaled(150), y: this.copyrightText.y } },
      from: { alpha: 1, position: { x: this.copyrightText.x, y: this.copyrightText.y } },
      delay: 0,
      duration: 1,
      easing: AnEase.easeOut
    }));
    return tweens;
  }
  //    
  setupScrollHandlers() {
    this.scrollValue = new AnInterpolator(
      {
        initialValue: 0,
        speed: 3,
        autoStart: true,
        interpolation: AnInterpolation.sinusoidal,
        callbacks: {
          onUpdate: () => this.syncScroll()
        }
      }
    );
    this.addToCleanup(AnEvents.on(`${this.controlsRouter}${"controls:pointerdown" /* PointerDown */}`, this.handlePointerDown.bind(this)).unsub);
    this.addToCleanup(AnEvents.on(`${this.controlsRouter}${"controls:pointermove" /* PointerMove */}`, this.handlePointerMove.bind(this)).unsub);
    this.addToCleanup(AnEvents.on(`${this.controlsRouter}${"controls:pointerup" /* PointerUp */}`, this.handlePointerUp.bind(this)).unsub);
    this.addToCleanup(AnEvents.on(`${this.controlsRouter}${"controls:pointercancel" /* PointerCancel */}`, this.handlePointerUp.bind(this)).unsub);
    this.addToCleanup(AnEvents.on(`${this.controlsRouter}${"controls:mouse:wheel" /* MouseWheel */}`, (e2) => this.handleMouseWheel(e2.data.deltaY)).unsub);
  }
  syncScroll() {
    if (!this.scrollValue) return;
    this.y = this.scrollValue.currentValue;
    this.elements["background"].position.set(0, -this.y);
    this.buttonClose.y = this.buttonClose.scaledHeight * 0.5 + this.getPadding() - this.y;
  }
  handlePointerDown(e2) {
    if (!this.isDragging) {
      this.isDragging = true;
      this.dragStartY = e2.data.y;
      this.initialMenuY = this.y;
    }
  }
  handlePointerMove(e2) {
    if (!this.isDragging) return;
    const deltaY = e2.data.y - this.dragStartY;
    this.scrollTo(deltaY);
  }
  scrollTo(deltaY) {
    let targetY = this.initialMenuY + deltaY;
    targetY = AnMath.clamp(targetY, -(this.copyrightText.y + this.copyrightText.height - AnViewport.height), 0);
    if (this.scrollValue)
      this.scrollValue.targetValue = targetY;
  }
  handlePointerUp() {
    this.isDragging = false;
  }
  handleMouseWheel(deltaWheel) {
    this.initialMenuY = 0;
    this.scrollTo(this.y - deltaWheel * 1.6);
  }
  update(dt) {
    super.update(dt);
    this.scrollValue?.update(dt);
  }
};

// games/packer/src/game/Game.ts
var SAFE_FRAME = { left: 15, right: 15, bottom: 15, top: 200 };
var gameColorsArray = [
  "Color0" /* Color0 */,
  "Color1" /* Color1 */,
  "Color2" /* Color2 */,
  "Color3" /* Color3 */,
  "Color4" /* Color4 */,
  "Color5" /* Color5 */,
  "Color6" /* Color6 */,
  "Color7" /* Color7 */,
  "Color8" /* Color8 */,
  "Color9" /* Color9 */,
  "Color10" /* Color10 */,
  "Color11" /* Color11 */,
  "Color12" /* Color12 */,
  "Color13" /* Color13 */,
  "Color14" /* Color14 */,
  "Color15" /* Color15 */,
  "Color16" /* Color16 */,
  "Color17" /* Color17 */,
  "Color18" /* Color18 */,
  "Color19" /* Color19 */,
  "Color20" /* Color20 */,
  "Color21" /* Color21 */,
  "Color22" /* Color22 */,
  "Color23" /* Color23 */,
  "Color24" /* Color24 */
];
var GameColorsDB = {
  ["Color0" /* Color0 */]: { baseColorTint: 3526655 },
  //+  
  ["Color1" /* Color1 */]: { baseColorTint: 10354559 },
  //+  
  ["Color2" /* Color2 */]: { baseColorTint: 16747644 },
  //+ 
  ["Color3" /* Color3 */]: { baseColorTint: 11967487 },
  //+ 
  ["Color4" /* Color4 */]: { baseColorTint: 16763516 },
  //+ -
  ["Color5" /* Color5 */]: { baseColorTint: 14085375 },
  //+ 
  ["Color6" /* Color6 */]: { baseColorTint: 16754166 },
  //+  
  ["Color7" /* Color7 */]: { baseColorTint: 9214975 },
  //+ -
  ["Color8" /* Color8 */]: { baseColorTint: 4194213 },
  //+ -
  ["Color9" /* Color9 */]: { baseColorTint: 16777077 },
  //+  
  ["Color10" /* Color10 */]: { baseColorTint: 16761786 },
  //+ -
  ["Color11" /* Color11 */]: { baseColorTint: 8703656 },
  //+ -
  ["Color12" /* Color12 */]: { baseColorTint: 14832546 },
  //+ 
  ["Color13" /* Color13 */]: { baseColorTint: 13853539 },
  //+  
  ["Color14" /* Color14 */]: { baseColorTint: 6526975 },
  //+ -
  ["Color15" /* Color15 */]: { baseColorTint: 65530 },
  //+  
  ["Color16" /* Color16 */]: { baseColorTint: 6513507 },
  //+  
  ["Color17" /* Color17 */]: { baseColorTint: 8411639 },
  //+  
  ["Color18" /* Color18 */]: { baseColorTint: 16762624 },
  //+ 
  ["Color19" /* Color19 */]: { baseColorTint: 41120 },
  //+ 
  ["Color20" /* Color20 */]: { baseColorTint: 16737812 },
  //+ -
  ["Color21" /* Color21 */]: { baseColorTint: 15269883, shopColorTint: 13229530 },
  //+ -
  ["Color22" /* Color22 */]: { baseColorTint: 2263842 },
  //+ -
  ["Color23" /* Color23 */]: { baseColorTint: 16711935 },
  //+  
  ["Color24" /* Color24 */]: { baseColorTint: 2829099 }
  //+  
};
var gameThemesArray = [
  "toys" /* Toys */,
  "fruits" /* Fruits */,
  "animals" /* Animals */,
  "music" /* Music */,
  "nature" /* Nature */,
  "home" /* Home */,
  "art" /* Art */,
  "sea" /* Sea */,
  "space" /* Space */,
  "geometry" /* Geometry */
];
var Game = class extends enhance(AnMenu).with(
  GameTutorialMixin
) {
  constructor(config2) {
    super(config2);
    /**  
     * **** game config ****
    */
    //     
    this.levelNum = null;
    // 
    this.tutorial = "None" /* None */;
    // 
    this.tutorialStage = 0;
    //      (    )
    this.tutorialPropType = "prop_0";
    //        
    this.activeScoredBlocksCount = 0;
    //      \,    
    this.winLoseState = false;
    this.dialogue = null;
    this.buttonInfo = null;
    this.labelMoves = null;
    this.tutorialRect = null;
    this.starsProgress = null;
    this.topMenuBG = null;
    this.topMenuSep = null;
    this.goalProgress = null;
    this.goalCounters = null;
    this.coinsCounter = null;
    this.coinCounterTween = null;
    this.coinTweens = [];
    this.labelMovesTween = null;
    //
    this.stat_startTime = /* @__PURE__ */ new Date();
    this.stat_moves = 0;
    this.stat_totalPropsCollected = 0;
    this.stat_goalPropsCollected = 0;
    this.stat_specialsUsed = 0;
    this.tutorialArrow = null;
    this.tutorialArrowCountToHide = 3;
    this.tutorialArrowTween = null;
    this.tutorialArrowApearTween = null;
    //     +5  
    this.playerContinueCount = 0;
    this.savedGameConfig = { ...config2 };
    this.levelNum = config2.levelNum ?? null;
    this.theme = config2.theme;
    this.mode = config2.mode;
    this.currentMoves = this.totalMoves = config2.totalMoves ?? 35;
    this.rndseed = config2.rndseed ?? AnRnd.int(100, 1e4);
    this.preset6x6 = structuredClone(config2.preset6x6) ?? null;
    this.cellMod = config2.cellMod ?? null;
    this.generators = config2.generators?.slice() ?? null;
    this.rules = config2.rules?.slice() ?? null;
    this.forbidSpecials = config2.forbidSpecials ?? [];
    this.tutorial = config2.tutorial ?? "None" /* None */;
    if (true) AnLog.debug(`this.currentMoves=${this.currentMoves}`);
    if (true) {
    }
    this.animLayer = new lib_exports.RenderLayer();
    this.uiLayer = new lib_exports.RenderLayer();
    switch (this.mode) {
      case "totalCollect" /* TotalCollect */:
        this.modeData = config2.modeData;
        this.modeData.current = 0;
        break;
      case "typesCollect" /* TypesCollect */:
        this.modeData = config2.modeData;
        this.modeData.types.forEach((elem) => elem.current = 0);
        break;
      default:
        notImplemented();
    }
    this.addToCleanup(AnEvents.on(
      "gameplay:block:apply",
      (e2) => this.onBlockApply(e2.data.block, e2.data.globalPos, e2.data.removeOnly, e2.data.fromPlayerSelection)
    ).unsub);
    this.addToCleanup(AnEvents.on(
      "gameplay:other:apply",
      (e2) => this.onOtherApply(e2.data.type, e2.data.score)
    ).unsub);
    this.addToCleanup(AnEvents.on(
      "gameplay:player:makeMove",
      (e2) => this.onPlayerMakeMove(e2.data)
    ).unsub);
    this.addToCleanup(AnEvents.on(
      "gameplay:field:readyForNextMove",
      (e2) => this.onFieldReadyForNextMove()
    ).unsub);
    this.addToCleanup(AnEvents.on(
      "gameplay:field:noMoves",
      (e2) => this.onFieldNoMoves()
    ).unsub);
    this.addToCleanup(AnEvents.on(
      "storage:color:update",
      (e2) => this.onSettingsColorUpdate(e2.data.value)
    ).unsub);
    this.addToCleanup(AnEvents.on(
      "storage:theme:update",
      (e2) => this.theme = e2.data.value
    ).unsub);
    this.addToCleanup(AnEvents.on(
      "app:lostFocus",
      (e2) => {
        if (GameApp.self.getActiveMenu() === this && !this.winLoseState)
          Platform.sdk?.reportEvent("GameplayStop" /* GameplayStop */);
      }
    ).unsub);
    this.addToCleanup(AnEvents.on(
      "app:getFocus",
      (e2) => {
        if (GameApp.self.getActiveMenu() === this && !this.winLoseState)
          Platform.sdk?.reportEvent("GameplayStart" /* GameplayStart */);
      }
    ).unsub);
    this.addToCleanup(() => {
      if (this.coinCounterTween) this.coinCounterTween.terminate();
      this.coinTweens.forEach((tween) => tween.terminate());
      if (this.tutorialArrowTween) this.tutorialArrowTween.terminate();
      if (this.tutorialArrowApearTween) this.tutorialArrowApearTween.terminate();
    });
  }
  onSettingsColorUpdate(color) {
    this.elements["background"].tint = GameColorsDB[color].baseColorTint;
  }
  showTutorialArrow(posCalc, rot = 0) {
    if (this.tutorialArrow) this.terminateUIElement(this.tutorialArrow);
    if (this.tutorialArrowTween) this.tutorialArrowTween.terminate();
    this.tutorialArrow = null;
    this.tutorialArrowTween = null;
    const tutorialArrow = this.addUIElement(new AnImage({
      atlas: "atlases/game.ss.pixi.atlas",
      sprite: "./tutorialArrow",
      anchor: AnAnchor.BottomCenter,
      resizeStrategy: () => {
        const pos = posCalc();
        tutorialArrow.scaledWidth = scaled(90);
        tutorialArrow.scaledHeight = scaled(90);
        tutorialArrow.position.set(pos.x, pos.y);
        tutorialArrow.applyDefaultResizeStrategy();
      }
    }));
    tutorialArrow.applyResizeStrategy();
    this.tutorialArrow = tutorialArrow;
    const tweenApear = new AnTween({
      target: this.tutorialArrow,
      from: { alpha: 0, scale: { x: 1, y: 1 }, rotation: Math.PI / 20 + rot },
      to: { alpha: 1, scale: { x: 1.3, y: 1.3 }, rotation: Math.PI / 20 + rot },
      duration: 0.5,
      easing: AnEase.easeOut,
      updater: this.localUpdater,
      callbacks: {
        onComplete: () => {
          this.tutorialArrowApearTween = null;
          const tween = new AnTween({
            target: this.tutorialArrow,
            from: { scale: { x: 1.3, y: 1.3 }, rotation: Math.PI / 20 + rot },
            to: { scale: { x: 1, y: 1 }, rotation: -Math.PI / 20 + rot },
            duration: 3,
            repeat: Infinity,
            reverse: true,
            easing: AnEase.easeInOutBack,
            updater: this.localUpdater,
            autoRemove: false
          });
          this.tutorialArrowTween = tween;
        }
      }
    });
    this.tutorialArrowApearTween = tweenApear;
  }
  hideTutorialArrow() {
    if (!this.tutorialArrow) return;
    if (this.tutorialArrowApearTween) this.tutorialArrowApearTween.terminate();
    const tutorialArrow = this.tutorialArrow;
    const tweenApear = new AnTween({
      target: tutorialArrow,
      from: { alpha: 1 },
      to: { alpha: 0 },
      duration: 0.5,
      easing: AnEase.easeIn,
      updater: this.localUpdater,
      callbacks: {
        onComplete: () => {
          this.tutorialArrowApearTween = null;
          if (this.tutorialArrow) this.terminateUIElement(this.tutorialArrow);
          if (this.tutorialArrowTween) this.tutorialArrowTween.terminate();
          this.tutorialArrow = null;
          this.tutorialArrowTween = null;
        }
      }
    });
    this.tutorialArrowApearTween = tweenApear;
    this.tutorialArrow = null;
  }
  onFieldReadyForNextMove() {
    if (this.tutorialArrow) {
      if (this.tutorialArrowCountToHide > 0) {
        this.tutorialArrowCountToHide--;
        if (this.tutorialArrowCountToHide === 0) this.hideTutorialArrow();
      }
    }
    if (this.activeScoredBlocksCount === 0)
      this.onZeroActiveScoredBlocks();
    if (!this.winLoseState)
      this.onTutorialSetFocusPanel();
  }
  checkWinState() {
    let ending = false;
    if (this.winLoseState) return true;
    if (this.mode === "totalCollect" /* TotalCollect */) {
      const data = this.modeData;
      if (data.current >= data.total) {
        ending = true;
        this.showMenuResult(true);
      }
    } else if (this.mode === "typesCollect" /* TypesCollect */) {
      const data = this.modeData;
      ending = data.types.every((type) => type.current >= type.total);
      if (ending)
        this.showMenuResult(true);
    }
    return ending;
  }
  checkLoseState() {
    let ending = false;
    if (this.winLoseState) return true;
    if (this.currentMoves === 0) {
      ending = true;
      this.showMenuResult(false);
    }
    return ending;
  }
  showMenuResult(isWin) {
    this.field.forbidSelectBlocks = true;
    this.winLoseState = true;
    const levelResult = this.calcLevelResult(isWin);
    const callbacks = isWin ? {} : {
      onGameRestart: () => this.restart(),
      onGameContinue: () => this.continue(G.continueMoreMoves)
    };
    if (isWin)
      Analytics.onLevelComplete(`level_${this.levelNum}`, levelResult.stars);
    else
      Analytics.onLevelFail(`level_${this.levelNum}`, this.playerContinueCount);
    if (levelResult.coins > 0)
      Analytics.onGetResource("coins", levelResult.coins, "rewardWin", "coins");
    const menuResult = new MenuResult({
      state: isWin ? "win" /* Win */ : "lose" /* Lose */,
      totalStars: GameApp.self.gameData.stars,
      totalCoins: GameApp.self.gameData.coins,
      activeStars: levelResult.stars,
      rewardCoins: levelResult.coins,
      callbacks
    });
    menuResult.start();
    if (isWin) {
      GameApp.self.gameData.stars += levelResult.stars;
      GameApp.self.gameData.coins += levelResult.coins;
      GameApp.self.gameData.level++;
      if (Platform.sdk)
        Platform.sdk.sendScoreToLeaderboard("stars", GameApp.self.gameData.stars);
      Platform.sdk?.reportEvent("CoolMoment" /* CoolMoment */);
      const endingTime = /* @__PURE__ */ new Date();
      const timeToComplete = (endingTime.getTime() - this.stat_startTime.getTime()) / (1e3 * 60);
      const avgGoalPropsPerMove = this.stat_goalPropsCollected / this.stat_moves;
      const statStr = `*** \u0441\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0430 \u0443\u0440\u043E\u0432\u043D\u044F ***

							levelNum: ${this.levelNum}

							moves: ${this.stat_moves}

							specialUsed: ${this.stat_specialsUsed}

							avgGoalPropsPerMove: ${avgGoalPropsPerMove}

							timeToComplete: ${timeToComplete} min

							`;
      if (true) AnLog.debug(statStr);
      Analytics.onEvent(`statistics:level_${this.levelNum}:moves`, this.stat_moves);
      Analytics.onEvent(`statistics:level_${this.levelNum}:avgGoalPropsPerMove`, avgGoalPropsPerMove);
      Analytics.onEvent(`statistics:level_${this.levelNum}:timeToCompleteInMin`, timeToComplete);
    }
  }
  showMenuSystem() {
    if (this.tutorial === "Train2" /* Train2 */ && this.tutorialArrowCountToHide > 0) {
      this.tutorialArrowCountToHide = 0;
      this.hideTutorialArrow();
    }
    AnSounds.play(
      `sounds/menu.snd.mp3`,
      0.6
    );
    Analytics.onEvent("ShowSystemMenu", this.levelNum);
    const menuSystem = new MenuSystem({});
    menuSystem.start();
  }
  //   
  calcLevelResult(isWin) {
    let stars = isWin ? G.calculateStars(this.totalMoves - this.currentMoves, this.totalMoves) : 0;
    let coins = G.calculateCoinReward(this.levelNum, stars);
    return { stars, coins };
  }
  onFieldNoMoves() {
    this.showBigTitle(AnLang.get("no moves"), 0, 0);
  }
  start() {
    this.createUI();
    this.resizeUI();
    this.show();
    Platform.sdk?.reportEvent("GameplayStart" /* GameplayStart */);
    Platform.sdk?.reportEvent("NewLevel" /* NewLevel */, this.levelNum);
    Analytics.onLevelStart(`level_${this.levelNum}`);
  }
  calcScaledSafeFrame() {
    return {
      left: scaled(SAFE_FRAME.left),
      right: scaled(SAFE_FRAME.right),
      top: scaled(SAFE_FRAME.top),
      bottom: scaled(SAFE_FRAME.bottom)
    };
  }
  onPlayerMakeMove(data) {
    this.currentMoves--;
    this.field.genCounter++;
    this.stat_moves++;
    if (this.currentMoves === 0) this.field.forbidSelectBlocks = true;
    this.updateMovesAnim();
    let chainLen = -1;
    let color = 16777215;
    if (AnMath.inRange(data.chainLength, 5, 6)) chainLen = 0, color = 8190976;
    else if (AnMath.inRange(data.chainLength, 7, 8)) chainLen = 1, color = 16766720;
    else if (AnMath.inRange(data.chainLength, 9, 10)) chainLen = 2, color = 16739125;
    else if (data.chainLength >= 11) chainLen = 3, color = 10289407;
    const message = chainLen >= 0 ? " " + AnLang.get(`chain_${chainLen}_${AnRnd.int(0, 12)}`) + "!" : "";
    this.showTip(`(${data.chainLength.toString()})` + message, { x: data.lastChainBlockPos.x, y: data.lastChainBlockPos.y - scaled(CellHalfSize) * 1.5 }, color);
    this.onShowTutorial();
  }
  updateMovesAnim() {
    const usedMoves = this.totalMoves - this.currentMoves;
    this.starsProgress.value = AnMath.clamp(G.calculateStarsProgressbar(usedMoves, this.totalMoves), 0, 1);
    const color = usedMoves <= this.totalMoves * G.threeStarsPerc ? 16777215 : usedMoves <= this.totalMoves * G.twoStarsPerc ? 16771629 : 16728116;
    this.labelMoves.updateText();
    this.labelMoves.textColor = color;
    if (this.labelMovesTween) {
      this.labelMovesTween.terminate();
      this.labelMovesTween = null;
    }
    const originX = this.labelMoves.x;
    this.labelMovesTween = new AnTween({
      target: this.labelMoves,
      from: { scale: { x: 1.05, y: 1 }, position: { x: originX - scaled(5), y: this.labelMoves.y } },
      to: { scale: { x: 1, y: 1 }, position: { x: originX, y: this.labelMoves.y } },
      duration: 2,
      easing: AnEase.easeOutElastic,
      updater: this.getUpdater(),
      autoRemove: true,
      callbacks: {
        onComplete: () => this.labelMovesTween = null
      }
    });
  }
  //       
  onOtherApply(type, score) {
    if (this.mode === "typesCollect" /* TypesCollect */) {
      const modeData = this.modeData;
      const modeDataType = modeData.types.find((elem) => elem.type === type);
      const counter = this.goalCounters.find((counter2) => counter2.iconType === type);
      if (counter && modeDataType) {
        modeDataType.current += score;
        if (modeDataType.current > modeDataType.total)
          modeDataType.current != modeDataType.total;
        counter.updateValue(modeDataType.total - modeDataType.current);
      }
    }
  }
  //     
  onBlockApply(block, globalPos, removeOnly = false, fromPlayerSelection = false) {
    block.prepareToApply();
    const blockScale = Math.max(this.field.scale.x, this.field.scale.y);
    block.scale.set(blockScale);
    block.position.set(globalPos.x, globalPos.y);
    this.addGraphics(block);
    this.animLayer.attach(block);
    const terminateFunc = () => block.terminate();
    const score = 1;
    if (block.special && BonusSpecBlockTypeArray.includes(block.type))
      this.stat_specialsUsed++;
    else
      this.stat_totalPropsCollected++;
    let posToAnim = null;
    let scoreFunc = null;
    if (block.prop && !removeOnly) {
      if (this.mode === "totalCollect" /* TotalCollect */) {
        const modeData = this.modeData;
        if (modeData.current <= modeData.total) {
          posToAnim = this.goalProgress.getGoalGlobalPos();
          posToAnim.x += this.field.scaledCellSize * 0.5;
          scoreFunc = () => {
            modeData.current += score;
            this.goalProgress.updateValue(modeData.current);
          };
        }
      } else if (this.mode === "typesCollect" /* TypesCollect */) {
        const modeData = this.modeData;
        const modeDataType = modeData.types.find((elem) => elem.type === block.type && elem.current <= elem.total);
        const counter = this.goalCounters.find((counter2) => counter2.iconType === block.type);
        if (counter && modeDataType) {
          posToAnim = counter.getMainIconGlobalPos();
          scoreFunc = () => {
            modeDataType.current += score;
            if (modeDataType.current > modeDataType.total)
              modeDataType.current != modeDataType.total;
            counter.updateValue(modeDataType.total - modeDataType.current);
          };
        }
      } else notImplemented();
    }
    if (posToAnim && scoreFunc) {
      const blockTimeDuration = 1.5;
      this.activeScoredBlocksCount++;
      this.stat_goalPropsCollected++;
      const tween = new AnTween({
        target: block,
        to: { position: { x: posToAnim.x, y: posToAnim.y }, scale: { x: blockScale * 0.7, y: blockScale * 0.7 } },
        duration: blockTimeDuration,
        easing: AnEase.easeInOutBack,
        updater: this.getUpdater(),
        tags: ["transition"],
        callbacks: {
          onComplete: () => {
            if (block.destroyed) return;
            const tween2 = new AnTween(
              {
                target: block,
                to: { alpha: 0, scale: { x: blockScale * 0.5, y: blockScale * 0.5 } },
                //tolerance: 0.01,
                duration: 0.7,
                easing: AnEase.easeInElastic,
                updater: this.getUpdater(),
                tags: ["transition"],
                callbacks: {
                  onComplete: () => {
                    AnSounds.play(
                      `sounds/accept.snd.mp3`,
                      AnRnd.float(0.4, 0.6),
                      0,
                      AnRnd.float(0.9, 1.1)
                    );
                    scoreFunc();
                    terminateFunc();
                    this.activeScoredBlocksCount--;
                    if (this.activeScoredBlocksCount === 0)
                      this.onZeroActiveScoredBlocks();
                  }
                }
              }
            );
            block.addToCleanup(() => tween2.terminate());
          }
        }
      });
      block.addToCleanup(() => tween.terminate());
    } else {
      const rndSeed = this.field.colRndSeed[block.gridPos.col];
      const tween = new AnTween({
        target: block,
        to: { alpha: 0, scale: { x: blockScale * 2, y: blockScale * 2 } },
        duration: 0.4,
        delay: rndSeed.seed_float(0, 0.4),
        easing: AnEase.easeIn,
        updater: this.getUpdater(),
        callbacks: {
          onComplete: terminateFunc
        }
      });
      block.addToCleanup(() => tween.terminate());
    }
  }
  onZeroActiveScoredBlocks() {
    if (!this.checkWinState())
      this.checkLoseState();
  }
  /**
   *      (w x h)    
   *  :
   * 1)   ,
   * 2)   (  >90%   ).
   *
   * @param screenWidth -  
   * @param screenHeight -  
   * @param totalCells -    (, 96, 120)
   * @returns {w, h} -      
   */
  calcOptimalGridSize(screenWidth, screenHeight, totalCells) {
    const divisors = /* @__PURE__ */ new Set();
    for (let i3 = 1; i3 <= Math.sqrt(totalCells); i3++) {
      if (totalCells % i3 === 0) {
        divisors.add(i3);
        divisors.add(totalCells / i3);
      }
    }
    const candidates = [];
    for (const w2 of divisors) {
      if (AnMath.isOdd(w2)) continue;
      const h2 = totalCells / w2;
      const cellWidth = screenWidth / w2;
      const cellHeight = screenHeight / h2;
      const area = cellWidth * cellHeight;
      const aspectRatio = Math.max(cellWidth / cellHeight, cellHeight / cellWidth);
      const gridAspectRatio = Math.max(w2 / h2, h2 / w2);
      if (gridAspectRatio > 2) continue;
      candidates.push({
        w: w2,
        h: h2,
        cellWidth,
        cellHeight,
        area,
        aspectRatio
      });
    }
    let maxArea = 0;
    for (const c2 of candidates) {
      if (c2.area > maxArea) {
        maxArea = c2.area;
      }
    }
    const acceptableCandidates = candidates.filter((c2) => c2.area >= maxArea * 0.9);
    acceptableCandidates.sort((a2, b3) => a2.aspectRatio - b3.aspectRatio);
    const best = acceptableCandidates[0];
    return { w: best.w, h: best.h };
  }
  createUI() {
    const background = this.addUIElement(
      "background",
      new AnImage(
        {
          sprite: "images/background.tex.pixi.jpg",
          anchor: AnAnchor.TopLeft,
          resizeStrategy: () => {
            background.position.set(0, 0);
            background.scaledWidth = AnViewport.width;
            background.scaledHeight = AnViewport.height;
            background.applyDefaultResizeStrategy();
          }
        }
      )
    );
    this.onSettingsColorUpdate(GameApp.self.gameData.color);
    const safeFrame = this.calcScaledSafeFrame();
    const optFieldSize = this.calcOptimalGridSize(AnViewport.width - (safeFrame.right + safeFrame.left), AnViewport.height - (safeFrame.bottom + safeFrame.top), G.cellsTotalCount);
    this.field = new Field({
      theme: this.theme,
      rndseed: this.rndseed,
      preset6x6: this.preset6x6 ?? void 0,
      cellMod: this.cellMod ?? void 0,
      generators: this.generators ?? void 0,
      rules: this.rules ?? void 0,
      forbidSpecials: this.forbidSpecials,
      colsCount: optFieldSize.w,
      rowsCount: optFieldSize.h,
      updater: this.localUpdater,
      controlsRouter: this.controlsRouter
    });
    this.field.assignResizeStrategy(
      () => {
        const safeFrame2 = this.calcScaledSafeFrame();
        const placeWidth = AnViewport.width - safeFrame2.left - safeFrame2.right;
        const placeHeight = AnViewport.height - safeFrame2.top - safeFrame2.bottom;
        const scaleX = placeWidth / this.field.realWidth;
        const scaleY = placeHeight / this.field.realHeight;
        const finalScale = Math.min(scaleX, scaleY);
        this.field.scale.set(finalScale);
        this.field.scaledWidth = this.field.realWidth * finalScale;
        this.field.scaledHeight = this.field.realHeight * finalScale;
        const offsetX = safeFrame2.left + (placeWidth - this.field.scaledWidth) / 2;
        const offsetY = safeFrame2.top + (placeHeight - this.field.scaledHeight) / 2;
        this.field.position.set(offsetX, offsetY);
      }
    );
    this.addUIElement("field", this.field);
    if (this.mode === "typesCollect" /* TypesCollect */) {
      const cages = this.modeData.types.find((elem) => elem.type === "cellCage");
      if (cages)
        cages.total = this.field.countCages();
      if (this.tutorial !== "Hearts" /* Hearts */ && this.tutorial !== "Train4" /* Train4 */) {
        const hearts = this.modeData.types.find((elem) => elem.type === "prop_heart");
        if (hearts) {
          hearts.total = Math.min(hearts.total, Math.floor(this.totalMoves * 0.5 / 3));
        }
      }
    }
    const topMenuPadding = 10;
    this.topMenuBG = this.addUIElement(
      "topMenuBG",
      new AnImage(
        {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./cell",
          anchor: AnAnchor.BottomCenter,
          slice9: {
            left: 18,
            right: 18,
            top: 18,
            bottom: 20
          },
          resizeStrategy: () => {
            const safeFrame2 = this.calcScaledSafeFrame();
            const padding = scaled(topMenuPadding);
            this.topMenuBG.scaledWidth = this.field.scaledWidth;
            this.topMenuBG.scaledHeight = safeFrame2.top - padding * 2;
            this.topMenuBG.scale9Adopt = this.field.scaledCellSize / CellSize;
            this.topMenuBG.applyDefaultResizeStrategy();
            this.topMenuBG.position.set(AnViewport.halfWidth, this.field.position.y - padding);
          }
        }
      )
    );
    this.topMenuSep = this.addUIElement(
      "topMenuSep",
      new AnImage(
        {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./sep",
          anchor: AnAnchor.Center,
          alpha: 0.4,
          //tint: 0x333333,
          resizeStrategy: () => {
            const padding = scaled(topMenuPadding);
            this.topMenuSep.scaledWidth = this.topMenuBG.scaledWidth * 0.95;
            this.topMenuSep.scaledHeight = scaled(2);
            this.topMenuSep.applyDefaultResizeStrategy();
            this.topMenuSep.position.set(AnViewport.halfWidth, this.topMenuBG.y - this.topMenuBG.scaledHeight * 0.5);
          }
        }
      )
    );
    this.starsProgress = this.addUIElement(
      "starsProgress",
      new AnProgressBar(
        {
          foreground: {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./starsProgressFront"
          },
          background: {
            atlas: "atlases/game.ss.pixi.atlas",
            sprite: "./starsProgressBack"
          },
          anchor: AnAnchor.LeftCenter,
          resizeStrategy: () => {
            const padding = scaled(topMenuPadding);
            const labelMove_height = this.topMenuBG.height * 0.5 - padding * 2;
            this.starsProgress.scaledHeight = scaled(40);
            this.starsProgress.scaledWidth = this.starsProgress.scaledHeight * 3.06;
            //!     
            this.starsProgress.applyDefaultResizeStrategy();
            this.starsProgress.position.set(this.topMenuBG.left + this.topMenuBG.scaledWidth * 0.025, this.topMenuBG.top + padding + labelMove_height * 0.5);
          }
        }
      )
    );
    this.starsProgress.value = 1;
    this.labelMoves = this.addUIElement(
      "labelMoves",
      new AnLabel({
        text: {
          textSource: () => AnLang.get("moves").toUpperCase() + `: ${this.currentMoves}`,
          fontName: "mainFont",
          fontSize: 60,
          textAlign: "left" /* Left */,
          autoUpdateLang: true,
          shadowAlpha: 0.7
          //anchor: AnAnchor.TopLeft,
        },
        //backgroundColor: 0x333333,
        labelAlign: "left" /* Left */,
        anchor: AnAnchor.TopLeft,
        resizeStrategy: () => {
          const padding = scaled(topMenuPadding);
          this.labelMoves.scaledWidth = this.topMenuBG.width * 0.5;
          this.labelMoves.scaledHeight = this.topMenuBG.height * 0.5 - padding * 2;
          this.labelMoves.applyDefaultResizeStrategy();
          this.labelMoves.position.set(this.starsProgress.x + this.starsProgress.width + scaled(25), this.topMenuBG.top + padding);
        }
      })
    );
    const counterHeight = 70;
    const counterWidth = 200;
    const totalCoins = GameApp.self.gameData.coins;
    this.coinsCounter = this.addUIElement(
      "coinsCounter",
      new UIGoalCounter(
        {
          currentCount: totalCoins,
          maxCount: Infinity,
          iconType: "coin_mod",
          anchor: AnAnchor.Center,
          layout: "vertical" /* Vertical */,
          resizeStrategy: () => {
            const padding = scaled(topMenuPadding);
            this.coinsCounter.scaledWidth = scaled(counterWidth);
            this.coinsCounter.scaledHeight = scaled(counterHeight);
            this.coinsCounter.applyDefaultResizeStrategy();
            this.coinsCounter.position.set(AnViewport.halfWidth, this.topMenuBG.top + padding + this.coinsCounter.scaledHeight * 0.5);
          }
        }
      )
    );
    this.coinsCounter.visible = false;
    this.buttonInfo = this.addUIElement(
      "buttonInfo",
      new AnButton({
        sprite: {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./button",
          slice9: {
            left: 20,
            right: 20,
            top: 20,
            bottom: 20
          }
        },
        // icon: {
        // 	atlas: 'atlases/game.ss.pixi.atlas',
        // 	sprite: './menuIcon',
        // },
        // iconScale: { x: 0.5, y: 0.5 },
        // hoverSprite: {
        // 	atlas: 'atlases/game.ss.pixi.atlas',
        // 	sprite: './buttonHover',
        // 	slice9: {
        // 		left: 20, right: 20, top: 20, bottom: 20
        // 	}
        // },
        labelText: {
          text: {
            textSource: "buttonMenu",
            fontName: "mainFont",
            fontSize: 70,
            textAlign: "center" /* Center */,
            autoUpdateLang: true,
            //shadowAlpha: 0.7,
            color: 3355443
          },
          //backgroundColor: 0x333333,
          labelAlign: "center" /* Center */,
          anchor: AnAnchor.Center
        },
        labelTextOffset: { x: 0, y: -3 },
        //labelTextColorHover: 0xffffff,
        padding: 5,
        anchor: AnAnchor.Center,
        controlsRouter: this.controlsRouter,
        resizeStrategy: () => {
          const padding = scaled(topMenuPadding);
          this.buttonInfo.scaledHeight = (this.topMenuBG.height * 0.5 - padding * 2) * 0.8;
          this.buttonInfo.scaledWidth = this.buttonInfo.scaledHeight * 2.4;
          this.buttonInfo.applyDefaultResizeStrategy();
          this.buttonInfo.position.set(this.topMenuBG.right - this.topMenuBG.scaledWidth * 0.025 - this.buttonInfo.scaledWidth * 0.5, this.labelMoves.y + this.labelMoves.scaledHeight * 0.5 + scaled(5));
        },
        callbacks: {
          onClick: () => {
            if (!this.winLoseState)
              this.showMenuSystem();
          }
        }
      })
    );
    if (this.mode === "totalCollect" /* TotalCollect */) {
      const modeData = this.modeData;
      this.goalProgress = this.addUIElement(
        "goalProgress",
        new UIGoalProgress(
          {
            totalCount: modeData.total,
            resizeStrategy: () => {
              this.goalProgress.scaledWidth = this.topMenuBG.scaledWidth * 0.95;
              this.goalProgress.scaledHeight = scaled(35);
              this.goalProgress.applyDefaultResizeStrategy();
              this.goalProgress.position.set(AnViewport.halfWidth, this.topMenuBG.y - this.topMenuBG.scaledHeight * 0.25);
            }
          }
        )
      );
    } else if (this.mode === "typesCollect" /* TypesCollect */) {
      const addGoalCounter = (type, count2) => {
        if (this.goalCounters === null) return;
        const counterID = this.goalCounters.length;
        const counter = this.addUIElement(
          "goalCounter" + counterID,
          new UIGoalCounter(
            {
              currentCount: count2,
              iconType: type,
              blockTheme: this.theme,
              anchor: AnAnchor.Center,
              layout: "horizontal" /* Horizontal */,
              resizeStrategy: () => {
                const padding = scaled(topMenuPadding);
                const countersCount = this.goalCounters.length;
                const counterHeight2 = this.topMenuBG.height * 0.5 - padding * 2;
                const counterWidth2 = counterHeight2 * 1.8;
                const countersPadding = Math.min((this.topMenuBG.scaledWidth - padding * 2 - counterWidth2 * countersCount) / (countersCount - 1), counterWidth2 * 0.8);
                counter.scaledWidth = counterWidth2;
                counter.scaledHeight = counterHeight2;
                counter.applyDefaultResizeStrategy();
                const posX = getSpriteXCentralDistribution(
                  counterID,
                  counterWidth2,
                  this.topMenuBG.scaledWidth - padding * 2,
                  countersCount,
                  countersPadding
                );
                counter.position.set(this.field.left + posX + padding, this.topMenuBG.bottom - padding * 0.5 - this.topMenuBG.scaledHeight * 0.25);
              }
            }
          )
        );
        this.goalCounters.push(counter);
      };
      const modeData = this.modeData;
      this.goalCounters = [];
      for (const type of modeData.types)
        addGoalCounter(type.type, type.total);
    } else
      notImplemented();
    this.dialogue = this.addUIElement("dialogue", new UIDialogue({
      anchor: AnAnchor.Center,
      bgScale9Adopt: this.topMenuBG.scale9Adopt,
      baseRealWidth: this.field.realWidth,
      resizeStrategy: () => {
        this.dialogue.scaledWidth = AnViewport.portraitMode ? AnViewport.width : this.topMenuBG.scaledWidth;
        this.dialogue.scaledHeight = this.topMenuBG.scaledHeight * 1.2;
        this.dialogue.applyDefaultResizeStrategy();
        this.dialogue.position.set(this.topMenuBG.x, this.topMenuBG.y - this.topMenuBG.scaledHeight * 0.5);
      }
    }));
    this.dialogue.visible = false;
    this.uiLayer.attach(this.dialogue);
    AnSounds.play(
      `sounds/level.snd.mp3`,
      0.6
    );
    this.showBigTitle(AnLang.get("level") + " " + this.levelNum);
    this.addGraphics(this.animLayer);
    this.addGraphics(this.uiLayer);
    runAfterSafe(2, this, () => this.onShowTutorial());
    if (this.levelNum === Infinity)
      this.field.showHintMarkers = false;
    if (this.tutorial !== "None" /* None */) {
      this.field.showHintMarkers = false;
      if (this.tutorial !== "Train1" /* Train1 */)
        this.field.forbidAllSpecBlocks = true;
    }
  }
  showTutorialRect(uiElem) {
    this.tutorialRect = this.addUIElement(
      "tutorialRect",
      new AnBorder(
        {
          type: "dashed" /* Dashed */,
          anchor: AnAnchor.TopLeft,
          updater: this.getUpdater(),
          resizeStrategy: () => {
            this.tutorialRect.position.set(uiElem.x - uiElem.scaledWidth * 0.5, uiElem.y - uiElem.scaledHeight * 0.5);
            this.tutorialRect.scaledWidth = uiElem.scaledWidth;
            this.tutorialRect.scaledHeight = uiElem.scaledHeight;
            this.tutorialRect.applyDefaultResizeStrategy();
          }
        }
      )
    );
    this.tutorialRect.applyResizeStrategy();
  }
  hideTutorialRect() {
    this.tutorialRect?.terminate();
    this.tutorialRect = null;
  }
  showTip(text, pos, color = 16777215, appearDelay = 0, stayDelay = 0) {
    const lenFactor = AnMath.remapClamp(text.length, 10, 20, 2.5, 7);
    const tip = this.addUIElement(new UITip({
      updater: this.getUpdater(),
      appearDelay,
      stayDelay,
      background: {
        atlas: "atlases/game.ss.pixi.atlas",
        sprite: "./greySpot"
      },
      labelText: {
        text: {
          textSource: text.toUpperCase(),
          autoUpdateLang: false,
          fontName: "mainFont",
          fontSize: 90,
          textAlign: "center" /* Center */,
          shadowAlpha: 0.7,
          shadowOffsetX: 4,
          shadowOffsetY: 4,
          color
        },
        labelAlign: "center" /* Center */
      },
      anchor: AnAnchor.Center,
      resizeStrategy: () => {
        const scaled2 = 0.75;
        tip.scaledWidth = this.field.scaledCellSize * lenFactor * scaled2;
        tip.scaledHeight = this.field.scaledCellSize * scaled2;
        tip.applyDefaultResizeStrategy();
        const halfWidth = tip.scaledWidth / 2;
        const halfHeight = tip.scaledHeight / 2;
        const minX = halfWidth;
        const maxX = AnViewport.width - halfWidth;
        const minY = halfHeight;
        const maxY = AnViewport.height - halfHeight;
        const clampedX = Math.max(minX, Math.min(maxX, pos.x));
        const clampedY = Math.max(minY, Math.min(maxY, pos.y));
        const offset = {
          x: clampedX - pos.x,
          y: clampedY - pos.y
        };
        tip.position.set(pos.x + offset.x, pos.y + offset.y);
      },
      callbacks: {
        onComplete: () => this.terminateUIElement(tip)
      }
    }));
    tip.applyResizeStrategy();
    tip.startAnimation();
    this.uiLayer.attach(tip);
  }
  showCoinsCounter() {
    if (this.coinCounterTween) {
      this.coinCounterTween.terminate();
      this.coinCounterTween = null;
    }
    const tween = new AnTween({
      target: this.coinsCounter,
      from: { alpha: 0, scale: { x: 0.7, y: 0.7 } },
      to: { alpha: 1, scale: { x: 1, y: 1 } },
      delay: 0,
      duration: 1,
      easing: AnEase.easeOutBack,
      updater: this.getUpdater(),
      callbacks: {
        onStart: () => this.coinsCounter.visible = true,
        onUpdate: () => {
          if (AnViewport.portraitMode && this.labelMoves)
            this.labelMoves.alpha = 1 - this.coinsCounter.alpha;
        },
        onComplete: () => {
          if (AnViewport.portraitMode && this.labelMoves)
            this.labelMoves.alpha = 0;
          this.coinCounterTween = null;
        }
      }
    });
    this.coinCounterTween = tween;
  }
  hideCoinsCounter() {
    if (this.coinCounterTween) {
      this.coinCounterTween.terminate();
      this.coinCounterTween = null;
    }
    const tween = new AnTween({
      target: this.coinsCounter,
      to: { alpha: 0, scale: { x: 0.7, y: 0.7 } },
      from: { alpha: 1, scale: { x: 1, y: 1 } },
      delay: 1,
      duration: 1,
      easing: AnEase.easeInBack,
      updater: this.getUpdater(),
      callbacks: {
        onUpdate: () => {
          if (AnViewport.portraitMode && this.labelMoves)
            this.labelMoves.alpha = 1 - this.coinsCounter.alpha;
        },
        onComplete: () => {
          if (AnViewport.portraitMode && this.labelMoves)
            this.labelMoves.alpha = 1;
          this.coinsCounter.visible = false;
          this.coinsCounter.scale.set(1, 1);
          this.coinCounterTween = null;
        }
      }
    });
    this.coinCounterTween = tween;
  }
  showBigTitle(text, appearDelay = 0.3, stayDelay = 2.5) {
    const title = this.addUIElement("UIBigTitle", new UIBigTitle({
      updater: this.getUpdater(),
      appearDelay,
      stayDelay,
      background: {
        atlas: "atlases/game.ss.pixi.atlas",
        sprite: "./gradBG"
      },
      labelText: {
        text: {
          textSource: text.toUpperCase(),
          autoUpdateLang: false,
          fontName: "mainFont",
          fontSize: 120,
          textAlign: "center" /* Center */,
          shadowAlpha: 0.7
        },
        labelAlign: "center" /* Center */
      },
      anchor: AnAnchor.Center,
      resizeStrategy: () => {
        title.scaledWidth = this.field.scaledCellSize * 8;
        title.scaledHeight = this.field.scaledCellSize;
        title.applyDefaultResizeStrategy();
        title.position.set(
          this.field.x + this.field.scaledWidth * 0.5,
          this.field.y + this.field.scaledHeight * 0.5
        );
      },
      callbacks: {
        onComplete: () => this.terminateUIElement(title)
      }
    }));
    title.applyResizeStrategy();
    title.startAnimation();
    this.uiLayer.attach(title);
  }
  createEntranceTweens() {
    const tweens = [];
    tweens.push(new AnTween({
      target: this.elements["topMenuBG"],
      from: { alpha: 0, scale: { x: 0.7, y: 0.7 } },
      to: { alpha: G.UIBackgroundTransparent, scale: { x: 1, y: 1 } },
      delay: 0.5,
      duration: 1,
      easing: AnEase.easeOutBack
    }));
    const starsProgress = this.elements["starsProgress"];
    tweens.push(new AnTween({
      target: starsProgress,
      from: { alpha: 0, position: { x: starsProgress.x + scaled(85), y: starsProgress.y } },
      to: { alpha: 1, position: { x: starsProgress.x, y: starsProgress.y } },
      delay: 2,
      duration: 2,
      easing: AnEase.easeOutBack
    }));
    const labelMoves = this.elements["labelMoves"];
    tweens.push(new AnTween({
      target: labelMoves,
      from: { alpha: 0, position: { x: labelMoves.x + scaled(85), y: labelMoves.y } },
      to: { alpha: 1, position: { x: labelMoves.x, y: labelMoves.y } },
      delay: 3,
      duration: 2,
      easing: AnEase.easeOut
    }));
    const buttonInfo = this.elements["buttonInfo"];
    tweens.push(new AnTween({
      target: buttonInfo,
      from: { alpha: 0, position: { x: buttonInfo.x - scaled(85), y: buttonInfo.y } },
      to: { alpha: 1, position: { x: buttonInfo.x, y: buttonInfo.y } },
      delay: 2,
      duration: 2,
      easing: AnEase.easeOutBack
    }));
    tweens.push(new AnTween({
      target: this.elements["topMenuSep"],
      from: { alpha: 0, scale: { x: 0.01, y: 1 } },
      to: { alpha: 1, scale: { x: 1, y: 1 } },
      delay: 3,
      duration: 2,
      easing: AnEase.easeOut
    }));
    if (this.mode === "totalCollect" /* TotalCollect */) {
      tweens.push(new AnTween({
        target: this.elements["goalProgress"],
        from: { alpha: 0, scale: { x: 0.8, y: 1 } },
        to: { alpha: 1, scale: { x: 1, y: 1 } },
        delay: 3,
        duration: 2,
        easing: AnEase.easeOut
      }));
    } else if (this.mode === "typesCollect" /* TypesCollect */) {
      let i3 = 0;
      for (const counter of this.goalCounters) {
        tweens.push(new AnTween({
          target: counter,
          from: { alpha: 0, scale: { x: 0.8, y: 0.8 }, position: { x: counter.x + scaled(85), y: counter.y } },
          to: { alpha: 1, scale: { x: 1, y: 1 }, position: { x: counter.x, y: counter.y } },
          delay: 3 + 0.5 * i3,
          duration: 2,
          easing: AnEase.easeOutBack
        }));
        ++i3;
      }
    }
    return tweens;
  }
  createExitTweens() {
    const tweens = [];
    return tweens;
  }
  update(dt) {
    super.update(dt);
    if (this.starsProgress) {
      this.starsProgress.update(dt);
    }
  }
  restart() {
    GameApp.self.runLevel(this.savedGameConfig);
  }
  addMoves(count2 = 0, pos = new GridPos(0, 0)) {
    AnSounds.play(
      `sounds/moves.snd.mp3`,
      0.6
    );
    this.currentMoves += count2;
    this.updateMovesAnim();
    this.showBigTitle(AnLang.get("spec_chest_moves").replace("%%count%%", count2.toString()), 0, 0.5);
  }
  addCoins(count2 = 0, pos) {
    this.showBigTitle(AnLang.get("spec_chest_coins").replace("%%count%%", count2.toString()), 0, 0.5);
    GameApp.self.gameData.coins += count2;
    Analytics.onGetResource("coins", count2, "rewardChest", "coins");
    const pixelPos = pos.toPixelPos();
    this.runCoinsAnims(count2, new lib_exports.Point(this.field.x + pixelPos.x * this.field.scale.x, this.field.y + pixelPos.y * this.field.scale.y), pos);
  }
  addActualProps(count2 = 0, pos) {
    this.showBigTitle(AnLang.get("spec_chest_props").replace("%%count%%", count2.toString()), 0, 0.5);
    let type = "prop_0";
    if (this.mode === "totalCollect" /* TotalCollect */) {
      type = PropBlockTypeArray[this.field.specRndSeed.seed_int(0, PropBlockTypeArray.length - 1)];
    } else if (this.mode === "typesCollect" /* TypesCollect */) {
      const typesCollect = this.goalCounters.reduce((acc, counter) => {
        if (!counter.finished && counter.iconType.startsWith("prop_") && counter.iconType != "prop_heart") acc.push(counter.iconType);
        return acc;
      }, []);
      if (typesCollect.length)
        type = typesCollect[this.field.specRndSeed.seed_int(0, typesCollect.length - 1)];
      else
        type = PropBlockTypeArray[this.field.specRndSeed.seed_int(0, PropBlockTypeArray.length - 1)];
    } else
      notImplemented();
    for (let i3 = 0; i3 < count2; ++i3) {
      runAfterSafe(i3 * 0.3, this.field, () => {
        AnSounds.play(
          `sounds/prop.snd.mp3`,
          AnRnd.float(0.4, 0.6) * 0.5,
          AnMath.remapClamp(pos.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
          AnRnd.float(0.9, 1.1)
        );
        const block = new Block({
          pos,
          type,
          theme: this.theme,
          skipCreatingAnim: true,
          updater: this.field.getUpdater(),
          selectionLayer: this.field.selectionLayer,
          blockLayer: this.field.blockLayer
        });
        this.field.addUIElement(block);
        this.field.applyBlock(block);
      });
    }
  }
  runCoinsAnims(rewardCoins, globalPosStart, pos) {
    const chunkValue = Math.trunc(rewardCoins * 0.2);
    const totalChunks = Math.ceil(rewardCoins / chunkValue);
    this.coinsCounter.scale.set(1, 1);
    const posStart = globalPosStart;
    const posEnd = this.coinsCounter.getMainIconGlobalPos();
    this.showCoinsCounter();
    for (let i3 = 0; i3 < totalChunks; ++i3) {
      const coinValue = i3 === totalChunks - 1 ? rewardCoins - chunkValue * i3 : chunkValue;
      const coin = this.addUIElement(new AnImage({
        atlas: "atlases/game.ss.pixi.atlas",
        sprite: "./coin_mod",
        anchor: AnAnchor.Center,
        resizeStrategy: () => {
          coin.scaledWidth = scaled(20);
          coin.scaledHeight = scaled(20);
          coin.applyDefaultResizeStrategy();
        }
      }));
      coin.visible = false;
      const tween = new AnTween({
        target: coin,
        from: { alpha: 0.5, position: { x: posStart.x, y: posStart.y } },
        to: { alpha: 1, position: { x: posEnd.x, y: posEnd.y } },
        delay: i3 * 0.3,
        duration: 0.7,
        tolerance: 0.3,
        easing: AnEase.easeOutBack,
        updater: this.getUpdater(),
        callbacks: {
          onStart: () => {
            coin.visible = true;
            AnSounds.play(
              `sounds/coin.snd.mp3`,
              AnRnd.float(0.4, 0.6) * 0.5,
              AnMath.remapClamp(pos.col, 0, GameApp.self.game.field.colsCount - 1, -0.5, 0.5),
              AnRnd.float(0.9, 1.1)
            );
          },
          onComplete: () => {
            removeByValue(this.coinTweens, tween);
            const tweenOut = new AnTween(
              {
                target: coin,
                to: { alpha: 0, scale: { x: 0.5, y: 0.5 } },
                tolerance: 0.01,
                duration: 0.8,
                easing: AnEase.easeInBack,
                updater: this.getUpdater(),
                callbacks: {
                  onComplete: () => {
                    this.coinsCounter.updateValue(this.coinsCounter.currentCount + coinValue);
                    this.terminateUIElement(coin);
                    removeByValue(this.coinTweens, tweenOut);
                    if (i3 === totalChunks - 1)
                      this.hideCoinsCounter();
                  }
                }
              }
            );
            this.coinTweens.push(tweenOut);
          }
        }
      });
      this.coinTweens.push(tween);
    }
  }
  continue(newMoves = 0) {
    this.addMoves(newMoves);
    this.field.forbidSelectBlocks = false;
    this.winLoseState = false;
    this.playerContinueCount++;
  }
  terminate() {
    super.terminate();
  }
};

// games/packer/src/game/Intro.ts
init_define_AnParams();
var Intro = class extends AnMenu {
  constructor(config2) {
    super(config2);
    this.callbacks = config2.callbacks ?? {};
  }
  start() {
    this.createUI();
    this.resizeUI();
    this.show();
  }
  createUI() {
    const background = this.addUIElement(
      "background",
      new AnImage(
        {
          sprite: "images/background.tex.pixi.jpg",
          anchor: AnAnchor.TopLeft,
          resizeStrategy: () => {
            background.position.set(0, 0);
            background.scaledWidth = AnViewport.width;
            background.scaledHeight = AnViewport.height;
            background.applyDefaultResizeStrategy();
          }
        }
      )
    );
    const dialogue = this.addUIElement("dialogue", new AnDialogue({
      text: {
        textSource: "\u041F\u0440\u0438\u0432\u0435\u0442! \u0420\u0430\u0434 \u0442\u0435\u0431\u044F \u0432\u0438\u0434\u0435\u0442\u044C \u0432 \u0438\u0433\u0440\u0435. \u041F\u0440\u0430\u0432\u0438\u043B\u0430 \u043E\u0447\u0435\u043D\u044C \u043F\u0440\u043E\u0441\u0442\u044B\u0435. \u041D\u0430\u0447\u0438\u043D\u0430\u0435\u043C?",
        fontName: "mainFont",
        fontSize: 100,
        textAlign: "center" /* Center */,
        autoUpdateLang: false,
        shadowAlpha: 0.4,
        shadowOffsetX: 3,
        shadowOffsetY: 3
      },
      anchor: AnAnchor.Center,
      speedFactor: 0.5,
      baseRealWidth: 800,
      resizeStrategy: () => {
        const dialogueWidth = AnViewport.width * 0.7;
        dialogue.setScaledSize(dialogueWidth, dialogueWidth / dialogue.realSizeRatio);
        dialogue.applyDefaultResizeStrategy();
        dialogue.position.set(AnViewport.halfWidth, AnViewport.halfHeight);
      }
    }));
    const frame = this.addUIElement(
      "frame",
      new AnImage(
        {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./cell",
          anchor: AnAnchor.Center,
          slice9: {
            left: 18,
            right: 18,
            top: 18,
            bottom: 20
          },
          resizeStrategy: () => {
            const frameWidth = AnViewport.width * 0.9;
            frame.scaledWidth = frameWidth;
            frame.scaledHeight = frameWidth / dialogue.realSizeRatio * 1.1;
            frame.applyDefaultResizeStrategy();
            frame.position.set(AnViewport.halfWidth, AnViewport.halfHeight);
          }
        }
      )
    );
  }
  createEntranceTweens() {
    const tweens = [];
    tweens.push(new AnTween({
      target: this.elements["frame"],
      from: { alpha: 0, scale: { x: 0.7, y: 0.7 } },
      to: { alpha: 2, scale: { x: 1, y: 1 } },
      delay: 0.5,
      duration: 2,
      easing: AnEase.easeOutBack
    }));
    runAfterSafe(2, this, () => this.elements["dialogue"].startAnimation(() => runAfterSafe(1, this, () => this.hide(this.callbacks.onComplete))));
    return tweens;
  }
  createExitTweens() {
    const tweens = [];
    tweens.push(new AnTween({
      target: this.elements["frame"],
      to: { alpha: 0, scale: { x: 0.7, y: 0.7 } },
      from: { alpha: 2, scale: { x: 1, y: 1 } },
      delay: 2,
      duration: 2,
      easing: AnEase.easeOut,
      tags: ["terminate"]
    }));
    this.elements["dialogue"].exitAnimation();
    return tweens;
  }
};

// games/packer/src/game/LevelData.ts
init_define_AnParams();

// games/packer/src/game/LevelGenerator.ts
init_define_AnParams();
var LevelGenerator = class {
  static generate(levelNum) {
    const overrideConfigParams = this.overrideConfigParams[levelNum] ?? null;
    const seed = overrideConfigParams?.seed ?? `levelGen_${levelNum}`;
    const rndLevelGen = new AnRnd(seed);
    if (true) AnLog.debug(`[GEN] \u0417\u0435\u0440\u043D\u043E \u0433\u0435\u043D\u0435\u0440\u0430\u0446\u0438\u0438 \u0443\u0440\u043E\u0432\u043D\u044F:${seed}`);
    const difficultyFactor = Math.min(Math.max(levelNum - G.predefinedLevels, 0) / (100 - G.predefinedLevels), 1);
    const totalCollectChance = AnMath.lerp(0.5, 0.3, difficultyFactor);
    let mode = rndLevelGen.seed_bool(totalCollectChance) ? "totalCollect" /* TotalCollect */ : "typesCollect" /* TypesCollect */;
    if (overrideConfigParams?.mode)
      mode = overrideConfigParams.mode;
    let LevelGenElem;
    ((LevelGenElem2) => {
      LevelGenElem2["Hearts"] = "hearts";
      LevelGenElem2["Stones"] = "stones";
      LevelGenElem2["Cages"] = "cages";
      LevelGenElem2["Paint"] = "paint";
    })(LevelGenElem || (LevelGenElem = {}));
    const levelGenElemsArray = shuffle(Object.values(LevelGenElem), rndLevelGen);
    if (overrideConfigParams) {
      if (overrideConfigParams.forbidHearts) removeByValue(levelGenElemsArray, "hearts" /* Hearts */);
      if (overrideConfigParams.forbidStones) removeByValue(levelGenElemsArray, "stones" /* Stones */);
      if (overrideConfigParams.forbidCages) removeByValue(levelGenElemsArray, "cages" /* Cages */);
      if (overrideConfigParams.forbidPaint) removeByValue(levelGenElemsArray, "paint" /* Paint */);
    }
    if (levelGenElemsArray.length && (rndLevelGen.seed_bool(AnMath.lerp(0.3, 0.5, difficultyFactor)) || overrideConfigParams?.forceSpecLevel)) {
      let specLevelElems = 0;
      AnRnd.executeByChance([
        { chance: AnMath.lerp(0.7, 0.3, difficultyFactor), action: () => specLevelElems = 1 },
        { chance: AnMath.lerp(0.3, 0.6, difficultyFactor), action: () => specLevelElems = 2 },
        { chance: AnMath.lerp(0.2, 0.1, difficultyFactor), action: () => specLevelElems = 3 },
        { chance: AnMath.lerp(0, 0.05, difficultyFactor), action: () => specLevelElems = 4 }
      ], rndLevelGen);
      if (overrideConfigParams?.specLevelElems) specLevelElems = overrideConfigParams.specLevelElems;
      specLevelElems = AnMath.clamp(specLevelElems, 1, levelNum < 50 ? 2 : levelNum < 100 ? 3 : 4);
      levelGenElemsArray.length = specLevelElems;
    } else
      levelGenElemsArray.length = 0;
    let modeData;
    if (mode === "totalCollect" /* TotalCollect */) {
      modeData = {};
      modeData.total = AnMath.ceilToMultiple(120 + (100 + rndLevelGen.seed_int(-20, 20)) * difficultyFactor, 5);
      removeByValue(levelGenElemsArray, "hearts" /* Hearts */);
      removeByValue(levelGenElemsArray, "paint" /* Paint */);
    } else if (mode === "typesCollect" /* TypesCollect */) {
      modeData = {};
      let typesCount = 0;
      AnRnd.executeByChance([
        { chance: AnMath.lerp(0.3, 0.1, difficultyFactor), action: () => typesCount = 2 },
        { chance: AnMath.lerp(0.5, 0.6, difficultyFactor), action: () => typesCount = 3 },
        { chance: AnMath.lerp(0.1, 0.3, difficultyFactor), action: () => typesCount = 4 }
      ], rndLevelGen);
      const types = [];
      const shouldAdd = (elem, prob = 1) => types.length < typesCount && levelGenElemsArray.includes(elem) && rndLevelGen.seed_bool(prob);
      if (shouldAdd("hearts" /* Hearts */)) types.unshift("prop_heart");
      if (shouldAdd("stones" /* Stones */, 0.5)) types.push("spec_stone");
      if (shouldAdd("cages" /* Cages */, 0.5)) types.push("cellCage");
      if (shouldAdd("paint" /* Paint */)) types.push("cellPainted");
      if (!types.includes("prop_heart")) removeByValue(levelGenElemsArray, "hearts" /* Hearts */);
      if (!types.includes("cellPainted")) removeByValue(levelGenElemsArray, "paint" /* Paint */);
      while (types.length < typesCount) {
        const propName = "prop_" + rndLevelGen.seed_int(0, 6);
        if (!types.includes(propName)) types.push(propName);
      }
      modeData.types = [];
      for (const type of types) {
        let count2 = AnMath.ceilToMultiple(15 * rndLevelGen.seed_float(0.5, 1) + (30 + rndLevelGen.seed_int(-10, 10)) * difficultyFactor, 2);
        if (type === "spec_stone") count2 = AnMath.ceilToMultiple(count2 / 2, 2);
        if (type === "cellPainted") count2 = AnMath.ceilToMultiple(G.cellsTotalCount * AnMath.lerp(0.3, 0.6, difficultyFactor), 2);
        modeData.types.push({ type, total: count2 });
      }
    } else
      notImplemented();
    let generators = [];
    let rules = [];
    let cellMod = [];
    if (levelGenElemsArray.includes("hearts" /* Hearts */)) {
      generators.push({ type: "spec_heart", num: 3, last: 0 });
    }
    if (levelGenElemsArray.includes("stones" /* Stones */)) {
      rules.push({ type: "DropRandomStones" /* DropRandomStones */, num: overrideConfigParams?.genStonesFactor ?? AnMath.lerp(0.1, 0.15, difficultyFactor) - rndLevelGen.seed_float(0, 0.05) });
    }
    if (levelGenElemsArray.includes("cages" /* Cages */)) {
      const chance = AnMath.lerp(0.2, 0.3, difficultyFactor) - rndLevelGen.seed_float(0, 0.15);
      rules.push({ type: "InitRandomCages" /* InitRandomCages */, num: chance });
    }
    if (levelGenElemsArray.includes("paint" /* Paint */)) {
      const area = overrideConfigParams?.paintArea ?? rndLevelGen.seed_int(0, 2);
      const variant = overrideConfigParams?.paintVariant ?? rndLevelGen.seed_int(0, 2);
      const extraCells = levelNum < 50 || rndLevelGen.seed_bool(0.3);
      const configs = {
        0: { y1: 2, y2: 3 },
        // center
        1: { y1: 0, y2: 5 },
        // left
        2: { y1: 1, y2: 4 }
        // right
      };
      const { y1, y2 } = configs[area];
      const xBase = variant * 2;
      cellMod.push(
        { pos: new GridPos(xBase, y1), mods: [1 /* Paint */] },
        { pos: new GridPos(xBase, y2), mods: [1 /* Paint */] }
      );
      if (extraCells) {
        cellMod.push(
          { pos: new GridPos(xBase + 1, y1), mods: [1 /* Paint */] },
          { pos: new GridPos(xBase + 1, y2), mods: [1 /* Paint */] }
        );
      }
    }
    let perfectMoves = 0;
    if (mode === "totalCollect" /* TotalCollect */) {
      modeData = modeData;
      perfectMoves = Math.ceil(modeData.total / AnMath.lerp(8, 10, difficultyFactor));
    } else {
      modeData = modeData;
      const totalItems = modeData.types.reduce((sum, t2) => sum + t2.total, 0);
      const avrPropPerChains = AnMath.remapClamp(modeData.types.length, 2, 4, 2.5, 5) + AnMath.lerp(0, 2, difficultyFactor);
      if (true) AnLog.debug(`[GEN] totalItems: ${totalItems} avrPropPerChains: ${avrPropPerChains}`);
      perfectMoves = Math.ceil(totalItems / avrPropPerChains);
    }
    if (true) AnLog.debug(`[GEN] perfectMoves:${perfectMoves} totalMoves:${G.calculateTotalMoves(perfectMoves)}`);
    if (true) AnLog.debug(`[GEN] rules:${struct(rules)}`);
    let config2 = {
      levelNum,
      theme: GameApp.self.gameData.theme,
      totalMoves: overrideConfigParams?.totalMoves ?? AnMath.ceilToMultiple(G.calculateTotalMoves(perfectMoves) - G.totalMovesAddMore, 2),
      rndseed: rndLevelGen.seed_int(1e5, 999999),
      mode,
      modeData: modeData ?? { total: 100 },
      generators: generators.length === 0 ? void 0 : generators,
      rules: rules.length === 0 ? void 0 : rules,
      cellMod: cellMod.length === 0 ? void 0 : cellMod
      // mode: GameMode.TypesCollect,
      // modeData: { types: [{ type: "prop_1", total: 3 }, { type: "prop_3", total: 3 }, { type: "prop_4", total: 3 }] },
    };
    return config2;
  }
};
///  X  
LevelGenerator.overrideConfigParams = {
  // 17: {
  // 	seed: `17_randgen`,
  // 	//totalMoves: 345,
  // 	mode: GameMode.TypesCollect,
  // 	//forbidCages: true,
  // }
  // ----------------------------------------
  18: {
    mode: "typesCollect" /* TypesCollect */
  },
  // ----------------------------------------
  20: {
    seed: `20_next`
  },
  // ----------------------------------------
  21: {
    seed: `fgh5`
  },
  // ----------------------------------------
  24: {
    seed: `vbn56nnn`,
    specLevelElems: 3,
    mode: "typesCollect" /* TypesCollect */
  },
  // ----------------------------------------
  27: {
    seed: `cvbcvb`,
    specLevelElems: 3,
    mode: "typesCollect" /* TypesCollect */,
    genStonesFactor: 0.1,
    paintArea: 1,
    paintVariant: 1
  },
  // ----------------------------------------
  30: {
    seed: `hhee`,
    mode: "totalCollect" /* TotalCollect */
  },
  // ----------------------------------------
  32: {
    seed: `3233gfh2322`,
    specLevelElems: 2,
    genStonesFactor: 0.1
  },
  // ----------------------------------------
  36: {
    seed: `xcvxcvxv`,
    specLevelElems: 4,
    forbidStones: true
  },
  // ----------------------------------------
  40: {
    seed: `c46qq`,
    specLevelElems: 4
  },
  // ----------------------------------------
  41: {
    seed: `234234234;'u`,
    specLevelElems: 4
  },
  // ----------------------------------------
  42: {
    seed: `cvbcvb4 vbn`,
    specLevelElems: 3,
    mode: "typesCollect" /* TypesCollect */,
    genStonesFactor: 0.1,
    paintArea: 1,
    paintVariant: 1
  },
  // ----------------------------------------
  43: {
    seed: `bbdyuw`,
    specLevelElems: 3,
    forceSpecLevel: true,
    mode: "typesCollect" /* TypesCollect */
  },
  // ----------------------------------------
  50: {
    seed: `45345345434999`
  },
  // ----------------------------------------
  53: {
    mode: "typesCollect" /* TypesCollect */
  },
  // ----------------------------------------
  59: {
    seed: `vbngjjjjjfrrew`,
    specLevelElems: 2,
    forceSpecLevel: true,
    mode: "typesCollect" /* TypesCollect */
  },
  // ----------------------------------------
  62: {
    genStonesFactor: 0.11,
    paintArea: 0,
    paintVariant: 1
  },
  // ----------------------------------------
  63: {
    mode: "typesCollect" /* TypesCollect */
  },
  // ----------------------------------------
  65: {
    forbidStones: true
  },
  // ----------------------------------------
  68: {
    genStonesFactor: 0.11
  },
  // ----------------------------------------
  70: {
    forbidStones: true
  },
  // ----------------------------------------
  73: {
    seed: `nnnfghhqqqq`
  },
  // ----------------------------------------
  77: {
    seed: `bnnnnnfqqrioo214`
  },
  // ----------------------------------------
  80: {
    forbidHearts: true,
    //paintArea: 0,
    paintVariant: 1
  },
  // ----------------------------------------
  87: {
    seed: `xxxttttxxx`
  },
  // ----------------------------------------
  89: {
    seed: `olabfg`
  },
  // ----------------------------------------
  90: {
    seed: `bbbbnfg`,
    genStonesFactor: 0.12,
    paintArea: 0,
    paintVariant: 1
  },
  // ----------------------------------------
  93: {
    genStonesFactor: 0.11
  },
  // ----------------------------------------
  95: {
    mode: "totalCollect" /* TotalCollect */
  },
  // ----------------------------------------
  97: {
    seed: `bbbbnvvbr55g`,
    forbidStones: true
  }
};

// games/packer/src/game/LevelData.ts
var _LevelData = class _LevelData {
  constructor() {
  }
  static getNextGamePlayElement() {
    const shownElements = GameApp.self.gameData.shownGameplayElements;
    const currentLevel = GameApp.self.gameData.level;
    for (const [key, minLevelNum] of Object.entries(_LevelData.introduceGameplayElement))
      if (!shownElements.includes(key) && currentLevel >= minLevelNum)
        return key;
    return "";
  }
  static get(levelID = 0) {
    let config2 = {
      levelNum: 123456,
      theme: GameApp.self.gameData.theme,
      totalMoves: 25,
      rndseed: 777,
      mode: "totalCollect" /* TotalCollect */,
      modeData: { total: 25 }
      // mode: GameMode.TypesCollect,
      // modeData: { types: [{ type: "prop_1", total: 3 }, { type: "prop_3", total: 3 }, { type: "prop_4", total: 3 }] },
    };
    switch (levelID) {
      //  
      case -1:
        config2 = {
          ...config2,
          levelNum: Infinity,
          theme: GameApp.self.gameData.theme,
          totalMoves: 125,
          rndseed: 777,
          mode: "totalCollect" /* TotalCollect */,
          modeData: { total: 125 },
          forbidSpecials: BonusSpecBlockTypeArray.slice()
          // mode: GameMode.TypesCollect,
          // modeData: { types: [{ type: "prop_1", total: 3 }, { type: "prop_3", total: 3 }, { type: "prop_4", total: 3 }] },
        };
        break;
      // LEVEL 1
      case 1:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(5),
          rndseed: 765457,
          mode: "totalCollect" /* TotalCollect */,
          modeData: { total: 25 },
          tutorial: "Chains" /* Chains */,
          preset6x6: AnMath.rotate270([
            ["prop_3", "prop_1", "prop_6", "prop_2", "prop_4", "prop_0"].reverse(),
            ["prop_5", "prop_1", "prop_2", "prop_5", "prop_1", "prop_3"].reverse(),
            ["prop_2", "prop_1", "prop_1", "prop_1", "prop_6", "prop_1"].reverse(),
            ["prop_6", "prop_3", "prop_2", "prop_1", "prop_5", "prop_2"].reverse(),
            ["prop_1", "prop_4", "prop_4", "prop_3", "prop_2", "prop_6"].reverse(),
            ["prop_4", "prop_6", "prop_3", "prop_1", "prop_0", "prop_5"].reverse(),
            //////////////////////////////////////////////////////////////////////////////////////
            ["prop_4", "prop_1", "prop_6", "prop_2", "prop_4", "prop_0"].reverse(),
            ["prop_0", "prop_1", "prop_4", "prop_4", "prop_0", "prop_3"].reverse(),
            ["prop_2", "prop_1", "prop_1", "prop_1", "prop_6", "prop_1"].reverse(),
            ["prop_0", "prop_3", "prop_2", "prop_1", "prop_0", "prop_2"].reverse(),
            ["prop_1", "prop_5", "prop_4", "prop_3", "prop_2", "prop_6"].reverse(),
            ["prop_4", "prop_6", "prop_3", "prop_1", "prop_0", "prop_5"].reverse()
          ]),
          forbidSpecials: BonusSpecBlockTypeArray.slice()
        };
        break;
      // LEVEL 2
      case 2:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(6),
          rndseed: 3711,
          mode: "totalCollect" /* TotalCollect */,
          modeData: { total: 40 },
          tutorial: "Bombs" /* Bombs */,
          preset6x6: AnMath.rotate270([
            //////////////////////////////////////////////////////////////////////////////////////
            ["prop_4", "prop_0", "prop_6", "prop_3", "spec_bomb", "prop_0"].reverse(),
            ["prop_1", "prop_2", "prop_1", "prop_6", "prop_3", "prop_5"].reverse(),
            ["prop_5", "prop_3", "spec_bomb", "prop_0", "prop_6", "prop_4"].reverse(),
            ["prop_0", "prop_5", "prop_6", "prop_5", "prop_5", "prop_3"].reverse(),
            ["prop_1", "prop_5", "prop_4", "prop_6", "prop_3", "prop_5"].reverse(),
            ["prop_5", "prop_3", "prop_3", "prop_0", "prop_6", "prop_1"].reverse(),
            ["prop_4", "prop_0", "prop_0", "spec_bomb", "prop_2", "prop_6"].reverse(),
            //////////////////////////////////////////////////////////////////////////////////////
            ["prop_3", "prop_3", "prop_2", "prop_2", "prop_2", "prop_1"].reverse(),
            ["prop_6", "spec_bomb", "prop_4", "prop_4", "prop_1", "prop_1"].reverse(),
            ["prop_5", "prop_0", "prop_2", "prop_5", "prop_4", "prop_1"].reverse(),
            ["prop_5", "prop_1", "prop_1", "prop_0", "prop_4", "prop_3"].reverse(),
            ["prop_1", "prop_0", "prop_1", "prop_1", "prop_0", "prop_4"].reverse(),
            ["prop_0", "prop_0", "prop_2", "prop_5", "prop_5", "prop_5"].reverse()
          ]),
          forbidSpecials: BonusSpecBlockTypeArray.filter((special) => !["spec_bomb"].includes(special))
        };
        break;
      // LEVEL 3
      case 3:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(15),
          //! 12
          rndseed: 7785,
          mode: "typesCollect" /* TypesCollect */,
          modeData: { types: [{ type: "prop_1", total: 10 }, { type: "prop_3", total: 12 }, { type: "prop_4", total: 15 }] },
          tutorial: "Rockets" /* Rockets */,
          preset6x6: AnMath.rotate270([
            ["prop_4", "prop_0", "spec_rocket_vertical", "prop_3", "prop_0", "prop_0"].reverse(),
            ["prop_5", "prop_3", "prop_6", "spec_rocket_diagonal1", "prop_6", "prop_4"].reverse(),
            ["prop_0", "prop_5", "spec_bomb", "prop_5", "prop_5", "prop_3"].reverse(),
            ["prop_1", "prop_5", "prop_4", "prop_6", "prop_3", "prop_5"].reverse(),
            ["spec_rocket_horizontal", "prop_3", "prop_3", "spec_bomb", "prop_6", "prop_1"].reverse(),
            ["prop_4", "prop_6", "prop_0", "prop_2", "prop_2", "prop_6"].reverse(),
            //////////////////////////////////////////////////////////////////////////////////////
            ["prop_0", "prop_0", "prop_1", "prop_4", "prop_2", "prop_0"].reverse(),
            ["prop_4", "prop_4", "prop_0", "prop_0", "prop_6", "spec_rocket_vertical"].reverse(),
            ["prop_6", "prop_5", "spec_rocket_diagonal1", "prop_4", "prop_6", "prop_3"].reverse(),
            ["prop_4", "prop_2", "prop_6", "prop_6", "prop_0", "prop_0"].reverse(),
            ["prop_5", "prop_4", "prop_6", "prop_3", "prop_5", "prop_4"].reverse(),
            ["prop_2", "prop_6", "prop_0", "prop_5", "prop_0", "prop_2"].reverse()
          ]),
          forbidSpecials: ["spec_dice", "spec_chest", "spec_rainbow", "spec_mirror"]
        };
        break;
      // LEVEL 4 (Train1)
      case 4:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(12),
          rndseed: 45645,
          //4552,
          mode: "totalCollect" /* TotalCollect */,
          modeData: { total: 75 },
          tutorial: "Train1" /* Train1 */,
          preset6x6: AnMath.rotate270([
            ["prop_2", "prop_0", "prop_5", "prop_4", "prop_5", "prop_3"].reverse(),
            ["prop_6", "prop_4", "prop_3", "prop_3", "prop_1", "prop_6"].reverse(),
            ["prop_4", "prop_3", "prop_3", "prop_6", "prop_5", "prop_3"].reverse(),
            ["prop_6", "prop_3", "prop_4", "prop_2", "prop_0", "prop_1"].reverse(),
            ["prop_6", "prop_3", "prop_1", "prop_2", "prop_6", "prop_1"].reverse(),
            ["prop_3", "prop_2", "prop_6", "prop_4", "prop_3", "prop_2"].reverse()
          ]),
          forbidSpecials: ["spec_dice", "spec_chest", "spec_rainbow", "spec_mirror"]
        };
        break;
      // LEVEL 5
      case 5:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(8),
          rndseed: 24347,
          mode: "typesCollect" /* TypesCollect */,
          modeData: { types: [{ type: "cellCage", total: 10 }] },
          tutorial: "Cages" /* Cages */,
          preset6x6: AnMath.rotate270([
            ["prop_1", "prop_4", "prop_6", "prop_4", "prop_0", "prop_6"].reverse(),
            ["prop_1", "prop_0", "prop_3", "prop_2", "prop_1", "prop_0"].reverse(),
            ["prop_6", "prop_1", "prop_3", "prop_3", "prop_5", "prop_0"].reverse(),
            ["prop_2", "prop_5", "prop_0", "prop_1", "prop_6", "prop_6"].reverse(),
            ["prop_6", "prop_1", "prop_4", "prop_6", "prop_0", "prop_2"].reverse(),
            ["prop_2", "prop_6", "prop_2", "prop_3", "prop_3", "prop_4"].reverse(),
            ///////////////////////////////////////////////////////////////////////
            ["prop_3", "prop_3", "prop_2", "prop_2", "prop_4", "prop_1"].reverse(),
            ["prop_6", "prop_2", "prop_4", "prop_4", "prop_1", "prop_1"].reverse(),
            ["prop_5", "prop_0", "prop_2", "prop_1", "prop_4", "prop_2"].reverse(),
            ["prop_5", "prop_5", "prop_6", "prop_0", "prop_0", "prop_3"].reverse(),
            ["prop_1", "prop_0", "prop_1", "prop_1", "prop_0", "prop_4"].reverse(),
            ["prop_0", "prop_0", "prop_2", "prop_5", "prop_5", "prop_5"].reverse()
          ]),
          cellMod: [{ pos: new GridPos(2, 0), mods: [2 /* Cage */] }, { pos: new GridPos(2, 5), mods: [2 /* Cage */] }, { pos: new GridPos(3, 0), mods: [2 /* Cage */] }, { pos: new GridPos(3, 5), mods: [2 /* Cage */] }, { pos: new GridPos(4, 0), mods: [2 /* Cage */] }, { pos: new GridPos(4, 1), mods: [2 /* Cage */] }, { pos: new GridPos(4, 2), mods: [2 /* Cage */] }, { pos: new GridPos(4, 3), mods: [2 /* Cage */] }, { pos: new GridPos(4, 4), mods: [2 /* Cage */] }, { pos: new GridPos(4, 5), mods: [2 /* Cage */] }],
          forbidSpecials: ["spec_dice", "spec_chest", "spec_rainbow", "spec_mirror"]
        };
        break;
      // LEVEL 6
      case 6:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(12),
          rndseed: 2246,
          mode: "totalCollect" /* TotalCollect */,
          modeData: { total: 95 },
          tutorial: "Mirrors" /* Mirrors */,
          preset6x6: AnMath.rotate270([
            ["prop_0", "prop_3", "prop_2", "prop_4", "prop_2", "prop_0"].reverse(),
            ["prop_2", "prop_0", "prop_3", "prop_4", "prop_0", "prop_6"].reverse(),
            ["prop_5", "prop_2", "prop_1", "prop_1", "prop_1", "prop_3"].reverse(),
            ["prop_3", "prop_5", "prop_2", "prop_1", "prop_3", "prop_6"].reverse(),
            ["prop_5", "prop_5", "prop_3", "prop_5", "prop_2", "spec_rocket_vertical"].reverse(),
            ["prop_5", "prop_5", "prop_5", "spec_mirror", "prop_6", "spec_rocket_horizontal"].reverse(),
            //////////////////////////////////////////////////////////////////////////////////////
            ["prop_0", "prop_0", "prop_1", "prop_4", "prop_6", "prop_4"].reverse(),
            ["prop_2", "prop_6", "prop_4", "prop_6", "prop_4", "prop_2"].reverse(),
            ["prop_5", "prop_5", "prop_0", "prop_3", "prop_2", "prop_5"].reverse(),
            ["prop_3", "prop_5", "prop_1", "prop_3", "prop_2", "prop_5"].reverse(),
            ["prop_5", "prop_6", "spec_mirror", "prop_2", "prop_0", "prop_3"].reverse(),
            ["prop_4", "prop_3", "prop_6", "prop_5", "prop_0", "prop_4"].reverse()
          ]),
          forbidSpecials: ["spec_dice", "spec_chest", "spec_rainbow"]
        };
        break;
      // LEVEL 7 (Train2)
      case 7:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(18) - 1,
          rndseed: 4552,
          mode: "totalCollect" /* TotalCollect */,
          modeData: { total: 100 },
          tutorial: "Train2" /* Train2 */,
          forbidSpecials: ["spec_dice", "spec_chest", "spec_rainbow"],
          rules: [
            { type: "InitRandomCages" /* InitRandomCages */, num: 0.4 }
          ]
        };
        break;
      // LEVEL 8
      case 8:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(12) + 1,
          rndseed: 778555,
          mode: "typesCollect" /* TypesCollect */,
          modeData: { types: [{ type: "spec_stone", total: 16 }] },
          tutorial: "Stones" /* Stones */,
          preset6x6: AnMath.rotate270([
            ["prop_3", "prop_6", "prop_3", "spec_stone", "prop_3", "prop_6"].reverse(),
            ["prop_2", "prop_2", "prop_2", "prop_4", "prop_0", "prop_3"].reverse(),
            ["prop_4", "prop_1", "prop_1", "prop_6", "prop_6", "prop_0"].reverse(),
            ["prop_5", "prop_3", "spec_stone", "prop_3", "prop_2", "prop_2"].reverse(),
            ["spec_stone", "prop_1", "prop_5", "prop_5", "spec_stone", "prop_5"].reverse(),
            ["prop_3", "prop_2", "prop_3", "prop_3", "prop_2", "prop_6"].reverse(),
            //////////////////////////////////////////////////////////////////////////////////////
            ["prop_3", "prop_2", "prop_6", "prop_4", "spec_stone", "prop_4"].reverse(),
            ["prop_0", "prop_3", "prop_1", "prop_5", "spec_stone", "prop_0"].reverse(),
            ["prop_1", "spec_stone", "prop_4", "prop_0", "prop_6", "spec_stone"].reverse(),
            ["spec_stone", "prop_1", "prop_0", "prop_2", "prop_0", "prop_5"].reverse(),
            ["prop_2", "spec_stone", "prop_1", "prop_1", "spec_stone", "prop_6"].reverse(),
            ["spec_stone", "spec_stone", "prop_3", "spec_stone", "spec_stone", "spec_stone"].reverse()
          ]),
          generators: [{ type: "spec_stone", num: 4, last: 0 }],
          forbidSpecials: ["spec_dice", "spec_chest", "spec_rainbow"]
        };
        break;
      // LEVEL 9
      case 9:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(13) - 1,
          rndseed: 5890,
          mode: "typesCollect" /* TypesCollect */,
          modeData: { types: [{ type: "prop_heart", total: 8 }, { type: "prop_5", total: 20 }, { type: "prop_6", total: 15 }] },
          tutorial: "Hearts" /* Hearts */,
          preset6x6: AnMath.rotate270([
            ["prop_1", "prop_2", "prop_1", "prop_4", "prop_6", "prop_5"].reverse(),
            ["prop_5", "prop_3", "prop_6", "prop_0", "prop_1", "prop_6"].reverse(),
            ["prop_1", "prop_4", "prop_5", "prop_4", "prop_0", "prop_2"].reverse(),
            ["prop_5", "prop_0", "prop_3", "spec_heart", "prop_0", "prop_5"].reverse(),
            ["prop_6", "spec_heart", "prop_6", "prop_6", "prop_6", "prop_3"].reverse(),
            ["prop_2", "prop_6", "prop_6", "prop_3", "prop_0", "spec_heart"].reverse(),
            //////////////////////////////////////////////////////////////////////////////////////
            ["prop_0", "prop_0", "prop_6", "prop_3", "prop_0", "prop_4"].reverse(),
            ["prop_6", "prop_2", "prop_4", "prop_4", "prop_6", "prop_5"].reverse(),
            ["prop_3", "spec_heart", "prop_3", "prop_1", "prop_3", "prop_4"].reverse(),
            ["prop_1", "prop_5", "prop_5", "prop_6", "prop_6", "prop_0"].reverse(),
            ["prop_1", "prop_2", "prop_2", "prop_5", "prop_5", "prop_6"].reverse(),
            ["prop_3", "prop_4", "prop_4", "prop_1", "spec_heart", "prop_5"].reverse()
          ]),
          generators: [{ type: "spec_heart", num: 3, last: 0 }],
          forbidSpecials: ["spec_dice", "spec_chest", "spec_rainbow"]
        };
        break;
      // LEVEL 10 (Train3)
      case 10:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(15) + 1,
          rndseed: 4552,
          mode: "totalCollect" /* TotalCollect */,
          modeData: { total: 120 },
          tutorial: "Train3" /* Train3 */,
          forbidSpecials: ["spec_dice", "spec_chest", "spec_rainbow"],
          rules: [
            { type: "DropRandomStones" /* DropRandomStones */, num: 0.1 }
          ]
        };
        break;
      // LEVEL 11
      case 11:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(10),
          rndseed: 3844,
          mode: "typesCollect" /* TypesCollect */,
          modeData: { types: [{ type: "cellPainted", total: 30 }] },
          tutorial: "Painted" /* Painted */,
          preset6x6: AnMath.rotate270([
            ["prop_3", "prop_4", "prop_5", "prop_3", "prop_5", "prop_4"].reverse(),
            ["prop_0", "prop_4", "prop_5", "prop_2", "prop_2", "prop_2"].reverse(),
            ["prop_6", "prop_0", "prop_2", "prop_4", "prop_4", "prop_3"].reverse(),
            ["prop_4", "prop_0", "prop_2", "prop_1", "prop_2", "prop_0"].reverse(),
            ["prop_2", "prop_6", "prop_6", "prop_2", "prop_6", "prop_3"].reverse(),
            ["spec_rocket_horizontal", "prop_4", "prop_1", "prop_5", "prop_0", "prop_1"].reverse(),
            //////////////////////////////////////////////////////////////////////////////////////
            ["prop_5", "prop_5", "prop_5", "prop_3", "prop_5", "prop_2"].reverse(),
            ["prop_2", "prop_2", "prop_6", "prop_5", "prop_3", "prop_3"].reverse(),
            ["prop_3", "prop_0", "prop_1", "prop_0", "prop_6", "prop_0"].reverse(),
            ["prop_4", "prop_4", "prop_4", "prop_1", "prop_3", "prop_1"].reverse(),
            ["prop_1", "prop_1", "prop_4", "prop_3", "prop_3", "prop_1"].reverse(),
            ["prop_2", "prop_6", "prop_0", "prop_4", "prop_6", "prop_1"].reverse()
          ]),
          cellMod: [{ pos: new GridPos(5, 2), mods: [1 /* Paint */] }, { pos: new GridPos(5, 3), mods: [1 /* Paint */] }],
          forbidSpecials: ["spec_dice", "spec_chest", "spec_rainbow"]
        };
        break;
      // LEVEL 12
      case 12:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(14) + 1,
          rndseed: 5975,
          mode: "typesCollect" /* TypesCollect */,
          modeData: { types: [{ type: "prop_0", total: 20 }, { type: "prop_3", total: 20 }, { type: "prop_1", total: 20 }, { type: "prop_2", total: 20 }] },
          tutorial: "Rainbows" /* Rainbows */,
          preset6x6: AnMath.rotate270([
            ["prop_4", "prop_1", "prop_5", "prop_2", "spec_rainbow", "prop_1"].reverse(),
            ["prop_2", "prop_2", "prop_2", "prop_5", "prop_2", "prop_0"].reverse(),
            ["prop_0", "spec_rainbow", "prop_3", "prop_2", "prop_4", "prop_0"].reverse(),
            ["prop_3", "prop_1", "prop_1", "prop_1", "prop_2", "prop_3"].reverse(),
            ["spec_rainbow", "prop_0", "prop_5", "prop_2", "prop_0", "prop_4"].reverse(),
            ["prop_0", "prop_3", "prop_3", "prop_3", "prop_3", "spec_rainbow"].reverse(),
            //////////////////////////////////////////////////////////////////////////////////////
            ["prop_6", "prop_5", "prop_1", "prop_1", "prop_6", "prop_0"].reverse(),
            ["prop_2", "prop_5", "prop_5", "prop_0", "prop_5", "prop_3"].reverse(),
            ["prop_0", "prop_5", "prop_4", "prop_0", "prop_1", "prop_2"].reverse(),
            ["prop_0", "prop_0", "prop_2", "prop_2", "prop_0", "prop_5"].reverse(),
            ["prop_6", "prop_5", "prop_0", "prop_1", "spec_rainbow", "prop_4"].reverse(),
            ["prop_0", "prop_5", "prop_3", "prop_3", "prop_1", "prop_0"].reverse()
          ]),
          forbidSpecials: ["spec_dice", "spec_chest"]
        };
        break;
      // LEVEL 13 (Train4)
      case 13:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(19) - 1,
          rndseed: 4552,
          mode: "typesCollect" /* TypesCollect */,
          modeData: { types: [{ type: "cellPainted", total: 30 }, { type: "prop_heart", total: 8 }] },
          tutorial: "Train4" /* Train4 */,
          preset6x6: AnMath.rotate270([
            // //////////////////////////////////////////////////////////////////////////////////////
            ["prop_2", "prop_6", "prop_5", "prop_3", "prop_0", "prop_6"].reverse(),
            ["prop_6", "spec_heart", "prop_4", "prop_4", "prop_1", "prop_3"].reverse(),
            ["prop_2", "prop_3", "prop_3", "prop_4", "prop_3", "prop_1"].reverse(),
            ["prop_5", "prop_5", "prop_0", "prop_6", "spec_heart", "prop_0"].reverse(),
            ["prop_6", "prop_0", "prop_0", "prop_0", "prop_5", "prop_0"].reverse(),
            ["prop_0", "prop_4", "prop_1", "prop_5", "prop_3", "prop_5"].reverse()
          ]),
          generators: [{ type: "spec_heart", num: 2, last: 0 }],
          cellMod: [{ pos: new GridPos(2, 2), mods: [1 /* Paint */] }, { pos: new GridPos(2, 3), mods: [1 /* Paint */] }, { pos: new GridPos(3, 2), mods: [1 /* Paint */] }, { pos: new GridPos(3, 3), mods: [1 /* Paint */] }],
          forbidSpecials: ["spec_dice", "spec_chest"]
        };
        break;
      // LEVEL 14
      case 14:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(12) - 1,
          rndseed: 8665,
          mode: "totalCollect" /* TotalCollect */,
          modeData: { total: 150 },
          tutorial: "Chests" /* Chests */,
          preset6x6: AnMath.rotate270([
            ["prop_2", "prop_6", "prop_1", "prop_0", "prop_1", "prop_3"].reverse(),
            ["prop_0", "prop_0", "prop_3", "prop_0", "prop_0", "prop_3"].reverse(),
            ["prop_1", "prop_6", "prop_0", "prop_3", "prop_1", "prop_3"].reverse(),
            ["prop_4", "prop_6", "prop_3", "prop_5", "prop_2", "prop_5"].reverse(),
            ["prop_2", "prop_1", "prop_4", "prop_6", "prop_6", "prop_2"].reverse(),
            ["prop_2", "prop_1", "prop_1", "spec_chest", "prop_3", "prop_4"].reverse(),
            //////////////////////////////////////////////////////////////////////////////////////
            ["prop_2", "prop_5", "prop_0", "prop_4", "prop_2", "prop_6"].reverse(),
            ["prop_4", "prop_6", "prop_1", "prop_1", "prop_4", "prop_6"].reverse(),
            ["prop_3", "prop_6", "prop_0", "prop_1", "prop_0", "prop_1"].reverse(),
            ["prop_1", "prop_4", "prop_6", "spec_chest", "prop_5", "prop_0"].reverse(),
            ["prop_6", "prop_6", "prop_4", "prop_2", "prop_3", "prop_3"].reverse(),
            ["prop_6", "prop_0", "prop_1", "prop_0", "prop_4", "prop_3"].reverse()
          ]),
          forbidSpecials: ["spec_dice"]
        };
        break;
      // LEVEL 15
      case 15:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(16) - 1,
          rndseed: 5533,
          mode: "totalCollect" /* TotalCollect */,
          modeData: { total: 150 },
          tutorial: "Dices" /* Dices */,
          preset6x6: AnMath.rotate270([
            ["prop_1", "prop_2", "prop_2", "prop_6", "prop_6", "prop_3"].reverse(),
            ["prop_0", "prop_2", "spec_dice", "prop_1", "prop_6", "prop_5"].reverse(),
            ["prop_3", "prop_5", "prop_2", "prop_5", "prop_1", "prop_1"].reverse(),
            ["prop_1", "prop_3", "prop_2", "prop_3", "prop_4", "prop_6"].reverse(),
            ["prop_3", "prop_6", "prop_2", "prop_4", "prop_0", "prop_5"].reverse(),
            ["prop_3", "prop_2", "prop_0", "prop_1", "prop_6", "prop_6"].reverse(),
            //////////////////////////////////////////////////////////////////////////////////////
            ["prop_3", "prop_0", "prop_0", "prop_1", "prop_3", "prop_5"].reverse(),
            ["prop_4", "prop_1", "prop_0", "prop_2", "prop_1", "prop_1"].reverse(),
            ["prop_3", "prop_3", "prop_5", "prop_0", "prop_6", "prop_4"].reverse(),
            ["prop_6", "prop_2", "prop_4", "prop_0", "spec_dice", "prop_0"].reverse(),
            ["prop_3", "prop_2", "prop_6", "prop_1", "prop_4", "prop_2"].reverse(),
            ["prop_0", "prop_5", "prop_6", "prop_4", "prop_1", "prop_4"].reverse()
          ]),
          forbidSpecials: []
        };
        break;
      // LEVEL 16 (Train5)
      case 16:
        config2 = {
          ...config2,
          levelNum: levelID,
          totalMoves: G.calculateTotalMoves(15) + 1,
          rndseed: 4552,
          mode: "typesCollect" /* TypesCollect */,
          modeData: { types: [{ type: "prop_2", total: 30 }, { type: "prop_5", total: 20 }, { type: "prop_3", total: 25 }] },
          tutorial: "Train5" /* Train5 */,
          rules: [
            { type: "DropRandomStones" /* DropRandomStones */, num: 0.1 },
            { type: "InitRandomCages" /* InitRandomCages */, num: 0.3 }
          ],
          forbidSpecials: []
        };
        break;
    }
    if (levelID > G.predefinedLevels)
      config2 = LevelGenerator.generate(levelID);
    if (levelID >= 14) {
      const chestGen = { type: "spec_chest", num: 5, last: 0 };
      config2.generators = [...config2.generators ?? [], chestGen];
    }
    if (true) {
    }
    return config2;
  }
};
//number -     
_LevelData.introduceGameplayElement = {
  "spec_bomb": 2,
  "spec_rocket_vertical": 3,
  "cellCage": 5,
  "spec_mirror": 6,
  "spec_stone": 8,
  "spec_heart": 9,
  "cellPainted": 11,
  "spec_rainbow": 12,
  "spec_chest": 14,
  "spec_dice": 15
};
var LevelData = _LevelData;

// angine/src/utils/AnStorage.ts
init_define_AnParams();
var AnStorage = class {
  constructor(storageName, version, entries, emitUpdateEvents = [], cloudSave, syncStrategy) {
    //    
    this.saveID = 0;
    //  
    this.storage = {};
    /**
     *      
     */
    this.saveDelayedTimerID = null;
    this.version = version;
    if (!cloudSave) AnLog.warn("\u041E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 \u043D\u0435 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u043E. \u0421\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u0431\u0443\u0434\u0443\u0442 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u044B\u043C\u0438");
    this.localSave = new AnLocalSave(storageName);
    this.cloudSave = cloudSave ?? null;
    this.syncStrategy = syncStrategy ?? null;
    this.emitUpdateEvents = emitUpdateEvents;
    this.define(entries);
  }
  /**
   *   
   */
  define(entries) {
    Object.keys(entries).forEach((key) => {
      const value = entries[key];
      this.storage[key] = { current: value, default: value };
      Object.defineProperty(this, key, {
        get() {
          return this.storage[key].current;
        },
        set(value2) {
          this.setValue(key, value2);
        },
        enumerable: true,
        configurable: true
      });
    });
  }
  /**
   *    
   */
  setValue(key, value) {
    const def = this.storage[key];
    if (!def) {
      AnLog.warn(`\u041F\u043E\u043F\u044B\u0442\u043A\u0430 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043D\u0435\u043E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435: ${key}`);
      return;
    }
    this.storage[key].current = value;
    if (this.emitUpdateEvents.includes(key)) {
      AnEvents.emit(`storage:${key}:update`, { key, value });
    }
    this.saveDelayed();
  }
  /**
   *   
   */
  async load() {
    let localData = null;
    let cloudData = null;
    try {
      localData = await this.localSave.loadData();
      if (true) AnLog.debug(`[STORAGE] \u0434\u0430\u043D\u043D\u044B\u0435 \u0438\u0437 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u044B`);
    } catch (error) {
      localData = null;
      if (true) AnLog.debug(`[STORAGE] \u043E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0434\u0430\u043D\u043D\u044B\u0445 \u0438\u0437 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430: ${error}`);
    }
    if (this.cloudSave) {
      try {
        cloudData = await this.cloudSave.loadData();
        if (true) AnLog.debug(`[STORAGE] \u0434\u0430\u043D\u043D\u044B\u0435 \u0438\u0437 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u044B`);
      } catch (error) {
        cloudData = null;
        if (true) AnLog.debug(`[STORAGE] \u043E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0434\u0430\u043D\u043D\u044B\u0445 \u0438\u0437 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430: ${error}`);
      }
    }
    if (!localData && !cloudData) {
      if (true) AnLog.debug(`[STORAGE] \u0414\u0430\u043D\u043D\u044B\u0445 \u043D\u0435\u0442, \u044D\u0442\u043E \u043F\u0435\u0440\u0432\u044B\u0439 \u0437\u0430\u043F\u0443\u0441\u043A, \u0437\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u043C \u0434\u0435\u0444\u043E\u043B\u0442\u043D\u044B\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u044F`);
      define_AnParams_default.firstRun = true;
      this.resetToDefaultAndSave();
      return;
    }
    define_AnParams_default.firstRun = false;
    if (localData !== null || cloudData !== null) {
      if (true) AnLog.debug(`[STORAGE] \u0414\u0430\u043D\u043D\u044B\u0435 \u0435\u0441\u0442\u044C \u0432 ${localData !== null ? "\u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E\u043C" : "\u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C"} \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435`);
      const validData = localData !== null ? localData : cloudData;
      this.migrateDataToActualVersion(validData);
      this.applyDataToStorage(validData);
      await this.backupDataToOtherSave(validData, localData === validData ? this.cloudSave : this.localSave);
      return;
    }
    if (localData !== null && cloudData !== null) {
      if (true) AnLog.debug(`[STORAGE] \u0414\u0430\u043D\u043D\u044B\u0435 \u0435\u0441\u0442\u044C \u0432 \u0434\u0432\u0443\u0445 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430\u0445 \u0441\u0440\u0430\u0437\u0443, \u043D\u0443\u0436\u043D\u043E \u0432\u044B\u0431\u0440\u0430\u0442\u044C \u043E\u0434\u043D\u043E \u0438\u0437 \u043D\u0438\u0445`);
      const validData = this.syncDataForNewer(localData, cloudData);
      this.migrateDataToActualVersion(validData);
      this.applyDataToStorage(validData);
      await this.backupDataToOtherSave(validData, localData === validData ? this.cloudSave : this.localSave);
      return;
    }
  }
  async backupDataToOtherSave(data, save) {
    if (!save) {
      if (true) AnLog.debug(`[STORAGE] \u0412\u0442\u043E\u0440\u043E\u0435 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E \u0434\u043B\u044F \u0431\u0435\u043A\u0430\u043F\u0430 \u0434\u0430\u043D\u043D\u044B\u0445`);
      return;
    }
    try {
      await save.saveData(data);
      if (true) AnLog.debug(`[STORAGE] \u0434\u0430\u043D\u043D\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0431\u0435\u043A\u0430\u043F\u043B\u0435\u043D\u044B \u0432\u043E \u0432\u0442\u043E\u0440\u043E\u0435 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435`);
    } catch (error) {
      if (true) AnLog.debug(`[STORAGE] \u043E\u0448\u0438\u0431\u043A\u0430 \u0431\u0435\u043A\u0430\u043F\u0430 \u0432\u043E \u0432\u0442\u043E\u0440\u043E\u0435 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435`);
    }
  }
  syncDataForNewer(localData, cloudData) {
    if (true) AnLog.debug(`[STORAGE] \u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430...`);
    if (localData.saveID === cloudData.saveID) {
      if (true) AnLog.debug(`[STORAGE] saveID \u0443 \u043D\u0438\u0445 \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u044E\u0442, \u043F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u0441\u0430\u043C\u0438 \u0434\u0430\u043D\u043D\u044B\u0435....`);
      return this.syncStrategy ? this.syncStrategy(localData, cloudData) : localData;
    }
    if (true) AnLog.debug(`[STORAGE] saveID \u043D\u0435 \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u0435\u0442, \u0432\u043E\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043C \u0441\u0442\u0430\u0440\u0448\u0438\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`);
    return localData.saveID > cloudData.saveID ? localData : cloudData;
  }
  /**
   *      ,     
   */
  migrateDataToActualVersion(data) {
    if (this.version !== data.version) {
    } else {
      if (true) AnLog.debug(`[STORAGE] \u043C\u0438\u0433\u0440\u0430\u0446\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445 \u043D\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F, \u0432\u0435\u0440\u0441\u0438\u0438 \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u044E\u0442`);
    }
  }
  /**
   *         (  )
   */
  getCurrentData() {
    let data = { saveID: this.saveID, version: this.version };
    Object.keys(this.storage).forEach((key) => data[key] = this.storage[key].current);
    return data;
  }
  //     
  applyDataToStorage(data) {
    Object.keys(data).forEach((key) => {
      if (this.storage[key] !== void 0)
        this.storage[key].current = data[key];
    });
    this.saveID = data.saveID + 1;
  }
  /**
   *  
   */
  async clear() {
    try {
      await this.localSave.clearData();
      await this.cloudSave?.clearData();
      if (true) AnLog.debug(`[STORAGE] \u0434\u0430\u043D\u043D\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0447\u0438\u0449\u0435\u043D\u044B`);
    } catch (error) {
      if (true) AnLog.debug(`[STORAGE] \u043E\u0448\u0438\u0431\u043A\u0430 \u043E\u0447\u0438\u0441\u0442\u043A\u0438 \u0434\u0430\u043D\u043D\u044B\u0445: ${error}`);
    }
  }
  /**
   *   
   */
  async save() {
    if (this.saveDelayedTimerID !== null) {
      clearTimeout(this.saveDelayedTimerID);
      this.saveDelayedTimerID = null;
    }
    const data = this.getCurrentData();
    this.saveID++;
    if (true) AnLog.debug(`[STORAGE] \u041D\u043E\u0432\u044B\u0439 saveID: ${this.saveID}`);
    const localSavePromise = this.localSave.saveData(data);
    const cloudSavePromise = this.cloudSave ? this.cloudSave.saveData(data) : Promise.resolve();
    const results = await Promise.allSettled([localSavePromise, cloudSavePromise]);
    results.forEach((result, index) => {
      if (result.status === "fulfilled") {
        if (true) AnLog.debug(`\u0421\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 ${index === 0 ? "\u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E\u0435" : "\u0432 \u043E\u0431\u043B\u0430\u043A\u0435"} \u0443\u0441\u043F\u0435\u0448\u043D\u043E.`);
      } else {
        if (true) AnLog.debug(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0438 ${index === 0 ? "\u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E\u043C" : "\u0432 \u043E\u0431\u043B\u0430\u043A\u0435"}: ${result.reason}`);
      }
    });
  }
  saveDelayed(delay2 = 2) {
    if (this.saveDelayedTimerID === null) {
      this.saveDelayedTimerID = runAfter(delay2, () => {
        this.saveDelayedTimerID = null;
        this.save();
      });
    }
  }
  /**
   *      
   */
  resetToDefaultAndSave() {
    Object.keys(this.storage).forEach((key) => {
      const defaultValue2 = this.storage[key].default;
      this.storage[key].current = typeof defaultValue2 === "object" ? structuredClone(defaultValue2) : defaultValue2;
    });
    this.save();
  }
};
var AnLocalSave = class {
  constructor(storageName) {
    this._storageName = storageName;
  }
  get storageName() {
    return this._storageName;
  }
  async loadData() {
    const json = localStorage.getItem(this._storageName);
    if (!json) throw new Error("[AnLocalSave] \u0434\u0430\u043D\u043D\u044B\u0435 \u043E\u0442\u0441\u0443\u0441\u0442\u0432\u0443\u044E\u0442");
    return JSON.parse(json);
  }
  async saveData(data) {
    const json = JSON.stringify(data);
    localStorage.setItem(this._storageName, json);
  }
  async clearData() {
    localStorage.removeItem(this._storageName);
  }
};

// games/packer/src/game/MenuInfo.ts
init_define_AnParams();

// games/packer/src/game/UIRays.ts
init_define_AnParams();
var UIRays = class extends enhance(AnUIGroupElement).with(AnUpdatableMixin) {
  constructor(config2) {
    config2.anchor = config2.anchor ?? AnAnchor.Center;
    super(config2);
    this.rays = [];
    this.raysCount = config2.raysCount ?? 16;
    this.rotateSpeed = config2.rotateSpeed ?? 0.1;
    this.raysScale = config2.raysScale ?? 1;
    const angleStep = Math.PI * 2 / this.raysCount;
    for (let i3 = 0; i3 < this.raysCount; i3++) {
      const ray = new AnImage(
        {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./galoRay",
          anchor: AnAnchor.TopCenter
        }
      );
      ray.rotation = i3 * angleStep;
      ray.scale.x = this.raysScale;
      ray.alpha = 0.1;
      this.addUIElement("ray" + i3, ray);
      this.rays.push(ray);
    }
    this.galo = new AnImage(
      {
        atlas: "atlases/game.ss.pixi.atlas",
        sprite: "./galoCircle",
        anchor: AnAnchor.Center
      }
    );
    this.galo.alpha = 0.3;
    this.addUIElement(this.galo);
    this.defaultResizeStrategy = () => {
      this.setSize(this.scaledWidth, this.scaledHeight);
      const galoSize = this.rays[0].height * 0.7;
      this.galo.setSize(galoSize, galoSize);
    };
    this.configResizeStrategy(config2.resizeStrategy);
  }
  update(dt) {
    super.update(dt);
    this.rotation += this.rotateSpeed * dt;
  }
};

// games/packer/src/game/MenuInfo.ts
var MenuInfo = class extends AnMenu {
  constructor(config2) {
    super(config2);
    this.type = config2.type;
    GameApp.self.gameData.shownGameplayElements.push(config2.type);
    GameApp.self.gameData.shownGameplayElements = [...GameApp.self.gameData.shownGameplayElements];
  }
  start() {
    this.createUI();
    this.resizeUI();
    this.show();
  }
  createUI() {
    const background = this.addUIElement(
      "background",
      new AnImage(
        {
          sprite: "images/hoverbg.tex.pixi.jpg",
          anchor: AnAnchor.TopLeft,
          resizeStrategy: () => {
            background.position.set(0, 0);
            background.scaledWidth = AnViewport.width;
            background.scaledHeight = AnViewport.height;
            background.applyDefaultResizeStrategy();
          }
        }
      )
    );
    background.tint = GameColorsDB[GameApp.self.gameData.color].baseColorTint;
    this.sun1 = this.addUIElement("sun", new UIRays({
      raysCount: 15,
      rotateSpeed: 0.07,
      anchor: AnAnchor.TopLeft,
      resizeStrategy: () => {
        const raysSize = Math.max(AnViewport.width, AnViewport.height) * 1.43;
        this.sun1.setScaledSize(raysSize, raysSize);
        this.sun1.applyDefaultResizeStrategy();
        this.sun1.position.set(AnViewport.halfWidth, AnViewport.halfHeight);
      }
    }));
    this.sun2 = this.addUIElement("sun2", new UIRays({
      raysCount: 15,
      rotateSpeed: -0.07,
      raysScale: 1.3,
      anchor: AnAnchor.TopLeft,
      resizeStrategy: () => {
        const raysSize = Math.max(AnViewport.width, AnViewport.height) * 1.43;
        this.sun2.setScaledSize(raysSize, raysSize);
        this.sun2.applyDefaultResizeStrategy();
        this.sun2.position.set(AnViewport.halfWidth, AnViewport.halfHeight);
      }
    }));
    this.sun1.blendMode = G.forceLowQulity ? "normal" : "add";
    this.sun2.blendMode = G.forceLowQulity ? "normal" : "add";
    const promoPicSize = 200;
    this.promotedPic = this.addUIElement(
      "promotedPic",
      new AnImage(
        {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./" + this.type,
          anchor: AnAnchor.Center,
          resizeStrategy: () => {
            this.promotedPic.setScaledSize(scaled(promoPicSize), scaled(promoPicSize));
            this.promotedPic.applyDefaultResizeStrategy();
            this.promotedPic.position.set(AnViewport.halfWidth, AnViewport.halfHeight);
          }
        }
      )
    );
    if (this.type === "cellPainted") {
      this.promotedPic.tint = Cell.getCellPaintedColor(GameColorsDB[GameApp.self.gameData.color].baseColorTint);
    }
    this.title = this.addUIElement(
      "title",
      new AnLabel({
        text: {
          textSource: this.type + "_name",
          fontName: "mainFont",
          fontSize: 120,
          textAlign: "center" /* Center */,
          autoUpdateLang: true,
          shadowAlpha: 0.7
          //anchor: AnAnchor.TopLeft,
        },
        //backgroundColor: 0x333333,
        labelAlign: "center" /* Center */,
        anchor: AnAnchor.Center,
        resizeStrategy: () => {
          this.title.applyDefaultResizeStrategy();
          this.title.position.set(AnViewport.halfWidth, scaled(200));
        }
      })
    );
    this.buttonNext = this.addUIElement(
      "buttonNext",
      new AnButton({
        sprite: {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./button",
          slice9: {
            left: 20,
            right: 20,
            top: 20,
            bottom: 20
          }
        },
        icon: {
          atlas: "atlases/game.ss.pixi.atlas",
          sprite: "./next_ico"
        },
        iconAlign: "left" /* Left */,
        iconScale: { x: 0.9, y: 0.9 },
        // hoverSprite: {
        // 	atlas: 'atlases/game.ss.pixi.atlas',
        // 	sprite: './buttonHover',
        // 	slice9: {
        // 		left: 20, right: 20, top: 20, bottom: 20
        // 	}
        // },
        labelText: {
          text: {
            textSource: "menuInfoNext",
            fontName: "mainFont",
            fontSize: 70,
            textAlign: "center" /* Center */,
            //autoUpdateLang: false,
            //shadowAlpha: 0.7,
            color: 3355443
          },
          // backgroundColor: 0x333333,
          // backgroundAlpha: 0.7,
          labelAlign: "center" /* Center */,
          anchor: AnAnchor.Center
        },
        labelTextOffset: { x: 0, y: -3 },
        //labelTextColorHover: 0xffffff,
        padding: 5,
        anchor: AnAnchor.Center,
        controlsRouter: this.controlsRouter,
        resizeStrategy: () => {
          const buttonsOffsetY = 100;
          const buttonsPosStartY = AnViewport.height - scaled(buttonsOffsetY);
          this.buttonNext.scaledHeight = scaled(90);
          this.buttonNext.scaledWidth = scaled(430);
          this.buttonNext.applyDefaultResizeStrategy();
          this.buttonNext.position.set(AnViewport.halfWidth, buttonsPosStartY);
        },
        callbacks: {
          onClick: () => this.onButtonNextClick()
        }
      })
    );
    this.dialogue = this.addUIElement("dialogue", new UIDialogue({
      anchor: AnAnchor.Center,
      baseRealWidth: 900,
      fontSize: 75,
      useBackground: false,
      resizeStrategy: () => {
        this.dialogue.scaledWidth = Math.min(AnViewport.width, AnViewport.height) * 0.95;
        this.dialogue.scaledHeight = this.buttonNext.y + this.buttonNext.scaledHeight * 0.5 - (this.promotedPic.y + this.promotedPic.scaledHeight * 0.5);
        this.dialogue.applyDefaultResizeStrategy();
        this.dialogue.position.set(AnViewport.halfWidth, AnViewport.halfHeight + scaled(200));
      }
    }));
    this.dialogue.showText(this.type + "_info");
  }
  onButtonNextClick() {
    Analytics.onEvent("InfoMenuNextClick");
    AnRender2D.addToFront(new AnFader({
      type: "in",
      duration: 2.5,
      callbacks: {
        onComplete: () => {
          GameApp.self.runNextGame();
        }
      }
    }));
    this.hide();
  }
  createEntranceTweens() {
    const tweens = [];
    tweens.push(new AnTween({
      target: this.elements["background"],
      from: { alpha: 0 },
      to: { alpha: 0.95 },
      duration: 2,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.sun1,
      from: { alpha: 0 },
      to: { alpha: 1 },
      duration: 6,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.sun2,
      from: { alpha: 0 },
      to: { alpha: 1 },
      duration: 6,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.promotedPic,
      from: { alpha: 0, scale: { x: 0.3, y: 0.3 } },
      to: { alpha: 1, scale: { x: 1, y: 1 } },
      delay: 1,
      duration: 3,
      easing: AnEase.easeOutElastic,
      callbacks: {
        onStart: () => {
          AnSounds.play(
            `sounds/info.snd.mp3`,
            0.6
          );
        }
      }
    }));
    tweens.push(new AnTween({
      target: this.title,
      from: { alpha: 0, position: { x: this.title.x, y: this.title.y - scaled(100) } },
      to: { alpha: 1, position: { x: this.title.x, y: this.title.y } },
      delay: 1,
      duration: 3,
      easing: AnEase.easeOutElastic
    }));
    tweens.push(new AnTween({
      target: this.buttonNext,
      from: { alpha: 0, position: { x: this.buttonNext.x, y: this.buttonNext.y + scaled(150) } },
      to: { alpha: 1, position: { x: this.buttonNext.x, y: this.buttonNext.y } },
      delay: 3,
      duration: 1,
      easing: AnEase.easeOutBack
    }));
    return tweens;
  }
  createExitTweens() {
    const tweens = [];
    tweens.push(new AnTween({
      target: this.elements["background"],
      to: { alpha: 0 },
      from: { alpha: 0.95 },
      duration: 1,
      easing: AnEase.easeIn
    }));
    tweens.push(new AnTween({
      target: this.sun1,
      to: { alpha: 0 },
      from: { alpha: 1 },
      duration: 1,
      easing: AnEase.easeIn
    }));
    tweens.push(new AnTween({
      target: this.sun2,
      to: { alpha: 0 },
      from: { alpha: 1 },
      duration: 1,
      easing: AnEase.easeIn
    }));
    let menuSndPlayed = false;
    tweens.push(new AnTween({
      target: this.promotedPic,
      to: { alpha: 0, scale: { x: 0.3, y: 0.3 } },
      from: { alpha: 1, scale: { x: 1, y: 1 } },
      duration: 2,
      easing: AnEase.easeInElastic,
      tags: ["terminate"],
      callbacks: {
        onUpdate: (tween, progress) => {
          if (progress > 0.3 && !menuSndPlayed) {
            menuSndPlayed = true;
            AnSounds.play(
              `sounds/menu.snd.mp3`,
              0.6
            );
          }
        }
      }
    }));
    this.dialogue.hideText();
    tweens.push(new AnTween({
      target: this.title,
      to: { alpha: 0, position: { x: this.title.x, y: this.title.y - scaled(100) } },
      from: { alpha: 1, position: { x: this.title.x, y: this.title.y } },
      duration: 0.8,
      easing: AnEase.easeOut
    }));
    tweens.push(new AnTween({
      target: this.buttonNext,
      to: { alpha: 0, position: { x: this.buttonNext.x, y: this.buttonNext.y + scaled(150) } },
      from: { alpha: 1, position: { x: this.buttonNext.x, y: this.buttonNext.y } },
      duration: 0.5,
      easing: AnEase.easeOut
    }));
    return tweens;
  }
  update(dt) {
    super.update(dt);
  }
};

// games/packer/src/api/DevStatsAPI.ts
init_define_AnParams();
var _DevStatsAPI = class _DevStatsAPI {
  /**
   *    API
   */
  constructor() {
  }
  /**
   *     
   * @param data    
   * @returns Promise<boolean> true  , false  
   */
  async sendLevelStats(data) {
    try {
      const response = await fetch(_DevStatsAPI.endpoint, {
        method: "POST",
        body: JSON.stringify(data),
        //    JSON
        headers: {
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        AnLog.error(`HTTP error! Status: ${response.status}`);
        return false;
      }
      const result = await response.json();
      if (result.status === "success") {
        if (true) AnLog.debug(`DevStats: \u0434\u0430\u043D\u043D\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u044B!`);
        return true;
      } else {
        AnLog.error(`Server error: ${result.error}`);
        return false;
      }
    } catch (error) {
      AnLog.error(`Network or fetch error: ${error}`);
      return false;
    }
  }
};
_DevStatsAPI.endpoint = "https://olegantipov.com/utils/devstats/save_data.php";
var DevStatsAPI = _DevStatsAPI;

// angine/src/audio/AnMusicPlaylist.ts
init_define_AnParams();
var import_howler2 = __toESM(require_howler());
var _AnMusicPlaylist = class _AnMusicPlaylist {
  static init(config2) {
    this.crossfadeDuration = config2.crossfadeDuration ?? 2;
    this.streaming = config2.streaming ?? false;
    this.autoplay = config2.autoplay ?? false;
    this._musicVolume = config2.musicVolume ?? 100;
    AnEvents.on("storage:musicVolume:update", (e2) => this.updateVolume(e2.data.value));
  }
  static updateVolume(value) {
    if (this._musicVolume === value) return;
    this._musicVolume = value;
    const index = this.currentTrackIndex;
    if (index !== -1 && this.tracks[index].howl?.playing)
      this.tracks[index].howl?.fade(0, this._musicVolume / 100, this.crossfadeDuration);
  }
  static async addTracks(trackUrls) {
    if (trackUrls.length === 0) {
      AnLog.error("AnMusicPlaylist: \u0441\u043F\u0438\u0441\u043E\u043A \u0442\u0440\u0435\u043A\u043E\u0432 \u043F\u0443\u0441\u0442!");
      return;
    }
    this.loadNextTrack([...trackUrls], this.autoplay);
  }
  static loadNextTrack(trackUrls, autoplay = false) {
    if (trackUrls.length === 0) return;
    const trackUrl = trackUrls.shift();
    const howl = new import_howler2.Howl({
      src: [trackUrl],
      html5: this.streaming,
      volume: 0,
      onload: () => {
        AnLog.info(`\u0422\u0440\u0435\u043A ${trackUrl} \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D.`);
        const index = this.tracks.push({ name: trackUrl, howl }) - 1;
        if (autoplay && this.currentTrackIndex === -1) {
          _AnMusicPlaylist.playTrack(index);
        }
        this.loadNextTrack(trackUrls);
      },
      onloaderror: (id, err2) => {
        AnLog.error(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0442\u0440\u0435\u043A\u0430 ${trackUrl}:`, err2);
        this.loadNextTrack(trackUrls);
      },
      onend: () => {
        this.playTrack((this.currentTrackIndex + 1) % this.tracks.length);
      }
    });
  }
  static playTrack(index) {
    this.currentTrackIndex = index;
    if (true) AnLog.debug(`\u041F\u0440\u043E\u0438\u0433\u0440\u044B\u0432\u0430\u0435\u0442\u0441\u044F \u0442\u0440\u0435\u043A ${this.tracks[index].name}`);
    this.tracks[index].howl?.play();
    this.tracks[index].howl?.fade(0, this._musicVolume / 100, this.crossfadeDuration);
  }
  static set volume(value) {
    this._musicVolume = Math.min(100, Math.max(0, value));
  }
  static get volume() {
    return this._musicVolume;
  }
  static set enabled(value) {
    if (this._enabled === value) return;
    this._enabled = value;
    if (this._enabled) {
      if (this.currentTrackIndex === -1) {
        const index = AnRnd.int(0, this.tracks.length - 1);
        this.playTrack(index);
      }
    } else {
      this.tracks[this.currentTrackIndex].howl?.stop();
      this.currentTrackIndex = -1;
    }
  }
  static get enabled() {
    return this._enabled;
  }
};
_AnMusicPlaylist.tracks = [];
//  Howl-
_AnMusicPlaylist.currentTrackIndex = -1;
_AnMusicPlaylist.streaming = false;
_AnMusicPlaylist.autoplay = false;
var AnMusicPlaylist = _AnMusicPlaylist;

// games/packer/src/platform/PlatformLoader.ts
init_define_AnParams();

// games/packer/src/platform/PlatformYandex.ts
init_define_AnParams();
var PlatformYandex = class extends PlatformBase {
  constructor() {
    super(...arguments);
    this.sdk = null;
    this.player = null;
  }
  async init() {
    if (!window.YaGames)
      throw new Error("[Yandex SDK] \u043D\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D, \u043F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430!");
    this.sdk = await window.YaGames.init();
    if (!this.sdk)
      throw new Error("[Yandex SDK] \u043D\u0435 \u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D, \u043F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430!");
    this.player = await this.sdk.getPlayer();
    if (!this.player)
      AnLog.warn(`[Yandex SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u0438\u0433\u0440\u043E\u043A\u0430 \u043D\u0435 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u044B!`);
    this._initialized = true;
    AnLog.info("[Yandex SDK] \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D \u0438 \u043F\u0440\u043E\u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D");
  }
  //     ( )
  get visualName() {
    return "yg";
  }
  //      
  modifyGameParams(G2) {
    super.modifyGameParams(G2);
    G2.moreGamesURL = "";
    G2.btnDoubleReward = true;
    G2.btnMoreMoves = true;
    G2.musicStreaming = false;
  }
  // ===  ===
  get playerName() {
    return "";
  }
  get playerLoggedIn() {
    return this.player?.isAuthorized() ?? false;
  }
  get currentLanguage() {
    const lang = this.sdk?.environment.i18n.lang ?? null;
    if (lang === null)
      return null;
    if (["ru", "be", "kk", "uk", "uz"].includes(lang)) return "ru";
    return "en";
  }
  // ===     ===
  reportEvent(event) {
    super.reportEvent(event);
    if (true) AnLog.debug(`[Yandex SDK] \u0421\u043E\u043E\u0431\u0449\u0430\u0435\u043C \u043E \u043D\u043E\u0432\u043E\u043C \u0441\u043E\u0431\u044B\u0442\u0438\u0438: ${event}`);
    switch (event) {
      case "GameLoaded" /* GameLoaded */:
        this.sdk?.features.LoadingAPI.ready();
        break;
      case "GameplayStart" /* GameplayStart */:
        this.sdk?.features.GameplayAPI.start();
        break;
      case "GameplayStop" /* GameplayStop */:
        this.sdk?.features.GameplayAPI.stop();
        break;
    }
  }
  // ===   ===
  get leaderboardsAvailable() {
    return Boolean(
      this.sdk && this.sdk.leaderboards && typeof this.sdk.leaderboards.setScore === "function"
    );
  }
  sendScoreToLeaderboard(boardID, score) {
    if (!this.leaderboardsAvailable) {
      if (true) AnLog.debug(`[Yandex SDK] \u0442\u0430\u0431\u043B\u0438\u0446\u044B \u0440\u0435\u043A\u043E\u0440\u0434\u043E\u0432 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B!`);
      return;
    }
    if (true) AnLog.debug(`[Yandex SDK] \u043F\u0440\u043E\u0431\u0443\u0435\u043C \u043E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u044C \u0434\u0430\u043D\u043D\u044B\u0435 [${score}] \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0443 \u0440\u0435\u043A\u043E\u0440\u0434\u043E\u0432 ${boardID}...`);
    this.sdk.leaderboards.setScore(boardID, score).then(() => {
      if (true) AnLog.debug(`[Yandex SDK] \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0442\u043F\u0440\u0430\u0432\u0438\u043B\u0438 \u0434\u0430\u043D\u043D\u044B\u0435 \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0443 \u0440\u0435\u043A\u043E\u0440\u0434\u043E\u0432!`);
    }).catch((error) => {
      if (true) AnLog.debug(`[Yandex SDK] \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0442\u043F\u0440\u0430\u0432\u043A\u0435 \u0434\u0430\u043D\u043D\u044B\u0445 \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0443 \u0440\u0435\u043A\u043E\u0440\u0434\u043E\u0432: ${error}`);
    });
  }
  // ===  ===
  get adsAvailable() {
    return Boolean(
      this.sdk && this.sdk.adv && typeof this.sdk.adv.showFullscreenAdv === "function" && typeof this.sdk.adv.showRewardedVideo === "function"
    );
  }
  showAds(type, callbacks) {
    super.showAds(type, callbacks);
    if (!this.adsAvailable) {
      if (true) AnLog.debug(`[Yandex SDK] \u0440\u0435\u043A\u043B\u0430\u043C\u0430 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430!`);
      callbacks.onError?.();
      return;
    }
    switch (type) {
      case "Fullscreen" /* Fullscreen */:
        this.sdk.adv.showFullscreenAdv({
          callbacks: {
            onOpen: () => callbacks.onOpen?.(),
            onClose: () => callbacks.onClose?.(),
            onError: () => callbacks.onError?.(),
            onOffline: () => callbacks.onError?.()
          }
        });
        break;
      case "Rewarded" /* Rewarded */:
        {
          let rewarded = false;
          this.sdk.adv.showRewardedVideo({
            callbacks: {
              onOpen: () => callbacks.onOpen?.(),
              onError: () => callbacks.onError?.(),
              onClose: () => {
                if (rewarded)
                  callbacks.onCloseRewarded?.();
                else
                  callbacks.onClose?.();
              },
              onRewarded: () => rewarded = true
            }
          });
        }
        break;
    }
  }
  // ===   ===
  get cloudDataAvailable() {
    return Boolean(
      this.player && typeof this.player.getData === "function" && typeof this.player.setData === "function"
    );
  }
  async loadData() {
    if (!this.cloudDataAvailable) throw new Error("\u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E!");
    let data = null;
    try {
      data = await this.player?.getData();
    } catch (error) {
      throw new Error("\u041E\u0448\u0438\u0431\u043A\u0430 \u0447\u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445 \u0438\u0437 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430!");
    }
    if (!data)
      throw new Error("\u0414\u0430\u043D\u043D\u044B\u0435 \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B!");
    if (true) AnLog.debug(`[Yandex SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u044B \u0438\u0437 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430`);
    return data;
  }
  async saveData(data) {
    if (!this.cloudDataAvailable) throw new Error("\u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E!");
    try {
      await this.player.setData(data);
      if (true) AnLog.debug(`[Yandex SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435`);
      return;
    } catch (error) {
      if (true) AnLog.debug(`[Yandex SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u041D\u0415 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B, \u043E\u0448\u0438\u0431\u043A\u0430 \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435: ${error}`);
      return;
    }
  }
  async clearData() {
    if (!this.cloudDataAvailable) throw new Error("\u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E!");
    try {
      await this.player.setData({});
      if (true) AnLog.debug(`[Yandex SDK] \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0447\u0438\u0449\u0435\u043D\u043E`);
      return;
    } catch (error) {
      if (true) AnLog.debug(`[Yandex SDK] \u043E\u0448\u0438\u0431\u043A\u0430 \u043E\u0447\u0438\u0441\u0442\u043A\u0438 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430: ${error}`);
      return;
    }
  }
};

// games/packer/src/platform/PlatformVK.ts
init_define_AnParams();
var import_vk_bridge = __toESM(require_index_umd(), 1);
var PlatformVK = class extends PlatformBase {
  constructor() {
    super(...arguments);
    this.sdk = null;
    this.storageName = "CloudStorageVK";
  }
  //private player: Player | null = null;
  async init() {
    if (!window.vkBridge)
      throw new Error("[VK SDK] \u043D\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D, \u043F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430!");
    this.sdk = window.vkBridge;
    if (true)
      this.sdk.subscribe((e2) => AnLog.debug(struct(e2)));
    if (true) AnLog.debug(`[VK SDK] \u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u0443\u0435\u043C \u043F\u043B\u0430\u0442\u0444\u043E\u0440\u043C\u0443....`);
    await this.sdk.send("VKWebAppInit");
    if (true) AnLog.debug(`[VK SDK] \u043F\u0440\u043E\u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u043E!`);
    this.sdk.send("VKWebAppCheckNativeAds", { ad_format: import_vk_bridge.EAdsFormats.REWARD });
    this.sdk.send("VKWebAppCheckNativeAds", { ad_format: import_vk_bridge.EAdsFormats.INTERSTITIAL });
    this._initialized = true;
    AnLog.info("[VK SDK] \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D \u0438 \u043F\u0440\u043E\u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D");
  }
  //      
  modifyGameParams(G2) {
    super.modifyGameParams(G2);
    G2.moreGamesURL = "";
    G2.btnDoubleReward = true;
    G2.btnMoreMoves = true;
    G2.musicStreaming = false;
  }
  // // ===  ===
  // get playerName(): string
  // {
  // 	//return this.playerLoggedIn ? this.player!.getName() : "";
  // 	return "";
  // };
  // get playerLoggedIn(): boolean
  // {
  // 	return this.player?.isAuthorized() ?? false;
  // };
  // get currentLanguage(): string | null
  // {
  // 	const lang = this.sdk?.environment.i18n.lang ?? null;
  // 	if (lang === null)
  // 		return null;
  // 	// ru  be, kk, uk, uz;
  // 	// en   .
  // 	if (['ru', 'be', 'kk', 'uk', 'uz'].includes(lang)) return 'ru';
  // 	return 'en';
  // }
  // // ===     ===
  // public reportEvent(event: PlatformEvent): void
  // {
  // 	super.reportEvent(event);
  // 	if (AnConfig.devMode) AnLog.debug(`[Yandex SDK]    : ${event}`);
  // 	switch (event)
  // 	{
  // 		case PlatformEvent.GameLoaded:
  // 			this.sdk?.features.LoadingAPI.ready();
  // 			break;
  // 		case PlatformEvent.GameplayStart:
  // 			this.sdk?.features.GameplayAPI.start();
  // 			break;
  // 		case PlatformEvent.GameplayStop:
  // 			this.sdk?.features.GameplayAPI.stop();
  // 			break;
  // 	}
  // }
  // // ===   ===
  // private get leaderboardsAvailable()
  // {
  // 	return Boolean(
  // 		this.sdk &&
  // 		this.sdk.leaderboards &&
  // 		typeof this.sdk.leaderboards.setScore === 'function'
  // 	);
  // }
  // public sendScoreToLeaderboard(boardID: string, score: number): void
  // {
  // 	if (!this.leaderboardsAvailable)
  // 	{
  // 		if (AnConfig.devMode) AnLog.debug(`[Yandex SDK]    !`);
  // 		return;
  // 	}
  // 	if (AnConfig.devMode) AnLog.debug(`[Yandex SDK]    [${score}]    ${boardID}...`);
  // 	this.sdk!.leaderboards.setScore(boardID, score)
  // 		.then(() =>
  // 		{
  // 			if (AnConfig.devMode) AnLog.debug(`[Yandex SDK]      !`);
  // 		})
  // 		.catch((error: unknown) =>
  // 		{
  // 			if (AnConfig.devMode) AnLog.debug(`[Yandex SDK]       : ${error}`);
  // 		});
  // }
  // ===  ===
  get adsAvailable() {
    return Boolean(
      this.sdk
    );
  }
  showAds(type, callbacks) {
    super.showAds(type, callbacks);
    if (!this.adsAvailable) {
      if (true) AnLog.debug(`[VK SDK] \u0440\u0435\u043A\u043B\u0430\u043C\u0430 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430!`);
      callbacks.onError?.();
      return;
    }
    switch (type) {
      case "Fullscreen" /* Fullscreen */:
        callbacks.onOpen?.();
        this.sdk.send("VKWebAppShowNativeAds", { ad_format: import_vk_bridge.EAdsFormats.INTERSTITIAL }).then((data) => {
          if (data.result) {
            callbacks.onClose?.();
          } else {
            callbacks.onError?.();
          }
        }).catch((error) => {
          if (true) AnLog.debug(`[VK SDK] \u043E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0440\u0435\u043A\u043B\u0430\u043C\u044B: ${error}`);
          callbacks.onError?.();
        });
        break;
      case "Rewarded" /* Rewarded */:
        callbacks.onOpen?.();
        this.sdk.send("VKWebAppShowNativeAds", { ad_format: import_vk_bridge.EAdsFormats.REWARD }).then((data) => {
          if (data.result) {
            callbacks.onCloseRewarded?.();
          } else {
            callbacks.onError?.();
          }
        }).catch((error) => {
          if (true) AnLog.debug(`[VK SDK] \u043E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0440\u0435\u043A\u043B\u0430\u043C\u044B: ${error}`);
          callbacks.onError?.();
        });
        break;
    }
  }
  // ===   ===
  get cloudDataAvailable() {
    return Boolean(
      this.sdk
    );
  }
  async loadData() {
    if (!this.cloudDataAvailable) throw new Error("\u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E!");
    let data = null;
    try {
      data = await this.sdk?.send("VKWebAppStorageGet", { keys: [this.storageName] });
    } catch (error) {
      throw new Error("\u041E\u0448\u0438\u0431\u043A\u0430 \u0447\u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445 \u0438\u0437 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430!");
    }
    if (!data || !data.length)
      throw new Error("\u0414\u0430\u043D\u043D\u044B\u0435 \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B!");
    const json = data[0].value;
    if (!json) throw new Error("[VK SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 \u043E\u0442\u0441\u0443\u0441\u0442\u0432\u0443\u044E\u0442");
    if (true) AnLog.debug(`[VK SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u044B \u0438\u0437 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430`);
    return JSON.parse(json);
  }
  async saveData(data) {
    if (!this.cloudDataAvailable) throw new Error("\u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E!");
    try {
      const json = JSON.stringify(data);
      await this.sdk?.send("VKWebAppStorageSet", { key: this.storageName, value: json });
      if (true) AnLog.debug(`[VK SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435`);
      return;
    } catch (error) {
      if (true) AnLog.debug(`[VK SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u041D\u0415 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B, \u043E\u0448\u0438\u0431\u043A\u0430 \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435: ${error}`);
      return;
    }
  }
  async clearData() {
    if (!this.cloudDataAvailable) throw new Error("\u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E!");
    try {
      await this.sdk?.send("VKWebAppStorageSet", { key: this.storageName, value: "" });
      if (true) AnLog.debug(`[VK SDK] \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0447\u0438\u0449\u0435\u043D\u043E`);
      return;
    } catch (error) {
      if (true) AnLog.debug(`[VK SDK] \u043E\u0448\u0438\u0431\u043A\u0430 \u043E\u0447\u0438\u0441\u0442\u043A\u0438 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430: ${error}`);
      return;
    }
  }
};

// games/packer/src/platform/PlatformGamePix.ts
init_define_AnParams();
var PlatformGamePix = class extends PlatformBase {
  constructor() {
    super(...arguments);
    this.sdk = null;
    this.storageName = "CloudStorageGamePix";
  }
  async init() {
    if (!window.GamePix)
      throw new Error("[GamePix SDK] \u043D\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D, \u043F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430!");
    this.sdk = window.GamePix;
    this._initialized = true;
    AnLog.info("[GamePix SDK] \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D \u0438 \u043F\u0440\u043E\u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D");
  }
  // //      
  modifyGameParams(G2) {
    super.modifyGameParams(G2);
    G2.moreGamesURL = "";
    G2.btnDoubleReward = true;
    G2.btnMoreMoves = true;
    G2.musicStreaming = false;
  }
  // // ===  ===
  // get playerName(): string
  // {
  // 	//return this.playerLoggedIn ? this.player!.getName() : "";
  // 	return "";
  // };
  // get playerLoggedIn(): boolean
  // {
  // 	return this.player?.isAuthorized() ?? false;
  // };
  get currentLanguage() {
    const lang = (this.sdk?.lang()).toLowerCase() ?? null;
    if (lang === null)
      return null;
    if (["ru", "be", "kk", "uk", "uz"].includes(lang)) return "ru";
    return "en";
  }
  // ===     ===
  reportEvent(event, data) {
    super.reportEvent(event);
    if (true) AnLog.debug(`[GamePix SDK] \u0421\u043E\u043E\u0431\u0449\u0430\u0435\u043C \u043E \u043D\u043E\u0432\u043E\u043C \u0441\u043E\u0431\u044B\u0442\u0438\u0438: ${event}` + (data ? struct(data) : ""));
    switch (event) {
      case "NewLevel" /* NewLevel */:
        const currentLevel = data;
        this.sdk?.updateLevel(currentLevel);
        break;
      case "CoolMoment" /* CoolMoment */:
        this.sdk?.happyMoment();
        break;
    }
  }
  // // ===   ===
  get leaderboardsAvailable() {
    return Boolean(
      this.sdk && typeof this.sdk.updateScore === "function"
    );
  }
  sendScoreToLeaderboard(boardID, score) {
    boardID = "";
    if (!this.leaderboardsAvailable) {
      if (true) AnLog.debug(`[GamePix SDK] \u0442\u0430\u0431\u043B\u0438\u0446\u044B \u0440\u0435\u043A\u043E\u0440\u0434\u043E\u0432 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B!`);
      return;
    }
    if (true) AnLog.debug(`[GamePix SDK] \u043F\u0440\u043E\u0431\u0443\u0435\u043C \u043E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u044C \u0434\u0430\u043D\u043D\u044B\u0435 [${score}] \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0443 \u0440\u0435\u043A\u043E\u0440\u0434\u043E\u0432 ${boardID}...`);
    this.sdk.updateScore(score);
  }
  // ===  ===
  get adsAvailable() {
    return Boolean(
      this.sdk && typeof this.sdk.rewardAd === "function" && typeof this.sdk.interstitialAd === "function"
    );
  }
  showAds(type, callbacks) {
    super.showAds(type, callbacks);
    if (!this.adsAvailable) {
      if (true) AnLog.debug(`[GamePix SDK] \u0440\u0435\u043A\u043B\u0430\u043C\u0430 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430!`);
      callbacks.onError?.();
      return;
    }
    switch (type) {
      case "Fullscreen" /* Fullscreen */:
        callbacks.onOpen?.();
        this.sdk.interstitialAd().then((res) => {
          if (res.success) {
            callbacks.onClose?.();
          } else {
            callbacks.onError?.();
          }
        }).catch((error) => {
          if (true) AnLog.debug(`[GamePix SDK] \u043E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0440\u0435\u043A\u043B\u0430\u043C\u044B: ${error}`);
          callbacks.onError?.();
        });
        break;
      case "Rewarded" /* Rewarded */:
        callbacks.onOpen?.();
        this.sdk.rewardAd().then((res) => {
          if (res.success) {
            callbacks.onCloseRewarded?.();
          } else {
            callbacks.onClose?.();
          }
        }).catch((error) => {
          if (true) AnLog.debug(`[GamePix SDK] \u043E\u0448\u0438\u0431\u043A\u0430 \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438 \u0440\u0435\u043A\u043B\u0430\u043C\u044B: ${error}`);
          callbacks.onError?.();
        });
        break;
    }
  }
  // ===   ===
  get cloudDataAvailable() {
    return Boolean(
      this.sdk && typeof this.sdk.localStorage.setItem === "function" && typeof this.sdk.localStorage.getItem === "function"
    );
  }
  async loadData() {
    if (!this.cloudDataAvailable) throw new Error("\u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E!");
    let data = null;
    try {
      const json = await this.sdk.localStorage.getItem(this.storageName);
      data = JSON.parse(json);
    } catch (error) {
      throw new Error("\u041E\u0448\u0438\u0431\u043A\u0430 \u0447\u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445 \u0438\u0437 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430!");
    }
    if (!data)
      throw new Error("\u0414\u0430\u043D\u043D\u044B\u0435 \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B!");
    if (true) AnLog.debug(`[GamePix SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u044B \u0438\u0437 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430`);
    return data;
  }
  async saveData(data) {
    if (!this.cloudDataAvailable) throw new Error("\u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E!");
    try {
      const json = JSON.stringify(data);
      await this.sdk.localStorage.setItem(this.storageName, json);
      if (true) AnLog.debug(`[GamePix SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435`);
      return;
    } catch (error) {
      if (true) AnLog.debug(`[GamePix SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u041D\u0415 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B, \u043E\u0448\u0438\u0431\u043A\u0430 \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435: ${error}`);
      return;
    }
  }
  async clearData() {
    if (!this.cloudDataAvailable) throw new Error("\u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E!");
    try {
      await this.sdk.localStorage.removeItem(this.storageName);
      if (true) AnLog.debug(`[GamePix SDK] \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0447\u0438\u0449\u0435\u043D\u043E`);
      return;
    } catch (error) {
      if (true) AnLog.debug(`[GamePix SDK] \u043E\u0448\u0438\u0431\u043A\u0430 \u043E\u0447\u0438\u0441\u0442\u043A\u0438 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430: ${error}`);
      return;
    }
  }
};

// games/packer/src/platform/PlatformGameMonetize.ts
init_define_AnParams();
var PlatformGameMonetize = class extends PlatformBase {
  constructor() {
    super(...arguments);
    this.sdk = null;
    this.onAdsOpenCallback = null;
    this.onAdsCloseCallback = null;
  }
  async init() {
    return new Promise((resolve, reject) => {
      const initializeSdk = () => {
        if (!this._initialized) {
          if (!window.sdk)
            throw new Error("[GameMonetize SDK] \u043D\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D, \u043F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430!");
          this.sdk = window.sdk;
          this._initialized = true;
          AnLog.info("[GameMonetize SDK] \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D \u0438 \u043F\u0440\u043E\u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D");
        }
      };
      window.sdkRouteEvent = (e2) => {
        if (true)
          AnLog.debug(`[GameMonetize SDK] \u0421\u043E\u0431\u044B\u0442\u0438\u0435: ${e2.name}`);
        switch (e2.name) {
          case "SDK_GAME_PAUSE":
            this.onAdsOpenCallback?.();
            this.onAdsOpenCallback = null;
            break;
          case "SDK_GAME_START":
            this.onAdsCloseCallback?.();
            this.onAdsCloseCallback = null;
            break;
          case "SDK_READY":
            try {
              initializeSdk();
              resolve();
            } catch (error) {
              reject(error);
            }
            break;
        }
      };
      try {
        if (window.sdk) {
          initializeSdk();
          resolve();
        }
      } catch (error) {
        reject(error);
      }
    });
  }
  //      
  modifyGameParams(G2) {
    super.modifyGameParams(G2);
    G2.moreGamesURL = "https://olegantipov.com/";
    G2.btnDoubleReward = true;
    G2.btnMoreMoves = true;
    G2.musicStreaming = false;
    G2.adsShowAfterLoading = true;
  }
  // ===  ===
  get adsAvailable() {
    return Boolean(
      this.sdk && typeof this.sdk.showBanner === "function"
    );
  }
  showAds(type, callbacks) {
    super.showAds(type, callbacks);
    if (!this.adsAvailable) {
      if (true) AnLog.debug(`[GameMonetize SDK] \u0440\u0435\u043A\u043B\u0430\u043C\u0430 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430!`);
      callbacks.onError?.();
      return;
    }
    switch (type) {
      case "Fullscreen" /* Fullscreen */:
        this.onAdsOpenCallback = callbacks.onOpen ?? null;
        this.onAdsCloseCallback = callbacks.onClose ?? null;
        this.sdk.showBanner();
        break;
      case "Rewarded" /* Rewarded */:
        this.onAdsOpenCallback = callbacks.onOpen ?? null;
        this.onAdsCloseCallback = callbacks.onCloseRewarded ?? null;
        this.sdk.showBanner();
        break;
    }
  }
};

// games/packer/src/platform/PlatformY8.ts
init_define_AnParams();
var APP_ID = "6985d51c5d7f616d7bbd87b8";
var GAME_ID = "249093";
var TEST_ADS = true;
var PlatformY8 = class extends PlatformBase {
  constructor() {
    super(...arguments);
    this.sdk = null;
    this.adsReady = false;
    this.adInFlight = false;
  }
  async init() {
    if (!window.y8 || typeof window.y8.sdk !== "function")
      throw new Error("[Y8 SDK] \u043D\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D, \u043F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430!");
    this.sdk = await window.y8.sdk();
    if (!this.sdk)
      throw new Error("[Y8 SDK] \u043D\u0435 \u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D, \u043F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430!");
    const appConfig = {
      appId: APP_ID,
      autoLogin: false
    };
    const adConfig = {
      gameId: GAME_ID,
      test: TEST_ADS,
      preloadAdBreaks: "on",
      sound: "on",
      onReady: () => {
        this.adsReady = true;
        if (true) AnLog.debug("[Y8 SDK] \u0440\u0435\u043A\u043B\u0430\u043C\u0430 \u0433\u043E\u0442\u043E\u0432\u0430 \u043A \u043F\u043E\u043A\u0430\u0437\u0443");
      }
    };
    await this.sdk.init(appConfig, adConfig);
    this._initialized = true;
    AnLog.info("[Y8 SDK] \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D \u0438 \u043F\u0440\u043E\u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D");
  }
  //      
  modifyGameParams(G2) {
    super.modifyGameParams(G2);
    G2.moreGamesURL = "";
    G2.btnDoubleReward = true;
    G2.btnMoreMoves = true;
    G2.musicStreaming = false;
  }
  // ===  ===
  get adsAvailable() {
    return Boolean(
      this.sdk && this.adsReady && typeof this.sdk.showAd === "function"
    );
  }
  showAds(type, callbacks) {
    super.showAds(type, callbacks);
    if (!this.adsAvailable) {
      if (true) AnLog.debug("[Y8 SDK] \u0440\u0435\u043A\u043B\u0430\u043C\u0430 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430");
      callbacks.onError?.();
      return;
    }
    if (this.adInFlight) {
      if (true) AnLog.debug("[Y8 SDK] \u0440\u0435\u043A\u043B\u0430\u043C\u0430 \u0443\u0436\u0435 \u043F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0435\u0442\u0441\u044F");
      callbacks.onError?.();
      return;
    }
    this.adInFlight = true;
    const adType = type === "Rewarded" /* Rewarded */ ? "reward" : "interstitial";
    const adName = adType === "reward" ? "rewarded Ad" : "interstitial Ad";
    let isRewarded = false;
    let adError = false;
    const beforeAd = () => {
      callbacks.onOpen?.();
      if (true) AnLog.debug("[Y8 SDK] \u0420\u0435\u043A\u043B\u0430\u043C\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0435\u0442\u0441\u044F");
    };
    const afterAd = () => {
      if (true) AnLog.debug("[Y8 SDK] \u0420\u0435\u043A\u043B\u0430\u043C\u0430 \u0437\u0430\u043A\u0440\u044B\u0442\u0430");
      this.adInFlight = false;
      if (type === "Rewarded" /* Rewarded */) {
        if (isRewarded)
          callbacks.onCloseRewarded?.();
        else
          callbacks.onClose?.();
      } else
        callbacks.onClose?.();
    };
    const adBreakDone = (info) => {
      if (true) AnLog.debug("[Y8 SDK] \u0420\u0435\u043A\u043B\u0430\u043C\u043D\u044B\u0439 \u0431\u043B\u043E\u043A \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D", info);
      this.adInFlight = false;
      if (info?.breakStatus === "frequencyCapped" || info?.breakStatus === "noAdPreloaded" || info?.breakStatus === "other") {
        adError = true;
        callbacks.onError?.();
      }
      if (!adError && type === "Rewarded" /* Rewarded */ && isRewarded) {
        callbacks.onCloseRewarded?.();
      }
    };
    const beforeReward = (showAdFn) => {
      if (true) AnLog.debug("[Y8 SDK] \u041D\u0430\u0447\u0438\u043D\u0430\u0435\u043C \u043F\u043E\u043A\u0430\u0437 \u043D\u0430\u0433\u0440\u0430\u0436\u0434\u0430\u0435\u043C\u043E\u0439 \u0440\u0435\u043A\u043B\u0430\u043C\u044B");
      showAdFn();
    };
    const adViewed = () => {
      isRewarded = true;
      if (true) AnLog.debug("[Y8 SDK] \u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u0434\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u043B \u0440\u0435\u043A\u043B\u0430\u043C\u0443 \u0434\u043E \u043A\u043E\u043D\u0446\u0430");
    };
    const adDismissed = () => {
      isRewarded = false;
      if (true) AnLog.debug("[Y8 SDK] \u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u0437\u0430\u043A\u0440\u044B\u043B \u0440\u0435\u043A\u043B\u0430\u043C\u0443 \u0440\u0430\u043D\u044C\u0448\u0435 \u0432\u0440\u0435\u043C\u0435\u043D\u0438");
    };
    const payload = {
      name: adName,
      beforeAd,
      afterAd,
      adBreakDone
    };
    if (adType === "reward") {
      payload.type = "reward";
      payload.beforeReward = beforeReward;
      payload.adDismissed = adDismissed;
      payload.adViewed = adViewed;
    }
    this.sdk.showAd(payload).catch((error) => {
      this.adInFlight = false;
      adError = true;
      if (true) AnLog.debug("[Y8 SDK] \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u043E\u043A\u0430\u0437\u0430 \u0440\u0435\u043A\u043B\u0430\u043C\u044B:", error);
      callbacks.onError?.();
    });
  }
};

// games/packer/src/platform/PlatformPlayDeck.ts
init_define_AnParams();
var PlatformPlayDeck = class extends PlatformBase {
  constructor() {
    super(...arguments);
    this.wrapper = null;
    this.player = null;
    this.storageName = "CloudStoragePlayDeck";
    this.handlers = /* @__PURE__ */ new Map();
    this.playButtonIsPressed = false;
  }
  async init() {
    this.wrapper = window.parent;
    this.createEventHandler();
    this._initialized = true;
    AnLog.info("[PlayDeck SDK] \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D \u0438 \u043F\u0440\u043E\u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D");
  }
  createEventHandler() {
    this.onLoadProgress = (percent) => {
      if (true) AnLog.debug(`[PlayDeck SDK] loading ${percent}%`);
      this.callMethod("loading", { value: percent });
    };
    this.handlers.set("play", () => this.playButtonIsPressed = true);
    window.addEventListener("message", (event) => {
      const playdeck = event.data?.playdeck;
      if (playdeck) {
        const handler = this.handlers.get(playdeck.method);
        if (handler) {
          if (true) AnLog.debug(`[PlayDeck SDK] handled ${playdeck.method}=>${struct(event.data?.value)}`);
          this.handlers.delete(playdeck.method);
          handler(event.data?.value);
        }
      }
    });
  }
  callMethod(method, params = null, makePromiseResult = false) {
    if (true) AnLog.debug(`[PlayDeck SDK] call ${method}(${struct(params ?? {})})`);
    this.wrapper?.postMessage({ playdeck: { method, ...params } }, "*");
    if (!makePromiseResult) return Promise.resolve();
    return new Promise((resolve, reject) => {
      this.handlers.set(method, (value) => {
        this.handlers.delete(method);
        resolve(value);
      });
    });
  }
  //      
  modifyGameParams(G2) {
    super.modifyGameParams(G2);
    G2.moreGamesURL = "";
    G2.btnDoubleReward = true;
    G2.btnMoreMoves = true;
    G2.musicStreaming = false;
  }
  get lastPrepareToPlayEnded() {
    return this.wrapper ? this.playButtonIsPressed : true;
  }
  // ===  ===
  get playerName() {
    return this.player?.username ?? "";
  }
  get playerLoggedIn() {
    return true;
  }
  get currentLanguage() {
    const lang = this.player?.locale ?? null;
    if (lang === null)
      return null;
    if (["ru", "be", "kk", "uk", "uz"].includes(lang)) return "ru";
    return "en";
  }
  // ===     ===
  reportEvent(event, data) {
    super.reportEvent(event);
    if (true) AnLog.debug(`[PlayDeck SDK] \u0421\u043E\u043E\u0431\u0449\u0430\u0435\u043C \u043E \u043D\u043E\u0432\u043E\u043C \u0441\u043E\u0431\u044B\u0442\u0438\u0438: ${event}`);
    switch (event) {
      case "NewLevel" /* NewLevel */:
        const currentLevel = data;
        this.callMethod("sendGameProgress", { progress: { level: currentLevel, isLastLevel: false } });
        break;
    }
  }
  // ===  ===
  get adsAvailable() {
    return Boolean(
      this.wrapper && this._initialized
    );
  }
  showAds(type, callbacks) {
    super.showAds(type, callbacks);
    if (!this.adsAvailable || type === "Fullscreen" /* Fullscreen */) {
      if (true) AnLog.debug(`[PlayDeck SDK] \u0440\u0435\u043A\u043B\u0430\u043C\u0430 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430!`);
      callbacks.onError?.();
      return;
    }
    const clearHandlers = () => {
      this.handlers.delete("startAd");
      this.handlers.delete("rewardedAd");
      this.handlers.delete("skipAd");
      this.handlers.delete("errAd");
      this.handlers.delete("notFoundAd");
    };
    this.handlers.set("startAd", () => callbacks.onOpen?.());
    this.handlers.set("rewardedAd", () => {
      clearHandlers();
      callbacks.onCloseRewarded?.();
    });
    this.handlers.set("skipAd", () => {
      clearHandlers();
      callbacks.onClose?.();
    });
    this.handlers.set("errAd", () => {
      clearHandlers();
      callbacks.onError?.();
    });
    this.handlers.set("notFoundAd", () => {
      clearHandlers();
      callbacks.onError?.();
    });
    this.callMethod("showAd");
  }
  // ===   ===[PlayDeck SDK]
  get cloudDataAvailable() {
    return Boolean(
      this.wrapper && this._initialized
    );
  }
  async loadData() {
    if (!this.cloudDataAvailable) throw new Error("[PlayDeck SDK] \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E!");
    let data = null;
    try {
      data = await this.callMethod("getData", { key: this.storageName }, true);
    } catch (error) {
      throw new Error("[PlayDeck SDK] \u041E\u0448\u0438\u0431\u043A\u0430 \u0447\u0442\u0435\u043D\u0438\u044F \u0434\u0430\u043D\u043D\u044B\u0445 \u0438\u0437 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430!");
    }
    if (!data)
      throw new Error("[PlayDeck SDK] \u0414\u0430\u043D\u043D\u044B\u0435 \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B!");
    const json = data.value;
    if (!json) throw new Error("[PlayDeck SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 \u043E\u0442\u0441\u0443\u0441\u0442\u0432\u0443\u044E\u0442");
    if (true) AnLog.debug(`[PlayDeck SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u044B \u0438\u0437 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430`);
    return JSON.parse(json);
  }
  async saveData(data) {
    if (!this.cloudDataAvailable) throw new Error("[PlayDeck SDK] \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E!");
    try {
      const json = JSON.stringify(data);
      await this.callMethod("setData", {
        key: this.storageName,
        value: json
      });
      if (true) AnLog.debug(`[PlayDeck SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435`);
      return;
    } catch (error) {
      if (true) AnLog.debug(`[PlayDeck SDK] \u0434\u0430\u043D\u043D\u044B\u0435 \u041D\u0415 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B, \u043E\u0448\u0438\u0431\u043A\u0430 \u0432 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u043C \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435: ${error}`);
      return;
    }
  }
  async clearData() {
    if (!this.cloudDataAvailable) throw new Error("[PlayDeck SDK] \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E!");
    try {
      await this.callMethod("setData", {
        key: this.storageName,
        value: ""
      });
      if (true) AnLog.debug(`[PlayDeck SDK] \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0435 \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0447\u0438\u0449\u0435\u043D\u043E`);
      return;
    } catch (error) {
      if (true) AnLog.debug(`[PlayDeck SDK] \u043E\u0448\u0438\u0431\u043A\u0430 \u043E\u0447\u0438\u0441\u0442\u043A\u0438 \u043E\u0431\u043B\u0430\u0447\u043D\u043E\u0433\u043E \u0445\u0440\u0430\u043D\u0438\u043B\u0438\u0449\u0430: ${error}`);
      return;
    }
  }
};

// games/packer/src/platform/PlatformWGPlayground.ts
init_define_AnParams();
var PlatformWGPlayground = class extends PlatformBase {
  constructor() {
    super(...arguments);
    this.onCloseRewarded = null;
    this.onClose = null;
  }
  //private sdk: any | null = null;
  get sdk() {
    return window[window.preroll.config.loaderObjectName];
  }
  async init() {
    if (!window.preroll?.config?.loaderObjectName)
      throw new Error("[WGPlayground SDK] \u043D\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D, \u043F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430!");
    this.sdk.registerRewardCallbacks({
      onReady: () => {
        if (true) AnLog.debug("[WGPlayground SDK] rewarded \u0440\u0435\u043A\u043B\u0430\u043C\u0430 \u0433\u043E\u0442\u043E\u0432\u0430");
      },
      //called when a rewarded ad is ready to be displayed
      onSuccess: () => {
        this.onCloseRewarded?.();
        this.onCloseRewarded = null;
      },
      //the ad is finished, user should be rewarded with the prize
      onFail: () => {
        this.onClose?.();
        this.onClose = null;
      }
      //the ad dispaly was canceled, user should not be rewarded with the prize
    });
    this._initialized = true;
    AnLog.info("[WGPlayground SDK] \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D \u0438 \u043F\u0440\u043E\u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D");
  }
  //      
  modifyGameParams(G2) {
    super.modifyGameParams(G2);
    G2.moreGamesURL = "https://olegantipov.com";
    G2.btnDoubleReward = true;
    G2.btnMoreMoves = true;
    G2.musicStreaming = false;
  }
  // ===  ===
  get adsAvailable() {
    return Boolean(
      this.sdk && typeof this.sdk.showRewardAd === "function" && typeof this.sdk.refetchAd === "function"
    );
  }
  showAds(type, callbacks) {
    super.showAds(type, callbacks);
    if (!this.adsAvailable) {
      if (true) AnLog.debug(`[WGPlayground SDK] \u0440\u0435\u043A\u043B\u0430\u043C\u0430 \u043D\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430!`);
      callbacks.onError?.();
      return;
    }
    switch (type) {
      case "Fullscreen" /* Fullscreen */:
        callbacks.onOpen?.();
        this.sdk.refetchAd(() => callbacks.onClose?.());
        break;
      case "Rewarded" /* Rewarded */:
        this.onCloseRewarded = () => callbacks.onCloseRewarded?.();
        this.onClose = () => callbacks.onClose?.();
        this.sdk.showRewardAd();
        break;
    }
  }
};

// games/packer/src/platform/PlatformLoader.ts
var PlatformLoader = class {
  static async load() {
    if (Platform.sdk) return;
    const platformType = "playdeck";
    AnLog.info(`\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u043C \u043F\u043B\u0430\u0442\u0444\u043E\u0440\u043C\u0443: ${platformType}`);
    await this.createPlatform(platformType);
    AnLog.info(`\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u043F\u043B\u0430\u0442\u0444\u043E\u0440\u043C\u044B \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u0430!`);
  }
  static async createPlatform(platform) {
    let platformType = platform;
    let platformInstance = null;
    try {
      switch (platform) {
        case "yandex" /* Yandex */:
          platformInstance = new PlatformYandex();
          break;
        case "vk" /* VK */:
          platformInstance = new PlatformVK();
          break;
        case "gamepix" /* GamePix */:
          platformInstance = new PlatformGamePix();
          break;
        case "gamemonetize" /* GameMonetize */:
          platformInstance = new PlatformGameMonetize();
          break;
        case "y8" /* Y8 */:
          platformInstance = new PlatformY8();
          break;
        case "playdeck" /* PlayDeck */:
          platformInstance = new PlatformPlayDeck();
          break;
        case "wgplayground" /* WGPlayground */:
          platformInstance = new PlatformWGPlayground();
          break;
      }
      if (!platformInstance) throw new Error(`\u0440\u0435\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F \u043F\u043B\u0430\u0442\u0444\u043E\u0440\u043C\u044B ${platform} \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u0430!`);
      await platformInstance?.init();
    } catch (error) {
      AnLog.error(`\u041D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044C \u043F\u043B\u0430\u0442\u0444\u043E\u0440\u043C\u0443 ${platform}:`, error);
    }
    if (!platformInstance)
      platformType = "standalone" /* Standalone */;
    Platform.type = platformType;
    Platform.sdk = platformInstance;
    Platform.visualName = platformInstance?.visualName ?? null;
  }
};

// games/packer/src/GameApp.ts
var GameApp = class _GameApp extends AnApp {
  constructor(config2) {
    super(config2);
    this.devStatsAPI = new DevStatsAPI();
    this.platformLoaderEnded = false;
    this.storageLoaderEnded = false;
  }
  get game() {
    return this._game;
  }
  get gameData() {
    return this._gameData;
  }
  async start() {
    super.start();
  }
  static get self() {
    return AnApp.self;
  }
  onPreloaderProgress(percent) {
    Platform.sdk?.onLoadProgress?.(percent);
  }
  onPreloaderStart() {
    PlatformLoader.load().finally(
      () => {
        this.platformLoaderEnded = true;
        this._gameData = new AnStorage(
          G.storageName,
          "1.0",
          {
            // 
            theme: "toys" /* Toys */,
            color: "Color0" /* Color0 */,
            soundVolume: 100,
            musicVolume: 100,
            voiceVolume: 100,
            language: this.getDefaultLanguage(),
            //  
            level: 1,
            coins: 0,
            stars: 0,
            //  
            shownGameplayElements: [],
            //  
            lastUnlockedColor: 0,
            lastUnlockedTheme: 0
          },
          ["soundVolume", "musicVolume", "language", "theme", "color"],
          Platform.sdk ?? void 0,
          (localData, cloudData) => {
            if (localData.level === cloudData.level) {
              if (true) AnLog.debug(`[STORAGE] \u043D\u043E\u043C\u0435\u0440\u0430 \u0443\u0440\u043E\u0432\u043D\u0435\u0439 \u0442\u043E\u0436\u0435 \u0441\u043E\u043F\u0430\u0434\u0430\u044E\u0442, \u0437\u043D\u0430\u0447\u0438\u0442 \u0431\u0435\u0440\u0435\u043C \u0442\u043E\u0442 \u0443 \u043A\u043E\u0433\u043E \u043C\u043E\u043D\u0435\u0442 \u0431\u043E\u043B\u044C\u0448\u0435`);
              return localData.coins > cloudData.coins ? localData : cloudData;
            } else {
              if (true) AnLog.debug(`[STORAGE] \u043D\u043E\u043C\u0435\u0440\u0430 \u0443\u0440\u043E\u0432\u043D\u0435\u0439 \u043D\u0435 \u0441\u043E\u043F\u0430\u0434\u0430\u044E\u0442, \u0432\u044B\u0431\u0438\u0440\u0430\u0435\u043C \u0442\u043E\u0442, \u0433\u0434\u0435 \u0431\u043E\u043B\u044C\u0448\u0438\u0439`);
              return localData.level > cloudData.level ? localData : cloudData;
            }
          }
        );
        if (G.dev_startWithFullReset) {
          this.storageLoaderEnded = true;
          define_AnParams_default.firstRun = true;
          this._gameData.resetToDefaultAndSave();
        } else {
          this._gameData.load().finally(() => {
            this.storageLoaderEnded = true;
          });
        }
      }
    );
  }
  getDefaultLanguage() {
    //!  ,        
    //!      
    const loadedLangs = ["en", "ru"];
    const currentLang = Platform.sdk?.currentLanguage ?? getCurrentOSLanguage();
    const defaultLang = loadedLangs.includes(currentLang) ? currentLang : "en";
    AnLog.info(`\u041F\u0440\u0438 \u043F\u0435\u0440\u0432\u043E\u043C \u0437\u0430\u043F\u0443\u0441\u043A\u0435 \u0432\u044B\u0441\u0442\u0430\u0432\u043B\u0435\u043D \u044F\u0437\u044B\u043A ${defaultLang}`);
    return defaultLang;
  }
  onPreloaderComplete() {
    const nextRun = () => {
      this.startGame();
    };
    const loadersEnded = () => this.platformLoaderEnded && this.storageLoaderEnded && (Platform.sdk?.lastPrepareToPlayEnded ?? true);
    if (loadersEnded())
      nextRun();
    else {
      const intervalID = setInterval(() => {
        if (loadersEnded()) {
          clearInterval(intervalID);
          nextRun();
        }
      }, 500);
    }
  }
  startGame() {
    if (G.dev_forceFirstRun) define_AnParams_default.firstRun = true;
    if (true) AnLog.debug(`\u041F\u0415\u0420\u0412\u042B\u0419 \u0417\u0410\u041F\u0423\u0421\u041A \u0418\u0413\u0420\u042B: ${define_AnParams_default.firstRun}`);
    Platform.sdk?.modifyGameParams(G);
    AnSounds.init({ soundVolume: this.gameData.soundVolume });
    const tracks = Array.from({ length: 6 }, (_, i3) => `music${i3 + 1}.mus.mp3`);
    if (true) AnLog.debug(`\u041C\u0443\u0437\u044B\u043A\u0430: ${struct(tracks)}`);
    if (!define_AnParams_default.firstRun)
      shuffle(tracks);
    AnMusicPlaylist.init({ crossfadeDuration: 2, streaming: G.musicStreaming, musicVolume: this.gameData.musicVolume, autoplay: true });
    if (!G.dev_forceNoMusic)
      AnMusicPlaylist.addTracks(tracks);
    if (true) AnLog.debug(`\u041E\u0446\u0435\u043D\u043A\u0430 \u043D\u0430\u0433\u0440\u0430\u0434\u044B \u0437\u0430 100 \u0443\u0440\u043E\u0432\u043D\u0435\u0439: ${struct(G.evalTotalRewardForLevels(100))}`);
    Platform.sdk?.reportEvent("GameLoaded" /* GameLoaded */);
    Analytics.onEvent("GameLoadedInSec", uptime() - firstTouchInitTime);
    if (true) {
      this.gameData.theme = "toys" /* Toys */;
      this.gameData.level = 8;
      this.gameData.coins = 15e3;
    }
    //!     
    //!      
    //!      
    const curlang = this.gameData.language;
    this.gameData.language = curlang;
    if (true)
      AnLog.debug(`\u0442\u0435\u043A\u0443\u0449\u0438\u0439 \u044F\u0437\u044B\u043A ${this.gameData.language}`);
    if (G.adsShowAfterLoading && Platform.sdk) {
      let doNextExecute = false;
      const placement = "preloader";
      Platform.sdk.showAds("Fullscreen" /* Fullscreen */, {
        onOpen: () => {
          Analytics.onFullscreenAdShow(placement);
          _GameApp.self.paused = true;
        },
        onClose: () => {
          _GameApp.self.paused = false;
          if (!doNextExecute) {
            doNextExecute = true;
            this.runNextGame();
          }
        },
        onError: () => {
          Analytics.onFullscreenAdError(placement);
          _GameApp.self.paused = false;
          if (true) AnLog.debug(`\u041E\u0448\u0438\u0431\u043A\u0430 \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F FullscreenAds`);
          if (!doNextExecute) {
            doNextExecute = true;
            this.runNextGame();
          }
        }
      });
    } else
      this.runNextGame();
  }
  //  
  runNextGame() {
    this.terminateGame();
    const showNextGameplayElement = LevelData.getNextGamePlayElement();
    if (showNextGameplayElement && !G.dev_disableMenuInfo) {
      const menuInfo = new MenuInfo({ type: showNextGameplayElement });
      menuInfo.start();
    } else {
      _GameApp.self.runLevel(LevelData.get(_GameApp.self.gameData.level));
    }
    AnRender2D.addToFront(new AnFader({ type: "out", duration: 2 }));
  }
  //     GameConfig
  runLevel(config2) {
    this.terminateGame();
    this._game = new Game(config2 ?? LevelData.get());
    this._game.start();
  }
  //      
  fullReset() {
    Analytics.onEvent("fullResetGameProgress");
    this._gameData.resetToDefaultAndSave();
    this.runNextGame();
  }
  terminateGame() {
    if (this._game && !this._game.isDestroyed)
      this._game.hide();
  }
  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////
  //     
  runTestMenu() {
    const menuResult = new MenuResult({ state: "win" /* Win */, activeStars: 3, rewardCoins: 5600 });
    menuResult.start();
  }
  runIntro() {
    const intro = new Intro({
      callbacks: {
        onComplete: () => this.runLevel()
      }
    });
    intro.start();
  }
};

// games/packer/src/main.ts
if (false) G.disableDevFeatures();
Analytics.init({ currencies: ["coins"], itemTypes: ["color", "theme", "rewardWin", "reward2X", "rewardChest"] });
var firstTouchInitTime = uptime();
Analytics.onEvent("FirstTouchInitInSec", firstTouchInitTime);
var config = {
  preloaderSkipExitAnimations: G.dev_preloaderSkipExitAnimations
};
var gameApp = new GameApp(config);
(async () => {
  await gameApp.start();
})();
export {
  firstTouchInitTime
};
//# sourceMappingURL=packer.js.map
